{"meta":{"title":"1ens's blog","subtitle":"","description":"a","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2022-05-24T15:09:56.842Z","updated":"2022-05-24T15:09:56.842Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2022-05-25T03:46:23.885Z","updated":"2022-05-25T03:46:23.885Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一个菜鸡逆向选手"},{"title":"所有分类","date":"2022-05-24T15:02:08.935Z","updated":"2022-05-24T15:02:08.935Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-24T15:03:31.990Z","updated":"2022-05-24T15:03:31.990Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-05-24T15:06:34.544Z","updated":"2022-05-24T15:06:34.544Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"big lao","text":"big lao 带带"},{"title":"所有标签","date":"2022-05-24T15:02:51.734Z","updated":"2022-05-24T15:02:51.734Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JIT","slug":"JIT","date":"2022-05-26T16:00:00.000Z","updated":"2022-05-28T08:42:33.595Z","comments":true,"path":"2022/05/27/JIT/","link":"","permalink":"http://example.com/2022/05/27/JIT/","excerpt":"","text":"什么是JITJIT &#x3D; Just In Time即时编译，是动态编译的一种形式，是一种优化虚拟机运行的技术。程序运行通常有两种方式，一种是静态编译，一种是动态解释，即时编译混合了这二者。 lujit运行过程： 解题： 得到一个.out 文件，电脑识别成Wireshark 系列文件，拉入WinHex会发现是.LJ开头，可以推断是Luajit逆向。 先编译LuaJit2.1.0Beta3Download (luajit.org) 去官网下载 运行x64 Native Tools Command Prompt for VS （用Everything搜索）， 然后将下载的安装包解压到相应的盘下，然后进入解压后的SRC文件 msvcbuild.bat gc64编译出的64位（题目的64位 msvcbuild.bat编译出的是32位 反编译bobsayshilol&#x2F;luajit-decomp at deprecated (github.com) 下载反编译工具 然后将上一步src文件夹里面jit文件夹，和lua51.dll luajit.exe 放到刚刚下载的反编译工具文件夹里面 然后将我们的题目附件改名为test.lua，再按下decoder_new.exe该文件就出现了out.lua和out2.lua 用sublime打开，就可以开始分析字节码了 未完待续。。","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-luajit","slug":"luajit","permalink":"http://example.com/tags/luajit/"}],"author":"1ens"},{"title":"CEF","slug":"cef","date":"2022-05-26T16:00:00.000Z","updated":"2022-05-27T14:31:42.247Z","comments":true,"path":"2022/05/27/cef/","link":"","permalink":"http://example.com/2022/05/27/cef/","excerpt":"","text":"32位无壳程序 CEF简介: 嵌入式Chromium框架(简称CEF) 是一个由Marshall Greenblatt在2008建立的开源项目，它主要目的是开发一个基于Google Chromium的Webbrowser控件。CEF支持一系列的编程语言和操作系统，并且能很容易地整合到新的或已有的工程中去。 解题：正面去分析的话，十分困难。去搜索相应字符串无果 这里我们可以去从数据调用去分析，我们去分析.data的数据 一组奇怪的数据，猜测加密时用到，交叉引用找到调用的地方 调试验证一下，一开始会停在调用的dll函数里面，我们直接步过，然后输入32位之后就会断下F9提示correct，验证我们的猜想是正确的。调试发现其实，加密整个逻辑就在else里面，一个魔改的SM4，其基本运算为异或^和循环左移&lt;&lt;&lt; round函数 解密： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned int SK[32] = &#123; 0xE8DB227C, 0x012451B9, 0xED08A9DB, 0xC91F65C3, 0xB3D1E981, 0x319B4734, 0xA4BA5551, 0xD0F2ED2D, 0x4A00D692, 0xE0AEFE30, 0x6BBCDB4A, 0xC315F6F1, 0xB4E1B030, 0x694C4ACE, 0x479208D3, 0x3F8C7B97, 0x747777A6, 0xEDEC9BBB, 0xC8E506C1, 0xB955A92A, 0xB388FDBB, 0x1A4697C3, 0xB10826AA, 0xBB1F2207, 0x291DCD60, 0x2BA3E3A7, 0x1B83DFDD, 0x014D4FD5, 0x80C659F3, 0x3EB45B23, 0x43E36266, 0xBD22532C&#125;;#define GET_ULONG(n, b, i) \\ (n) = ( (unsigned long) (b)[(i + 3)] &lt;&lt; 24 ) \\ | ( (unsigned long) (b)[(i + 2)] &lt;&lt; 16 ) \\ | ( (unsigned long) (b)[(i + 1)] &lt;&lt; 8 ) \\ | ( (unsigned long) (b)[(i )] ); \\#define PUT_ULONG(n, b, i) \\&#123; \\ (b)[(i) + 3] = (unsigned char) ( (n) &gt;&gt; 24 ); \\ (b)[(i) + 2] = (unsigned char) ( (n) &gt;&gt; 16 ); \\ (b)[(i) + 1] = (unsigned char) ( (n) &gt;&gt; 8 ); \\ (b)[(i) ] = (unsigned char) ( (n) ); \\&#125; #define SHL(x, n) ( ((x) &amp; 0xFFFFFFFF) &lt;&lt; n )#define ROTL(x, n) ( SHL((x), n) | ((x) &gt;&gt; (32 - n)) )#define SWAP(a, b) &#123; unsigned t = a; a = b; b = t; t = 0; &#125; void SM4_Decrypt(unsigned char * input, unsigned char * output, int len); void Round(unsigned char input[16], unsigned char output[16]);int main(void)&#123; unsigned char input[] = &#123; 0x7D, 0x54, 0xCB, 0xC0, 0x74, 0xDB, 0xF5, 0xD7, 0x6F, 0xD9, 0x92, 0x1B, 0xEB, 0x28, 0x46, 0x20, 0xE5, 0xD5, 0xD3, 0x60, 0x80, 0x6D, 0x36, 0x2F, 0xB0, 0x63, 0x2F, 0x61, 0x20, 0x0F, 0xA9, 0x30 &#125;; unsigned char output[32] = &#123; 0 &#125;; int i; SM4_Decrypt(input, output, 32); for ( i = 0; i &lt; 32; i++ ) &#123;// printf(&quot;0x%X, &quot;, output[i]); printf(&quot;%c&quot;, output[i]); &#125; return 0;&#125;void SM4_Decrypt(unsigned char * input, unsigned char * output, int len)&#123; int i; for ( i = 0; i &lt; 16; i++ ) SWAP(SK[i], SK[31 - i]); while ( len &gt; 0 ) &#123; Round(input, output); input += 16; output += 16; len -= 16; &#125;&#125;void Round(unsigned char input[16], unsigned char output[16])&#123; unsigned long tmp[4] = &#123; 0 &#125;; int i; unsigned int t = 0; GET_ULONG(tmp[0], input, 0); GET_ULONG(tmp[1], input, 4); GET_ULONG(tmp[2], input, 8); GET_ULONG(tmp[3], input, 12); for ( i = 0; i &lt; 32; i++ ) &#123; t = SK[i] ^ tmp[(i + 1) % 4] ^ tmp[(i + 2) % 4] ^ tmp[(i + 3) % 4]; tmp[i % 4] ^= t ^ ROTL(t, 2) ^ ROTL(t, 24) ^ ROTL(t, 10) ^ ROTL(t, 18); &#125; for ( i = 0 ; i &lt; 4; i++ ) GET_ULONG(SK[26 - i], input, i * 4); // 正好是把加密后的值放入 那么解密的时候就是把密文放入即可 PUT_ULONG(tmp[3], output, 0); PUT_ULONG(tmp[2], output, 4); PUT_ULONG(tmp[1], output, 8); PUT_ULONG(tmp[0], output, 12);&#125; 运行得到 3b2365b04700b5eac3a5fd0ba21b687f 参考：DASCTF2022 X VOID-CEF - P.Z’s Blog (ppppz.net)","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-CEF","slug":"CEF","permalink":"http://example.com/tags/CEF/"}],"author":"1ens"},{"title":"WER","slug":"WER","date":"2022-05-25T16:00:00.000Z","updated":"2022-05-26T14:18:22.094Z","comments":true,"path":"2022/05/26/WER/","link":"","permalink":"http://example.com/2022/05/26/WER/","excerpt":"","text":"无壳，64位 什么是WER：Windows 错误报告 (WER) 是一种灵活的基于事件的反馈基础结构，旨在收集有关Windows可以检测、向 Microsoft 报告信息以及为用户提供任何可用解决方案的硬件和软件问题的相关信息。 参考：关于 WER - Win32 apps | Microsoft Docs 其关键函数如下： 123DWORD WINAPI ApplicationRecoveryCallback( PVOID pvParameter //上下文信息在调用‎‎注册应用程序恢复回拨‎‎函数以注册恢复时指定。‎); ‎应用程序定义的回调函数，用于在应用程序遇到未处理的异常或无响应时保存数据和应用程序状态信息。 参考：ApplicationRecoveryCallback callback function (Windows) | Microsoft Docs 1234HRESULT WerReportHang( [in] HWND hwndHungApp, //‎处理未响应的窗口。 [in, optional] PCWSTR pwzHungApplicationName //要在挂起的报告 UI 中显示的无响应应用程序的名称。); 返回值‎：‎返回S_OK函数是否能够在失败时启动报告或错误代码。请注意，S_OK并不一定意味着“无响应”报告已成功完成，而只是表示已启动。‎ 参考：WerReportHang function (errorrep.h) - Win32 apps | Microsoft Docs 主要运行逻辑为： 1.在初始化注册ApplicationRecoveryCallback函数 2.在OnExit调用WerReportHang触发异常 3.运用ApplicationRecoveryCallback进行真正的逻辑处理。 本题OnExit函数就在main函数里面，调用WerReportHang就会关闭调试器，调试不起来 解题： 搜索关键函数，在import表里面找到，放在了一个dll里面 然后交叉引用找到： 这里的sub_14000F3B0就是我们要找的关键函数 也可以通过MessageBox函数来找。 123data = [ 0x05, 0x03, 0x55, 0x05, 0x04, 0x07, 0x5E, 0x54, 0x05, 0x07, 0x50, 0x02, 0x03, 0x53, 0x5F, 0x50, 0x53, 0x50, 0x53, 0x05, 0x55, 0x00, 0x54, 0x55, 0x57, 0x03, 0x05, 0x02, 0x52, 0x50, 0x51, 0x53]for i in range(len(data)): print(chr(data[i] ^ 102), end = &quot;&quot;) 异或写脚本得到flag","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-[wer]","slug":"wer","permalink":"http://example.com/tags/wer/"}],"author":"1ens"},{"title":"末日邀请","slug":"KCTF-末日邀请（加密闯关）","date":"2022-05-23T16:00:00.000Z","updated":"2022-05-24T15:49:32.139Z","comments":true,"path":"2022/05/24/KCTF-末日邀请（加密闯关）/","link":"","permalink":"http://example.com/2022/05/24/KCTF-%E6%9C%AB%E6%97%A5%E9%82%80%E8%AF%B7%EF%BC%88%E5%8A%A0%E5%AF%86%E9%97%AF%E5%85%B3%EF%BC%89/","excerpt":"","text":"先是输入flag也就是ID，然后进行check，主要考察算法。 对我们的输入进行一系列异或，最后赋值给v39，注意这里v39类型是char，接着进行sbox数据初始化， 然后进行CRC32验证，这里可以动调取到flag，这里v34的值后面会给出并进行验证。 接着先将字符转成数值，存入内存，并且如果大于58就减去55.接着用冰雹猜想验证输入的前三位。我们可以爆破得到v17的值是定值7.具体前三位先按下不表 爆破代码： 123456789101112131415161718192021222324252627#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int i; // edxint v13; // ecxint v15; // eaxint j; // edxint v17; // ediint v33[200]; // [esp+10h] [ebp-368h]int main()&#123; for (int i = 0; i &lt;= 0xff; i++) &#123; v13 = i; v15 = v13; for (j = 1; j &lt; 200; ++j) &#123; if ((v15 &amp; 1) != 0) // 奇数*3+1 v15 = 3 * v15 + 1; else v15 &gt;&gt;= 1; // 偶数右移1 v33[j] = v15; &#125; v17 = v33[198] | v33[197] | v33[196]; cout &lt;&lt; v17 &lt;&lt; endl; &#125;&#125; 后面就是判断后四位是否为KCTF 动调发现是v41[1]是输入的第8个字符，推测后面还需要验证九位，然后进行取余验证，依次取最高前i位，看是否能取余i，不能则失败。但是后面对这里有一个约束。先是冒泡排序从小到大排序，然后对比19，也就是必须包含19每个数字 爆破取得这九位：381654729 12345for i in range(100000000,1000000000): if i//10000000 %2 == 0 and i//1000000%3 == 0 and i//100000%4 == 0 and i//10000%5 == 0 and i//1000 %6 == 0 and i//100 % 7 == 0 and i//10 % 8 == 0 and i%9 == 0: num_all = str(i) if &quot;1&quot; in num_all and &quot;2&quot; in num_all and &quot;3&quot; in num_all and &quot;4&quot; in num_all and &quot;5&quot; in num_all and &quot;6&quot; in num_all and &quot;7&quot; in num_all and &quot;8&quot; in num_all and &quot;9&quot; in num_all : print(i) 最后就是判断v34是否相等 也就是前三位 爆破得到前三位：421 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdint.h&gt; uint32_t magic_arr[] = &#123;0x00000000, 0x09073096, 0x120E612C, 0x1B0951BA, 0xFF6DC419, 0xF66AF48F, 0xED63A535, 0xE46495A3, 0xFEDB8832, 0xF7DCB8A4, 0xECD5E91E, 0xE5D2D988, 0x01B64C2B, 0x08B17CBD, 0x13B82D07, 0x1ABF1D91, 0xFDB71064, 0xF4B020F2, 0xEFB97148, 0xE6BE41DE, 0x02DAD47D, 0x0BDDE4EB, 0x10D4B551, 0x19D385C7, 0x036C9856, 0x0A6BA8C0, 0x1162F97A, 0x1865C9EC, 0xFC015C4F, 0xF5066CD9, 0xEE0F3D63, 0xE7080DF5, 0xFB6E20C8, 0xF269105E, 0xE96041E4, 0xE0677172, 0x0403E4D1, 0x0D04D447, 0x160D85FD, 0x1F0AB56B, 0x05B5A8FA, 0x0CB2986C, 0x17BBC9D6, 0x1EBCF940, 0xFAD86CE3, 0xF3DF5C75, 0xE8D60DCF, 0xE1D13D59, 0x06D930AC, 0x0FDE003A, 0x14D75180, 0x1DD06116, 0xF9B4F4B5, 0xF0B3C423, 0xEBBA9599, 0xE2BDA50F, 0xF802B89E, 0xF1058808, 0xEA0CD9B2, 0xE30BE924, 0x076F7C87, 0x0E684C11, 0x15611DAB, 0x1C662D3D, 0xF6DC4190, 0xFFDB7106, 0xE4D220BC, 0xEDD5102A, 0x09B18589, 0x00B6B51F, 0x1BBFE4A5, 0x12B8D433, 0x0807C9A2, 0x0100F934, 0x1A09A88E, 0x130E9818, 0xF76A0DBB, 0xFE6D3D2D, 0xE5646C97, 0xEC635C01, 0x0B6B51F4, 0x026C6162, 0x196530D8, 0x1062004E, 0xF40695ED, 0xFD01A57B, 0xE608F4C1, 0xEF0FC457, 0xF5B0D9C6, 0xFCB7E950, 0xE7BEB8EA, 0xEEB9887C, 0x0ADD1DDF, 0x03DA2D49, 0x18D37CF3, 0x11D44C65, 0x0DB26158, 0x04B551CE, 0x1FBC0074, 0x16BB30E2, 0xF2DFA541, 0xFBD895D7, 0xE0D1C46D, 0xE9D6F4FB, 0xF369E96A, 0xFA6ED9FC, 0xE1678846, 0xE860B8D0, 0x0C042D73, 0x05031DE5, 0x1E0A4C5F, 0x170D7CC9, 0xF005713C, 0xF90241AA, 0xE20B1010, 0xEB0C2086, 0x0F68B525, 0x066F85B3, 0x1D66D409, 0x1461E49F, 0x0EDEF90E, 0x07D9C998, 0x1CD09822, 0x15D7A8B4, 0xF1B33D17, 0xF8B40D81, 0xE3BD5C3B, 0xEABA6CAD, 0xEDB88320, 0xE4BFB3B6, 0xFFB6E20C, 0xF6B1D29A, 0x12D54739, 0x1BD277AF, 0x00DB2615, 0x09DC1683, 0x13630B12, 0x1A643B84, 0x016D6A3E, 0x086A5AA8, 0xEC0ECF0B, 0xE509FF9D, 0xFE00AE27, 0xF7079EB1, 0x100F9344, 0x1908A3D2, 0x0201F268, 0x0B06C2FE, 0xEF62575D, 0xE66567CB, 0xFD6C3671, 0xF46B06E7, 0xEED41B76, 0xE7D32BE0, 0xFCDA7A5A, 0xF5DD4ACC, 0x11B9DF6F, 0x18BEEFF9, 0x03B7BE43, 0x0AB08ED5, 0x16D6A3E8, 0x1FD1937E, 0x04D8C2C4, 0x0DDFF252, 0xE9BB67F1, 0xE0BC5767, 0xFBB506DD, 0xF2B2364B, 0xE80D2BDA, 0xE10A1B4C, 0xFA034AF6, 0xF3047A60, 0x1760EFC3, 0x1E67DF55, 0x056E8EEF, 0x0C69BE79, 0xEB61B38C, 0xE266831A, 0xF96FD2A0, 0xF068E236, 0x140C7795, 0x1D0B4703, 0x060216B9, 0x0F05262F, 0x15BA3BBE, 0x1CBD0B28, 0x07B45A92, 0x0EB36A04, 0xEAD7FFA7, 0xE3D0CF31, 0xF8D99E8B, 0xF1DEAE1D, 0x1B64C2B0, 0x1263F226, 0x096AA39C, 0x006D930A, 0xE40906A9, 0xED0E363F, 0xF6076785, 0xFF005713, 0xE5BF4A82, 0xECB87A14, 0xF7B12BAE, 0xFEB61B38, 0x1AD28E9B, 0x13D5BE0D, 0x08DCEFB7, 0x01DBDF21, 0xE6D3D2D4, 0xEFD4E242, 0xF4DDB3F8, 0xFDDA836E, 0x19BE16CD, 0x10B9265B, 0x0BB077E1, 0x02B74777, 0x18085AE6, 0x110F6A70, 0x0A063BCA, 0x03010B5C, 0xE7659EFF, 0xEE62AE69, 0xF56BFFD3, 0xFC6CCF45, 0xE00AE278, 0xE90DD2EE, 0xF2048354, 0xFB03B3C2, 0x1F672661, 0x166016F7, 0x0D69474D, 0x046E77DB, 0x1ED16A4A, 0x17D65ADC, 0x0CDF0B66, 0x05D83BF0, 0xE1BCAE53, 0xE8BB9EC5, 0xF3B2CF7F, 0xFAB5FFE9, 0x1DBDF21C, 0x14BAC28A, 0x0FB39330, 0x06B4A3A6, 0xE2D03605, 0xEBD70693, 0xF0DE5729, 0xF9D967BF, 0xE3667A2E, 0xEA614AB8, 0xF1681B02, 0xF86F2B94, 0x1C0BBE37, 0x150C8EA1, 0x0E05DF1B, 0x0702EF8D&#125;; char cstr[] = &quot;...KCTF381654729&quot;; int main() &#123; for (int i = 0x20; i &lt; 0x7e; i++) &#123; for (int j = 0x20; j &lt; 0x7e; j++) &#123; for (int k = 0x20; k &lt; 0x7e; k++) &#123; cstr[0] = i; cstr[1] = j; cstr[2] = k; int32_t v11 = -1; for (int idx = 0; idx &lt; 16; idx++) &#123; v11 = magic_arr[(uint8_t)(v11 ^ cstr[idx])] ^ (v11 &gt;&gt; 8); &#125; if ((~v11) == 0xF52E0765) &#123; printf(&quot;%c %c %c\\n&quot;, i, j, k); &#125; &#125; &#125; &#125;&#125; 最后的flag:421KCTF381654729","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-加解密","slug":"加解密","permalink":"http://example.com/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/"}],"author":"1ens"},{"title":"ezam","slug":"ezam（ollvm 迷宫 进制）","date":"2022-05-23T16:00:00.000Z","updated":"2022-05-26T13:18:54.861Z","comments":true,"path":"2022/05/24/ezam（ollvm 迷宫 进制）/","link":"","permalink":"http://example.com/2022/05/24/ezam%EF%BC%88ollvm%20%E8%BF%B7%E5%AE%AB%20%E8%BF%9B%E5%88%B6%EF%BC%89/","excerpt":"","text":"题目打开 标准的ollvm混肴，用脚本两次去除 得到正常的程序 初步分析是以为多项式相加，疏忽了v17以及前面一大段数据的初始化。想着用z3硬解失败了。主要逻辑为读取输入，判断是否为数字，然后转换成四进制，走迷宫。前面的一大段加密是初始化迷宫地图v17，我们可以动调得到一个16*28的迷宫：（做题多尝试 123456789101112131415161,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,0,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0 下面看一下 sub_400670 函数 ，结合动调，是十进制转四进制算法。下面就是迷宫出走方式得到两条路径，根据函数判断路径长度是45，所以是上面那条232222322330030000303322223333333222233333333232222322330030000303322222222222333333300033333333然后四进制转十进制得到flag 1234567891011def anyToDecimal(num,n): baseStr = &#123;&quot;0&quot;:0,&quot;1&quot;:1,&quot;2&quot;:2,&quot;3&quot;:3,&quot;4&quot;:4,&quot;5&quot;:5,&quot;6&quot;:6,&quot;7&quot;:7,&quot;8&quot;:8,&quot;9&quot;:9, &quot;a&quot;:10,&quot;b&quot;:11,&quot;c&quot;:12,&quot;d&quot;:13,&quot;e&quot;:14,&quot;f&quot;:15,&quot;g&quot;:16,&quot;h&quot;:17,&quot;i&quot;:18,&quot;j&quot;:19&#125; new_num = 0 nNum = len(num) - 1 for i in num: new_num = new_num + baseStr[i]*pow(n,nNum) nNum = nNum -1 print(new_num)anyToDecimal(&#x27;232222322330030000303322223333333222233333333&#x27;, 4) flag{902741462666576198076399615}","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-[迷宫] -[进制]","slug":"迷宫-进制","permalink":"http://example.com/tags/%E8%BF%B7%E5%AE%AB-%E8%BF%9B%E5%88%B6/"}],"author":"1ens"}],"categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-luajit","slug":"luajit","permalink":"http://example.com/tags/luajit/"},{"name":"-CEF","slug":"CEF","permalink":"http://example.com/tags/CEF/"},{"name":"-[wer]","slug":"wer","permalink":"http://example.com/tags/wer/"},{"name":"-加解密","slug":"加解密","permalink":"http://example.com/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/"},{"name":"-[迷宫] -[进制]","slug":"迷宫-进制","permalink":"http://example.com/tags/%E8%BF%B7%E5%AE%AB-%E8%BF%9B%E5%88%B6/"}]}