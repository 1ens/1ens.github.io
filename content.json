{"meta":{"title":"1ens's blog","subtitle":"","description":"a","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2022-05-24T15:09:56.842Z","updated":"2022-05-24T15:09:56.842Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2022-05-24T15:02:08.935Z","updated":"2022-05-24T15:02:08.935Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-05-24T15:06:34.544Z","updated":"2022-05-24T15:06:34.544Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"big lao","text":"big lao 带带"},{"title":"所有标签","date":"2022-05-24T15:02:51.734Z","updated":"2022-05-24T15:02:51.734Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-24T15:00:44.362Z","updated":"2022-05-24T15:00:44.362Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-24T15:03:31.990Z","updated":"2022-05-24T15:03:31.990Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"KCTF-末日邀请（加密闯关）","date":"2022-05-24T12:32:00.850Z","updated":"2022-05-24T14:23:30.140Z","comments":true,"path":"2022/05/24/KCTF-末日邀请（加密闯关）/","link":"","permalink":"http://example.com/2022/05/24/KCTF-%E6%9C%AB%E6%97%A5%E9%82%80%E8%AF%B7%EF%BC%88%E5%8A%A0%E5%AF%86%E9%97%AF%E5%85%B3%EF%BC%89/","excerpt":"","text":"先是输入flag也就是ID，然后进行check，主要考察算法。 对我们的输入进行一系列异或，最后赋值给v39，注意这里v39类型是char，接着进行sbox数据初始化， 然后进行CRC32验证，这里可以动调取到flag，这里v34的值后面会给出并进行验证。 接着先将字符转成数值，存入内存，并且如果大于58就减去55.接着用冰雹猜想验证输入的前三位。我们可以爆破得到v17的值是定值7.具体前三位先按下不表 爆破代码： 123456789101112131415161718192021222324252627#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int i; // edxint v13; // ecxint v15; // eaxint j; // edxint v17; // ediint v33[200]; // [esp+10h] [ebp-368h]int main()&#123; for (int i = 0; i &lt;= 0xff; i++) &#123; v13 = i; v15 = v13; for (j = 1; j &lt; 200; ++j) &#123; if ((v15 &amp; 1) != 0) // 奇数*3+1 v15 = 3 * v15 + 1; else v15 &gt;&gt;= 1; // 偶数右移1 v33[j] = v15; &#125; v17 = v33[198] | v33[197] | v33[196]; cout &lt;&lt; v17 &lt;&lt; endl; &#125;&#125; 后面就是判断后四位是否为KCTF 动调发现是v41[1]是输入的第8个字符，推测后面还需要验证九位，然后进行取余验证，依次取最高前i位，看是否能取余i，不能则失败。但是后面对这里有一个约束。先是冒泡排序从小到大排序，然后对比19，也就是必须包含19每个数字 爆破取得这九位：381654729 12345for i in range(100000000,1000000000): if i//10000000 %2 == 0 and i//1000000%3 == 0 and i//100000%4 == 0 and i//10000%5 == 0 and i//1000 %6 == 0 and i//100 % 7 == 0 and i//10 % 8 == 0 and i%9 == 0: num_all = str(i) if &quot;1&quot; in num_all and &quot;2&quot; in num_all and &quot;3&quot; in num_all and &quot;4&quot; in num_all and &quot;5&quot; in num_all and &quot;6&quot; in num_all and &quot;7&quot; in num_all and &quot;8&quot; in num_all and &quot;9&quot; in num_all : print(i) 最后就是判断v34是否相等 也就是前三位 爆破得到前三位：421 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdint.h&gt; uint32_t magic_arr[] = &#123;0x00000000, 0x09073096, 0x120E612C, 0x1B0951BA, 0xFF6DC419, 0xF66AF48F, 0xED63A535, 0xE46495A3, 0xFEDB8832, 0xF7DCB8A4, 0xECD5E91E, 0xE5D2D988, 0x01B64C2B, 0x08B17CBD, 0x13B82D07, 0x1ABF1D91, 0xFDB71064, 0xF4B020F2, 0xEFB97148, 0xE6BE41DE, 0x02DAD47D, 0x0BDDE4EB, 0x10D4B551, 0x19D385C7, 0x036C9856, 0x0A6BA8C0, 0x1162F97A, 0x1865C9EC, 0xFC015C4F, 0xF5066CD9, 0xEE0F3D63, 0xE7080DF5, 0xFB6E20C8, 0xF269105E, 0xE96041E4, 0xE0677172, 0x0403E4D1, 0x0D04D447, 0x160D85FD, 0x1F0AB56B, 0x05B5A8FA, 0x0CB2986C, 0x17BBC9D6, 0x1EBCF940, 0xFAD86CE3, 0xF3DF5C75, 0xE8D60DCF, 0xE1D13D59, 0x06D930AC, 0x0FDE003A, 0x14D75180, 0x1DD06116, 0xF9B4F4B5, 0xF0B3C423, 0xEBBA9599, 0xE2BDA50F, 0xF802B89E, 0xF1058808, 0xEA0CD9B2, 0xE30BE924, 0x076F7C87, 0x0E684C11, 0x15611DAB, 0x1C662D3D, 0xF6DC4190, 0xFFDB7106, 0xE4D220BC, 0xEDD5102A, 0x09B18589, 0x00B6B51F, 0x1BBFE4A5, 0x12B8D433, 0x0807C9A2, 0x0100F934, 0x1A09A88E, 0x130E9818, 0xF76A0DBB, 0xFE6D3D2D, 0xE5646C97, 0xEC635C01, 0x0B6B51F4, 0x026C6162, 0x196530D8, 0x1062004E, 0xF40695ED, 0xFD01A57B, 0xE608F4C1, 0xEF0FC457, 0xF5B0D9C6, 0xFCB7E950, 0xE7BEB8EA, 0xEEB9887C, 0x0ADD1DDF, 0x03DA2D49, 0x18D37CF3, 0x11D44C65, 0x0DB26158, 0x04B551CE, 0x1FBC0074, 0x16BB30E2, 0xF2DFA541, 0xFBD895D7, 0xE0D1C46D, 0xE9D6F4FB, 0xF369E96A, 0xFA6ED9FC, 0xE1678846, 0xE860B8D0, 0x0C042D73, 0x05031DE5, 0x1E0A4C5F, 0x170D7CC9, 0xF005713C, 0xF90241AA, 0xE20B1010, 0xEB0C2086, 0x0F68B525, 0x066F85B3, 0x1D66D409, 0x1461E49F, 0x0EDEF90E, 0x07D9C998, 0x1CD09822, 0x15D7A8B4, 0xF1B33D17, 0xF8B40D81, 0xE3BD5C3B, 0xEABA6CAD, 0xEDB88320, 0xE4BFB3B6, 0xFFB6E20C, 0xF6B1D29A, 0x12D54739, 0x1BD277AF, 0x00DB2615, 0x09DC1683, 0x13630B12, 0x1A643B84, 0x016D6A3E, 0x086A5AA8, 0xEC0ECF0B, 0xE509FF9D, 0xFE00AE27, 0xF7079EB1, 0x100F9344, 0x1908A3D2, 0x0201F268, 0x0B06C2FE, 0xEF62575D, 0xE66567CB, 0xFD6C3671, 0xF46B06E7, 0xEED41B76, 0xE7D32BE0, 0xFCDA7A5A, 0xF5DD4ACC, 0x11B9DF6F, 0x18BEEFF9, 0x03B7BE43, 0x0AB08ED5, 0x16D6A3E8, 0x1FD1937E, 0x04D8C2C4, 0x0DDFF252, 0xE9BB67F1, 0xE0BC5767, 0xFBB506DD, 0xF2B2364B, 0xE80D2BDA, 0xE10A1B4C, 0xFA034AF6, 0xF3047A60, 0x1760EFC3, 0x1E67DF55, 0x056E8EEF, 0x0C69BE79, 0xEB61B38C, 0xE266831A, 0xF96FD2A0, 0xF068E236, 0x140C7795, 0x1D0B4703, 0x060216B9, 0x0F05262F, 0x15BA3BBE, 0x1CBD0B28, 0x07B45A92, 0x0EB36A04, 0xEAD7FFA7, 0xE3D0CF31, 0xF8D99E8B, 0xF1DEAE1D, 0x1B64C2B0, 0x1263F226, 0x096AA39C, 0x006D930A, 0xE40906A9, 0xED0E363F, 0xF6076785, 0xFF005713, 0xE5BF4A82, 0xECB87A14, 0xF7B12BAE, 0xFEB61B38, 0x1AD28E9B, 0x13D5BE0D, 0x08DCEFB7, 0x01DBDF21, 0xE6D3D2D4, 0xEFD4E242, 0xF4DDB3F8, 0xFDDA836E, 0x19BE16CD, 0x10B9265B, 0x0BB077E1, 0x02B74777, 0x18085AE6, 0x110F6A70, 0x0A063BCA, 0x03010B5C, 0xE7659EFF, 0xEE62AE69, 0xF56BFFD3, 0xFC6CCF45, 0xE00AE278, 0xE90DD2EE, 0xF2048354, 0xFB03B3C2, 0x1F672661, 0x166016F7, 0x0D69474D, 0x046E77DB, 0x1ED16A4A, 0x17D65ADC, 0x0CDF0B66, 0x05D83BF0, 0xE1BCAE53, 0xE8BB9EC5, 0xF3B2CF7F, 0xFAB5FFE9, 0x1DBDF21C, 0x14BAC28A, 0x0FB39330, 0x06B4A3A6, 0xE2D03605, 0xEBD70693, 0xF0DE5729, 0xF9D967BF, 0xE3667A2E, 0xEA614AB8, 0xF1681B02, 0xF86F2B94, 0x1C0BBE37, 0x150C8EA1, 0x0E05DF1B, 0x0702EF8D&#125;; char cstr[] = &quot;...KCTF381654729&quot;; int main() &#123; for (int i = 0x20; i &lt; 0x7e; i++) &#123; for (int j = 0x20; j &lt; 0x7e; j++) &#123; for (int k = 0x20; k &lt; 0x7e; k++) &#123; cstr[0] = i; cstr[1] = j; cstr[2] = k; int32_t v11 = -1; for (int idx = 0; idx &lt; 16; idx++) &#123; v11 = magic_arr[(uint8_t)(v11 ^ cstr[idx])] ^ (v11 &gt;&gt; 8); &#125; if ((~v11) == 0xF52E0765) &#123; printf(&quot;%c %c %c\\n&quot;, i, j, k); &#125; &#125; &#125; &#125;&#125; 最后的flag:421KCTF381654729","categories":[],"tags":[]},{"title":"","slug":"ezam（ollvm 迷宫 进制）","date":"2022-05-24T12:32:00.840Z","updated":"2022-05-24T14:23:18.402Z","comments":true,"path":"2022/05/24/ezam（ollvm 迷宫 进制）/","link":"","permalink":"http://example.com/2022/05/24/ezam%EF%BC%88ollvm%20%E8%BF%B7%E5%AE%AB%20%E8%BF%9B%E5%88%B6%EF%BC%89/","excerpt":"","text":"题目打开 标准的ollvm混肴，用脚本两次去除 得到正常的程序 初步分析是以为多项式相加，疏忽了v17以及前面一大段数据的初始化。想着用z3硬解失败了。主要逻辑为读取输入，判断是否为数字，然后转换成四进制，走迷宫。前面的一大段加密是初始化迷宫地图v17，我们可以动调得到一个16*28的迷宫：（做题多尝试 123456789101112131415161,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,0,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0 下面看一下 sub_400670 函数 ，结合动调，是十进制转四进制算法。下面就是迷宫出走方式得到两条路径，根据函数判断路径长度是45，所以是上面那条232222322330030000303322223333333222233333333232222322330030000303322222222222333333300033333333然后四进制转十进制得到flag 1234567891011def anyToDecimal(num,n): baseStr = &#123;&quot;0&quot;:0,&quot;1&quot;:1,&quot;2&quot;:2,&quot;3&quot;:3,&quot;4&quot;:4,&quot;5&quot;:5,&quot;6&quot;:6,&quot;7&quot;:7,&quot;8&quot;:8,&quot;9&quot;:9, &quot;a&quot;:10,&quot;b&quot;:11,&quot;c&quot;:12,&quot;d&quot;:13,&quot;e&quot;:14,&quot;f&quot;:15,&quot;g&quot;:16,&quot;h&quot;:17,&quot;i&quot;:18,&quot;j&quot;:19&#125; new_num = 0 nNum = len(num) - 1 for i in num: new_num = new_num + baseStr[i]*pow(n,nNum) nNum = nNum -1 print(new_num)anyToDecimal(&#x27;232222322330030000303322223333333222233333333&#x27;, 4) flag{902741462666576198076399615}","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-05-24T10:37:46.858Z","updated":"2022-05-24T10:37:46.858Z","comments":true,"path":"2022/05/24/hello-world/","link":"","permalink":"http://example.com/2022/05/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}