{"meta":{"title":"1ens's blog","subtitle":"","description":"a","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2022-05-24T15:09:56.842Z","updated":"2022-05-24T15:09:56.842Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2022-05-25T03:46:23.885Z","updated":"2022-05-25T03:46:23.885Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一个菜鸡逆向选手"},{"title":"所有分类","date":"2022-05-24T15:02:08.935Z","updated":"2022-05-24T15:02:08.935Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-05-24T15:02:51.734Z","updated":"2022-05-24T15:02:51.734Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-05-24T15:06:34.544Z","updated":"2022-05-24T15:06:34.544Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"big lao","text":"big lao 带带"},{"title":"","date":"2022-05-24T15:03:31.990Z","updated":"2022-05-24T15:03:31.990Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"JIT","slug":"JIT","date":"2022-05-27T16:00:00.000Z","updated":"2022-05-28T09:02:18.393Z","comments":true,"path":"2022/05/28/JIT/","link":"","permalink":"http://example.com/2022/05/28/JIT/","excerpt":"","text":"什么是JITJIT &#x3D; Just In Time即时编译，是动态编译的一种形式，是一种优化虚拟机运行的技术。程序运行通常有两种方式，一种是静态编译，一种是动态解释，即时编译混合了这二者。 lujit运行过程： 解题： 得到一个.out 文件，电脑识别成Wireshark 系列文件，拉入WinHex会发现是.LJ开头，可以推断是Luajit逆向。 先编译LuaJit2.1.0Beta3Download (luajit.org) 去官网下载 运行x64 Native Tools Command Prompt for VS （用Everything搜索）， 然后将下载的安装包解压到相应的盘下，然后进入解压后的SRC文件 msvcbuild.bat gc64编译出的64位（题目的64位 msvcbuild.bat编译出的是32位 反编译bobsayshilol&#x2F;luajit-decomp at deprecated (github.com) 下载反编译工具 然后将上一步src文件夹里面jit文件夹，和lua51.dll luajit.exe 放到刚刚下载的反编译工具文件夹里面 然后将我们的题目附件改名为test.lua，再按下decoder_new.exe该文件就出现了out.lua和out2.lua 用sublime打开，就可以开始分析字节码了 未完待续。。","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-luajit","slug":"luajit","permalink":"http://example.com/tags/luajit/"}],"author":"1ens"},{"title":"TWIN","slug":"TWIN","date":"2022-05-27T16:00:00.000Z","updated":"2022-05-28T14:18:24.673Z","comments":true,"path":"2022/05/28/TWIN/","link":"","permalink":"http://example.com/2022/05/28/TWIN/","excerpt":"","text":"TLS回调函数：TLS(Thread Local Storage, 线程局部存储)回调函数，TLS 回调函数的调用运行要先于 EP 代码的执行，并且每次创建或结束线程都会再次调用，故常用于反调试。 可以在节区表发现IMAGE_TLS_DIRECTORY，找到Address of Callbacks（注意回调函数一般不止一个） 题解： 32位无壳 首先是一个虚假的逻辑验证。 在函数栏搜索找到callback函数，但是$+5,没有直接反编译，找到主要回调函数 这里有一个小花指令，最好retn会跳到sub_4019BF,后面还会有一处 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158void __usercall sub_4019BF(int a1@&lt;ebp&gt;)&#123; void *v1; // eax if ( *(_DWORD *)(a1 + 12) == 1 ) &#123; memset((void *)(a1 - 284), 0, 0x50u); sub_401930((void *)(a1 - 284)); *(_BYTE *)(a1 - 1) = 0; *(_BYTE *)(a1 - 1) = NtCurrentPeb()-&gt;BeingDebugged; if ( !*(_BYTE *)(a1 - 1) ) return; *(_BYTE *)(a1 - 32) = 57; *(_BYTE *)(a1 - 31) = 51; *(_BYTE *)(a1 - 30) = 62; *(_BYTE *)(a1 - 29) = 56; *(_BYTE *)(a1 - 28) = 0; sub_4018C0(a1 - 32); hObject = CreateFileMappingA(0, 0, 4u, 0, 0x1000u, (LPCSTR)(a1 - 32)); *(_DWORD *)dword_404448 = MapViewOfFile(hObject, 0xF001Fu, 0, 0, 0x1000u); *(_BYTE *)(a1 - 116) = 47; *(_BYTE *)(a1 - 115) = 19; *(_BYTE *)(a1 - 114) = 26; *(_BYTE *)(a1 - 113) = 30; *(_BYTE *)(a1 - 112) = 12; *(_BYTE *)(a1 - 111) = 26; *(_BYTE *)(a1 - 110) = 95; *(_BYTE *)(a1 - 109) = 22; *(_BYTE *)(a1 - 108) = 17; *(_BYTE *)(a1 - 107) = 15; *(_BYTE *)(a1 - 106) = 10; *(_BYTE *)(a1 - 105) = 11; *(_BYTE *)(a1 - 104) = 95; *(_BYTE *)(a1 - 103) = 6; *(_BYTE *)(a1 - 102) = 16; *(_BYTE *)(a1 - 101) = 10; *(_BYTE *)(a1 - 100) = 13; *(_BYTE *)(a1 - 99) = 95; *(_BYTE *)(a1 - 98) = 25; *(_BYTE *)(a1 - 97) = 19; *(_BYTE *)(a1 - 96) = 30; *(_BYTE *)(a1 - 95) = 24; *(_BYTE *)(a1 - 94) = 69; *(_BYTE *)(a1 - 93) = 95; *(_BYTE *)(a1 - 92) = 0; v1 = (void *)sub_4018C0(a1 - 116); sub_401930(v1); *(_BYTE *)(a1 - 8) = 90; *(_BYTE *)(a1 - 7) = 12; *(_BYTE *)(a1 - 6) = 0; sub_4018C0(a1 - 8); sub_401130((char *)(a1 - 8), dword_404448[0]); &#125; if ( !*(_DWORD *)(a1 + 12) ) &#123; *(_BYTE *)(a1 - 24) = 81; *(_BYTE *)(a1 - 23) = 80; *(_BYTE *)(a1 - 22) = 11; *(_BYTE *)(a1 - 21) = 18; *(_BYTE *)(a1 - 20) = 15; *(_BYTE *)(a1 - 19) = 0; sub_4018C0(a1 - 24); sub_401410(); memset((void *)(a1 - 204), 0, 0x44u); *(_DWORD *)(a1 - 204) = 68; CreateProcessA( (LPCSTR)(a1 - 24), 0, 0, 0, 0, 3u, 0, 0, (LPSTARTUPINFOA)(a1 - 204), (LPPROCESS_INFORMATION)(a1 - 136)); *(_BYTE *)(a1 - 44) = 28; *(_BYTE *)(a1 - 43) = 16; *(_BYTE *)(a1 - 42) = 13; *(_BYTE *)(a1 - 41) = 13; *(_BYTE *)(a1 - 40) = 26; *(_BYTE *)(a1 - 39) = 28; *(_BYTE *)(a1 - 38) = 11; *(_BYTE *)(a1 - 37) = 117; *(_BYTE *)(a1 - 36) = 0; *(_BYTE *)(a1 - 16) = 8; *(_BYTE *)(a1 - 15) = 13; *(_BYTE *)(a1 - 14) = 16; *(_BYTE *)(a1 - 13) = 17; *(_BYTE *)(a1 - 12) = 24; *(_BYTE *)(a1 - 11) = 117; *(_BYTE *)(a1 - 10) = 0; *(_BYTE *)(a1 - 88) = 47; *(_BYTE *)(a1 - 87) = 19; *(_BYTE *)(a1 - 86) = 26; *(_BYTE *)(a1 - 85) = 30; *(_BYTE *)(a1 - 84) = 12; *(_BYTE *)(a1 - 83) = 26; *(_BYTE *)(a1 - 82) = 95; *(_BYTE *)(a1 - 81) = 28; *(_BYTE *)(a1 - 80) = 19; *(_BYTE *)(a1 - 79) = 16; *(_BYTE *)(a1 - 78) = 12; *(_BYTE *)(a1 - 77) = 26; *(_BYTE *)(a1 - 76) = 95; *(_BYTE *)(a1 - 75) = 11; *(_BYTE *)(a1 - 74) = 23; *(_BYTE *)(a1 - 73) = 26; *(_BYTE *)(a1 - 72) = 95; *(_BYTE *)(a1 - 71) = 27; *(_BYTE *)(a1 - 70) = 26; *(_BYTE *)(a1 - 69) = 29; *(_BYTE *)(a1 - 68) = 10; *(_BYTE *)(a1 - 67) = 24; *(_BYTE *)(a1 - 66) = 24; *(_BYTE *)(a1 - 65) = 26; *(_BYTE *)(a1 - 64) = 13; *(_BYTE *)(a1 - 63) = 95; *(_BYTE *)(a1 - 62) = 30; *(_BYTE *)(a1 - 61) = 17; *(_BYTE *)(a1 - 60) = 27; *(_BYTE *)(a1 - 59) = 95; *(_BYTE *)(a1 - 58) = 11; *(_BYTE *)(a1 - 57) = 13; *(_BYTE *)(a1 - 56) = 6; *(_BYTE *)(a1 - 55) = 95; *(_BYTE *)(a1 - 54) = 30; *(_BYTE *)(a1 - 53) = 24; *(_BYTE *)(a1 - 52) = 30; *(_BYTE *)(a1 - 51) = 22; *(_BYTE *)(a1 - 50) = 17; *(_BYTE *)(a1 - 49) = 117; *(_BYTE *)(a1 - 48) = 0; sub_401510(a1 - 24, a1 - 136); if ( dword_404440 == 1 ) &#123; sub_4012C0(*(_DWORD *)dword_404448 + 20, 5, &amp;unk_40405C); *(_DWORD *)(a1 - 120) = memcmp((const void *)(*(_DWORD *)dword_404448 + 20), &amp;unk_40402C, 0x14u); if ( !*(_DWORD *)(a1 - 120) ) &#123; sub_4018C0(a1 - 44); sub_401930((void *)(a1 - 44));LABEL_12: CloseHandle(hObject); return; &#125; &#125; else if ( dword_404440 == -2 ) &#123; sub_4018C0(a1 - 88); sub_401930((void *)(a1 - 88)); goto LABEL_12; &#125; sub_4018C0(a1 - 16); sub_401930((void *)(a1 - 16)); goto LABEL_12; &#125;&#125; 这个函数有两大部分 这个a1 + 12就是对应着运行前与退出，对应DLL_PROCESS_ATTACH和DLL_PROCESS_DETACH 所以总结一下！a1 + 12 &#x3D;&#x3D; 1是线程运行之前执行 a1 + 12 &#x3D;&#x3D; 0 是线程退出后运行 首先会遇到一个PEB反调试，我们直接修改ZF标志位绕过。 然后就是一个异或，将原始数据inputflag混肴。 紧接着读取我们的输入， 输入之后F9进入第二部分 获取WriteFile API的地址 将WriteFile API地址改成自写函数的地址（也就是Hook函数） 也就是之后我们调用WriteFile函数地址就会调用Hook函数（Hook函数里执行完Hook代码就会脱钩） GetModuleHandleA得到WiteFile函数的句柄，GetProcAddress函数获取WriteFile函数的地址存入dword_4043DC，并在sub_4016C0中将这个值修改为sub_401650的地址值。 随后在第二个TLS函数会调用ExitProcess()，也就是退出进程，那么退出进程又会调用TLS函数链，于是又回到了第一个TLS函数，不过这次进的是退出线程的函数块，分析主要函数 这里创建了一个文件，也就是tmp文件，但是对名字也进行了混肴,然后往里面写入进程。 我们可以发现这里的writefile变成了我们相要执行的函数 把子进程的两个值改成6，实践上是xxtea在加密过程中的右移轮次。 接下来分析一下tmp文件。 其中 先判断是否被调试，然后对delta进行异或操作。 hObject = CreateFileMappingA(0, 0, 4u, 0, 0x1000u, Name_FLAG);创建名字为FLAG的文件映射对象，用于进程间通信。*(_DWORD *)input = MapViewOfFile(hObject, 0xF001Fu, 0, 0, 0x1000u);存了内存映射文件，便于后面的共享内存。简而言之，就是创建一个名为FLAG的文件映射对象，把input指向的地址设置成一块共享的内存，这样就可以在子进程里对input这块内存进行修改，实现加密。 一个魔改的XXTEA加密，z右移5改成了右移6位 这里一处函数需要注意 WaitForDebugEvent表明父进程调用子进程是以调试方式打开，也就是说父进程调试子进程，所以实际上子进程的反调试是不能绕过的，正常执行程序应该会进入子进程的if语句，对key和delta进行一些魔改运算。0xC0000005，这是一个异常代码，代表EXCEPTION_ACCESS_VIOLATION，内存访问异常，也即子进程中触发的异常。 也就是说，子进程被父进程调试，当子进程发生异常，应当交由调试者（父进程）处理。所以当子进程中触发异常，程序就会流回父进程，判断是否为内存访问异常，如果是，就对eip和eax做出相应修改。 再回去看子进程触发异常的地方，eip+5之后正好跳过了会触发异常的地方。而eax里存储的实际上是delta经过一通魔改运算之后的结果。也就是说，delta不仅在子进程里被修改，还会在父进程里异或一次，也就是还原成之前最初的模样 前一半的（修改的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define DELTA 0x1c925d64#define MX (((z&gt;&gt;6^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))uint32_t k[4]= &#123;0x12,0x90,0x56,0x78&#125;;void xxtea(uint32_t* v, int n, uint32_t* key)&#123; unsigned int sum,z,p,y; int e, rounds; rounds = 6 + 52/n; sum = rounds * DELTA; y = v[0]; do &#123; e = (sum &gt;&gt; 2) &amp; 3; for (p=n-1; p&gt;0; p--) &#123; z = v[p-1]; y = v[p] -= MX; &#125; z = v[n-1]; y = v[0] -= MX; sum -= DELTA; &#125; while (--rounds);&#125;int main()&#123; uint32_t v[5] = &#123;0x6b7ce328,0x4841d5dd,0x963784dc,0xef8a3226,0x776b226&#125;; int n = 5; xxtea(v, n, k); int i; for(i=0;i&lt;5;i++) &#123; printf(&quot;%c&quot;,v[i]&amp;0xff); printf(&quot;%c&quot;,v[i]&gt;&gt;8&amp;0xff); printf(&quot;%c&quot;,v[i]&gt;&gt;16&amp;0xff); printf(&quot;%c&quot;,v[i]&gt;&gt;24&amp;0xff); &#125; return 0;&#125; 后面那半就比较好出了，没有改任何Delta数或XXTEA算法 miniLctf{cbda59ff59e3e90c91c02e9b40b78b} 参考：miniL2022 WP 今晚恰烤lq！ - 云之君 (yunzh1jun.com)","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"TLS回调函数","slug":"TLS回调函数","permalink":"http://example.com/tags/TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"},{"name":"反调试","slug":"反调试","permalink":"http://example.com/tags/%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"name":"异常处理","slug":"异常处理","permalink":"http://example.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}],"author":"1ens"},{"title":"CEF","slug":"cef","date":"2022-05-26T16:00:00.000Z","updated":"2022-05-27T14:31:42.247Z","comments":true,"path":"2022/05/27/cef/","link":"","permalink":"http://example.com/2022/05/27/cef/","excerpt":"","text":"32位无壳程序 CEF简介: 嵌入式Chromium框架(简称CEF) 是一个由Marshall Greenblatt在2008建立的开源项目，它主要目的是开发一个基于Google Chromium的Webbrowser控件。CEF支持一系列的编程语言和操作系统，并且能很容易地整合到新的或已有的工程中去。 解题：正面去分析的话，十分困难。去搜索相应字符串无果 这里我们可以去从数据调用去分析，我们去分析.data的数据 一组奇怪的数据，猜测加密时用到，交叉引用找到调用的地方 调试验证一下，一开始会停在调用的dll函数里面，我们直接步过，然后输入32位之后就会断下F9提示correct，验证我们的猜想是正确的。调试发现其实，加密整个逻辑就在else里面，一个魔改的SM4，其基本运算为异或^和循环左移&lt;&lt;&lt; round函数 解密： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned int SK[32] = &#123; 0xE8DB227C, 0x012451B9, 0xED08A9DB, 0xC91F65C3, 0xB3D1E981, 0x319B4734, 0xA4BA5551, 0xD0F2ED2D, 0x4A00D692, 0xE0AEFE30, 0x6BBCDB4A, 0xC315F6F1, 0xB4E1B030, 0x694C4ACE, 0x479208D3, 0x3F8C7B97, 0x747777A6, 0xEDEC9BBB, 0xC8E506C1, 0xB955A92A, 0xB388FDBB, 0x1A4697C3, 0xB10826AA, 0xBB1F2207, 0x291DCD60, 0x2BA3E3A7, 0x1B83DFDD, 0x014D4FD5, 0x80C659F3, 0x3EB45B23, 0x43E36266, 0xBD22532C&#125;;#define GET_ULONG(n, b, i) \\ (n) = ( (unsigned long) (b)[(i + 3)] &lt;&lt; 24 ) \\ | ( (unsigned long) (b)[(i + 2)] &lt;&lt; 16 ) \\ | ( (unsigned long) (b)[(i + 1)] &lt;&lt; 8 ) \\ | ( (unsigned long) (b)[(i )] ); \\#define PUT_ULONG(n, b, i) \\&#123; \\ (b)[(i) + 3] = (unsigned char) ( (n) &gt;&gt; 24 ); \\ (b)[(i) + 2] = (unsigned char) ( (n) &gt;&gt; 16 ); \\ (b)[(i) + 1] = (unsigned char) ( (n) &gt;&gt; 8 ); \\ (b)[(i) ] = (unsigned char) ( (n) ); \\&#125; #define SHL(x, n) ( ((x) &amp; 0xFFFFFFFF) &lt;&lt; n )#define ROTL(x, n) ( SHL((x), n) | ((x) &gt;&gt; (32 - n)) )#define SWAP(a, b) &#123; unsigned t = a; a = b; b = t; t = 0; &#125; void SM4_Decrypt(unsigned char * input, unsigned char * output, int len); void Round(unsigned char input[16], unsigned char output[16]);int main(void)&#123; unsigned char input[] = &#123; 0x7D, 0x54, 0xCB, 0xC0, 0x74, 0xDB, 0xF5, 0xD7, 0x6F, 0xD9, 0x92, 0x1B, 0xEB, 0x28, 0x46, 0x20, 0xE5, 0xD5, 0xD3, 0x60, 0x80, 0x6D, 0x36, 0x2F, 0xB0, 0x63, 0x2F, 0x61, 0x20, 0x0F, 0xA9, 0x30 &#125;; unsigned char output[32] = &#123; 0 &#125;; int i; SM4_Decrypt(input, output, 32); for ( i = 0; i &lt; 32; i++ ) &#123;// printf(&quot;0x%X, &quot;, output[i]); printf(&quot;%c&quot;, output[i]); &#125; return 0;&#125;void SM4_Decrypt(unsigned char * input, unsigned char * output, int len)&#123; int i; for ( i = 0; i &lt; 16; i++ ) SWAP(SK[i], SK[31 - i]); while ( len &gt; 0 ) &#123; Round(input, output); input += 16; output += 16; len -= 16; &#125;&#125;void Round(unsigned char input[16], unsigned char output[16])&#123; unsigned long tmp[4] = &#123; 0 &#125;; int i; unsigned int t = 0; GET_ULONG(tmp[0], input, 0); GET_ULONG(tmp[1], input, 4); GET_ULONG(tmp[2], input, 8); GET_ULONG(tmp[3], input, 12); for ( i = 0; i &lt; 32; i++ ) &#123; t = SK[i] ^ tmp[(i + 1) % 4] ^ tmp[(i + 2) % 4] ^ tmp[(i + 3) % 4]; tmp[i % 4] ^= t ^ ROTL(t, 2) ^ ROTL(t, 24) ^ ROTL(t, 10) ^ ROTL(t, 18); &#125; for ( i = 0 ; i &lt; 4; i++ ) GET_ULONG(SK[26 - i], input, i * 4); // 正好是把加密后的值放入 那么解密的时候就是把密文放入即可 PUT_ULONG(tmp[3], output, 0); PUT_ULONG(tmp[2], output, 4); PUT_ULONG(tmp[1], output, 8); PUT_ULONG(tmp[0], output, 12);&#125; 运行得到 3b2365b04700b5eac3a5fd0ba21b687f 参考：DASCTF2022 X VOID-CEF - P.Z’s Blog (ppppz.net)","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-CEF","slug":"CEF","permalink":"http://example.com/tags/CEF/"}],"author":"1ens"},{"title":"WER","slug":"WER","date":"2022-05-25T16:00:00.000Z","updated":"2022-05-26T14:18:22.094Z","comments":true,"path":"2022/05/26/WER/","link":"","permalink":"http://example.com/2022/05/26/WER/","excerpt":"","text":"无壳，64位 什么是WER：Windows 错误报告 (WER) 是一种灵活的基于事件的反馈基础结构，旨在收集有关Windows可以检测、向 Microsoft 报告信息以及为用户提供任何可用解决方案的硬件和软件问题的相关信息。 参考：关于 WER - Win32 apps | Microsoft Docs 其关键函数如下： 123DWORD WINAPI ApplicationRecoveryCallback( PVOID pvParameter //上下文信息在调用‎‎注册应用程序恢复回拨‎‎函数以注册恢复时指定。‎); ‎应用程序定义的回调函数，用于在应用程序遇到未处理的异常或无响应时保存数据和应用程序状态信息。 参考：ApplicationRecoveryCallback callback function (Windows) | Microsoft Docs 1234HRESULT WerReportHang( [in] HWND hwndHungApp, //‎处理未响应的窗口。 [in, optional] PCWSTR pwzHungApplicationName //要在挂起的报告 UI 中显示的无响应应用程序的名称。); 返回值‎：‎返回S_OK函数是否能够在失败时启动报告或错误代码。请注意，S_OK并不一定意味着“无响应”报告已成功完成，而只是表示已启动。‎ 参考：WerReportHang function (errorrep.h) - Win32 apps | Microsoft Docs 主要运行逻辑为： 1.在初始化注册ApplicationRecoveryCallback函数 2.在OnExit调用WerReportHang触发异常 3.运用ApplicationRecoveryCallback进行真正的逻辑处理。 本题OnExit函数就在main函数里面，调用WerReportHang就会关闭调试器，调试不起来 解题： 搜索关键函数，在import表里面找到，放在了一个dll里面 然后交叉引用找到： 这里的sub_14000F3B0就是我们要找的关键函数 也可以通过MessageBox函数来找。 123data = [ 0x05, 0x03, 0x55, 0x05, 0x04, 0x07, 0x5E, 0x54, 0x05, 0x07, 0x50, 0x02, 0x03, 0x53, 0x5F, 0x50, 0x53, 0x50, 0x53, 0x05, 0x55, 0x00, 0x54, 0x55, 0x57, 0x03, 0x05, 0x02, 0x52, 0x50, 0x51, 0x53]for i in range(len(data)): print(chr(data[i] ^ 102), end = &quot;&quot;) 异或写脚本得到flag","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-[wer]","slug":"wer","permalink":"http://example.com/tags/wer/"}],"author":"1ens"},{"title":"末日邀请","slug":"KCTF-末日邀请（加密闯关）","date":"2022-05-23T16:00:00.000Z","updated":"2022-05-24T15:49:32.139Z","comments":true,"path":"2022/05/24/KCTF-末日邀请（加密闯关）/","link":"","permalink":"http://example.com/2022/05/24/KCTF-%E6%9C%AB%E6%97%A5%E9%82%80%E8%AF%B7%EF%BC%88%E5%8A%A0%E5%AF%86%E9%97%AF%E5%85%B3%EF%BC%89/","excerpt":"","text":"先是输入flag也就是ID，然后进行check，主要考察算法。 对我们的输入进行一系列异或，最后赋值给v39，注意这里v39类型是char，接着进行sbox数据初始化， 然后进行CRC32验证，这里可以动调取到flag，这里v34的值后面会给出并进行验证。 接着先将字符转成数值，存入内存，并且如果大于58就减去55.接着用冰雹猜想验证输入的前三位。我们可以爆破得到v17的值是定值7.具体前三位先按下不表 爆破代码： 123456789101112131415161718192021222324252627#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int i; // edxint v13; // ecxint v15; // eaxint j; // edxint v17; // ediint v33[200]; // [esp+10h] [ebp-368h]int main()&#123; for (int i = 0; i &lt;= 0xff; i++) &#123; v13 = i; v15 = v13; for (j = 1; j &lt; 200; ++j) &#123; if ((v15 &amp; 1) != 0) // 奇数*3+1 v15 = 3 * v15 + 1; else v15 &gt;&gt;= 1; // 偶数右移1 v33[j] = v15; &#125; v17 = v33[198] | v33[197] | v33[196]; cout &lt;&lt; v17 &lt;&lt; endl; &#125;&#125; 后面就是判断后四位是否为KCTF 动调发现是v41[1]是输入的第8个字符，推测后面还需要验证九位，然后进行取余验证，依次取最高前i位，看是否能取余i，不能则失败。但是后面对这里有一个约束。先是冒泡排序从小到大排序，然后对比19，也就是必须包含19每个数字 爆破取得这九位：381654729 12345for i in range(100000000,1000000000): if i//10000000 %2 == 0 and i//1000000%3 == 0 and i//100000%4 == 0 and i//10000%5 == 0 and i//1000 %6 == 0 and i//100 % 7 == 0 and i//10 % 8 == 0 and i%9 == 0: num_all = str(i) if &quot;1&quot; in num_all and &quot;2&quot; in num_all and &quot;3&quot; in num_all and &quot;4&quot; in num_all and &quot;5&quot; in num_all and &quot;6&quot; in num_all and &quot;7&quot; in num_all and &quot;8&quot; in num_all and &quot;9&quot; in num_all : print(i) 最后就是判断v34是否相等 也就是前三位 爆破得到前三位：421 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdint.h&gt; uint32_t magic_arr[] = &#123;0x00000000, 0x09073096, 0x120E612C, 0x1B0951BA, 0xFF6DC419, 0xF66AF48F, 0xED63A535, 0xE46495A3, 0xFEDB8832, 0xF7DCB8A4, 0xECD5E91E, 0xE5D2D988, 0x01B64C2B, 0x08B17CBD, 0x13B82D07, 0x1ABF1D91, 0xFDB71064, 0xF4B020F2, 0xEFB97148, 0xE6BE41DE, 0x02DAD47D, 0x0BDDE4EB, 0x10D4B551, 0x19D385C7, 0x036C9856, 0x0A6BA8C0, 0x1162F97A, 0x1865C9EC, 0xFC015C4F, 0xF5066CD9, 0xEE0F3D63, 0xE7080DF5, 0xFB6E20C8, 0xF269105E, 0xE96041E4, 0xE0677172, 0x0403E4D1, 0x0D04D447, 0x160D85FD, 0x1F0AB56B, 0x05B5A8FA, 0x0CB2986C, 0x17BBC9D6, 0x1EBCF940, 0xFAD86CE3, 0xF3DF5C75, 0xE8D60DCF, 0xE1D13D59, 0x06D930AC, 0x0FDE003A, 0x14D75180, 0x1DD06116, 0xF9B4F4B5, 0xF0B3C423, 0xEBBA9599, 0xE2BDA50F, 0xF802B89E, 0xF1058808, 0xEA0CD9B2, 0xE30BE924, 0x076F7C87, 0x0E684C11, 0x15611DAB, 0x1C662D3D, 0xF6DC4190, 0xFFDB7106, 0xE4D220BC, 0xEDD5102A, 0x09B18589, 0x00B6B51F, 0x1BBFE4A5, 0x12B8D433, 0x0807C9A2, 0x0100F934, 0x1A09A88E, 0x130E9818, 0xF76A0DBB, 0xFE6D3D2D, 0xE5646C97, 0xEC635C01, 0x0B6B51F4, 0x026C6162, 0x196530D8, 0x1062004E, 0xF40695ED, 0xFD01A57B, 0xE608F4C1, 0xEF0FC457, 0xF5B0D9C6, 0xFCB7E950, 0xE7BEB8EA, 0xEEB9887C, 0x0ADD1DDF, 0x03DA2D49, 0x18D37CF3, 0x11D44C65, 0x0DB26158, 0x04B551CE, 0x1FBC0074, 0x16BB30E2, 0xF2DFA541, 0xFBD895D7, 0xE0D1C46D, 0xE9D6F4FB, 0xF369E96A, 0xFA6ED9FC, 0xE1678846, 0xE860B8D0, 0x0C042D73, 0x05031DE5, 0x1E0A4C5F, 0x170D7CC9, 0xF005713C, 0xF90241AA, 0xE20B1010, 0xEB0C2086, 0x0F68B525, 0x066F85B3, 0x1D66D409, 0x1461E49F, 0x0EDEF90E, 0x07D9C998, 0x1CD09822, 0x15D7A8B4, 0xF1B33D17, 0xF8B40D81, 0xE3BD5C3B, 0xEABA6CAD, 0xEDB88320, 0xE4BFB3B6, 0xFFB6E20C, 0xF6B1D29A, 0x12D54739, 0x1BD277AF, 0x00DB2615, 0x09DC1683, 0x13630B12, 0x1A643B84, 0x016D6A3E, 0x086A5AA8, 0xEC0ECF0B, 0xE509FF9D, 0xFE00AE27, 0xF7079EB1, 0x100F9344, 0x1908A3D2, 0x0201F268, 0x0B06C2FE, 0xEF62575D, 0xE66567CB, 0xFD6C3671, 0xF46B06E7, 0xEED41B76, 0xE7D32BE0, 0xFCDA7A5A, 0xF5DD4ACC, 0x11B9DF6F, 0x18BEEFF9, 0x03B7BE43, 0x0AB08ED5, 0x16D6A3E8, 0x1FD1937E, 0x04D8C2C4, 0x0DDFF252, 0xE9BB67F1, 0xE0BC5767, 0xFBB506DD, 0xF2B2364B, 0xE80D2BDA, 0xE10A1B4C, 0xFA034AF6, 0xF3047A60, 0x1760EFC3, 0x1E67DF55, 0x056E8EEF, 0x0C69BE79, 0xEB61B38C, 0xE266831A, 0xF96FD2A0, 0xF068E236, 0x140C7795, 0x1D0B4703, 0x060216B9, 0x0F05262F, 0x15BA3BBE, 0x1CBD0B28, 0x07B45A92, 0x0EB36A04, 0xEAD7FFA7, 0xE3D0CF31, 0xF8D99E8B, 0xF1DEAE1D, 0x1B64C2B0, 0x1263F226, 0x096AA39C, 0x006D930A, 0xE40906A9, 0xED0E363F, 0xF6076785, 0xFF005713, 0xE5BF4A82, 0xECB87A14, 0xF7B12BAE, 0xFEB61B38, 0x1AD28E9B, 0x13D5BE0D, 0x08DCEFB7, 0x01DBDF21, 0xE6D3D2D4, 0xEFD4E242, 0xF4DDB3F8, 0xFDDA836E, 0x19BE16CD, 0x10B9265B, 0x0BB077E1, 0x02B74777, 0x18085AE6, 0x110F6A70, 0x0A063BCA, 0x03010B5C, 0xE7659EFF, 0xEE62AE69, 0xF56BFFD3, 0xFC6CCF45, 0xE00AE278, 0xE90DD2EE, 0xF2048354, 0xFB03B3C2, 0x1F672661, 0x166016F7, 0x0D69474D, 0x046E77DB, 0x1ED16A4A, 0x17D65ADC, 0x0CDF0B66, 0x05D83BF0, 0xE1BCAE53, 0xE8BB9EC5, 0xF3B2CF7F, 0xFAB5FFE9, 0x1DBDF21C, 0x14BAC28A, 0x0FB39330, 0x06B4A3A6, 0xE2D03605, 0xEBD70693, 0xF0DE5729, 0xF9D967BF, 0xE3667A2E, 0xEA614AB8, 0xF1681B02, 0xF86F2B94, 0x1C0BBE37, 0x150C8EA1, 0x0E05DF1B, 0x0702EF8D&#125;; char cstr[] = &quot;...KCTF381654729&quot;; int main() &#123; for (int i = 0x20; i &lt; 0x7e; i++) &#123; for (int j = 0x20; j &lt; 0x7e; j++) &#123; for (int k = 0x20; k &lt; 0x7e; k++) &#123; cstr[0] = i; cstr[1] = j; cstr[2] = k; int32_t v11 = -1; for (int idx = 0; idx &lt; 16; idx++) &#123; v11 = magic_arr[(uint8_t)(v11 ^ cstr[idx])] ^ (v11 &gt;&gt; 8); &#125; if ((~v11) == 0xF52E0765) &#123; printf(&quot;%c %c %c\\n&quot;, i, j, k); &#125; &#125; &#125; &#125;&#125; 最后的flag:421KCTF381654729","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-加解密","slug":"加解密","permalink":"http://example.com/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/"}],"author":"1ens"},{"title":"ezam","slug":"ezam（ollvm 迷宫 进制）","date":"2022-05-23T16:00:00.000Z","updated":"2022-05-28T09:03:02.930Z","comments":true,"path":"2022/05/24/ezam（ollvm 迷宫 进制）/","link":"","permalink":"http://example.com/2022/05/24/ezam%EF%BC%88ollvm%20%E8%BF%B7%E5%AE%AB%20%E8%BF%9B%E5%88%B6%EF%BC%89/","excerpt":"","text":"题目打开 标准的ollvm混肴，用脚本两次去除 得到正常的程序 初步分析是以为多项式相加，疏忽了v17以及前面一大段数据的初始化。想着用z3硬解失败了。主要逻辑为读取输入，判断是否为数字，然后转换成四进制，走迷宫。前面的一大段加密是初始化迷宫地图v17，我们可以动调得到一个16*28的迷宫：（做题多尝试 123456789101112131415161,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,0,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0 下面看一下 sub_400670 函数 ，结合动调，是十进制转四进制算法。下面就是迷宫出走方式得到两条路径，根据函数判断路径长度是45，所以是上面那条232222322330030000303322223333333222233333333232222322330030000303322222222222333333300033333333然后四进制转十进制得到flag 1234567891011def anyToDecimal(num,n): baseStr = &#123;&quot;0&quot;:0,&quot;1&quot;:1,&quot;2&quot;:2,&quot;3&quot;:3,&quot;4&quot;:4,&quot;5&quot;:5,&quot;6&quot;:6,&quot;7&quot;:7,&quot;8&quot;:8,&quot;9&quot;:9, &quot;a&quot;:10,&quot;b&quot;:11,&quot;c&quot;:12,&quot;d&quot;:13,&quot;e&quot;:14,&quot;f&quot;:15,&quot;g&quot;:16,&quot;h&quot;:17,&quot;i&quot;:18,&quot;j&quot;:19&#125; new_num = 0 nNum = len(num) - 1 for i in num: new_num = new_num + baseStr[i]*pow(n,nNum) nNum = nNum -1 print(new_num)anyToDecimal(&#x27;232222322330030000303322223333333222233333333&#x27;, 4) flag{902741462666576198076399615}","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"迷宫","slug":"迷宫","permalink":"http://example.com/tags/%E8%BF%B7%E5%AE%AB/"},{"name":"进制","slug":"进制","permalink":"http://example.com/tags/%E8%BF%9B%E5%88%B6/"}],"author":"1ens"}],"categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-luajit","slug":"luajit","permalink":"http://example.com/tags/luajit/"},{"name":"TLS回调函数","slug":"TLS回调函数","permalink":"http://example.com/tags/TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"},{"name":"反调试","slug":"反调试","permalink":"http://example.com/tags/%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"name":"异常处理","slug":"异常处理","permalink":"http://example.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"-CEF","slug":"CEF","permalink":"http://example.com/tags/CEF/"},{"name":"-[wer]","slug":"wer","permalink":"http://example.com/tags/wer/"},{"name":"-加解密","slug":"加解密","permalink":"http://example.com/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/"},{"name":"迷宫","slug":"迷宫","permalink":"http://example.com/tags/%E8%BF%B7%E5%AE%AB/"},{"name":"进制","slug":"进制","permalink":"http://example.com/tags/%E8%BF%9B%E5%88%B6/"}]}